Fikri ve Sınai Mülkiyet Ders
GİRİŞ
Fikri ve Sınai Mülkiyet Ders Notları
Sınai Mülkiyet Nedir ?
İnsan yaratıcılığının, buluşlarının ve orijinal tasarımlarının geliştirilmesi ve koruma
altına alınmasıyla ilgili bir kavramdır.
Patent Nedir ?
Patent, sınırlı bir yer ve süre için üçüncü kişiler tarafından buluşun izinsiz olarak
üretilmesini, kullanılmasını veya satılmasını engelleme yoluyla sahibine tanınan
tekel hakkıdır. Bu hakkın kullanabileceğini gösteren belgeye ise patent belgesi
denir.
Bir buluşun patentlenebilmesi için yeni, buluş basamağını içeren ve sanayiye
uygulanabilir olması gerekmektedir. Ancak, konusu kamu düzenine veya genel
ahlaka aykırı olan buluşlara, bitki veya hayvan türleri veya önemli ölçüde biyolojik
esaslara dayanan bitki veya hayvan yetiştirilmesi usullerine patent
verilmemektedir.
Ayrıca;
• Keşifler, bilimsel teoriler, matematik metotları;
• Zihni, ticari ve oyun faaliyetlerine ilişkin plan, usul ve kurallar;
• Edebiyat ve sanat ederleri, bilim eserleri, estetik niteliği olan yaratmalar,
bilgisayar yazılımları;
• Bilginin derlenmesi, düzenlenmesi, sunulması ve iletilmesi ile ilgili teknik
yönü buunmayan usuller;
• İnsan veya hayvan vücuduna uygulanacak cerrahi ve tedavi usulleri ile insan,
hayvan vücudu ile ilgili teşhis usulleri buluş niteliğinde olmadıkları için
koruma kapsamı dışındadırlar.
Buluş Nedir ?
Buluş, teknoloji alanında belirli bir sorunun çözümüne ilişkin, teknik özelliği olan
fikir ürünüdür. Buluş bazen yepyeni bir cihaz, ürün yöntem veya prosesin
yaratılması, bazende bilinen bir ürün veya proseste yapılan ilerlemeye yönelik bir
iyileştirmedir.
Aynı teknik problemin her farklı çözümü farklı bir buluştur. Teknik niteliğe sahip
olmalıdır. Aksi takdirde sadece soyut ve kavramsal düzeyde bir önermeden
bahsedilebilir.
Bir buluşun patent olabilmesi için;
• Yenilik
• Buluş basamağı içermesi
• Sanayiye uygulanabilir olması
Faydalı Model Nedir ?
Dünya çapında yeni olan ve sanayiye uygulanabilen buluşların sahiplerine koruma
sağlayan bir sınai mülkiyet hakkıdır. Faydalı model belgesi patentle
karşılaştırıldığında hem daha kısa zamanda hem de daha az bir masrafla
alınabilmektedir. Faydalı model ile fikri koruma sağlama sürecinin nispeten daha
basit ve ucuz olmasının, özellikle küçük ve orta ölçekli sanayicilerimizin ve
araştırma kuruluşlarımızın buluş yapmalarını ve bunların sanayiye uygulamalarını
özendireceği düşünülmüştür.
Patent ile Faydalı Model arasındaki fark;
Patent / Faydalı Model Başvurusu için Gerekli Evraklar
• Başvuru dilekçesi, ( T.P.E. internet sitesinden elde edilebilir, bir nüsha)
• Buluş konusunu açıklayan tarifname, (2 nüsha)
• Korunması istenilen buluşun yeni olduğu iddia edilen teknik özellikleri
kapsayan istem veya istemler (2 nüsha)
• Tarifnamede, istem veya istemlerde atıf yapılan teknik resimler ( 2 nüsha )
• Özet ( 2 nüsha )
• Başvuru ücretinin ödendiğini gösterir belge
• Başvuralacak kurum ise Türk Patent Enstitüsü'dür.
Buluşları hangi sistemlerde koruyabiliriz ?
Koruma süreleri ne kadardır ve bu süreler uzatılabilir mi ?
İncelemesiz Patent Sisteminde; Buluş sahiplerine 7 yıllık bir koruma
sağlanmaktadır.
İncelemeli Patent Sisteminde; Patentlenebilirlik kriterlerine göre(yenilik, buluş
basamağı, sanayiye uygulanabilirlik) bakılır. 20 yıl koruma sağlanır.
Faydalı Model Sisteminde; 10 yıllık koruma sağlanır. ( Araştırma ve inceleme
yoktur.) İncelemesiz 20 yıla kadar uzatılabilir. İncelemeli ve faydalı uzatılamaz.
Rüçhan Hakkı Nedir ?
Rüçhan hakkı öncelik hakkı demektir. Yani bir buluş sahibi herhangi bir ülkede
yaptığı patent başvurusunu takip eden 12 ay içinde başka bir ülkede de aynı buluş
için patent başvurusu yapıp, ilk yaptığı başvuruya dayanarak öncelik hakkını talep
edebilir.
Patent Haklarının İhlali
A -) Hukuk Davaları ;
• Patent sahibi mahkemede aşağıdaki taleplerde bulunabilir.
o Tecavüzün önlenmesi, durdurulması, giderilmesi, tespiti davaları
o Tazminat davaları
o El koyma
o Şekil değiştirme ve imha
o Mülkiyet hakkı tanınması
o Kamuya ilan yoluyla duyurulması
o İhtiyati tedbirler
B -) Ceza Davaları
• Bu cezalar, suçun faili ve fiilin niteliğine göre;
o 4 yıla kadar hapis
o 46.000 TL'ye kadar para
o İş yerlerinin 1 yıldan az olmamak şartıyla kapatılması
o 1 yıldan az olmamak koşuluyla ticaretten men edilmesi
Endüstriyel Tasarım Nedir ?
Bir eşyanın süs veya estetik olarak görüntüsüdür. İki veya 3 boyutlu olabilir.
Tasarım bir ürünün tümü, bir parçası veya üzerindeki süslemenin çizgi, şekil, biçim,
renk, doku, malzeme gibi insan duyguları ile algılanan çeşitli unsur ve özelliklerin
oluşturduğu bütün denilebilir.
• Örnek olarak; Bardak, klavye, trafik levhaları verilebilir.
Ürün Nedir ?
Tasarımın tescil edilebilmesi için öncelikle ürün tanımına uymaları gerekmektedir.
Kanunda ürün: Bilgisayar programları ve yarı iletkenlerin topografyaları hariç
olmak üzere;
Birleşik bir sistem veya bunu oluşturan parçaları, setler, takımlar ambalajlar gibi
nesneleri, birden çok nesnenin veya sunuşun bir arada algılanabilen bileşimleri,
grafik sembolleri ve tipografik karakterleri içine alan geniş bir tanıma sahiptir.
Tasarım Hakkı Kapsamı Nedir ?
Bir endüstriyel tasarımın tescil edilerek korunması ile hak sahibi, tekel haklara
sahip olur. Bu sayede üçüncü kişiler tasarım hakkı sahibinin izni olmaksızın;
• Bu tasarımları üretemez
• Piyasaya sunamaz, satamaz, ithal edemez.
• Sözleşme yapmak için icapta bulunamaz.
• Ticari amaçla kullanamaz.
Tasarımda yenilik nedir ?
Bir tasarımı başvuru tarihinden veya rüçhan tarihinden önce dünyanın herhangi bir
yerinde kamuya sunulmamış ise o tasarım yeni kabul edilir.
Ayırt edici nitelik nedir ?
Endüstriyel tasarımın görsel olarak, bilinen diğer tasarımlardan belirgin bir
farklılığa sahip olması, ayırt edici niteliğe sahip olması anlamına gelmektedir.
Koruma kapsamı dışında tutulan tasarımlar nelerdir ?
• Yeni ve ayırt edici niteliğe sahip olmayan tasarımlar
• Tasarımcıya seçenek özgürlüğü bırakmayan tasarımlar
• Zorunlu biçim ve boyutlarda üretilebilen tasarımlar, koruma kapsamı
dışındadırlar.
Tasarımın piyasada rekabet gücüne katkıları nelerdir?
Kalite bakımından birbirine yakın ürünlere dair verilen satın alma kararlarında,
üretilen malın estetik özellikleri önem kazanmaktadır. Ürünün formu, rengi, hacmi
gibi faktörler önem kazanmıştır. Fonksiyonellik, kullanım kolaylığı, ergonomi
Tasarım hakkı talep eden ile tasarımcı arasındaki farklar nelerdir ?
Tasarım hakkı sahibi; tescile konu tasarımı veya tasarımın uygulandığı ürünü
üreten, piyasaya sunan, satan, sözleşme yapmak için icapta bulunan, ticari amaçlı
kullanandır.
Tasarımcı ise, tasarımı gerçekleştiren kimsedir.
Endüstriyel Tasarımlar kaç yıl korumaya alınır?
Tescilli tasarımların koruma süresi başvuru tarihinden itibaren 5 yıldır.
Koruma süresi, tescilin beşer yıllık dönemler halinde yenilenmesi işlemiyle 25 yıla
kadar uzatılabilir.
Çoklu başvuru nedir ? Koşulları nelerdir ?
Çoklu başvuru, tek bir başvuru ile birden çok tasarım için koruma telp edilmesidir.
tasarımcıların çoklu başvuruya konu olabilmesi için ürünlerin;
• Aynı alt sınıfa ait olması veya
• Aynı takıma ait olması veya
• Birleşik bir ürünün parçaları olması veya
• Birden çok nesnenin ya da sunuşun bir arada algılanabilen bir birleşimi
oluşturması gerekir.
Fikri ve Sınai Mülkiyet Ders
SON
Bilgi Sistemleri Dersi
Giriş
Bilgi Sistemleri
Dr. Galip Aydın
Bilgi
 Türkçe: Haber, malumat, vukuf, marifet, irfan
 1. İnsan aklının erebileceği olgu, gerçek ve ilkelerin bütünü, bili,
malumat.
 2. Öğrenme, araştırma veya gözlem yolu ile elde edilen gerçek,
malumat, vukuf:
“Babası, önce ona, Mazlume ve ailesi hakkında
birçok bilgi vermişti.” -H. E. Adıvar.
 3. İnsan zekâsının çalışması sonucu ortaya çıkan düşünce ürünü,
malumat, vukuf.
 4. fel. Genel olarak ve ilk sezi durumunda zihnin kavradığı temel
düşünceler.
 5. Bilim: Doğa bilgisi.
 6. bl. Kurallardan yararlanarak kişinin veriye yönelttiği anlam.
Güncel Türkçe Sözlük
Bilgi
 Felsefe Terimleri Sözlüğü
 I. (Genellikle) 1. Bilme edimi. 2-Bilinen şey; bilme edimi sonunda ulaşılan şey.
 II. (Felsefede) Bir şeyin bir şey olarak kavranması. Burada tasarımlamadan ayrı olarak
bilme eğilimi vardır.
 Bilgi çeşitli biçimlerde ortaya çıkabilir:
 1. İnsandaki ruhsal bir olay olarak.
 2. Kavrama edimi, asalt bilinç edimi, yönelme (eğilim, intention) olarak.
 3. Özne (bilen) ve nesne (bilinen) arasındaki ilişki olarak (= bilgi bağlantısı).
 4. Nesnenin öznedeki imgesi, tasarımı, izdüşümü olarak (= bilgi oluşumu).
 5. Tasarım imgesinin nesneyle uyuşması olarak.
 6. Bilgimizin ve bilgi imgemizin nesnenin tüm içeriğine yaklaşma eğilimi olarak (=
bilgi süreci, bilgi ilerlemesi).
 7. Bilginin başkasına ulaştırılabilir, aktarılabilir sonucu olarak; bilgi ürünü, bilgi
sonucu.
 T. : marifet, malumat
 Lat.: cognitio İng.: knowledge, congnition Fr.: connaissance Alm.: Erkenntnis
Bilgi
 İrfan
 Bilmek, anlayış, tecrübe ve zekâdan ileri gelen zihnî
kemal.
 İlim ile irfan ve ma'rifet arasında fark vardır: İlim, vech-i
küllî ile, yani her vechesiyle bilmektir. İrfan ve marifet
ise; vech-i cüz'î ile bilmektir. Fıtrî istidat eseri olarak
inceleyerek tefekkür edip bilmektir.
 Marifet
 Bilme, bir şeyi cüz'i vecihle bilmek.
 Hüner. Üstadlık. San'at.
 İlim ve fenlerle tahsil olunan mâlumat. İrfan kazanmak.
Data
 In computer science, data is anything in a form suitable for use with
a computer. Data is often distinguished from programs. A program is a
set of instructions that detail a task for the computer to perform. In this
sense, data is thus everything that is not program code.
 Olgu, kavram ya da komutların, iletişim, yorum ve işlem için elverişli
biçimsel ve uzlaşımsal bir gösterimi. Elverişlilik, kişiler ya da özdevimli
makinelerle iletişim, yorum ya da işleme uygunluk biçiminde
düşünülür, bk.bilgi.
T. : malumat İng.: data Fr.: donnée
Bilişim Terimleri Sözlüğü
 1. Sonuç çıkarmak, çıkarsama yapmak, ya da bir incelemeyi sürdürmek
için gerekli olaylara, ilişkilere ve sayısal ham bilgilere verilen ad. 2. Bir
araştırmada sorunun çözümünü sağlamak amacıyla derlenen bilgiler.
T. : muta İng.: datum Fr.: donné
Eğitim Terimleri Sözlüğü
Data
 Deneysel ölçümler ya da sayımlar sonucu elde edilen sayılar kümesi.
Fizik Terimleri Sözlüğü
 Deneysel ölçme sonucu bulunan nicelik ya da sayı.
Fiziksel Kimya Terimleri Sözlüğü
 Deneyler ya da gözlemler sonunda elde edilen nicel ya da nitel değerler,
İstatistik Terimleri Sözlüğü
 1. Çözüme ulaşmak için işlenebilir duruma getirilmiş bilgi. 2. Bilgisayar için işlenebilir
duruma getirilmiş sayısal ya da sayısal olmayan bilgi.
Matematik Terimleri Sözlüğü
 bilişim: Olgu, kavram ya da komutların, iletişim, yorum ve işlem için elverişli, biçimsel ve
uzlaşımsal gösterimi.
Uygulayım Terimleri Sözlüğü
 İşlenebilir duruma getirilmiş sayısal nicelik.
Adli Bilişim İncelemeleri
Kriminal Terimleri Sözlüğü
T. : veri, malumat İng.: data,datum Fr.: donnée
Information
 Bilgi işlemde, kullanılan uzlaşımsal kurallardan yararlanarak
kişinin veriye yönelttiği anlam.
Bilişim Terimleri Sözlüğü
 Doğanın nesne ve olayları üzerinde kuramsal ya da görgül yoldan
öğrenilen şey.
Fizik Terimleri Sözlüğü
 Bireylerin herhangi bir çaba sarfetmeksizin ulaştığı dışardan verilen
olgular.
İktisat Terimleri Sözlüğü
 1. Öğrenme, araştırma ya da gözlem yolu ile edinilen gerçekler.
2. (Bilgi kuramı) Tümü ya da bir parçası sınıflandırmaya elverişli
olan nesneler topluluğunun, niceliği ile ilgili yönü.
Ruhbilim Terimleri Sözlüğü
T.: malumat
Knowledge
 Eğitim Terimleri Sözlüğü
- İnsan usunun kapsayabileceği olgu, gerçek ve ilkelerin tümüne
verilen ad.
- Bir yargılamada bulunabilmek için bilinmesi gereken öğelerin
her birine verilen ad.
- Bir şeyi bilme hali.
 İktisat Terimleri Sözlüğü
- Bireylerin öğrenme, araştırma veya gözlem yolu ile çaba
sarfederek elde ettiği olgular.
vukuf, marifet

DIKW
 The "DIKW Hierarchy", refers loosely to a class of
models for representing purported structural
and/or functional relationships between
data, information, knowledge, and wisdom.
 "Typically information is defined in terms of data,
knowledge in terms of information, and wisdom in
terms of knowledge".
The Rock (1934) - T. S. Eliot
 All our knowledge brings us nearer to our ignorance,
All our ignorance brings us nearer to death,
But nearness to death no nearer to God.
Where is the Life we have lost in living?
Where is the wisdom we have lost in knowledge?
Where is the knowledge we have lost in
information?
The cycles of Heaven in twenty centuries
Brings us farther from God and nearer to the Dust.
from T.S. Eliot, "Choruses from 'The Rock'“
, 1934
Data in DIKW Context
 In the context of DIKW, data is conceived of
as symbols or signs,representing stimuli or
signals, that are "of no use until...in a usable (that is,
relevant) form". Zeleny characterized this non-usable
characteristic of data as "know-nothing".
 Discrete, objective facts or observations, which are
unorganized and unprocessed and therefore have no
meaning or value because of lack of context and
interpretation. ( Rowley, Jennifer; Richard
Hartley (2006))
Information in DIKW Context
 In the context of DIKW, information meets the
definition for knowledge by
description ("information is contained
in descriptions ), and is differentiated from data in
that it is "useful". "Information is inferred from
data", in the process of answering
interrogative questions (e.g., "who", "what",
"where", "how many", "when"), thereby making
the data useful for "decisions and/or action".
 "Classically, information is defined as data that are
endowed with meaning and purpose."
Knowledge in DIKW Context
 The knowledge component of DIKW "is generally agreed
to be an elusive concept which is difficult to define.
Knowledge is typically defined with reference to
information." Definitions may refer to information having
been processed, organized or structured in some way, or
else as being applied or put into action.
 Zins has suggested that knowledge, being subjective rather
than universal, is not the subject of study in information
science, and that it is often defined in propositional terms,
while Zeleny has asserted that to capture knowledge in
symbolic form is to make it into information, i.e., that "All
knowledge is tacit".
Wisdom in DIKW Context
 Zeleny described wisdom as "know-why", but later refined his definitions, so
as to differentiate "why do" (wisdom) from "why is" (information), and
expanding his definition to include a form of know-what ("what to do, act or
carry out").
Zeleny has argued for a tier to the model beyond wisdom, termed
"enlightenment".
 Ackoff refers to understanding as an "appreciation of 'why'", and wisdom as
"evaluated understanding", where understanding is posited as a discrete layer
between knowledge and wisdom. Adler had previously also included an
understanding tier, while other authors have depicted understanding as a
dimension in relation to which DIKW is plotted. Rowley attributes the
following definition of wisdomto Ackoff:
 Wisdom is the ability to increase effectiveness. Wisdom adds
value, which requires the mental function that we call
judgment. The ethical and aesthetic values that this implies
are inherent to the actor and are unique and personal.



Bilgi Sistemleri
Dr. Galip Aydın
Bilgi Sistemleri

Bilgi Sistemlerinin Tanımı
 Bilgi Sistemleri toplumlarda ve organizasyonlarda,
bilginin toplanması, işlenmesi, depolanması,
dağıtılması ve kullanılması ile ilgili stratejik,
yönetimsel ve operasyonel işlemlerle ilgilenen
profesyonel ve akademik bir disiplindir.
 Typically, information systems or the more
common legacy information systems include
people, procedures, data, software, and hardware
(by degree) that are used to gather and
analyze digital information.
 Tipik olarak bir Bilgi Sistemi dijital bilgiyi toplamak
ve analiz etmekte kullanılan insanlar, prosedürler,
veriler, yazılım ve (belli bir dereceye kadar)
donanımları içerir.
Bilgisayarlı Bilgi Sistemleri
 Spesifik olarak bilgisayar tabanlı bilgi sistemleri,
insanların ve organizasyonların veriyi toplamak,
filtrelemek, işlemek, oluşturmak veya dağıtmak
için kullandıkları tamamlayıcı donanım/yazılım
ağlarından oluşur.

Bilgi Sistemlerinin Türleri
 Klasik Bilgi Sistemleri kaynaklarında piramit
şeklinde aynı zamanda kurumun yapısını da
yansıtan sınıflama yapılmıştır.
 Buna göre Bilgi Sistemlerinin temel türleri:
 Hareket İşleme (İşlem İşleme) Sistemleri
 Yönetim Bilgi Sistemleri
 Karar Destek Sistemleri
 Yönetici Bilgi Sistemleri
Bilgi Sistemlerinin Türleri
 Ancak yeni teknolojiler ve yeni gelişmelerle
beraber orijinal piramit modeline uymayan bilgi
sistemleri ortaya çıkmıştır:
 Veri Depoları
 ERP (Enterprise Resource Planning)
 Girişimci Sistemleri (Enterprise Systems)
 Uzman Sistemler
 Coğrafi Bilgi Sistemleri
 Global Bilgi Sistemleri
 Ofis Otomasyon Sistemleri

Bilgi Sistemlerinin İlişkili Olduğu
Alanlar
 Computer Science
 Bioinformatics
 Business informatics
 Cheminformatics
 Disaster informatics
 Geoinformatics
 Information system
 Management Infomation Systems
Bilgi
Sistemleri
•Depolama
•Erişim
•Organizasyon
BS Karakteristik
Özellikleri
•Hareket Yönetim Sistemleri (TPS)
•Karar Destek Sistemleri (DSS)
•Uzman Bilgi Sistemleri (EIS)
•Yönetim Bilgi Sistemleri (MIS)
•Ofis Otomsayon Sistemleri (OAS)
•Hata Kontrolü
•Şifreleme/Encryption
Yedekleme ve
Güvenlik
•Değer Aralığı
Kontrolü
•Liste Kontrolü
•Tip Kontrolü
•Değer Konrolü
•Birim
•Veri bozulması
•Veri kaybı
•Kaynak bütünlüğü
BS Türleri
Doğruluk
•Bilgisayarsız
•Bilgisayarlı
•Dosya
•İlişkisel Organizasyon
Yöntemleri
•Veri Sözlükleri
•Şematik
Diagramlar
•Normalizasyon
Etik
Konular •Gizlilik
•Doğruluk
•Copyright
•Veri Madenciliği
•Data Warehousing
Erişim
Veri doğrulama
Veri
bütünlüğü
Güvenilirlik
Bilgi Sistemlerinin Bileşenleri
 İnsanlar
 Bilgi Sistemlerinde insanların farklı rolleri olabilir:
 Sistem Analizi
 Programcı
 Tekniker
 Mühendis
 Network Yöneticisi
 Bilgi Sistemi Yöneticisi
 Veri girişi operatörü
 Ekipmanlar
 Yazılım ve Donanımsal kaynaklar
 Prosedürler
 Çerçevesi iyi tanımlanmış ve adımları belirlenmiş eylemler. Basit bir görevden
daha öte kompleks görevleri tanımlar. Mesela yedekleme yapıp, sistemi
yeniden yapılandırmak ve yazılım güncellemeleri gerçekleştirmek gibi.
 Veri
 Daha sonra işlenerek (manipüle edilerek) bilgi üretilen, ham, düzenlenmemiş,
ayrık, izole edilmiş ve potansiyel olarak kullanışlı veriler.
Hareket Yönetim Sistemleri
(TPS)
 Hareket Yönetim Sistemleri bir organizasyonun
günlük hareketlerini (işlemlerini) toplayan,
depolayan, değişiklik yapan ve erişime açan bilgi
sistemleridir.
 HYS iş hayatında genellikle paranın hareketini ve
bir şirketin günlük işlemlerini güvenli bir şekilde
kayıt altına alırlar.
TPS
 A transaction processing system is a type
of information system.
 TPSs collect, store, modify, and retrieve
the transactions of an organization.
 A transaction is an event that generates or
modifies data that is eventually stored in an
information system.
 To be considered a transaction processing
system the computer must pass the ACID test.
TPS
 The essence of a transaction program is that it manages
data that must be left in a consistent state, e.g. if an
electronic payment is made, the amount must be both
withdrawn from one account and added to the other; it
cannot complete only one of those steps. Either both must
occur, or neither.
 In case of a failure preventing transaction completion, the
partially executed transaction must be 'rolled back' by the
TPS.
 it is particularly important for online processing: if e.g. an
airline seat reservation system is accessed by multiple
operators, after an empty seat inquiry, the seat reservation
data must be locked until the reservation is made,
otherwise another user may get the impression a seat is
still free while it is actually being booked at the time.
ACID
 In computer science, ACID (atomicity,
consistency, isolation, durability) is a set of
properties that guarantee database
transactions are processed reliably.
 In the context of databases, a single logical
operation on the data is called a transaction.
 For example, a transfer of funds from one bank
account to another, even though that might
involve multiple changes (such as debiting one
account and crediting another), is a single
transaction.
Atomicity
 Atomicity requires that database modifications
must follow an "all or nothing" rule. Each
transaction is said to be atomic. If one part of the
transaction fails, the entire transaction fails and
the database state is left unchanged.
 To be compliant with the 'A', a system must
guarantee the atomicity in each and every
situation, including power failures / errors /
crashes.
 This guarantees that 'an incomplete transaction'
cannot exist.
Consistency
 The consistency property ensures that any transaction the
database performs will take it from one consistent state to
another.
 Consistency states that only consistent (valid according to
all the rules defined) data will be written to the database.
 Quite simply, whatever rows will be affected by the
transaction will remain consistent with each and every rule
that is applied to them (including but not only: constraints,
cascades, triggers).
 While this is extremely simple and clear, it's worth noting
that this consistency requirement applies to everything
changed by the transaction, without any limit (including
triggers firing other triggers launching cascades that
eventually fire other triggers etc.) at all.
Isolation
 Isolation refers to the requirement that no
transaction should be able to interfere with
another transaction at all.
 In other words, it should not be possible that two
transactions affect the same rows run
concurrently, as the outcome would be
unpredicted and the system thus unreliable.
Durability
 Durability means that once a transaction has
been committed, it will remain so.
 In other words, every committed transaction is
protected against power loss/crash/errors and
cannot be lost by the system and can thus be
guaranteed to be completed.
HYS özellikleri
 HYS’lerin 4 önemli karakteristiği:
 Hızlı Cevap
 Güvenilirlik
 Esnek olmamak
 Kontrollü İşlemler
Toplu İşlemler (Batch Processing)
 Bilgisayarların ve işlemci gücünün düşük olduğu
zamanlarda toplu işlem sistemleri geliştirilmiştir.
 Toplu işlemde, işlenmesi gereken tüm bilgiler önce
toplanır sonra toplu bir halde işlenir.
Gerçek Zamanlı İşleme
(Real Time Processing)
 Veri işleme aynı anda aynı yerde gerçekleşir.
 POS makineleri
 ATMler
 GZİ’de iki önemli konu gözönünde
bulundurulmalıdır:
 Concurrency (Aynı anda erişim)
 Aynı veriyi aynı anda birden fazla kullanıcı
değiştirememelidir
 Atomicity
 İşlemin bütün adımları tamamlanmalı veya işlem
gerçekleşmemiş kabul edilmeli ve tüm değişiklikler geri
alınmalıdır.
Hareket İşleme Monitörü
(Transaction Processing Monitor)
Bilgi Sistemleri – 2010
Dr. Galip Aydın
Verinin Temsili
Veri – Kitap Listesi
 Dosyalarda saklanabilir
 Sorgulama imkanı yok
 Özel programlarla arama ve sorgulama yapılabilir
Anna Karenina Lev N. Tolstoy Sosyal 2002 9757384250 19.9
Gülün Adı Umberto Eco Can 2009 9755102450 32
Semerkant Amin Maalouf Yapı Kredi 2010 9750810039 16
Leyla ile Mecnun İskender Pala Kapı 2010 9758950386 8
Akşam Güneşi Reşat Nuri Güntekin İnkılap 2010 9751026606 21
Veritabanı
 Sütun türleri belirlenebilir
 Yeni veri ekleme kolay
 Sorgulama yapılabilir
İsim Yazar Yayınevi Yayın_Yılı ISBN Fiyat
Anna Karenina Lev N. Tolstoy Sosyal 2002 9757384250 19.9
Gülün Adı Umberto Eco Can 2009 9755102450 32
Semerkant Amin Maalouf Yapı Kredi 2010 9750810039 16
Leyla ile Mecnun İskender Pala Kapı 2010 9758950386 8
Akşam Güneşi Reşat Nuri Güntekin İnkılap 2010 9751026606 21
İçerik ve Temsil
 Veritabanından veya kaynaklardan çekildikten sonra
veriler nasıl saklanmalı/temsil edilmeli/transfer
edilmeli
Anna Karenina;Lev N. Tolstoy;Sosyal;2002;9757384250;19.9
Gülün Adı;Umberto Eco;Can;2009;9755102450;32
Semerkant;Amin Maalouf;Yapı Kredi;2010;9750810039;16
Leyla ile Mecnun;İskender Pala;Kapı;2010;9758950386;8
Akşam Güneşi;Reşat Nuri Güntekin;İnkılap;2010;9751026606;21
Anna Karenina;Lev N. Tolstoy;Sosyal;2002;9757384250;19.9
Gülün Adı;;;2009;9755102450;32
Semerkant;Amin;Maalouf;;2010;9750810039;16
Leyla ile Mecnun;İskender Pala;;2010;9758950386;
Akşam Güneşi;Reşat Nuri Güntekin;İnkılap;2010;9751026606;
İçerik Değişikliği
 Veritabanına yeni sütün eklenmesi
 Veriye daha önce düşünülmemiş bir ayrıntının
eklenmesi daha önce geliştirilmiş temsil
yöntemlerini bozabilir
 Verinin yapısının her zaman önceden bilinmesi ve
bunlara göre veri analizi programlarının yazılması
mümkün değildir.
Farklı kaynaklardan verilerin
birleştirilmesi
İsim Yazar
Anna Karenina Lev N. Tolstoy
Gülün Adı Umberto Eco
Semerkant Amin Maalouf
Leyla ile Mecnun İskender Pala
Akşam Güneşi Reşat Nuri Güntekin
ISBN İsim Fiyat
9757384250 Anna Karenina 19.9
9755102450 Gülün Adı 32
9750810039 Semerkant 16
9758950386 Leyla ile Mecnun 8
9751026606 Akşam Güneşi 21
Yazar Dogum_Tarihi Olum_Tarihi Dogum_Yeri
Lev N. Tolstoy 9/10/1828 20/11/1828 Rusya
Umberto Eco 5/1/1932 - İtalya
Amin Maalouf 25/2/1949 - Beyrut
İskender Pala 8/6/1958 - Uşak
Reşat Nuri
Güntekin 25/11/1889 7/12/1956 İstanbul
Yayınevi TEL
Sosyal 212-1111111
Can 312-5555555
Yapı Kredi 216-3333333
Kapı 312-6666666
İnkılap 212-2222222
Internet
(Wikipedia)
Text ve Yapılandırılmış Verilerin
Birleştirilmesi
Yapılandırılmış Veri
Veritabanları
Yapılandırılmamış Veri
Dokümanlar
Yarı
Yapılandırılmış
Veri
www
Yeni bir veri modeli ihtiyacı
 Gevşek ve zengin bir yapı
 Gelişmeye açık, bilinmeyen özelliklere kolay adapte
olabilen, düzensiz yapıları destekleyebilecek
 Yapılandırılmış fakat heterojen veri kaynaklarını
birleştirebilmeli
 Tag ve linklerden oluşan text türü veri
 Farklı veri modellerinin kombinasyonu (ilişkisel,
hiyerarşik, text)
Markup Languages
 1970’de Charles Goldfarb, Ed Mosher and Ray
Lorie IBM’de çalışırken GML’i buldular.
 GML yapısal etiketler taşıyan teknik dokümanları
işaretlemek için bir yöntemi tarif etmek için
geliştirilmişti.
 Goldfarb, Mosher ve Lorie isimlerinin kısaltması
 Goldfarb ‘mark-up language’ terimini icat etti ve
daha sonra bu isim SGML olarak değiştirildi
Standard Generalised Markup Language
 ISO 1986’da SGML’i bir standart olarak kabul etti
HTML
 SGML bir dizi işaretleme dili geliştirmek için
kullanıldı
 1991’de Tim Berners Lee SGML kullanarak
HTML’i geliştirdi
 SGML çok efektif fakat komplex, HTML ise çok
basit fakat belirli bir dizi tag ile kısıtlıdır.
 HTML verinin nasıl gösterileceği (presentation) ile
ilgilenir
HTML
<html>
<body>
<table>
<tr>
<td>İsim</td>
<td>Yazar</td>
</tr>
<tr>
<td>Anna Karenina</td>
<td>Lev N. Tolstoy</td>
</tr>
<tr>
<td>Gülün Adı</td>
<td>Umberto Eco</td>
</tr>
</table>
</body>
</html>
İsim Yazar
Anna Karenina Lev N. Tolstoy
Gülün Adı Umberto Eco
HTML – Tags and Attributes
<html>
<body>
<table border="1">
<tr height="23" style="height: 17.25pt">
<td height="23">İsim</td>
<td>Yazar</td>
</tr>
<tr height="23">
<td height="23"><span>Anna Karenina</span></td>
<td>Lev N. Tolstoy</td>
</tr>
<tr height="23">
<td height="23"><span>Gülün Adı</span></td>
<td>Umberto Eco</td>
</tr>
</table>
</body>
</html>
XML
 SGML kadar etkili fakat o kadar karmaşık
olmayan
 HTML kadar basit fakat kısıtlı olmayan bir markup
diline olan ihtiyaç
 XML bu boşluğu doldurmak için geliştirildi
 1996’da Sun Microsystems’te çalışan Jon Bosak
ve ekibi SGML’den yola çıkarak XML üzerinde
çalışmaya başladılar.
XML vs HTML
 XML verinin içeriğini tarif eder.
 HTML verinin nasıl gösterileceğini anlatır.
 XML verinin aktarımı ve depolanması amacıyla
geliştirilmiştir
 XML tek başına hiçbir iş yapmaz.
Bilgi Sistemleri – 2010
Dr. Galip Aydın
XML
eXtensible Markup Language
eXtensible Markup Language
 Yapısal veriler taşıyan dökümanları biçimlemek
(markup) için geliştirilmiş bir dil.
 W3C XML Specification
 http://www.w3.org/TR/REC-xml/
 Standard Generalized Markup Language (SGML)
kullanılarak geliştirilmiş
 İnternette veri değişimi ile ilgili eksikliği kapatmak
amaçlanmış
XML vs HTML
 XML
 İhtiyaca göre arttırılabilir
tag’ler
 İçerik yönelimli
 Standart veri değişim
biçimi
 Farklı çıktı biçimlerine
izin verir
• HTML
• Belli sayıda tag
• Verinin gösterimini
esas alır
• Veri doğrulama
yeteneği yok
• Tek tür, standart
çıktı
XML Ne İçin Kullanılır
 İnternette verilerin bir yerden başka bir yere aktarılması için
 XML alt dilleri veya lehçeleri (subsets, dialects) özel alan
uygulamaları için geliştirilebilir
 RSS, internette haberleri paylaşmak için
 GML (Geography Markup Language) coğrafi verilerin değişimi
için
 MathML (Mathematical Markup Language) matematiksel verilerin
tarifi için
 CML (Chemical Markup Language) Kimyasal veriler, moleküler
bilgilerin anlatılması için
 GeneXML (Gene Expression Markup Language), DNA mikro
dizileri ve Gen verileri için
 MusicML, müzik verileri, notalar vs tarifi için
 W3C (World Wide Web Consortium) tarafından kaydedilen birçok
XML dili farklı alanlarda veri değişimi için standart formatlar
tanımlar
XML’in Avantajları
 Veriyi HTML’den ayırır
 Dinamik HTML oluşturma,
 Gösterimle ilgili kısımlardan bağımsız veri
dokümanları
 Veri paylaşımını basitleştirir
 Bilgisayarlar ve veritabanları birbiriyle uyumsuz
biçimlerde verileri saklar
 XML plain text biçiminde veriyi sakladığı için veriler
yazılım ve donanımdan bağımsız olarak
depolanabilir
XML’in Avantajları
 Veri değişimini basitleştirir
 Geliştiriciler için en fazla zaman alan işlerden biri
birbiriyle uyumsuz formatlardaki verilerin farklı
sistemler arasında değişimidir
 XML farklı uygulamalar tarafından okunabildiği için
veri değişimi kolaylaşır
 Platform değişikliklerini kolaylaştırır
 Uygulama veya işletim sisteminin veriden
bağımsızlaştırılması yenileme veya güncellemeyi
kolaylaştırır
XML’in Avantajları
 Verinin daha fazla tüketiciye açık olmasını sağlar
 Farklı uygulamalar, programlar veriye sadece HTML
sayfalarında değil XML veri kaynaklarında da
ulaşabilir
 XML ile veri birçok farklı okuma makinelerine açık
hale gelir (el bilgisayarları, haber beslemeleri, cep
telefonları vs.)
XML Örnek
<?xml version="1.0" encoding="UTF-8"?>
<Kitap>
<İsim>Anna Karenina</İsim>
<Yazar>Lev Tolstoy</Yazar>
<Yayınevi>Can</Yayınevi>
<Yayınyılı>2008</Yayınyılı>
<ISBN>12345678910</ISBN>
<Fiyat>38.5</Fiyat>
</Kitap>
XML Kuralları
 Bir XML dökümanı bir veya birden fazla element
içerir
 Her elementin bir ismi vardır. Başka elementler
barındırabilir ve nitelikler (attribute) taşıyabilir
 Etiketler (tag) başlama-etiketi ve bitiş-etiketi
olmak üzere çift olarak yazılır
 İç içe etiketler doğru yazılmalıdır:
 <Kitap><İsim></Kitap></İsim> hatalı yazım
 <Kitap><İsim></İsim></Kitap> doğru yazım
XML Kuralları
 Boş etiketler kısaltılabilir
 <Kitap></Kitap> şeklindeki bir boş etiket
 <Kitap/> şeklinde kısaltılabilir
 XML etiketleri büyük-küçük harflere duyarlıdır
 <KİTAP>
,
<Kitap>
,
<kitap> farklı etiketlerdir
 Nitelikler (Attribute) eşit işaretiyle ayrılmış isimdeğer çiftleridir:
 <Öğrenci No="12345">Ali Demir</Öğrenci>
 Nitelikler elementlere ikincil, ek bilgileri eklemek
için kullanılırlar
 Bir XML dökümanı tek bir kök (root) element taşır
Well-Formed XML
 Bir XMl dökümanı bütün kurallara uyarak
yazılmışsa doğru-biçimlendirilmiş (well-formed)
denir
 XML parser programları öncelikle bu kurallara
uyulup uyulmadığını kontrol ederler
 İnternet tarayıcıları XML parser programları
içerirler
XML’de Referans vermek
<?xml version="1.0" encoding="UTF-8"?>
<Soyağacı>
<Kişi id="1">
<İsim>Ali</İsim>
</Kişi>
<Kişi id="2">
<İsim>Veli</İsim>
</Kişi>
<Kişi id="3">
<İsim>Ayşe</İsim>
<Çocuklar ids="1 2"></Çocuklar>
</Kişi>
</Soyağacı>
XML Veri Modeli: Ağaçlar
<Kitaplar>
<Kitap id="123">
<İsim>Anna Karenina</İsim>
<Yazar>Lev Tolstoy</Yazar>
<Yayınevi>Can</Yayınevi>
<Yayınyılı>2008</Yayınyılı>
<ISBN>123456789</ISBN>
<Fiyat>35</Fiyat>
</Kitap>
<Makale ref="123" id="1">
<Yazar>
<isim>Ali Demir</isim>
</Yazar>
<Başlık>Tolstoy'un Eserleri</Başlık>
</Makale>
</Kitaplar>
Tolstoy’un Eserleri
Kitaplar
123 1
Can
Ali Demir
yazar başlık
yayınevi
isim
Makale
Kitap
yazar
Tolstoy
ref
XML Ağaçları
adres
isim email telefon doğumgünü
isim soyisim yıl ay gün
XML Ağaçları
 XML Dokümanları tek bir kök elemana sahiptir.
 XML veri ağacı genel sıralı bir ağaçtır
 Bir elemanın herhangi sayıda çocuk elemanları
olabilir
 Çocuk elemanların kendi çocukları olabilir
 Root elemandan başlayarak ağaç üzerinde
yürünerek ağacın yapısı çıkarılabilir
 Elamanların hiyerarşik düzeni verinin yapısı ve
ilişkileri ile ilgili bilgi verir
İlişkisel veritabanı - XML
isim telefon
ali 123
ayşe 456
fatma 789
<Kisiler>
<Kisi>
<isim>ali</isim>
<telefon>123</telefon>
</Kisi>
<Kisi>
<isim>ayse</isim>
<telefon>456</telefon>
</Kisi>
<Kisi>
<isim>fatma</isim>
<telefon>789</telefon>
</Kisi>
</Kisiler>
isim telefon
ali 123
ayşe 456
fatma 789
<Kisi
>
<isim
>ali</isim
>
<telefon
>123</telefon
>
<telefon
>444</telefon
>
<telefon
>555</telefon
>
</Kisi
>
???
Document Type Definitions (DTD)
 DTD XML dilinin bir parçasıdır ve yazıldığı XML
dokümanları için gramer olarak işlev görür.
 <!ELEMENT isim [veri_tipi]> şeklinde yazılır
DTD
<liste>
<kisi>
<isim>Ali</isim>
<yas>25</yas>
<email>ali@mail.com</email>
</kisi>
<kisi>………</kisi>
</liste>
<!ELEMENT liste (kisi*)>
<!ELEMENT kisi (isim, yas, email)>
<!ELEMENT isim (#PCDATA)>
<!ELEMENT yas (#PCDATA)>
<!ELEMENT email (#PCDATA)>
DTD
İşaret Kaç defa geçiyor
(işaret yok) Gerekli Sadece bir
? Seçmeli Bir veya Sıfır
* Seçmeli,
tekrar edebilir
0, 1, veya çok
sayıda
+ Gerekli, tekrar
edebilir
1 veya çok
XML Schema
 XML Schema aynı zamanda XML dokümanıdır
 DTD’lerden sonra geliştirilmiş ve doküman
hakkında daha fazla bilgi sunar.
 Tanımlanmış birçok veri türü vardır: integer,
decimal, string, boolean, date, time
 Elemanlar simple ve complex türler olarak ikiye
ayrılmıştır
 Ağaç yapısının nasıl olacağı ve bir elemanın kaç
çocuğu olacağına karar verilebilir
XML Schema Örnek
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
<xs:element name="liste">
<xs:complexType>
<xs:sequence>
<xs:element name="kisi" maxOccurs="unbounded">
<xs:complexType>
<xs:sequence>
<xs:element name="isim"
type="xs:string"/>
<xs:element name="yas" type="xs:string"/>
<xs:element name="email"
type="xs:string"/>
</xs:sequence>
</xs:complexType>
</xs:element>
</xs:sequence>
</xs:complexType>
</xs:element>
</xs:schema>
XML Schema Complex Types

<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
<xs:element name="liste">
<xs:complexType>
<xs:sequence>
<xs:element name="kisi" type="kisiType" maxOccurs="unbounded"/>
</xs:sequence>
</xs:complexType>
</xs:element>
<xs:complexType name="kisiType">
<xs:sequence>
<xs:element name="isim" type="xs:string"/>
<xs:element name="yas" type="xs:string"/>
<xs:element name="email" type="xs:string"/>
</xs:sequence>
</xs:complexType>
<xs:element name="kisi" type="kisiType"/>
</xs:schema>
XSLT
Extensible Stylesheet Language Transformations
 XSLT bir xml dokümanını başka birisine (genelde
HTML) dönüştürmek için kullanılır
 XSLT dönüşümü programları bir xml dosyasını
giriş olarak alıp başka bir xml dosyasını çıktı
olarak verir.
 Eğer çıktı HTML ise web tarayıcıları ile
görüntülenebilir
 XML verisini kolaylıkla göstermek için güzel bir
yol
XSLT Örnek
<?xml version="1.0" encoding="ISO-8859-1"?>
<xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="adress">
<html><head><title>Adresler</title></head>
<body>
<xsl:value-of select=“isim"/>
<br/><xsl:value-of select="email"/>
<br/><xsl:value-of select=“telefon"/>
<br/><xsl:value-of select=“dogumgunu"/>
</body>
</html>
</xsl:template>
</xsl:stylesheet>
XSLT
 XSLT dönüşümü web tarayıcısı tarafından
yapılabilir
 Fakat farklı tarayıcılar farklı HTML çıktısı
verebileceği için, dönüşüm sunucu tarafında da
yapılabilir
 XSLT dönüşümü için kullanılan programlama
diline uygun kütüphaneler kullanılır
Java - XSLT
http://www.w3schools.com/dom/
Dr. Galip AYDIN
XML
Document Object Model (DOM)
DOM
 DOM bir W3C (World Wide Web Consortium)
standardıdır
 XML ve HTML gibi dokümanlara erişim için
standart bir yol tanımlar
 "The W3C Document Object Model (DOM) is a
platform and language-neutral interface that
allows programs and scripts to dynamically
access and update the content, structure, and
style of a document."
DOM
 DOM standart modeller tanımlayan 3 farklı
parça/seviye içerir
 Core DOM: Herhangi bir yapısal doküman için
 XML DOM: XML dokümanları için
 HTML DOM: HTML Dokümanları için
XML DOM
 XML için
 standart bir nesne modeli
 Standart bir programlama arayüzü
 Platform ve dilden bağımsız
 XML DOM bütün XML elementleri için nesne ve
özellikleri ve bunlara erişim için gerekli metodları
(arayüzler) tanımlar
 Diğer bir deyişle DOM, XML elementlerine erişim,
değiştirme, ekleme, silme gibi işlemler için bir
standart sağlar.
DOM Node
 DOM açısından XML içindeki herşey bir
düğümdür (node)
 Dokümanın kendisi doküman düğümüdür
 Her bir xml elementi bir element düğümüdür
 XML elementlerinin içindeki yazılar yazı düğümüdür
(text node)
 Herbir nitelik (attribute) nitelik düğümüdür
 Yorum düğümleri de bulunabilir
XML DOM Tree
DOM Ağacı
 Düğüm ağacındaki her bir düğümün diğerleriyle
hiyerarşik bir ilişkisi vardır
 Bu ilişkileri anlatmak için ebeveyn, çocuk ve
kardeş (parent, children, siblings) terimleri
kullanılır
 Ebeveyn düğümlerin çocukları vardır
 Aynı seviyedeki çocuklar kardeş (kız veya erkek)
olarak adlandırılırlar
Düğüm Ağacında İlişkiler
 Bir düğüm ağacında en tepedeki düğüme kök
denir
 Kök düğüm hariç her düğümün sadece bir
ebeveyni vardır
 Bir düğümün sınırsız sayıda çocuğu olabilir
 Çocuğu olmayan düğümlere yaprak denir
 Aynı ebeveyne sahip, aynı seviyedeki düğümlere
kardeş denir

XML DOM Parser
 XML dokümanlarını ayrıştırmak için kullanılan
çeşitli uygulamalar (parser) yazılmıştır
 XML DOM modeli elemanlara erişim, değiştirmek,
silmek veya eklemek için metotlar içerir ancak
öncelikle dokümanın DOM nesnesine yüklenmesi
gerekir
JavaScript DOM Parser
if (window.XMLHttpRequest)
{
xhttp=new XMLHttpRequest();
}
else // IE 5/6
{
xhttp=new ActiveXObject("Microsoft.XMLHTTP");
}
xhttp.open("GET","books.xml",false);
xhttp.send();
xmlDoc=xhttp.responseXML;
DOM Properties
 x.nodeName – x düğümünün ismi
 x.nodeValue - x düğümünün değeri
 x.parentNode - x düğümünün ebeveyn düğümü
 x.childNodes - x düğümünün çocukları olan düğümler
 x.attributes - x düğümünün nitelikleri
XML DOM Metotları
 x.getElementsByTagName(name) – verilen
isimdeki bütün elementleri getir
 x.appendChild(node) – x düğümüne bir çocuk
düğüm ekle
 x.removeChild(node) – x düğümünden verilen
düğümü sil
<script type="text/javascript">
xmlDoc=loadXMLDoc("books.xml");
x=xmlDoc.getElementsByTagName("book")[0].childNodes;
y=xmlDoc.getElementsByTagName("book")[0].firstChild;
for (i=0;i<x.length;i++)
{
if (y.nodeType==1)
{//Process only element nodes (type 1)
document.write(y.nodeName + "<br />");
}
y=y.nextSibling;
}
</script>
<script type="text/javascript">
text="<book>";
text=text+"<title>Everyday Italian</title>";
text=text+"<author>Giada De Laurentiis</author>";
text=text+"<year>2005</year>";
text=text+"</book>";
xmlDoc=loadXMLString(text);
// documentElement always represents the root node
x=xmlDoc.documentElement.childNodes;
for (i=0;i<x.length;i++)
{
document.write(x[i].nodeName);
document.write(": ");
document.write(x[i].childNodes[0].nodeValue);
document.write("<br />");
}
</script>
title: Everyday Italian
author: Giada De Laurentiis
year: 2005
Java DOM Kütüphaneleri
DOM4J
http://dom4j.sourceforge.net/
 JDOM
http://www.jdom.org/
Apache XML projeleri
…
DOM4J Örnek
import java.net.URL;
import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.io.SAXReader;
public class Foo {
public Document parse(URL url) throws DocumentException {
SAXReader reader = new SAXReader();
Document document = reader.read(url);
return document;
}
}
Çocuk Düğümlere Erişim
public void bar(Document document) throws DocumentException {
Element root = document.getRootElement();
// iterate through child elements of root
for ( Iterator i = root.elementIterator(); i.hasNext(); ) {
Element element = (Element) i.next();
// do something
}
// iterate through child elements of root with element name "foo"
for ( Iterator i = root.elementIterator( "foo" ); i.hasNext(); ) {
Element foo = (Element) i.next();
// do something
}
// iterate through attributes of root
for ( Iterator i = root.attributeIterator(); i.hasNext(); ) {
Attribute attribute = (Attribute) i.next();
// do something
}
}
DOM Ağacı Üzerinde Yürüme
public void treeWalk(Document document) {
treeWalk( document.getRootElement() );
}
public void treeWalk(Element element) {
for ( int i = 0, size = element.nodeCount(); i < size; i++ ) {
Node node = element.node(i);
if ( node instanceof Element ) {
treeWalk( (Element) node );
}
else {
// do something....
}
}
}
Yeni XML Oluşturma
import org.dom4j.Document;
import org.dom4j.DocumentHelper;
import org.dom4j.Element;
public class Foo {
public Document createDocument() {
Document document = DocumentHelper.createDocument();
Element root = document.addElement( "root" );
Element author1 = root.addElement( "author" )
.addAttribute( "name", "James" )
.addAttribute( "location", "UK" )
.addText( "James Strachan" );
Element author2 = root.addElement( "author" )
.addAttribute( "name", "Bob" )
.addAttribute( "location", "US" )
.addText( "Bob McWhirter" );
return document;
}
}
SAX – Simple API for XML
 SAX DOM’a alternatif olarak geliştirilmiş bir sıralı
erişim ayrıştırıcısıdır (parser).
 XML dokümanlarını okumak için gerekli araçları
sağlar.
 SAX olay-güdümlü (event-driven) olarak çalışan
akışa göre çalışan (stream-parser) bir
ayrıştırıcıdır.
 SAX ayrıştırıcısı karşılaştığı düğümleri sırasıyla
işler (event), ve bu işleme dokümanın sonuna
kadar devam eder.
SAX vs DOM
 SAX DOM’a göre daha küçük hafızaya ihtiyaç
duyar. Özellikle büyük XML dokümanlarının
işlenmesinde bu büyük bir avantajdır.
 DOM parser tüm XML ağacının hafızaya
yüklenmesine gereksinim duyar.
 Olay-güdümlü yaklaşım dolayısıyla SAX parser
DOM’a göre genellikle daha hızlıdır.
 XSLT ve XPATH gibi bazı teknolojiler tüm XML
ağacına ihtiyaç duydukları için SAX parser
kullanamazlar.
StAX – XML Pull Parser
 Araştırın !
 sjsxp
 Woodstox
 Aalto
http://www.w3schools.com/xpath/
XPath bir W3C standardıdır
XPath XML dökümanlarının kısımlarını
seçmek için kullanılan bir sintakstır.
XPath sorguları XML olarak yazılmazlar
ama genelde XSLT ile yoğun bir şekilde
kullanılır.
Küçük bir programlama dili gibi
fonksiyonları, testleri ve ifadeleri vardır.
XPath’in XML eleman adresi tarif yaklaşımı
işletim sistemlerinin dosya adresleme
yöntemine benzer.
XPath ifadeleri işletildiğinde tipi düğüm-seti
(XML ağacının bir grup düğümünden
oluşan bir set), boolean, rakam veya String
tipinde bir nesne döndürür.
Adresler
İşletim Sistemi: XPath:
/ = kök dizin /kütüphane= kök element
/kütüphane/kitap/abc =
tkütüphane klasörünün
içindeki kitap klasöründeki
abc dosyası
/kütüphane/kitap/bölüm/kısım =
kütüphanedeki her kitap içindeki bir
bölümün her kısım elementi
. = erişilmekte olan klasör . = erişilmekte olan element
.. = bir üst klasör .. = erişilmekte olan elementin
ebeveyni
/kütüphane/kitaplar/* =
/kütüphane/kitaplar
altındaki tüm dosyalar
/kütüphane/kitaplar/bölüm/* =
/kütüphane/kitaplar/bölüm
altındaki tüm elementler
abc = klasördeki abc
adındaki dosya
kısım = erişilen elementin çocuğu
olan her kısım elementi
 / ile başlayan bir adres dokümanın tepesinden başlayan mutlak bir
adresi temsil eder
• Örnek: /mesajlar/mesaj/başlık/kimden
• Mutlak adresler birden fazla eleman seçebilir
• Tek başına bir / tüm dokümanı temsil eder
 A path that does not begin with a / represents a path starting from the
current element
• Örnek: header/from
 / ile başlamayan bir adres şu anda erişilmekte olan elementten
başlayan bir adresi temsil eder
• Örnek: başlık/kimden
 // ile başlayan bir adres dokümanın herhangi bir yerinden başlayabilir
• Örnek: //başlık/kimden xml dosyasındaki başlık elementinin çocuğu
olan bütün kimden elementlerini seçer
• Bu yöntem tün tüm dosyayı arama gerektirdiği için pahalı olabilir
 Parantez içindeki bir rakam o sayıya denk gelen belirli bir
elementi seçer (saymaya 1’den başlanır)
• Örnek: /kütüphane/kitap[1], kütüphanedeki ilk kitabı
seçer
• Örnek: //bölüm/kısım[2] XML dokümanındaki her bölüm
elementinin ikinci kısım elementini seçer
• Örnek: //kitap/bölüm[1]/kısım[2]
 last() fonksiyonu parantez içinde kullanılınca son çocuğu
seçer
• Örnek: /kütüphane/kitap/bölüm[last()]
• Sondan bir önceki bölüm elementini seçmek için
Örnek: /kütüphane/kitap/bölüm[last()]
 Yıldız veya asterisk, “wild card” olarak
kullanılır ve bu seviyedeki tüm elementler
anlamına gelir
• Örnek: /kütüphane/kitap/bölüm/* ifadesi kütüphane
içindeki her bir kitap elementinin her bölüm
elementinin tüm çocuklarını seçer
• Örnek: //kitap/* ifadesi her kitap elementinin her bir
çocuğunu seçer (bölümler)
• Örnek: /*/*/*/paragraf ifadesi her tam olarak 3 atası
olan her paragraf elementini seçer
• Örnek: //* ifadesi tüm dokümandaki tüm elementleri
seçer
Niteliklerin kendilerini veya belirli nitelik
barındıran elementleri seçebilirsiniz
• Hatırlatma: bir nitelik isim-değer çifti barındırır
örneğin <bölüm no="5">
• Niteliğin kendisini seçmek için isminin önüne @
yazılır
• Örnek: @no ifadesi ismi no olan bütün
nitelikleri seçer
• Example: //@* ifadesi dokümanın içerisindeki
tüm nitelikleri seçer
 //bölüm[@no] ifadesi no adında bir niteliği
bulunan tüm bölüm elementlerini seçer
 //bölüm[not(@no)] ifadesi no adında bir
niteliği bulunmayan tüm bölüm elementlerini
seçer
 //bölüm[@*] ifadesi bir attribute barındıran
tüm bölüm elementlerini seçer
 //bölüm[not(@*)] ifadesi attribute
barındırmayan tüm bölüm elementlerini seçer
 //bölüm [@no='3'] ifadesi no adında bir
niteliğinin değeri 3 olan tüm bölüm
elementlerini seçer
<?xml version="1.0" encoding="UTF-8"?>
<Kutuphane>
<Kitap id="123">
<İsim>Anna Karenina</İsim>
<Yazar>Lev Tolstoy</Yazar>
<Yayınevi>Can</Yayınevi>
<Yayınyılı>2008</Yayınyılı>
<ISBN>123456789</ISBN>
<Fiyat>35</Fiyat>
</Kitap>
<Kitap id="12">
<İsim>Sinekli Bakkal</İsim>
<Yazar>Halide Edip Adivar</Yazar>
<Yayınevi>Can</Yayınevi>
<Yayınyılı>2010</Yayınyılı>
<ISBN>9750707766</ISBN>
<Fiyat>25</Fiyat>
</Kitap>
<Kitap id="15">
<İsim>Puslu Kitalar Atlasi</İsim>
<Yazar>Ihsan Oktay Anar</Yazar>
<Yayınevi>Iletisim</Yayınevi>
<Yayınyılı>2008</Yayınyılı>
<ISBN>345129876</ISBN>
<Fiyat>18</Fiyat>
</Kitap>
</Kutuphane>
Root
Kutuphane
Kitap Kitap
İsim Yayın
evi Yazar Yayın
yılı ISBN Fiyat
//Kutuphane/Kitap/Yayınyılı
//Kutuphane/Kitap/Fiyat
//Kutuphane/*/Fiyat
//Yazar
//ISBN
/Kutuphane//Fiyat
//Kutuphane/Kitap/@id
//Kutuphane/Kitap[Fiyat]
//Kutuphane/Kitap[Fiyat=18]
//Kutuphane/Kitap/@id=12
 //Kutuphane/Kitap/Yayınyılı
• <Yayınyılı>2008</Yayınyılı>
• <Yayınyılı>2010</Yayınyılı>
• <Yayınyılı>2008</Yayınyılı>
 //Kutuphane/Kitap/Fiyat
• <Fiyat>35</Fiyat>
• <Fiyat>25</Fiyat>
• <Fiyat>18</Fiyat>
 //Yazar
• <Yazar>Lev Tolstoy</Yazar>
• <Yazar>Halide Edip Adivar</Yazar>
• <Yazar>Ihsan Oktay Anar</Yazar>
//Kutuphane/Kitap/@id
• id="123"
• id="12"
• id="15"
//Kutuphane/Kitap[Fiyat=18]
<Kitap id="15">
<İsim>Puslu Kitalar Atlasi</İsim>
<Yazar>Ihsan Oktay Anar</Yazar>
<Yayınevi>Iletisim</Yayınevi>
<Yayınyılı>2008</Yayınyılı>
<ISBN>345129876</ISBN>
<Fiyat>18</Fiyat>
</Kitap>
//Kutuphane/Kitap[Fiyat<25]
<Kitap id="123">
<İsim>Anna Karenina</İsim>
<Yazar>Lev Tolstoy</Yazar>
<Yayınevi>Can</Yayınevi>
<Yayınyılı>2008</Yayınyılı>
<ISBN>123456789</ISBN>
<Fiyat>35</Fiyat>
</Kitap>
//Kutuphane/Kitap/Yazar/text()
• Lev Tolstoy
• Halide Edip Adivar
• Ihsan Oktay Anar
 Önceki örnekler Xpath veri ağacında aşağıya
doğru yürümek için kullanılır.
 Daha kompleks sorgular ve ağaç üzerinde
yukarıya, sağa, sola vs doğru ilerlemek için
eksenler kullanılır
 //Kutuphane/Kitap[2]/self::* - Kendisi
 //Kutuphane/Kitap[2]/preceding::* - Önceki
 //Kutuphane/Kitap[2]/following::* - Sonraki
 //Kutuphane/Kitap[2]/ancestor::* - Ebeveyni
 //Kutuphane/Kitap[2]/child::* - Çocukları
<kutuphane
>
<kitap
>
<bolum/> <bolum> <kısım> <paragraf/> <paragraf/>
</kısım
>
</bolum
>
<bolum/>
</kitap
>
<kitap/>
</kutuphane
>
 //bolum[2]/self::*  //bolum[2]/preceding::*  //bolum[2]/following::*  //bolum[2]/ancestor::*  //bolum[2]/descendant::*
paragraph[1] paragraph[2]
kısım[1]
bolum[1] bolum[2] bolum[3]
kitap[1] kitap[2]
Kutuphane
self
ancestor
descendant
preceding
following
Bilgi Sistemleri Dersi
Son
Sayısal Elektronik Laboratuvarı Dersi
Giriş
ELEKTRONİK DEVRE ÇİZİM VE SİMÜLASYON PROGRAMI
EWB (Electronics Workbench)
Günümüzde her türlü elektronik devrenin tasarım ve analizinde artık simülasyon
(benzetim) programları yaygın olarak kullanılmaktadır. Bu programlar sayesinde zamandan
ve paradan tasarruf sağlanarak bilgisayar başında devre tasarımı ve analizi kolayca
yapılabilmektedir.
Elektronik devre çizimi için kullanılan pek çok program bulunmaktadır. Ancak çizimle
birlikte devre analizi de yapan program sayısı fazla değildir. Burada EWB programının 5.12
versiyonu anlatılacaktır. Amaç, programın temel düzeyde nasıl kullanılacağını göstermektir.
Programın eski versiyonlarında bulunmayan bazı gelişmiş özelliklerin nasıl kullanılacağını
öğrenmek için programın help (yardım) menüsünden yararlanılmalıdır. Programın doğru bir
şekilde kullanılabilmesi için elektroteknik, analog ve dijital elektronik, kontrol teorisi,
sinyaller ve sistemler gibi alanlarda belirli bir düzeyde bilgi sahibi olunması gereklidir.
1. PROGRAMIN TANITIMI
EWB programı uygun şekilde bilgisayara yüklenip çalıştırıldığında ekranda şekil 1’deki
çalışma sayfası görünür. En üstte “File, Edit, Circuit, Analysis, Window, Help” menülerini
içeren menü satırı bulunur. En alt satırda ise test cihazları ve elektronik devre elemanlarını
içeren malzeme kutuları bulunur. Sağ tarafta bulunan anahtar yardımıyla simülasyonun
başlatılması veya sona erdirilmesi sağlanır. Pause butonu ise simülasyonu bir süre durdurmak
için kullanılır. İlerleyen bölümlerde test cihazları ve malzeme kutularının içeriği hakkında
bilgi verilecektir.


Şekil 1
2. TEST CİHAZLARI
Bu bölümde, analiz edilecek bir devrede kullanılacak ölçü aletleri ve sinyal kaynakları
tanıtılacaktır. Şekil 2’nin üst kısmında görülen butona basılmasıyla Instruments menüsü açılır.
Burada, test cihazları programdaki görünüş sırasına göre toplu halde verilmiştir. Aşağıda her
birinin görevi ve çalışma şekli kısaca anlatılmaktadır.
Şekil 2
2.1. AVO Metre (Multimeter)
Şekil 3
2.2. Sinyal Üreteci ( Function Generator)
Şekil 4
2.3. Osiloskop (Oscilloscope)
Şekil 5’de 2 kanallı osiloskop görülmektedir. Osiloskop üzerindeki butonlar gerçek
osiloskoptaki ile aynıdır. Görüntüyü büyütmek için expand butonuna basılır.
Şekil 5
Şekil 2’nin ilk sırasında yer alan küçük kutu AVO
metredir. Bu eleman mouse ile çalışma sayfasına taşınıp çift
tıklanırsa şekil 3’deki büyük kutu açılır. İki uçlu bu eleman
sayesinde doğru ve alternatif akım şartlarında akım(A),
gerilim(V), direnç(Ω) ölçülebilmektedir. Ayrıca logaritmik
kazanç da dB (desibel) cinsinden hesaplanabilmektedir.
Şekil 4’de görülen sinyal üreteci ile dalga şekli
farklı 3 sinyal üretilebilmektedir. Bunlar sinüsoidal,
üçgen ve kare dalga’dır. Sinyal üreteci üzerindeki ayar
butonları yardımıyla sinyalin frekansı (frequency) ve
genliği (amplitude) değiştirilebilmektedir. Duty cycle ve
offset adlı butonlar ile sırasıyla işaretin görev periyodu
ve kayma miktarı ayarlanmaktadır. Sinyal kaynağı
üzerinde görünen genlik değeri maksimum değerdir.
Örneğin efektif değeri 220 V olan şebeke gerilimini elde
etmek için genlik 311V seçilmelidir.
2.4. Bode Çizici (Bode Plotter)
Şekil 6’da görülen test cihazı bir devrenin bode diyagramını çizmek için kullanılır. Bu
sayede bir devrenin frekans cevabı (genlik-frekans ve faz-frekans eğrileri) elde edilir.
Şekil 6
2.5. Kelime Üreteci (Word Generator)
Şekil 7
2.6. Lojik Analizör (Logic Analyzer)

Şekil 8
Şekil 7’de görülen 16 çıkış ucu olan kelime
üreteci sayesinde dijital (sayısal) bir elektronik
devreye 16 bitlik lojik sinyaller gönderilebilir.
Frekans ayarlaması yapılarak bilgi aktarım hızı
istenildiği gibi seçilebilir. Sol kısımda, gönderilen
bilginin heksadesimal (16’lık taban) karşılığı
görülmektedir. Ayrıca ikili (binary) veya ASCII
kodu da görülebilir.
Şekil 8’deki lojik analizör yardımıyla
bir dijital devrenin herhangi bir
noktasındaki zamana bağlı dalga şekli
görülebilir. Zaman ekseni uygun şekilde
seçilerek ekrandaki dalga sıklığı
artırılabilir. Ayrıca girişe uygulanan
sinyalin heksadesimal karşılığı da
okunabilir.
2.7. Lojik Çevirici (Logic Converter)
Şekil 9
3. MALZEME KUTULARI
3.1. Kaynaklar (Sources)
Şekil 10’un üst kısmında görülen kutucuğa mouse ile tıklandığında kaynaklar penceresi
açılır. Şekilden de görüldüğü gibi pek çok kaynak türü bulunmaktadır. Bunların ne işe
yaradığı aşağıda sırasıyla verilmiştir.

Şekil 10
• Ground : Toprak bağlantısı
• Battery : Doğru gerilim kaynağı
• DC Current Source : Doğru akım kaynağı
• AC Voltage Source : Alternatif gerilim kaynağı (Gerilim değerini efektif değer olarak gösterir).
• AC Current Source : Alternatif akım kaynağı
• Voltage-Controlled Voltage Source : Gerilim kontrollü gerilim kaynağı
• Voltage-Controlled Current Source : Gerilim kontrollü akım kaynağı
• Current-Controlled Voltage Source : Akım kontrollü gerilim kaynağı
• Current-Controlled Current Source : Akım kontrollü akım kaynağı
• +Vcc Voltage Source : +Vcc gerilim kaynağı (5 volt)
• +Vdd Voltage Source : +Vdd gerilim kaynağı (15 volt)
• Clock : Saat (Kare dalga üreteci)
• AM Source : Genlik modülasyonu (Amplitude modulation) kaynağı
• FM Source : Frekans modülasyonu (Frequency modulation) kaynağı
• Voltage-Controlled Sine Wave Oscillator : Gerilim kontrollü sinüs dalga osilatörü
• Voltage-Controlled Triangle Wave Oscillator : Gerilim kontrollü üçgen dalga osilatörü
• Voltage-Controlled Square Wave Oscillator : Gerilim kontrollü kare dalga osilatörü
• Controlled One-Shot : Kontrollü tek darbe (Darbe genişliği ayarlanabilen darbe üreteci)
• Piecewise Linear Source : Parça parça lineer (doğrusal) kaynak (Bir txt uzantılı dosyadan alacağı
zaman ve gerilim değerlerine göre sinyal üretir).
• Voltage-Controlled Piecewise Linear Source : Gerilim kontrollü parça parça doğrusal kaynak
• Frequecy-Shift-Keying Source : Frekans kaydırmalı anahtarlama kaynağı
• Polynomial Source : Çokterimli (polinom) kaynak
• Nonlinear Dependent Source : Doğrusal olmayan bağımlı kaynak
Şekil 9’da görülen lojik çevirici
yardımıyla bir lojik devrenin
doğruluk tablosu elde edilir. Bu test
cihazı ile doğruluk tablosuna göre
otomatik lojik devre çizimi de
yaptırılabilir. Aynı zamanda cihazın
alt kısmında doğruluk tablosuna göre
otomatik olarak elde edilmiş lojik
ifadeler de görülebilir.
3.2. Basic (Temel)
Şekil 11’de görülen malzeme kutusunda temel elektriksel devre elemanları bulunur.
Aşağıda bu elemanların sırasıyla açıklaması verilmiştir.
Şekil 11
• Connector : Bağlayıcı
• Resistor : Direnç
• Capacitor : Kondansatör, kapasitör
• Inductor : Bobin, indüktör
• Transformer : Transformatör, trafo
• Relay : Röle
• Switch : Anahtar
• Time-Delay Switch : Zaman gecikmeli anahtar
• Voltage-Controlled Switch : Gerilim kontrollü anahtar
• Current- Controlled Switch : Akım kontrollü anahtar
• Pull-Up Resistor : Yukarı çekme direnci (Bir ucu pozitif kaynağa bağlı olan direnç)
• Potentiometer : Potansiyometre, ayarlı direnç
• Resistor Pack : Direnç kutusu (Eşit değerde 8 bağımsız direnç içerir)
• Voltage Controlled Analog Switch : Gerilim kontrollü analog anahtar
• Polarized Capacitor : Kutuplu kondansatör
• Variable Capacitor : Değişken (ayarlı) kondansatör
• Variable Inductor : Ayarlı bobin
• Coreless Coil : Çekirdeksiz bobin
• Magnetic Core : Manyetik çekirdek
• Nonlinear Transformer : Doğrusal olmayan transformatör
3.3. Diodes (Diyotlar)
Şekil 12’de görülen kutuda çeşitli yarıiletken elemanlar bulunmaktadır.
Şekil 12
• Diode : Diyot
• Zener Diode : Zener diyot
• LED : LED (Light Emitting Diode), ışık yayan diyot
• Full-Wave Bridge Rectifier : Tam dalga köprü doğrultucu
• Shockley Diode : Şotki diyot
• Silicon Controlled Rectifier : Silikon kontrollü doğrultucu, tristör
• Diac : Diyak
• Triac : Triyak
3.4. Transistors (Transistörler)
Şekil 13’de görülen malzeme kutusunda çeşitli transistör türleri bulunur.
Şekil 13
• NPN Transistor : NPN transistör
• PNP Transistor : PNP transistör
• N-Channel JFET : N kanallı JFET
• P-Channel JFET : P kanallı JFET
• 3-Terminal Depletion N-MOSFET : 3 uçlu kanal ayarlamalı N-MOSFET
• 3-Terminal Depletion P-MOSFET : 3 uçlu kanal ayarlamalı P-MOSFET
• 4-Terminal Depletion N-MOSFET : 4 uçlu kanal ayarlamalı N-MOSFET
• 4-Terminal Depletion P-MOSFET : 4 uçlu kanal ayarlamalı P-MOSFET
• 3-Terminal Enhancement N-MOSFET : 3 uçlu kanal oluşturmalı N-MOSFET
• 3-Terminal Enhancement P-MOSFET : 3 uçlu kanal oluşturmalı P-MOSFET
• 4-Terminal Enhancement N-MOSFET : 4 uçlu kanal oluşturmalı N-MOSFET
• 4-Terminal Enhancement P-MOSFET : 4 uçlu kanal oluşturmalı P-MOSFET
• N Channel GaAsFET : N kanallı GaASFET
• P Channel GaAsFET : P kanallı GaASFET
3.4. Analog ICs (Analog IC’ler)
Şekil 14’de çeşitli analog entegre devreler görülmektedir.
Şekil 14
• 3-Terminal Opamp : 3 uçlu Opamp (İşlemsel kuvvetlendirici)
• 5-Terminal Opamp : 5 uçlu Opamp
• 7-Terminal Opamp : 7 uçlu Opamp
• 9-Terminal Opamp : 9 uçlu Opamp
• Comparator : Karşılaştırıcı
• Phase-Locked Loop : Faz kilitlemeli çevrim
3.5. Mixed ICs (Karışık IC’ler)
Şekil 15’de çeşitli entegre devreler görülmektedir.
Şekil 15
• Analog-to-Digital Converter : Analog-dijital dönüştürücü (ADC)
• Digital-to-Analog Converter (I) : Dijital-analog dönüştürücü (I) (DAC)
• Digital-to-Analog Converter (V) : Dijital-analog dönüştürücü (V) (DAC)
• Monostable Multivibrator : Tek kararlı multivibratör
• 555 Timer : 555 zamanlayıcı
3.6. Digital ICs (Dijital IC’ler)
Şekil 16’da çeşitli dijital entegre şablonları bulunur. Bunlar yardımıyla 7447, 74145,
74240 gibi entegreler seçilebilir.
Şekil 16

• 74XX Template : 74XX şablonu
• 741XX Template : 741XX şablonu
• 742XX Template : 742XX şablonu
• 743XX Template : 743XX şablonu
• 744XX Template : 744XX şablonu
• 4XXX Template : 4XXX şablonu
3.7. Logic Gates (Lojik Kapılar)
Şekil 17’de lojik devrelerde kullanılan lojik kapıların sembolleri görülmektedir.
Şekil 17
• 2-Input AND Gate : 2 girişli VE kapısı
• 2-Input OR Gate : 2 girişli VEYA kapısı
• NOT Gate : DEĞİL kapısı
• 2-Input NOR Gate : 2 girişli VEYA DEĞİL kapısı
• 2-Input NAND Gate : 2 girişli VE DEĞİL kapısı
• 2-Input XOR Gate : 2 girişli ÖZEL VEYA kapısı
• 2-Input XNOR Gate : 2 girişli ÖZEL VEYA DEĞİL kapısı
• Tristate Buffer : 3 durumlu tampon
• Buffer : Tampon
• Schmitt Triggered Inverter : Schmitt tetiklemeli tersleyen
• AND Gates : VE kapıları
• OR Gates : VEYA kapıları
• NAND Gates : VE DEĞİL kapıları
• NOR Gates : VEYA DEĞİL kapıları
• NOT Gates : DEĞİL kapıları
• XOR Gates : ÖZEL VEYA kapıları
• XNOR Gates : ÖZEL VEYA DEĞİL kapıları
• BUFFERS : Tamponlar
3.8. Digital (Dijital)
Şekil 18’de çeşitli dijital entegre devre elemanları görülmektedir.
Şekil 18
• Half-Adder : Yarım toplayıcı
• Full-Adder : Tam toplayıcı
• RS Flip-Flop : RS flip flop
• JK Flip-Flop with Active High Asynch Inputs : Aktif yüksek asenkron girişli JK flip flop
• JK Flip-Flop with Active Low Asynch Inputs : Aktif düşük asenkron girişli JK flip flop
• D Flip-Flop : D flip flop
• D Flip-Flop with Active Low Asynch Inputs : Aktif düşük asenkron girişli D flip flop
• Multiplexers : Bilgi seçiciler, Çoğullayıcılar (Mux)
• Demultiplexers : Bilgi dağıtıcılar, Yol çoklayıcılar (Demux)
• Encoders : Kodlayıcılar
• Arithmetic : Aritmetik
• Counters : Sayıcılar
• Shift Registers : Kaydırmalı kaydediciler
• Flip-Flops : Flip flop’lar
3.9. Indicators (Göstergeler)
Şekil 19’da, elektronik devrelerde kullanılan bazı sesli ve ışıklı göstergeler
görülmektedir.
Şekil 19
• Voltmeter : Voltmetre
• Ammeter : Ampermetre
• Bulb : Ampul
• Red Probe : Kırmızı prob, lojik sinyal seviye gösterici
• Seven-Segment Display : Yedi segmentli display
• Decoded Seven-Segment Display : Kod çözücülü yedi segmentli display
• Buzzer : Buzer, belirli frekansta ses üreten devre elemanı
• Bargraph Display : Çubukgrafik display
• Decoded Bargraph Display : Kod çözücülü çubukgrafik display
3.10. Controls (Kontroller)
Şekil 20’de görülen kontrol elemanlarının adları aşağıdaki verilmiştir.

Şekil 20
• Voltage Differentiator : Gerilim türev alıcı
• Voltage Integrator : Gerilim integral alıcı
• Voltage Gain Block : Gerilim kazanç bloğu
• Transfer Function Block : Transfer fonksiyon bloğu
• Multiplier : Çarpıcı
• Divider : Bölücü
• Three-Way Voltage Summer : 3 yollu gerilim toplayıcı
• Voltage Limiter : Gerilim sınırlandırıcı
• Voltage Controlled Limiter : Gerilim kontrollü sınırlandırıcı
• Current Limiter Block : Akım sınırlandırıcı blok
• Voltage Hysteresis Block : Gerilim histeresiz bloğu
• Voltage Slew Rate Block : Gerilim eğim oranı bloğu (Sinyalin yükselme ve düşme hızını ayarlar)
3.11. Miscellaneous (Çeşitli)
Şekil 21’de simülasyon sırasında kullanılacak çeşitli elemanlar görülmektedir.
Şekil 21
• Fuse : Sigorta
• Write Data : Veri yazma (Simülasyon sonuçlarını ASCII dosyaya yazar)
• Netlist Component : Netlist elemanı (Üreteci firmanın eleman modelini .CIR uzantılı bir dosya
aracılığıyla devreye eklemek için kullanılır)
• Lossy Transmission Line : Kayıplı iletim hattı
• Lossles Transmission Line : Kayıpsız iletim hattı
• Crystal : Kristal
• DC Motor : Doğru akım motoru
• Triode Vacuum Tube : Triyod vakum tüpü
• Boost (Step-Up) Converter : Yükseltici konvertör
• Buck (Step-Down) Converter : Düşürücü konvertör
• Buck-Boost Converter : Düşürücü-yükseltici konvertör
• Textbox : Metin kutusu
• Title Block : Başlık bloğu (Başlık, tarih, isim yazmak için kullanılır)
4. ELEKTRONİK DEVRE ÇİZİMİ İÇİN ÖN BİLGİLER
Bu bölümde, devre çizimi sırasında yapılan hatalı bağlantılardan, ayarlı elemanlardan ve
eleman modellerinin nasıl seçileceğinden bahsedilecektir.
4.1. Hatalı Bağlantılar
Aşağıda, devre çizimi sırasında yapılan yanlış bağlantıların birkaç tanesi verilmiştir. Bu
tip hatalı bağlantılar yapıldığında simülasyon başlatılamaz ve ekranda hata yapıldığına dair
bir uyarı mesajı görülür.
• Gerilim kaynağı kısa devre yapılmaz. Akım kaynağı açık devre yapılmaz.

• Kondansatör açık devre yapılmaz. Bobin kısa devre yapılmaz.

• Farklı değerli gerilim kaynakları paralel bağlanmaz. Aynı değerli olanlar küçük değerli
seri bir dirençle birlikte paralel bağlanabilir.

• Bir devrede birden fazla toprak bağlantısı bulunmamalıdır. Aksi taktirde toprak noktaları
birbirine fiziksel olarak bağlı duruma gelir. Buna göre alttaki iki devre de aynıdır.
• Osiloskop bağlantısı için devrede mutlaka bir toprak bağlantısı olmalıdır. Devrenin bir
ucuna veya osiloskobun sağ üst köşesindeki uca toprak bağlantısı yapılmadan simülasyon
başlatılırsa hata oluşur. Bunun için her zaman alttaki şeklin sağındaki gibi bir bağlantı
şekli oluşturulmalıdır.

4.2. Ayarlı Elemanlar
Şekil 22
Şekil 22’de ayarlı direnç, kondansatör ve bobin elemanları görülmektedir. Ayarlı
elemanlar üzerinde sırasıyla hangi tuşla kontrol edileceğini belirten bir isim (R, L veya C),
elemanın toplam değeri (1kΩ, 10µF veya 10mH) ve o andaki değeri % şeklinde yazılıdır
(%50, %40 veya %23). Elemanların değeri klavye üzerindeki belirli tuşlara basılarak
değiştirilir. Bir elemanın değerini azaltmak için R, L veya C tuşuna basılır. Bu isim şekil
23’deki pencerelerdeki Key kısmında belirtilir. Elemanın değerini artırmak için ise Shift-R,
Shift-C ve Shift-L tuşlarına basılır. Şekil 23’de görülen Setting ve Increment ayarları ise
başlangıç değeri ve artım miktarını ayarlamak için kullanılır.

Şekil 23
4.3. Eleman Modelleri
EWB programında devre çizimi yapılırken, devrede kullanılan elemanların tipi ile
birlikte modeli de seçilebilmektedir. Bir eleman için uygun parça numarası kullanılarak
tasarımın gerçeğe uygunluğu sağlanır. Örneğin diyot, transistör, opamp gibi elemanlardan
oluşan bir devrede eğer model seçimi yapılmazsa, program bu elemanların ideal olduğunu
varsayarak simülasyon yapar. Ancak, bu şekilde simülasyon yapılması gerçeği tam olarak
yansıtmaz. Çünkü pratikte her bir devre elemanının kendine özgü pek çok parametresi vardır.
Ve bu parametreler dikkate alınmadan ideal şartlar için simülasyon yapıldığında, elde edilen
sonuçlar ile gerçek sonuçlar arasında mutlaka farklılıklar meydana gelir. Bir devre elemanının
en doğru parametreleri için üretici firma kataloglarından yararlanılmalıdır. EWB programının
eleman kütüphanesindeki değerler bazen yanlış olabilmektedir. Bu tür durumlarda
http://www.electronicsworkbench.com adresinden bilgi alınabilir.
Aşağıda diyot ve transistör için model seçiminin nasıl yapılacağı gösterilmiştir. Bir
diyodun modeli seçilmek istendiğinde diyot elemanına mouse ile çift tıklanır. Bu durumda
şekil 24’de görülen pencere açılır. Bu pencerede Models seçeneğine tıklanır. Library
kısmındaki kütüphanelerden uygun olan biri işaretlenir. Bu durumda Library penceresinin
yanındaki Model penceresinde elemanın parça numaraları görülür. Bunlardan biri seçilip
Tamam butonuna basılmasıyla model seçimi tamamlanmış olur.
Şekil 24
Eğer modeldeki parametrelerin değiştirilmesi veya okunması gerekiyorsa Edit butonuna
basılır. Bu durumda şekil 25’de görünen pencere açılarak Sheet 1 ve Sheet 2 adlı sayfalarda
elemana ait bütün parametreler görünür. Bu parametrelerin değiştirilmesi gerekiyorsa,
değişiklikler mutlaka üretici firmanın bilgilerine göre yapılmalıdır. Rasgele yazılan değerler,
eleman modelinin yanlış olmasına ve simülasyonun hatalı yapılmasına neden olur.

Şekil 25
5. ANALİZ TÜRLERİ
5.1. Sürekli ve Geçici Rejim Cevabı
Bir devrenin geçici durum cevabını elde etmek için simülasyon başlatılmadan önce bazı
ayarlamalar yapılması gerekir. Örneğin seri bir RC devresinde kondansatörün şarj eğrisini
elde etmek için şekil 26’daki devre çizilir ve gerekli osiloskop bağlantısı yapılırsa, osiloskop
ekranında 10 volt değerinde bir doğru gerilim görünür. Bilindiği gibi bu, sürekli durum
cevabıdır.
Şekil 26
Geçici rejim cevabını elde etmek için Analysis menüsünden Transient seçeneğine
mouse ile tıklanır. Bu durumda şekil 27’nin sol kısmında görülen Transient Analysis
penceresi açılır. Bu pencerede Initial conditions (başlangıç şartları) için Set to Zero seçeneği
işaretlenir. (Eğer Calculate DC operating point seçeneği işaretlenirse geçici rejim cevabı
görülemez). Analysis kısmında simülasyonun başlangıç ve bitiş süreleri (TSTART ve
TSTOP) belirtildikten sonra Nodes in Circuit kısmına, geçici rejim cevabı istenen düğümlerin
numarası eklenir. (Yukarıdaki örnek için, sadece kondansatörün üst ucunun bağlı olduğu 1
nolu düğüm seçilmiştir. Hangi düğümün hangi elemana ait olduğunu anlamak için mouse,
devre şeması üzerindeki • bağlantı elemanının üzerine getirilir. Bu durumda ekranın alt
kısmında Connector: Node 1 şeklinde bir yazı görülür). Bu ayarlardan sonra simulate
butonuna basılır. Bu esnada şekil 27’nin sağ kısmında görülen Analysis Graphs penceresi
otomatik olarak açılarak geçici rejim cevabını gösterir. Gerekli ölçümlerin yapılabilmesi için
Analysis Graphs menüsü üzerindeki butonlar kullanılır.

Şekil 27
5.2. Fourier Analizi
Bu analiz yardımıyla zamana bağlı bir işaretin frekans spektrumu çizdirilebilmektedir.
Böylece işaretin hangi harmoniklere sahip olduğu ve bu harmoniklerin genliklerinin ne kadar
olduğu görülebilmektedir. Bir devrenin fourier analizini yapmak için önce devre çizilir. Daha
sonra Analysis menüsünden Fourier seçeneğine mouse ile tıklanır. Bu durumda şekil 28’in
sağ kısmındaki pencere açılır. Bu pencereye çıkış düğümünün numarası, temel frekans değeri
(eğer farklı frekanslı 1’den fazla kaynak varsa frekansların en küçük ortak çarpan değeri) ve
harmonik sayısı girilir. Son olarak simulate butonuna basılarak grafik ekranda sonuç görülür.
Şekil 28
Örnek olarak şekil 28’in sol kısmındaki devre için fourier analizi yapılmıştır. Devrede 3
farklı frekanstaki sinüsoidal işaretin bir 3 yollu gerilim toplayıcı ile toplandığı görülmektedir.
Çıkış ucuna ise osiloskop bağlıdır. Fourier analizini yapmak için Fourier Analysis
penceresinde fundemental frequency kısmına 10 Hz yazılmış ve harmonik sayısı 20 olarak
seçilmiştir. Böylece 200Hz’e kadar olan frekans bileşenleri görülebilecektir.
Şekil 29’daki grafik penceresinde zaman cevabı ve fourier analiz sonucu görülmektedir.
Fourier analizi sonuçlarına bakıldığında 50Hz, 120Hz ve 150 Hz’de pik’ler oluştuğu ve bu
pik’lerin genliklerinin sinüsoidal işaretlerin maksimum değerlerine eşit olduğu görülmektedir.
Şekil 29
5.3. Parametre Değişimi Analizi
Bu analiz yardımıyla bir devre elemanının değerindeki değişimin, devrenin çalışmasını
nasıl etkileyeceği gösterilir. Bu analizi yapabilmek için devre çizildikten sonra Analysis
menüsünden Parameter Sweep seçeneğine mouse ile tıklanır. Bu durumda şekil 30’un sağ
kısmında görülen pencere açılır. Bu pencerede hangi elemanın hangi parametresinin
değiştirileceği, parametrenin başlangıç ve son değeri, tarama tipi, değerin artım miktarı ve
çıkış düğüm numarası belirtilir. Örneğin kaynağın gerilim değeri, direncin toleransı veya
kondansatörün kapasitesi gibi seçimler yapılabilir. Bu sayede bir devre elemanının değerini
değiştirip simülasyonu yeniden tekrarlamak yerine, otomatik olarak değer değiştirilerek
sonuçlar grafik ekranda toplu halde gösterilir. Bu da devrenin parametre değişimlerinden nasıl
etkilendiğini kolayca anlamaya yardımcı olur.
Şekil 30
Yukarıdaki seri RC devresinde kaynak geriliminin 1 ile 10 V arasında 1’er volt adımla
değişmesi durumunda kondansatör geriliminin bu değişimden nasıl etkilendiği geçici rejim
analizi yapılarak şekil 31’in sol kısmında gösterilmiştir. R ve C çarpımı değişmediği için
kondansatörün dolma süresinin aynı kaldığı, fakat şarj olduğu gerilim değerinin değiştiği
görülmektedir. Şekil 31’in sağ kısmında ise kondansatör kapasitesinin 1 ile 10 µF arasında
1’er µF adımla değişmesi durumunda kondansatör geriliminin bu değişimden nasıl etkilendiği
gösterilmiştir. R ve C çarpımı her adımda farklı bir değer aldığı için kondansatörün şarj
süresinin her bir durumda değiştiği görülmektedir.
Şekil 31
Öğr. Gör.Levent TÜRKLER Electronic Work Bench Ders Notları 1

BİLGİSAYAR DESTEKLİ TASARIM-1
DERS NOTLARI
© 2003 Aliağa
Öğr. Gör.Levent TÜRKLER Electronic Work Bench Ders Notları 2
Sistem Gereksinimleri: Sistemin Kurulması için;
Minimum Konfigürasyon
486 CPU
Win95 işletim sistemi
8 Mb RAM
17 Mb HDD Boşluk
İdeal konfigürasyon
Pentium 233 Mhz CPU
Win98
32 Mb RAM
17 Mb HDD Boşluk
Programın Kurulum Dosyası Yaklaşık 7 Mb büyüklüğündedir. Bu haliyle bir diskete sığmayacağı
için CD ile kurulması yada parçalara ayrılmış haliyle disketlerde bulunmalıdır.
Kurulum: Bilgisayara kurulacak olan program gerekli yerden çalıştırılır. Karşımıza Resim.1 de görülen
pencere çıkaracaktır.
Resim.1
Bu sayfada Kurulacak program belirtilmeltedir.
Electronic Work Bench v5.12c kurulum programına hoşgeldiniz. Bu program şimdi bilgisayarına
kurulacaktır.
Kurulum güncelleme değildir. Bundan dolayı kurulama başlamadan önce tüm programlardan
çıkınız. Çıkmak için CANCEL (İPTAL) tuşuna basınız ve programları kapattıktan sonra tekrar kurulum
progrmını çalıştırınız.
UYARI:Bu program uluslararası yasalar ile korunmaktadır. Programın yetkisiz kişilerce yeniden
oluşturulması ve izinsiz olarak dağıtılması yasaktır.
Kuruluma devam etmek için NEXT (İLERİ) tuşuna basınız.
Burada yukarıda da belirtildiği üzere CANCEL (İPTAL) tuşu ile kurulumdan çıkarsınız. NEXT
tuşuna bastığınızda Resim.2 de görülen ekran gelecektir.
Öğr. Gör.Levent TÜRKLER Electronic Work Bench Ders Notları 3
Resim.2
Bu kısımda Kurulumun yapılması için gerekli klasörün yolu belirtilir. Eğer uolu komut satırında
yazabilirsiniz. Ya da BROWSE (GÖZAT) tuşu ile bunu seçebilirsiniz. Bu yol daha sonra değiştirilemez.
İleride gerekli dosyaları bu rada bulacağımız düşünülürse yol bilinmelidir.
Standart bu yol C:\Program Files\EWB512 Bu kısımın altında gerekli harddiskte alan ve bu kısımın da
altında bizim HDD mizin kapasitesi belirtmektedir.
NEXT tuşuna basarak ileri
BACK tuşu ile bir önceki ekrana
CANCEL tuşu ile Kurulumdan vazgeçilir.
NEXT tuşuna basılarak bir sonraki Resim.3 ekrana gelinecektir. Burada kurulan programların
kısayollarının BAŞLAT menüsündeki PROGRAMLAR klasöründe nereye hangi ad ile klasör oluşturularak
yerleştirileceği belirtilmektedir. Program kurulduktan sonra çalıştırılmak istenirse bu klasörden
kısayollar arancaktır.
Standart kurulumda bu klasör adı Electronic WorkBench dir. Bu klasörün içerisine 5 adet
kısayol kopyalanır bunlar;
Electronic WorkBench : Programı çalıştırma kısayolu dur.
Help for Electronic WorkBench : Program yardımı
Readme : Program hakkında kısa açıklayıcı bilgi verir
Order Information : Daha fazla bilgiyi alabilmeniz için gerekli adreslere
ulabileceğiniz başvuru formu
Remove Electronic WorkBench v5.12c : Bilgisayarınızdan programı kaldırmak için kullanılır. Bu
kısayola tıkladığınız takdirde ileride anlacağımız sorular ve menüler ile program bilgisayarıızdan silinir.
Eğer programı yanlışlıkla silmek istemiyorsanız bu kısayolu silin. Eğer daha sonra kaldırmak istersiz.
Denetim Masasında Program Ekle/Kaldır dan da programı kaldırabilirsiniz.
Öğr. Gör.Levent TÜRKLER Electronic Work Bench Ders Notları 4
Resim.3
Resim.4
En son Resim.4 deki ekran görüntüsü masaüstüne gelir. Burada Finish butonu ile Kurulum
işleminde dosya kopyalama işlemine geçirlir.
Resim.5
Öğr. Gör.Levent TÜRKLER Electronic Work Bench Ders Notları 5
Karşımıza çıkan son pencere kopyalama işlemlerinin tamamlandığını belirtir. Bundan sonra
bilgisayarınızda bu programı kullanabilirsiniz.
Resim.6
Program çalıştırıldığında açılan pencerede diğer windows uygulamalarında olduğu gibi bir
program başlığı menüler araç çubukları ve çalışma alanı vardır. Çalışma alanının altında Durum çubuğu
bulunmaktadır. Araç Çubuklarının yanında çalıştırma düğmesi bulunmaktadır. Devre
simülasyonu bu anahtar sayesinde yapılır.
Ayrıca bu anahtarın altında simülasyonu bekletme için PAUSE düğmesi bulunmaktadır.
FILE EDIT CIRCUIT
ANALYSIS
HELP
WINDOWS
Öğr. Gör.Levent TÜRKLER Electronic Work Bench Ders Notları 6
Komutların kullanılmasında dikkat edilecek noktalar;
• Koyu yazılanlar çalışabilecek olan komutlar yani aktif, gri olarak yazılan komutlar ise o anda
çalışamayacak pasif komutlardır.
• Komutların yanındaki ... 'üç nokta' o komutun o anda işlem yapmayacağını yeni bir menünün
açılacağını işlemin bu menüden sonra gerçekleşeceğini belirtir.
• Menülerde Komutların yanında belitilen tuş kombinasyonları bu işlemlerin kısayollarını
belirtmektedir. Örneğin CTRL+N..FILE menüsünde New işlemi anlamına gelir.
• Komutların bir harf altının çizilmesi o menüdeki komutun kısayolunu ifade etmektedir.
Örneğin File menüsündeki New komutunun N harfinin çizilmesi bu menüde çalışırken N
harfine basılması durumunda New işlemi gerçekleşeceği anlamına .
Menülerin işlevleri;
FILE : Dosyalama işlemleri
EDIT : Düzen İşlemleri
CIRCUIT : Devre işlemleri
ANALYSIS : Simülasyon işlevleri
WINDOWS : Çalışılan çizimin bulunduğu pencere işlemleri
HELP : Yardım işlemleri
FILE Menüsü:
New (Yeni): Yeni bir çalışma sayfası açar. Eğer çalışılan bir sayfa öncelikle bu sayfanın kaydedilmesini
belirtlen bir uyarı menüsü gelir. Kısayolu:CTRL+N Tuş:
Burada Devremize bir isim vermediğimiz takdirde devre Untitled yani başlıksız olarak
adlandırılır. Burada “Untitled Devresinde yapmış olduğunuz değişiklikleri kaydetmek istiyormusunuz?”
şeklinde soruya veilecek 3 cevap vardır;
Evet : Değişiklik kaydedilir. Bunun için ilk defa kaydetme yapılmadıysa ileride anlatılacak
olan Save As penceresi gelir.
Hayır : Yapılan değişiklikler kaydedilmeden yeni bir çalışma sayfası açılır.
İptal : Değişiklikler kaydedilmez Yeni sayfa açma işlemi İptal edilir.
Open (Aç): Daha önce kaydedilmiş olantasarımı açmak için kullanırız. Bu komuta tıklandığında bir menü
açılır. Burada kaydettiğiniz klasör adını sağ bölmeden seçilir. Sol bölmeden de dosyayı seçer ve Tamam
tuşuna tıklarız. Eğer Dosyalarımız farklı bir sürücüde Yani farklı bir HDD, CD-ROM, FDD ise Sürücü
kısmında istediğimiz sürücüyü belirledikten sonra bu işlemler yapılır. Kısayolu:CTRL+O
Tuş:
Öğr. Gör.Levent TÜRKLER Electronic Work Bench Ders Notları 7
Electronic WorkBench programında iki çeşit dosya türü seçilir. Bunlardan uzantısı CA olanlar Analog
tasarımları CD olanlar ise dijital tasarımları temsil etmektedir. Bunların dışında bir tasarımı kaydetmek
istediğimizde aksi bir durum seçilmediği takdirde dosyalarımız EWB uzantılı olarak kaydedilecektir.
Save (Kaydet): Daha önce kaydedilmiş bir dosyayı tekrar üzerine kaydetmek istersek bu komutu
kullanırız. Eğer dosyayı daha önce kaydetmediysek ilk defa kaydedilecekse bu komut tıklandığında Save
As komutu devreye girer. Kısayolu:CTRL+S Tuş:
Save As (Farklı Kaydet): Bir dosya ilk defa kaydedilecekse, adı veya dosyanın konumu değiştirilecekse
(Örneğin Harddiskten Floppy Diske kaydedilecekse) bu komut kullanılır. Dikkat edilirse Open
komutunda karşımıza çıkan pencere karşımıza gelcektir. Ancak başılığı farklı olduğu görülür. Dosyayı
kaydetme anında Dosya türü olarak 2 çeşit kaydetme şekli vardır. Bunlardan ikiside aynı uzantılıdır.
Ancak versiuon farklılıkları sebebiyle dosyayı açmak istediğimiz bilgisayarda versiyon hangisi ise bu
versiyona dikkat ederek kayıt yapılması gerekir.
Revert to Saved (Yeniden Yükle):Tasarımında yapoılan değişiklikleri iptal edilerek kayıtlı halde yeniden
çağırır. Bu işlemi yapmadan önce uyarı penceresi ekrana gelir.
Bu sayfada “Yaptığınız tüm değişikliler kaybedilecektir.” uyarısı bulunmaktadır.
Tamam : Yeniden Yüklenir.
İptal : Sayfanın yeniden yüklenme işlemi iptal edilir. Tasarım olduğu gibi kalır.
Import (Dosya Al):SPICE formatında hazırlanmış bir tasarımı EWB formatına aktarır.
Export (Dosya Ver):EWB formatında ki tasarımı SPICE formatında kaydeder.
Öğr. Gör.Levent TÜRKLER Electronic Work Bench Ders Notları 8
Print (Yazdır):Hazırlanan şemayı yazıcıya aktarmak için kullanıllır. Kısayolu:CTRL+P Tuş:
Burada açılan pencere 2 kısma ayrılır. Bunlardan sol sütünda tasarımda yazdırılması istenen kısımları
gösterir. Burada
Schematic (Şema) yazııcıdan çıkma oranı (örneğimizde %200)
Description: Varsa açıklama penceresi
Part List : Tasarımda kullanılan Parça listesi
Model List: Tasarımda kullanılan parçaların modellerin listesi
Subcircuits: Devrede varsa alt devreler
Sağ Sütünda ise tasarımda kullanılan ekipmanlar listelernir. Bu ekipmanlardan hangisi kullanılırsa burada
Onay kutusu açık olur. Örneğimizde sadece Osilaskop açık olarak görülmektedir.
Multimeter: AVOmetre
Function Genarator:Fonksiyon Jenaratörü
Oscillascope: Osilaskop
Bode Plotter: Bode Plotter
Word Genarator: Binary Sayı Üretici
Logic Converter: Mantıksal Denetleyici
Boolean Expression: Boolean Deyimleri
XP Plot: 2 düzlemli Plotter
Burada kullanılan tuşlar
PRINT: YAZDIR
CANCEL: İPTAL
ACCEPT: UYGULA (Bundan sonraki tüm tasarımlarda Yazdırma varsayılanları bunlar kabul edilir)
SETUP: Yazdırma Ayarları
Print Setup (Yazıcı Ayarları):Sayfanın yazdırma için gerekli ayarlarını yapar. Bu sayfa yazıcıya göre
değişim gösterir.
Öğr. Gör.Levent TÜRKLER Electronic Work Bench Ders Notları 9
Özellikler tuşu ile yazıcının kendi ayarlarına geçilir. Buraya program dışından Denetim Masasında Yazıcı
Seçenekleriyle de ulaşılabilir.
Exit (Çıkış): Programdan çıkmak için kullanılan seçenektir. Programı kapatmak için kullanılan bir
yöntemde pencerenin üzerindeki tuşunu tıklayarakta yapılabilir. Kısayolu:ALT+F4
Install (Kurulum): Yeni ekleri ve güncellemeleri Disket halinde yükleme yapmak için kullanılır. Açılan
pencerede yüklemenin hangi disketten yapılacağı belirtilir.
Export to PSPICE: PSPICE programına tasarımı aktarmak için kullanılır.
IMPORT from SPICE: SPICE programından dosya almak için kullanabilirsiniz.
EXPORT to SPICE: SPICE programına tasarımı aktarmak için kullanılır.
EDIT Menüsü:
Cut (Kes): İstenen bir elemanı yada devrenin bir kısmını bulunduğu yerden silerek panayo kopyalamak
için kullanılır. Kısayolu:CTRL+X Tuş:
Copy (Kopyala):İstenen bir elemanı yada devrenin bir kısmını bulunduğu yerde bırakarak panoya
kopyalamak için kullanılır. Kısayolu:CRTL+C Tuş:
Paste (Yapıştır):Panodaki bir elemanı yada devrenin bir kısmını sayfa üzerine yerleştirir.
Kısayolu:CTRL+X Tuş:
Delete (Sil): Şemada seçilen eleman yada tasarımın bir kısmını siler.Kısayolu:DEL
Select All (Tümünü Seç):Şemadaki tüm elemanları seçmek için Kullanılır. Kısayolu:CTRL+A
Copy as Bitmap (Ekran Görüntüsü):Seçilen bir alanı resim formatında panoya alır. Daha sonra istenilen
bir windows programına yapıştırılır. (Örneğin Word de bir resim olarak) ancak Bu öge resim olarak
panoya kaydedildiği için EWB de bu öğeyi yapıştırma işlemini yapamayız
Öğr. Gör.Levent TÜRKLER Electronic Work Bench Ders Notları 10
Show Clipboard (Panoyu Göster):Copy As Bipmap olarak panoya alınmış bir resim ögesini görüntülemek
için Pano Defteri Görüntüleyicisi açar. (win95 ve Win98 de bu işlemin gerçekleşmesi için pano
görüntüleyicinin Windows kurulumdan (Program Ekle/Kaldır) eklenmiş olması gerekir.
CIRCUITS Menüsü:
Rotate (Döndür):Seçilen bir elemanı 90° sola döndürür. Kısayolu:CTRL+R Tuş:
Flip Horizantal (Yatay Döndür): Seçilen Elemanı yatay eksende döndürür. Tuş:
Flip Vertical (Dikey Döndür):Seçilen Elemanı Dikey eksende döndürür. Tuş:
Component Properties (Parça Özellikleri):Seçilen elemanın özelliklerini gösterir. Her eleman için farklı
bir pencere karşımıza gelir açılan bu pencerede görülen genel ögeler (Örn:transformatör için);
Label (Etiket):Elemana isim verdiğimiz kısım,
Refernans ID: Tanımlama numarası (Örn:Trf1 vb.)
Models: Kullandığımız transformatörün Modeli
Fault:Hata tanımlamaları
Display: Elemanın devrede yanında gösterilmesi istediğimiz açıklamaları şeklinde özetlenebilir.
Öğr. Gör.Levent TÜRKLER Electronic Work Bench Ders Notları 11
Create Subcircuits: Devreye ait alt devreler eklenmek istiniyorsa buradan eklenir. Böylelikle daha
karışık devreler parçalara bölünerek anlatımı kolaylaşır.Ayrıca katları olan bir devrenin katlarını
parçalara bölmek ve çelışmasını anlatmak kolaylaşır. Devrede istenilen devre elemanları seçildikten
sonra bu seçenek seçilir burada bu alt devreye bir isim vermesi istenir. Tuş :
Arakasından devreyi taşıma yöntemlerinden birisi seçilir. Devreden kopyala,Devreden taşı, Devrede
yeniden yerleştir İptal gibi seçeneklerden biri ile devre alt devreler oluşturulur. Yapılan bu alt
devreler istenildiğinde Eleman Araç Çubuklarındaki Favorites (Sık kullanılanlar) Tuşundan çağırılabilir
Kısayolu:CTRL+B Alt Devre Ekleme
Zoom In (Yakınlaştır):Ekrandaki devreyi büyütmek için kullanılır. Sadece ekran görüntüsünü
yakınlaştırır. Yazıcı çıktısı ile bir ilgisi yoktur. Kısayolu:CTRL++ Tuş:
Zoom Out (Uzaklaştır):Ekrandaki devreyi küçültmek için kullanılır. Sadece ekran görüntüsünü
yakınlaştırır. Yazıcı çıktısı ile bir ilgisi yoktur. Kısayolu:CTRL+- Tuş:
Bunların dışında standart araç çubuğunda tuşu ile görüntü istenilen oranda ayarlanabilir
Öğr. Gör.Levent TÜRKLER Electronic Work Bench Ders Notları 12
Schematic Options (Şema Seçenekleri):Çizilen devrede görüntü ile ilgili ayarların yapıldığı yerdir.
Show Grid:Klavuz Noktalarını Göster
Use Grid:Çizimin yapılması sırasında Klavuz kullan.
Show/Hide:Görüntü Özelliklerini Göster/Gizle
Show Labels: Etiketlerini Göster. Component Properties den girdiğimiz tamamen bizim tarafımızdan
verilmiş olan tanımlayıcı bilgilerdir.
Show refernans ID: Program taradından verilen otomatik tanımlayıcı kimlikleri göster. Örn: R1 V1 vb
Show Models:Kullandığımız elemanın modelini göster. Örn. BC237
Show Values: Değerleri göster. Örn 1 K Direnç
Show nodes: Eklerin sayısını Göster.
Autohide Parts Bin:Eleman araç Çubuğundan bir eleman seçildiğinde gizle
Keep Parts Bin positions: Eleman araç Çubuğunu sabitle (Tekrar açıldığında aynı pozisyonda açılsın)
Fonts: Şemalarda kullanılan yazıtiplerini ve boyutlarını belirler.
Öğr. Gör.Levent TÜRKLER Electronic Work Bench Ders Notları 13
Label:Etiket Yazıtipi ve büyüklüğü (Değiştirmek için Set Label Font Tıklanmalı)
Values:Değerlerin yazıtipi ve büyüklüğü (Değiştirmek için Set Value Font Tıklanmalı)
Wiring:Kablolamanın nasıl olucağını belirler.
Manuel-route wires:İletken hatlarını elle ayarla.
Auto-route wires: İletken hatlarını otomatik ayarla.
Drag to connect:Bağlantıya sürükle.
Always Rerote Wires: Daima iletkenleri yeniden düzenle. İletken üzerindeki her değişiklikte iletkenin
durumu yeniden düzenlenir.
If possible, do not move wires:Mümkünse iletkenin yerini değiştirme.
Auto-delete connectors: Otomatik olarak gereksiz ekleri siler
Printing:Yazdırmanın kurallarını belirler.
For,printig, zoom to: Yazdırma için yakınlaştırma 200% (Daha önce yazdırma seçeneklerinde de
gördüğümüz yakınlaştırma oranı)
Use visual page breaks for main workspace: Temel çalışma sayfası için Görsel sayfa ayarlarını
kullanabilirsiniz. (Temel Çalışma Alanını Örn A4 sayfa formatında parçalara böler)
Use visual page breaks for subcircuits:Alt devreler İçin Görsel sayfa ayarlarını kullanabilirsiniz. (Alt
devre Çalışma Alanını Örn A4 sayfa formatında parçalara böler)
ANALYSIS Menüsü
Activate(Sistemi Çalıştır):Yapılan simülasyonu çalıştırmak için seçilir. Kısayol:CTRL+G Tuş:
Pause (Beklet): Simülasyon sırasında devreyi bekletmek için kullanılır. Kısayol:F9 Tuş:
Stop(Durdur): Simülasyonu durdurmak için seçilir.Kısayol:CTRL+G
Analysis Options(Analiz Seçenekleri): Yapılan analizin Varsayılanlarını Ayarlar. Kısayolu:CTRL+Y
Öğr. Gör.Levent TÜRKLER Electronic Work Bench Ders Notları 14
GLOBAL
Absolute Current Tolerance (ABSTOL) : Gerçek Akım toleransı ayarlar. Varsayılan değer
bipolar transistör için en uygun değerdir.
Gmin minimum conductance (GMIN) : Herhangi bir devre kolunda kullanılmış olan iletkenliği
ayarlar. Hiçbir zaman 0 olamaz. Bu değeri yükseltmek
devrenin çözümünü pozitif yönde arttıracaktır. Fakat
aynı zamanda simülasyonun hızını da düşürecektir.
Pivot relative ratio(PIVREL) : Matriks bölümünün en geniş sütunu ile kabul
edilebilebilir eksen değeri arasındaki oranı ayarlar.
Değer 0 ve 1 arasında olmalıdır.
Pivot absolute tolerance (PIVTOL) : Eksen olarak kabul edilen matrix girişinin mutlak
minimum değerini ayarlar.
Relative error tolerance (RELTOL) : Simülasyonun üniversal gerçeklik (doğruluk) kontrolüyle
ilgili hata toleransını ayarlar. Bu değer çözümün birleşimi
ve simülasyon hızını önemli derecede etkileyebilir
Simulation Temperature (TEMP) : Simülasyon anında varsayılan çevre sıcaklığı
Absolute voltage tolerance (VNTOL) : Programın mutlak voltaj hata toleransını ayarlar
Charge tolerance (CHGTOL) : Coloumb' lardaki yüklenme toleransını ayarlar
Ramp Time (RAMPTIME): : Bağımsız kaynakları, kapasitör ve indüktörün başlangıç
durumları sıfırdan son değerlerine kadar seçilen zaman
süresinde arttırır.
Relative convergence step size limit (CONVSTEP):DC Operasyon noktasının çözümü için otomatik
birleştirme yardımıyla ilgili adım büyüklük limiti kurarak
kontrol eder.
Absolute convergence step size limit (CONVABSSTEP):DC Operasyon noktasının çözümünde otomatik
birleştirme yardımını mutlak adım büyüklük limiti
kurarak kontrol eder.
Convergence limit (CONVLIMIT) : Kullanılan bazı built in eleman modellerinde birleştirme
algoritmasını sağlar/Engeller
Analog node shunt resistance (RSHUNT) :Devredeki tüm analog birleşimlerde topraklama için
direçleri ekler. Değerleri azaltmak simülasyonun hızını
azaltır.
Öğr. Gör.Levent TÜRKLER Electronic Work Bench Ders Notları 15
Temporary file size for simulation (Mb) :Simülasyon sonuçlarını depolamak için dosya
büyüklüklerini ayarlamamızı sağlar. Dosya maximum
büyüklüğü ulaştığı zaman kalan disk boşluğunu kullanarak
devam etmeyi veya mevcut datadan kurtulmayı ve
simülasyonu durdurmayı seçebileceğimiz bir diyalog
ortaya çıkar.
DC
Operating Point analysis Iteration Limit (ITL1): Bir DC nokta analizi esnasında enyüksek sınırı limitini
Newton-Raphson iterasyonunu ayarlar.
Steps in Gmin stepping algorithm (GMINSTEPS): Gmin adımlama algoritmasında adımların numaralarını
kurar. Dc operasyon nokta analizi sırasında bir çözüm
bulamamıza yardımcı olur. Eğer bir sıfır değeri seçildiyse Gmin
adımlama algoritması kullanılamaz (Engellenir)
Steps in sources stepping algorithm (SRCSTEPS): Kaynak adımlama algoritmasında adımların sayısını
kurar .DC operasyon nokta analizi esnasında bir çözüm
bulmamıza yardımcı olur.
TRANSIENT
Transient time point iteration (ITL4):
Maximum order for integration method (MAXORD)
Transient Error Tolerance factor (TRTOL)
Transient Analysis Integration Method (METHOD)
Print Statiscal data (ACCT)
DEVICE:
MOS drain diffusion area (DEFAD) :MOS sızıntı difüzyon alanı için değeri ayarlar
MOS source diffusion area (DEFAS) :MOS kaynak difüzyon alanı için değeri ayarlar.
MOS channel lenght (DEFL) :MOS kanal uzunluğu için değeri ayarlar.
MOS channel width (DEFW) :MOS kanal genişliği için değeri ayarlar.
Model parameters normal temparature (TNOM):Model parametrenin ölçüldüğü veya hesaplandığı
normal ısıyı ayarlar.
Nonlineer Model Evaluation Device Baypass (BYPASS):doğrusal olmayan model değerlendirmesi için
bypass şeması aletini açar/kapatır. Kapatma seçildiğinde
simülasyon zamanı artabilir.
Öğr. Gör.Levent TÜRKLER Electronic Work Bench Ders Notları 16
Compact transmission line data (TRYTOCOMPACT):sadece Lossy transmission dizi (sıra)elemanı için
uygulanabilir. Seçenek açıldığı zaman elektronik WorkBench data deposunu azaltmaya çalışır ve Lossy
transmission dizisi içeren devrenin geçici simülasyonu için memory kullanımı gereklidir.
INSTRUMENTS
Oscillascope
Pause after each screen
Generate time steps automatically
Minimum number of time points
Maximum time step (TMAX)
Initial condiditions
Set to Zero
User-defined
Colculate DC operating points
Bode plotter
Point per cycle
DC Operating Point:Devrede seçilen noktadaki DC analizini gerçekleştirir.
Öğr. Gör.Levent TÜRKLER Electronic Work Bench Ders Notları 17
AC Frequency Analysis: Devrede seçilen nokta için AC frekans analiziniz yapar.
Transient Analysis: Seçilen nokta için kısa süreli analizi gerçekleştirir.
Fourier Analysis: Devreye uygulanan frekansa etki eden harmonikleri Fourier Açılımları ile analizini
gerçeleştirir.
Öğr. Gör.Levent TÜRKLER Electronic Work Bench Ders Notları 18
Monte Carlo Analysis:Monte Carlo analizi istatiksel bir analizdir. Eleman özelliklerinin devre
performansını nasıl değiştirdiklerini görmemizi sağlar.
Analysis Graphs:Yapılan analizleri grafiksel ve sayısal olarak inceleyebileceğimiz. Aynı zamanda
simülasyonlarda oluşacak hataları görebileceğimiz penceredir Tuş:
Öğr. Gör.Levent TÜRKLER Electronic Work Bench Ders Notları 19
WINDOW Menüsü:
Arrange:
Circuit: devre Penceresini Göster.
Description:Açıklama Penceresini Göster. Devrenini Açıklmasının yapılacağı yer Kısayolu:CTRL+D
HELP Menüsü:
Help (Yardım):EWB hakkında yardım alabilirsiniz: Kısayolu:F1
Help Index: Yardım için index oluşturur. EWB program aradığınız bir olayı kelimeyle arayabilirsiniz.
About For Elecronic Work Bench
Öğr. Gör.Levent TÜRKLER Electronic Work Bench Ders Notları 20
PARTS BIN (Eleman Araç Çubukları ):Electronic Work Bench Programı Üzerinde birçok elemanı
bulunduran bir programdır. Bu Elemanlar çeşitli gruplar ayrılmıştır. Bu gruplar sırasıyla;
• Sources (Kaynaklar)
• Basic (Temel)
• Diode (Diyod)
• Transistör
• Analog IC's (Analog Entegreler)
• Mixed IC's (Karışık Entegreler)
• Digital IC's (Dijital Entegreler )
• Lojik Gates (Lojik Kapılar)
• Digital (R-S FlipFlop Multiplexers)
• Indicator (Göstergeler)
• Controls (Controller)
• Miscellaneous (Çeşitli devre Elemanları)
• Instruments (Ekipmalar-Ölçü aletleri)
Sources (Kaynaklar):
1. Ground (Toprak)
2. Batery (Pil)
3. DC Current Sources (DC Akım Kaynağı)
4. AC Voltage Sources (AC Gerilim Kaynağı)
5. AC Current Sources (AC Akım Kaynağı)
6. Voltage-Controlles Voltage Sources (Gerilime Bağımlı Gerilim Kaynağı)
7. Voltage-Controlles Current Sources (Gerilime Bağımlı Akım Kaynağı)
8. Current-Controlles Voltage Sources (Akıma Bağımlı Gerilim Kaynağı)
9. Current-Controlles Current Sources (Akıma Bağımlı Akım Kaynağı)
10.+Vcc Voltage Sources (+Vcc Gerilim Kaynağı)
11. +Vdd Voltage Sources (+Vdd Gerilim Kaynağı)
12.Clock (Saat sinyal üreteci)
13.AM Sources (AM Kaynak)
14.FM Sources (FM Kaynak)
15.Voltage-Controlled Sine Wave Oscillator (Gerilime Bağımlı Sinüsoydal Dalga Osilatör)
16.Voltage-Controlled Triangle Oscillator (Gerilime Bağımlı Üçgen Dalga Osilatör)
17.Voltage-Controlled square Wave Oscillator (Gerilime Bağımlı Kare Dalga Osilatör)
18.Controlled-One shot (Çok yönlü darbe şekli)
19.Piecewice Linear Souces (Parçakontrollü doğrusal kaynak)
20. Voltage-Controlled Piecewice Linear Sources (Gerilime Bağımlı parça kontrollü doğrusal
kaynak)
21.Frequance-Shift-Keying Sources (Frekans Değiştirme Anahtar Kaynağı)
22. Polynomial Souces (Gerilime Bağımlı çoklu nomial Kaynak)
23. Nonlinear Dependent Sources (Doğrusal olmayan Bağımlı Kaynak)
Öğr. Gör.Levent TÜRKLER Electronic Work Bench Ders Notları 21
Basic (Temel):
1. Connector (Ek)
2. Rezistor (Direnç)
3. Capacitor (Kutupsuz Kondansatör)
4. Inductor (Bobin)
5. Transformer (Transformatör)
6. Relay (Röle)
7. Switch (Anahtar)
8. Time-Delay Switch (Zaman Gecikmeli Anahtar)
9. Voltage-Controlled Switch (Gerilime Bağımlı Anahtar)
10.Akım-Controlled Switch (Akıma Bağımlı Anahar)
11. Pull-up rezistor (Mantık devresi sonlandırıcı direnç)
12.Potentiometer (Potansiyometre)
13.Rezistor Pack (Direnç Kutusu)
14.Voltage-Controlled Switch (Gerilime Bağımlı anahtar)
15.Polarized Capacitor (Kutupsal Kondansatör)
16.Variable Capacitor (Ayarlanabilir Kondansatör)
17.Variable Inductor (Ayarlanabilir Bobin)
18.Coreless Coil (Nüvesiz Bobin)
19.Magnetik Core (Manyetik Bobin)
20. Nonlinear Transfor (Doğrusal Olmayan Transformatör)
Diode (Diyod):
1. Diode (diyod)
2. Zener Diode (Zener Diyod)
3. LED
4. Full Wave Brigde Rectifier (Tam dalga köprü tipi doğrultucu)
5. Shockley Diode (Şok diyod)
6. Silicon-Controlled Rectifier (Tristör)
7. Diac (Diyak)
8. Triac (Triyak)
Öğr. Gör.Levent TÜRKLER Electronic Work Bench Ders Notları 22
Transistors :
1. NPN Transistör
2. PNP Transistor
3. N Channel JFET (N Kanallı JFET)
4. P Channel JFET (P Kanallı JFET)
5. 3 terminal Depletion N-MOSFET (3 girişli boşaltım N-MOSFET)
6. 3 terminal Depletion P-MOSFET (3 girişli boşaltım P-MOSFET)
7. 4 terminal Depletion N-MOSFET (3 girişli boşaltım N-MOSFET)
8. 4 terminal Depletion P-MOSFET (3 girişli boşaltım P-MOSFET)
9. 3 terminal Enhancement N-MOSFET (3 girişli genişletilmiş N-MOSFET)
10.3 terminal Enhancement P-MOSFET (3 girişli genişletilmiş P-MOSFET)
11. 4 terminal Enhancement N-MOSFET (3 girişli genişletilmiş N-MOSFET)
12.4 terminal Enhancement P-MOSFET (3 girişli genişletilmiş P-MOSFET)
13.N Channel GaAsFET
14.P Channel GaAsFET
Analog IC's:
1. 3 Terminal Opamp (3 girişli Opamp)
2. 5 Terminal Opamp (5 girişli Opamp)
3. 7 Terminal Opamp (7 girişli Opamp)
4. 8 Terminal Opamp (9 girişli Opamp)
5. Comperator (Karşılaştırıcı)
6. Phase-Locked Loop (Faz Kilitlemeli Bağlayıcı)
Mixed IC's
1. Analog to Digital Converter (Analog Dijital Dönüştürücü)
2. Digital to Analog Converter (I)(Dijital Analog Dönüştürücü (I))
3. Digital to Analog Converter (V)(Dijital Analog Dönüştürücü (V))
4. Monostable Multivibrator (Karasız multivibrator)
5. 555 Timer (555 zamanlayıcı)
Öğr. Gör.Levent TÜRKLER Electronic Work Bench Ders Notları 23
Digital IC's
1. 74xx Template (74xx serisi Entegreler)
2. 741xx Template (741xx serisi Entegreler)
3. 742xx Template (742xx serisi Entegreler)
4. 743xx Template (743xx serisi Entegreler)
5. 744xx Template (744xx serisi Entegreler)
6. 4xxx Template (4xxx serisi Entegreler)
Logic Gates:
1. 2 Input AND Gate (2 Girişli Ve Kapısı)
2. 2 Input OR Gate (2 Girişli Veya Kapısı)
3. NOT Gate (Değil Kapısı)
4. 2 Input NOR Gate (2 Girişli Veya Değil Kapısı)
5. 2 Input NAND Gate (2 Girişli Ve Değiil Kapısı)
6. 2 Input XOR Gate (2 Girişli Exculucive Veya Kapısı)
7. 2 Input XNOR Gate (2 Girişli Exculucive Veya Değil Kapısı)
8. Tris-state Buffer (3 Durumlu Tampon Kapısı)
9. Buffer Gate (Tampon Kapısı)
10.Schmitt Trigger Dönüştürücü
11. AND Gates (Cmos-4xxxTTL-74xxx)
12.OR Gates (Cmos-4xxxTTL-74xxx)
13.NAND Gates (Cmos-4xxxTTL-74xxx)
14.NOR Gates (Cmos-4xxxTTL-74xxx)
15.NOT Gates (Cmos-4xxxTTL-74xxx)
16.XOR Gates (Cmos-4xxxTTL-74xxx)
17.XNOR Gates (Cmos-4xxxTTL-74xxx)
18.BUFFER Gates (Cmos-4xxxTTL-74xxx)
Indicators:
1. Voltmetre
2. Ampermetre
3. Bumb (Lamba)
4. Red Prob
5. Seven-Segment Display
6. Decoded seven-Segment Display
7. Buzzer
8. Bargraph Display
9. Decoded Bargraph Display
Dijital:
Öğr. Gör.Levent TÜRKLER Electronic Work Bench Ders Notları 24
1. Half Adder (Yarım Ekleyici)
2. Full Adder (Tam Ekleyici)
3. R_S Flip Flop
4. J_K Flip-Flop with Active High Asynch Inputs (Yüksek Hareketli Asenkron Girişli J_K Flip Flop)
5. J_K Flip-Flop with Active Low Asynch Inputs (Düşük Hareketli Tam asenkron Girişli J_K Flip Flop)
6. D Flip Flop
7. D Flip-Flop with Active Low Asynch Inputs (Düşük Hareketli Tam asenkron Girişli D Flip Flop)
8. Multiplexers
9. Demultiplexers
10.Encoders (Kod Çözücüler)
11. Counters (Sayıcılar)
12.Aritmetics (Matematik İşlemcileri)
13.Shift Register (Kaydırmalı Kaydediciler)
14.Flip Flop
Controls
1. Voltage Differentiator (Gerilim Ayrıştırıcı)
2. Voltage Integrator(Gerilim Birleştirici)
3. Voltage Gain Block (Gerilim Kazanç Bloğu)
4. Transfer Function Block (Fonksiyon Transfer Bloğu)
5. Multiplier (Çoklayıcı)
6. Divider (Bölücü)
7. Three Way Voltage Summer (Üç yollu gerilim toplayıcı)
8. Voltage Limiter (Gerilim Sınırlayıcı)
9. Voltage Controlled Limiter (Gerilim Kontrollü Sınırlayıcı)
10.Current Limiter Block (Akım sınırlayıcı Blok)
11. Voltage Hysteresis Block
12..Voltage Slew rate Block
Instruments:
1. Multimeter (AVOMetre)
2. Function Generator (Fonksiyon Üreteci)
3. Oscillaskope (Osilaskop)
4. Bode Plotter
5. Word Generator (Sayı Üreteci)
6. Logic Analyzer (Mantık Analiz)
7. Logic Converter (Mantık Dönüştürücü)
Öğr. Gör.Levent TÜRKLER Electronic Work Bench Ders Notları 25
Miscellaneous:
1. Fuse (Sigorta)
2. Write Data (Veri Yazıcı)
3. Netlist Component
4. Lossy Transmission Line (Kayıp İletim Hattı)
5. Lossless Transmission Line (Kayıpsız İletim Hattı)
6. Criystal (Kristal)
7. Dc Motor (Doğru Akım Motoru)
8. Three Vakum Tube (Katot Tüp)
9. Boost (Step-Up) Converter (Yukarı Dönüştürücü)
10.Buck (Setp-Down) Converter (Aşağı Dönüştürücü)
11. Boost/Buck Converter (Yukarı/Aşağı Dönüştürücü)
12.TextBox (Metin Kutusu)
13.Title Block (Başlık Bloğu)
Öğr. Gör.Levent TÜRKLER Electronic Work Bench Ders Notları 26
TASARIMLARIMLARIN ÇİZİLMESİ
EWB Programında yapılması istenen devre için gerekli Elemanlar araç çubuklarından alınarak
çalışma sayfasına yerleştirildikten sonra elemanların uçlarına mouse un imleci ile yaklşıldığı zaman
eleman uçlarının siyah noktalar belirir. Bu noktalara mouse un sağ tuşu ile tıklanarak elimizi kaldırmadan
diğer elemanın ucuna götürdüğümüz takdirde iki eleman arasında iletken çizilmiş olur.
Eğer çizilmiş bir iletkene ek yapılmak istenirse iki yöntem vardır. Bunlardan bir tanesi çizigi
arasına ek noktası yerleştirilir. Bu ya iletkenleri ayırıp bu ek noktası ile tekrar bağlamayla gerçekleşir,
yada iletkeni ayırmadan ek noktası bu iletken üzerine getirilip bırakılırsa ek noktası otomatik olarak
yerleşir. İkinci yöntem ise ek yapılacak iletken var olan iletkene yarklaştırılıp bırakılırsa ek noktası
otomatik olarak yapılır.
Eğer iki iletken kesişecekse ve aralarında bağlantının olması istenmiyorsa birinci iletken bağlandıktan
sonra ikinci iletken çizgi üzerinde tutulmadan diğer elemana bağlanır.
Burada iki direnç arasındaki iletken ile bobin ve konsansatör arasındaki iletken arasında hiçbir ek
noktası olmadığı için bağlantıda yoktur. Eğer iki iletken kesiştikleri noktada birleştirilmek istenirse
iletkenlerin kesiştikleri noktaya ek noktası koyulur ekler kendiliğinden gerçekleşir.
Öğr. Gör.Levent TÜRKLER Electronic Work Bench Ders Notları 27
Devre çizimi sırasında eleman arasındaki iletken eğer aynı doğrultuda değilse ve Schematic
Options seçeneklerinde gördüğümüz Auto-route wires seçeneği işaretli ise iletken otomatik olarak en
iyi şekli alacak şekilde yerleştirilir. (Gerekli olduğu takdirde köşeler oluşabilir)
Çizim işlemi bittikten sonra eğer elemanların yerleri değiştirilmek istenirse Elemanın üzerine
tıklanarak eleman istenildiği noktaya çekilebilir. Bu durumda iletken ek noktalarından kopmadan eleman
istenildiği yere taşınır Eleman bırakıldığında iletken yeni konuma göre şekil alır.
Öğr. Gör.Levent TÜRKLER Electronic Work Bench Ders Notları 28
Çizim Uygulaması-1: Bu uygulamada basit bir elektrik devresini oluşturacağız. Bu devrede 12 Voltluk
bir pil iletken bir lamba bir anahtar yardımyla çalışacaktır. Bunun gerekli elemanları bulundukları araç
çubuklarında alarak tasarım sayfası üzerine yerleştirelim ve biraz önce anlatıldığı yöntemlerle
birleştirelim.
Pil için; Sources (Kaynak) araç Çubuğundan Battery elemanını
Anahtar için; Basic (Temel) araç Çubuğundan Switch elemanını
Lamba için; Inducator (Göstergeler) araç Çubuğundan Bulb elemanını alırız.
Devre Şeması:
Burada anahtar üzerinde görülen SPACE yazısı bu anahtarı kumadan eden klavye üzerindeki tuşu
göstermektedir. Devremize göre bu işi yapan tuş boşluk çubuğudur. Devreyi kurduktan sonra EWB
penceresinde sağ üst köşedeki açama kapama anahtarı yada ANALYSIS menüsündeki Active seçeneği
ile devre çalıştırılır. Boşluk çubuğuna tıklandığında anahtar kapanır ve lambanın görünümünde değişme
meydana gelir.
Burada da görüldüğü gibi lamba koyulaşır. Anahtarı söndürmek için boşluk çubuğuna tekrar
tıklanır. Anahtar açılır ve lamba eski konumuna geri döner. Lambayı ykıp söndürmek için kullanılan
anahtarı farklı bir tuş ile çalıştırmak istiyorsanız. Yada devrenizde iki farklı buton kullanmanız
gerektiğinde anahtar üzerine çift tıklanarak Eleman özellikleri (Component Properties) penceresini
açarız. Burada Key seçeneğini istediğimiz buton ile değiştiririz.
Örneğimizde SPACE iken bunu A yapmak istersek buraya A yazarız. Buton bundan sonra A tuşu
ile kontrol edilir.
Görüldüğü gibi sistemde simülasyon beklendiği gibi çalışmaktadır. Peki gerçek bir simülasyonda
çalışma gibi sorunları da gösterilmesi gerekmektedir. Buna göre üreteç gerilimini 12 V 120V değerine
çıkarmış olsaydık. Lambanın arızalanması yani flamanlı lamba için flamanların erimesi gerekir. Bizim
devremizde bunu denersek görülecek simülasyon şu şekilde olmalıdır. Bunun için pil gerilimini
değiştirmek için pil üzerien çift tıklanarak yine eleman özelliklerine gelinir. Burada pil gerilimi 12 Volt
değerinden 120 volta çıkarılıp Tamam tuşuna basılırsa pil gerilimi değiştirilmiş olur.
Öğr. Gör.Levent TÜRKLER Electronic Work Bench Ders Notları 29
Şimdi devrenin nasıl bir tepki verdiğini görelim: Gerçek bir devrede uyuglanan gerilim nedeni ile
fazla akım geçer bu lambanın flamanlarını fazla ısınmasına ve sonuç olarak flamanların kopmasına neden
olur.
Görüldüğü gibi lambanın uçları kopmuş şekliyle görülmektedir. Bu da programımızın bizlere
devreninin çalışmasının yanı sıra sorunlarıda aynı şekilde gösterdiğinin bir örneğidir.
Çalışma Sorusu: Bu devrede bir anahtar ile bir lamba kontrol edilmiştir. Sizler bu devrede gerekli
değişiklikleri yaparak iki anahtar ile iki farklı lambayı kontrol edebilecek bir devre tasarlayınız.
Lambalardan birini A, diğerini B tuşunun kontrol etmesini sağlayın.
1
F. Ü. MÜH.FAK.
BİLGİSAYAR MÜH. BÖL.
SAYISAL ELEKTRONİK LAB.
DENEY NO: 1
LOJİK KAPILAR VE KOMBİNASYONAL LOJİK DEVRELER
Deneyin Amacı :
Bu deneyde Boolean cebirinde kullanılan operatörlerin (mantık kapıları ) tanınması,
boolean cebirindeki eşitliklerin mantıksal kapılar ile gerçekleştirilmesi, kombinasyonal lojik
devre tasarımı ve fonksiyon denklemlerininin oluşturulması incelenecektir. Ayrıca Min.
Terimlerin toplamı veya Max.Terimlerin çarpımı şeklinde oluşturulmuş fonksiyon
denklemlerinin NAND veya NOR bağlaçları ile gerçekleştirilmesine ait uygulamalar
yapılacaktır.
Ön bilgi:
Boolean Cebiri sadece iki durumda bulunabilen değişkenlerle çalışan matematiğin bir
dalıdır. Bu cebir yapısı itibariyle iki tabanlı sayı sistemini kullanmaya uygundur (iki tabanlı
sayı sistemindeki rakamların 0 veya 1 durumlarında bulunabileceğini hatırlayınız.)
Elektronikte de de iki durumlu rakamlarla ifade edilebilen ikili sayı sisteminin uygulaması
oldukça basittir.
Boolean değişkenleri durum değişkenleri olarak ta bilinir. Bu tip değişkenler sadece
iki durumda bulunabilirler. Durumlar doğru veya yanlış olarak bilinir. Bu şekildeki mantıksal
değişkenler 1 veya 0, HI (HIGH) veya LO (LOW), ON veya OFF , TRUE veya FALSE,
olarak ifade edilir.
Boolean cebrinin temel operatörleri VE (AND), VEYA (OR) ,DEĞİL (NOT)
bağlaçlarıdır. Bunlardan türeyen NAND ( VE DEĞİL), NOR (VEYA DEĞİL) vb. bağlaçlarda
kullanılır. Sadece Lojik çarpım ve lojik toplama işlemlernin yapıldığı Boolen Cebrin’de
değişkenler belirli kurallara göre bağlaçlar ile bağlanarak Fonksiyon denklemleri elde edilir.
Doğruluk tabloları Boolean değişkenlerin aralarındaki ilişkinin tarif edilmesini için
önemli bir ifade şeklidir.. Bir doğruluk tablosu bütün bağımsız değişkenleri ve bağımlı
değişkenleri ve onların mümkün olan bütün durum kombinasyonlarını listeler. Bağımsız
değişkenler doğruluk tablosunun sol tarafının üstünde listelenir. Doğruluk tablosunun en üst
sağ tarafında da bağımlı değişkenler (çıkış büyüklükleri) vardır. Doğruluk tablosunun
sütunları Boolean değişkenleri ile birleştirilmiş mümkün olan bütün durumları gösterir.
Fonksiyon denklemleri ise doğruluk tablosunun boolean cebrineki ifade tarzıdır.
Aşağıdaki tablonun değerlendirilmesi ve boolean cebrinin kural ve teoremlerinin hatırlanması
öğrencinin sorumluluğundadır.
A B F G H I j K
0 0 0 0 1 1 1 0
0 1 1 0 1 0 0 1
1 0 1 0 1 0 0 1
2
1 1 1 1 0 0 1 0
Fonksiyon
denklemleri F= A+B G=A.B H=(A.B) I = A+B J=AOB K=AOB
Bir Kombinasyonal Lojik devre ( Çıkış değerlerinin sadece giriş değişkenlerine bağımlı
olduğu devre ) tasarımında izlenecek yol aşağıdaki gibidir.
a) Sözle anlatımdan tanım tablosu oluşturulur.
b) Tanım tablosundan fonksiyon denklemi elde edilir. ( Min.Terimlerin toplamı veya Max.
Terimlerin çarpımı şeklinde. )
c) Fonksiyon denklemi kısaltılır.(Teoremler veya Karnough yöntemi veya tablo yöntemi ile )
d) İstenirse tek tip bağlaç ile gerçekleştirmek için işlem yapılır. ( NAND veya NOR
bağlaçları ile )
e) Lojik şema ve uygulama yapılır.
Lojik uygulamada seçilecek entegre devre familyası, devrenin özelliklerine göre belirlenir.
Günümüzde çok özel devreler hariç genellikle devre gerçekleştirmede TTL ve CMOS
familyasını entegre devreler kullanılmaktadır.
Hazırlık Soruları:
1. TTL devreleri ne gibi özellikler gösterir.?
2. Entegre devre familyası seçimindeki 4 önemli kriter nedir.
3. NPN tipi transistörler kullanarak deney 1.5 ve deney 1.4 için elektronik devre
tasarımını gerçekleştiriniz.?
4. Diyod kullanarak deney 3.3 için elektronik devre tasarımını gerçekleştiriniz.?
5. F=ABC+CB+AC+AB+C fonksiyon denkleminin tersi ve kısaltılmış sonucu nedir.
Deney 1.1. Not Kapısı Ve Doğruluk Tablosunun Elde Edilmesi
74LS04 entegre devresi ile aşağıdaki devreyi kurunuz ve doğruluk tablosunu
oluşturunuz.?
Deney 1.2. And Kapısı Ve Doğruluk Tablosunun Elde Edilmesi
74LS08 entegre devresi ile aşağıdaki devreyi kurunuz ve doğruluk tablosunu
oluşturunuz.?
Deney 1.3. Or Kapısı Ve Doğruluk Tablosunun Elde Edilmesi
74LS32 entegre devresi ile aşağıdaki devreyi kurunuz ve doğruluk tablosunu
oluşturunuz.?
1 2
lojik
indicator 1 lojik
indicator 2
PB-1 LI3
LS1
LS2
LI1 LI2
74LS08
3
Deney 1.4 . Nand Kapısı Ve Doğruluk Tablosunun Elde Edilmesi
74LS00 entegre devresi ile aşağıdaki devreyi kurunuz ve doğruluk tablosunu
oluşturunuz.?
Deney 1.5. Nor Kapısı Ve Doğruluk Tablosunun Elde Edilmesi
74LS02 entegre devresi ile aşağıdaki devreyi kurunuz ve doğruluk tablosunu
oluşturunuz.?
Deney 1.6. Minterm Ve Maxterm Doğruluk Tablolarının Kullanımı
Bu deneyde kombinasyonel lojik devrelerin gereksiz lojik elemanlarını azaltma
tekniklerini göreceğiz.
Deneyde Kullanılacak Elemanlar: C.A.D.E.T seti,
74LS08 Quad 2 girişli AND,
74LS04 Hex NOT kapısı,
74LS27 Triple 3 girişli NOR,
74LS32 Quad 2 girişli OR.
LI3
LS1
LS2
LI1 LI2
74LS32
LI3
LS1
LS2
LI1 LI2
74LS00
LI3
LS1
LS2
LI1 LI2
74LS02
4
Deneyin Yapılışı: Aşağıda verilmiş devreyi kurunuz.
LS1, LS2 ve LI3'ü kullanarak bu devrenin doğruluk tablosunu oluşturunuz. Bu devre gereksiz
elemanlara sahiptir. Karnough diyagramını kullanarak daha sade hale getiriniz. Daha sonra
setten bu devreyi kaldırıp aşağıdakini kurunuz ve bu devreninde doğruluk tablosunu
gerçekleştiriniz.
Sorular:
1. Yukarıdaki iki devrenin doğruluk tablolarını karşılaştırınız.
2. Hangi devrenin kullanımı daha iyidir?, Niçin?
3. Kuruğunuz 1.devreden elde ettiğiniz doruluk tablosunu kullanarak teoremler yardımıyla
denklemi en kısaltılmış hale getiriniz.
Deney 1.7. Basit Bir Decoder (Kod Çözücü) Devresi
Deneyde Kullanılacak Elemanlar: C.A.D.E.T seti,
74LS08 Quad 2 girişli AND,
74LS04 Hex NOT kapısı,
74LS11 Triple 3 girişli AND,
Decoderler genellikle bilgisayarlarda hafıza ve I/O elemanlarına yetki vermekte kullanılırlar.
Bir decoder çoğu kere AND ve NOT kapılarından gerçekleştirilir.
LS1
LS2
LI3
74LS04
2/6
74LS08
3/4
74LS27
1/3
1 2
3 4
1
2
3
4
5
9
6
10
3
4
5
6
8
5 6
74LS04
1/6
LS1
LS2
LI3
1 2
1
2
3 4
3
74LS04 74LS32
5
Deneyin Yapılışı:
LS1, LS2 ve LI1'i kullanarak aşağıdaki devrenin doğruluk tablosunu bulunuz.
Daha sonra bu devreyi kaldırıp 2*4 lük decoder devresi
olan aşağıdaki devreyi gerçekleştirniz. Bu devreninde
doğruluk tablosunu oluşturunuz.
Sorular:
1. 2*4'lük decoderin çalışmasını anlatınız.
2. 101 binary değerinin kodunu çözen bir devre tasarlayınız.
3. BCD sayıları decimale dönüştüren 2*4'lük bir decoder devresi tasarlayınız. Böyle bir
devrede kaç tane AND kapısı gerekli olacaktır.
4. 2*4'lük decoder devresi için doğruluk tablosu neden
Y  AB  AB  AB AB
şeklinde
yazılamaz.
Deney 1.8 Encoderların Çalışma İlkesi
Encoderlar bir veya daha fazla girişi kabul edip çok bitli bir binary çıkışı üretirler. En
basit encoder devresi pozitif bir NAND kapısıdır.
LS2
LS1
LS3
LI1
3
4
5
6
74LS11
1/3
LS2
LS1
LI4
LI3
LI2
LI1
1 2
3 4
1
2
3
4
5
6
9
10
8
13
12
11
74LS04
2/6
74LS08
4/4
6
Deneyde Kullanılacak Elemanlar: C.A.D.E.T seti,
74LS00 Quad 2-girişli NAND.
Deneyin Yapılışı:
Aşağıda gösterilen devreyi kurunuz. Burada PB1 ve PB2 C.A.D.E.T'in push butonlarıdır. LS3
Lojik-0 da iken PB1 ve PB2'ye aynı anda basınız. PB1 ve PB2 kendiliğinden lojik-1 konumuna
gelirken LS3 kullanıcı sayesinde eski konumuna döner. Daha sonra sadece PB1'e ve PB2'ye
basınız. Her durum için gözlemlerinizi kaydediniz.
Deney 5: EXOR DEVRESİ VE ONUN BAZI UYGULAMALARI
Deneyde Kullanılacak Elemanlar: C.A.D.E.T seti,
74LS08 Quad 2 girişli AND,
74LS04 Hex NOT kapısı,
74LS86 Quad EXOR,
74LS32 Quad 2 girişli OR.
Deneyin Yapılışı:
EXOR fonksiyonu için doğruluk tablosu ve bu tablonun kapı devresi aşağıda verilmiştir.
PB2
PB1
LS3
LI2
LI1
1
2
5
4
3
6
7
A B Y
0 0 0
0 1 1
1 0 1
1 1 0
LS1, LS2 ve LI3 kullanarak bu devrenin doğruluk tablosunu çıkarınız. Devre şekilde görüldüğü
gibi girişler tek olduğu zaman çıkış lojik-1 olur. Bu yüzden EXOR devreleri çoğu kere tek/çift
belirleyici olarak adlandırılır.
Yukarıdaki devreyi kaldırıp yerine 74LS86 kapısını set üzerine kurunuz. Bu devreninde
doğruluk tablosunu çıkarınız.
Sorular:
1. Yukarıdaki iki devrenin doğruluk tablolarını
karşılaştınız.
2. EXOR kapısı hangi matematiksel fonksiyonu
gerçekleştirir.
3. Kullanımda hangi devre daha iyidir, Neden?
4. EXOR'un Karnough diyagramını çıkarınız.
Deney 6: EXNOR Devresi
Deneyde Kullanılacak Elemanlar: C.A.D.E.T seti,
74LS04 Hex NOT kapısı,
74LS86 Quad EXOR
Deneyin Yapılışı:
Aşağıda gösterilen devreyi kurunuz.
LS1
LS2
LI3
1 1
1
2
3 4
4
2
2
3
5
6
3
74LS04
2/6
74LS08
2/4
74LS32
1/4
LS1
LS2
LI3
1
2
3
74LS86
1/4
8
EXNOR lojik fonksiyonu EXOR'un tamlayanıdır. Bu devrenin doğruluk tablosunu çıkarınız.
EXNOR devresi girişler birbirine eşit olduğu zaman çıkışı lojik-1 yapar.
Sorular:
1. EXNOR lojik denklemini direk olarak doğruluk tablosundan çıkarınız.
2. EXNOR fonksiyonu için Karnough diyagramını oluşturunuz.
F.Ü. MÜH. FAK.
BİLGİSAYAR MÜH. BÖL.
SAYISAL ELEKTRONİK LAB.
DENEY 2
ORTA ÖLÇEKLİ ENTEGRE DEVRELER VE UYGULAMALARI
Deneyin Amacı
1- MSI (Medium Scale İntegrated Circuit-Orta Ölçekli Entegre Devre) devrelerin tanınması,
özelliklerinin sınanması
2- MSI devreleri ile uygulamalar yapılması
Ön Bilgi
Orta ölçekli entegre devreler, içerisinde yaklaşık 9-100 eleman bulundurulabilen , çok amaçlı
kullanılabilen sayısal entegre devrelerdir. Entegre içerisindeki kapı yoğunluğu SSI devrelere göre daha fazla
olduğundan genellikle CMOS teknolojisiyle üretilirler.
Genel maksatlı kullanılabilen MSI entegrelere örnek; Decoder, Encoder, Multiplexer,
Demultiplexer, Shift-Register, ROM, PLA vb. gösterilebilir.
Bunlardan multiplexer ve demultiplexerler esas fonksiyonları dışında kombinasyonal
lojik devre gerçekleştirme uygulamalarında da sıkça kullanırlar.
Hazırlık Soruları
LS1
LS2
LI3
1
2
3 1 2
9
• Deney föyü dışında displayler, multiplexerler, demultiplexerler, decoderler, encoderler ve
bunlarla ilgili uygulamalar araştırılıp çalışılacaktır.
• ROM ve PLA ‘lar hakkında bilgi edinilecektir.
• Kayıtçılar ve türleri öğrenilecektir.
• Deneye gelinmeden önce her öğrenci farklı olacak biçimde yukarıda çalışılan elemanlarla
ilgili uygulaması deney raporunda verilmek üzere birer problem çalışacaktır.
DENEYİN YAPILIŞI
Deney.1 – DECODERLER ( KOD ÇÖZÜCÜLER )
Deneyin Amacı :
Bu deneyde MSI devrelerinin çalışması ve 4:10 decoderler ile uygulamalar yapılacaktır. Bu devre sık
sık BCD-Desimal decoder olarak kullanılır. Aynı zamanda 3:8 decoder ve 2:4 decoderler gibi dörtten daha az
binary giriş sayısı için decoder olarak kullanılabilir. 74LS42 entegresi; 4 bitlik ikilik sayıların, onluk sistemdeki
karşılıklarının gösterilmesini sağlayan bir entegredir. Aşağıdaki adımlara göre deneyin yapılışı;
1- Bağlantı devresi Şekil.1 ‘de gösterilmiştir. Bu devre BCD olarak kodlanmış 4 bitlik sayıların 10 ‘luk sisteme
dönüşümünü sağlayan bir devredir. Deney setinde 74LS42 için gerekli bağlantılar aşağıdaki şekilde
girişlerin anahtarlar üzerinden bağlanması ve çıkışlara da LED ‘lerin bağlanması ile gerçekleştirilir.
Şekil.1 : BCD/DEC decoder
2- Binary girişler olarak
girişlere bağlanan deney seti üzerindeki LS1-LS4 anahtarları kullanılır. Çıkışlara bağlanan LI1-LI8 LED
‘leri 1-8 desimal çıkışlarına çözülmüştür. LED-2 8 ve LED-1 9 çıkışıdır. Devrenin çalışmasını gözleyin ve
gözlemlerinizi kaydedin.
3- Burada giriş olarak LS1-LS3 ve çözülen çıkışlar olarak LI1-LI8 kullanılır. Bu devre 3:8 uçlu decoderdir.
4- Aşağıdaki soruları cevaplarken bağlı devreyi ayırınız.
Sorular :
1- Dokuzdan daha büyük bir sayı binary giriş uçlarına girildiğinde çıkışlar ne olur?
2- LS1-LS4 girişlerine geçersiz bir giriş girildiğini anlatmak için kullanılan devre tipi nedir?
3- 3:8 uçlu decoder için geçersiz girişleri bulmak için kullanılması gereken devre tipi nedir?
4- 74LS42 ‘nin çıkışları LO ‘mu yoksa HI ‘mı doğrudur?
5- C.A.D.E.T. dahili bir displaye sahiptir şöyle ki 74LS42 ‘nin çıkışları TTL bir yük sürer ve doğrudan LED
bağlanamaz. 74LS42 doğrudan bir LED sinyalini sürmek için kullanılabilir mi?
Deney.2 - DECODER/SÜRÜCÜLER
10
Bu deneyde 7447 Display entegresinin kullanımı araştırılacaktır. Aynı zamanda yedi parçalı
displaylerin kullanımı hakkında çalışma yapılacaktır. Basit displaylerin gerçekleştirilmesi çalışılacaktır. 7447
entegresi, BCD kodundaki 4 bitlik sayıların ortak anodlu displayleri sürmesi için kullanılır. Deney adımları
aşağıdaki gibidir.
1- Bu deneyde yedi parçalı LED display çalışılacaktır. Board üzerine LTS 312 (7 parçalı ortak anodlu display)
yerleştirilir.
2- 14. pin +5 VDC ‘ye bağlanır. 4,5 ve 12. pinler için bağlantı yapılmaz. LTS 312 bir ortak anodlu display
olduğuna ve aynı zamanda yedi parçalı displayler ortak katod konfigürasyonunda kullanılabilir olduğuna
dikkat ediniz. Aynı zamanda display parçalarının a-f olarak en üstten saat yelkovanı yönünde
etiketlendiğine de dikkat ediniz. Yedinci parça g olarak etiketlenmiştir ve kesişme parçasıdır. Bu
displaylerin çoğu sol ve sağ desimal noktalara sahiptir. Bazen temel bir eksi işareti göstermek için yeteneğe
sahiptir. Burada gerçekleştirilen display bir tek tamsayı desimal displaydir. Bir full tamsayı desimal display
herhangi bir 0-9
sayısını gösterebilir.
Yarım tamsayı sadece
bir veya boşluk
gösterebilir. Devrenin
bağlantısı aşağıda
gösterilmiştir.
Şekil.2 :BCD/7 parçalı
decoder
3- LS1-LS4 ‘ü LO ‘ya döndürün ve enerjiyi uygulayın. Yedi parçalı displayde sıfır görülecektir. A-D girişleri
olarak LS1-LS4 ve çıkış olarak displayi kullanın. Bu devrenin çalışmasını gözleyin ve kaydedin.
4- Aşağıdaki soruları cevaplarken bağlı devreyi ayırınız.
Sorular :
1- Display sıfırlanabilir mi? Bu nasıl geliştirilebilir?
2- 330  ‘luk dirençlerin kullanılmasının amacı nedir?
3- LTS 312 en büyük gücü tükettiğinde gösterilen sayı nedir?
4- Boşluk göstermek için gereken giriş nedir?
Deney.3 – ENCODERLER ( KODLAYICILAR )
Bu deneyin amacı encoderleri araştırmaktır. Burada 74LS148 83 encoder çalışılacaktır. Bu tip encoder
aynı zamanda sekizlik encoder olarak bilinir. Sekizlik bir tuş takımını çözmek veya octal-binary dönüştürme
yapmak için kullanılabilir. Deneyin yapılışı aşağıdaki gibidir.
1- 74LS148 C.A.D.E.T. board üzerine yerleştirilir. 74LS148 ‘e toprak ve güç bağlantısı yapılır.
11
2- Devrenin bağlantı şeması Şekil.3 ‘de gösterilmiştir. Bu 8:3 encoderdir.
Şekil.3 : Sekiz-Üç uçlu
encoder
3- LS1-LS8 anahtarını HI (lojik1) ’a getirin ve
enerjiyi uygulayın. LI1-LI3 HI gösterecektir.
4- Giriş olarak LS1-LS8 ve çıkış olarak LI1-LI4
kullanılır. Devrenin çalışması gözlenir ve kaydedilir. Bir girişten daha fazla sıfır (LO) verildiğinde ne
olacağına dikkat ediniz.
5- Aşağıdaki soruları cevaplarken bağlı devreyi ayırınız.
Sorular :
1- 74LS148 ‘in girişleri LO veya HI doğrumudur?
2- Bu deneyde kullanılan çıkışlar LO veya HI doğrumudur?
3- Öncelikli encoderin ne anlama geldiğini açıklayınız?
4- Sıfır girişte ve giriş olmaması arasındaki farklılıkları anlatınız?
Deney.4 – DİGİTAL MULTİPLEXERLER ( SAYISAL ÇOĞULLAYICI )
Bu deneyde digital multiplexerler çalışılacaktır. 74LS153 41 veri seçici/multiplexer çalışılacaktır. Bir
multiplexer paralel seri dönüştürme için veya bir veri seçici olarak kullanılabilir. Bir multiplexer lojik
fonksiyonları gerçekleştirmek için de kullanılabilir. Aşağıdaki deneyde dört-bir uçlu multiplexerin çalışması
öğrenilecektir. Deneyin yapılışı aşağıdaki gibidir.
1- 74LS153 C.A.D.E.T. üzerine yerleştirilir. Devrenin toprak ve güç bağlantısı yapılır.
2- Devrenin bağlantı şeması aşağıda gösterilmiştir. Bu devre basit bir multiplexerdir. A, B giriş seçme uçları,
1Y çıkış, IC0...IC3 giriş uçlarıdır.
Şekil.4 : Basit bir multiplexer
12
3- LS1-LS4, LS7 ve LS8 ‘i LO (lojik 0) ’a getirin. Enerjiyi uygulayın.
4- Veri girişleri olarak LS1-LS4, seçme girişleri olarak LS7 ile LS8 ve çıkış olarak LI8 kullanılır. Bu devrenin
çalışması gözlenir ve kayıt edilir.
5- Deneyin bu bölümünde bir lojik fonksiyonu gerçekleştirmek için 74153 kullanılacaktır. Lojik AND
fonksiyonu gerçekleştirilecektir.
6- A ve B girişleri olarak LS7 ve LS8 kullanılacak ve LI8 ‘deki çıkış gözlenecektir. Bu devre için doğruluk
tablosunu kanıtlayınız.
7- Aşağıdaki soruları cevaplarken bağlı devreyi ayırınız.
Sorular :
1- Dört-bir uçlu multiplexerin çalışmasını açıklayınız.
2- Bir 74LS153 kullanarak lojik EXNOR nasıl gerçekleştirilebilir?
Deney.5 – DEMULTİPLEXERLER
Bu deneyde demultiplexerler çalışılacaktır. Demultiplexerler veya veri dağıtıcılar digital bilgisayarlarda
geniş olarak kullanılırlar. Bu deneyde 74LS138 3:8 decoderler/demultiplexerler çalışılacaktır. Bu hafıza
devreleri için adres decoder olarak veya bir demultiplexer olarak kullanılabilir.
Deney Prosedürü :
1- 74LS138 C.A.D.E.T. üzerine yerleştirilir. Devrenin toprak ve güç bağlantısı yapılır.
2- Basit bir demultiplexer devresi bağlantı şeması Şekil.5 ‘de gösterilmiştir.
Şekil.5 : Basit bir demultiplexer
3- Seçme girişleri olarak LS1-LS3, veri
girişi olarak LS8 ve çıkışlar olarak LI1-
LI8 kullanılır. Devrenin çalışmasını
inceleyiniz ve gözlemlerinizi kaydediniz. Seçilmeyen çıkışların durumuna dikkat ediniz.
4- Aşağıdaki soruları cevaplarken bağlı devreyi ayırınız.
Sorular :
1- Demultiplexer multiplexerin ters fonksiyonu olduğundan dolayı 74LS138 seri paralel dönüştürme için
kullanılabilir mi?
2- Demultiplexer ne tip bir devreden yapılmıştır?
13
İnceleme Soruları
1- Bir MSI devre tanımlayınız.
2- Lojik devrelerin gerçekleştirilmesi için hangi alternatifler kullanılabilir?
3- Temel decoder devresi nedir?
4- Temel encoder devresinin adı nedir?
5- Bir digital multiplexer tanımlayınız.
6- Bir digital demultiplexer tanımlayınız.
7- Decoderler için iki uygulama veriniz.
8- Multiplexerlerin üç uygulaması nedir?
9- Demultiplexerler ile yapılan bir uygulama ismi veriniz.
10- 16 girişli bir multiplexer için kaç tane kontrol ucuna gerek vardır?
Raporda İstenenler :
• Deneyde yaptıklarınızı, deneyde aldığınız sonuçları, bu sonuçların değerlendirilmesini ve dikkatinizi
çeken noktaları yazınız.
• Deneye gelmeden önce hazırladığınız problemler EWB programında çalışacak şekliyle yapılacak ve
yapılan işlemler ayrıntılı olarak açıklanarak sonuçları ile birlikte yazılacaktır.
• Deneyde kullandığınız devrelerin doğruluk tablolarını çıkarınız.
• Decoder ile display arasındaki bağlantı şemasını çizerek açıklayınız.
• Daha önce bilgi edindiğiniz elemanlar hakkında özetleyici bilgi veriniz.
F.Ü. MÜH.FAK.
BİLGİSAYAR MÜH.BÖL.
SAYISAL ELEKTRONİK LAB.
DENEY 3
SAYISAL ARİTMETİK
Deneyin Amacı
Bu deneyde işaretli ve işaretsiz sayılar için ikili sayı ( Binary ) sistemindeki toplama
işleminin anlaşılması, işlem performansını artırabilmek için iki tabanındaki sayıların ikili
tamlayan (complement) biçiminin anlaşılması, ikili sistemdeki sayıların çarpılıp bölünmesi
işlemlerinin anlaşılması hedeflenmiştir.
Ayrıca 16 (Hexa decimal ) tabanlı sayı sistemi ve BCD kodundaki sayılar ile aritmetik
işlemlerin yapılması üzerinde durulacaktır.
Önbilgi
N bitlik bir sayı 0 - 2
N
-1 arasındaki sayıları temsil edebilir. Bu şekildeki ifade tarzı işaretsiz
tamsayı veya kesirler için geçerlidir. Ancak sayısal sistemlerde işaretli sayılarında kullanılması
zorunludur. Bu yüzden işaretli sayılarında ifade edilmesi gerekmektedir. İşaretli sayılar iki
şekilde ifade edilmektedir ( Kodlanmaktadır ).
14
1-İşaret biti, mutlak değer şeklinde kodlama :
Bu şekilde gösterimde sayının mutlak değeri ikili sistemde ifade edilir ve bu sözcüğe (en ağırlıklı bit olarak )
işaret biti eklenir. Sayı pozitif ise işaret biti 0, sayı negatif ise işaret biti 1 olur. Örnek ;
01010111 (+87) 11010111(-87)
Bu örneklerdeki 8 bitlik sözcükler sayının mutlak değerini ve işaretini belirtir.
Toplama ve çıkarma işlemlerinde, işaret bitinide işleme katmak için bazı kurallara ihtiyaç
vardır. Bu kurallar aşağıda özetlenir.
• Aynı işaretli olanlar aynen toplanır işaret biti değiştirilmez.
• İşaret biti farklı olanlar ise işaret bitine bakılmaksızın büyük olandan küçük olan çıkarılır.
Büyük olanın işareti yazılır. Aşağıdaki örnekleri inceleyiniz.
•

001011 + 01011 001011 +01011
+ 001110 + 01110 + 100110 - 00110
+ 11001 (011001) +00101 (000101)
001011 +01011 001011 + 01011
+110110 -10110 - 001001 - 01001
-01011 (01011) +00010 (000010)
Örnekler iyi incelenirse bu şekilde kodlanmış sayıları çıkartmak için çıkartma devrelerine
gerek olduğu görülür ( Bu konunun öğrenci tarafından araştırılması gerekir.)
2- Sayının tümleyen metoduna göre kodlanması:
İkilik sayıların kodlanmasının özel bir şeklide ikili sayı sistemleri için kullanılan tamamlayıcı (tümleyici )
gösterimidir. Bu gösterim en yaygın kullanım haline gelmiştir. Bunun sebebi 2’li sayı sisteminin tamamlayıcı
formu sayısal makinelerde kolayca gösterilebilir ve işlem yapılabilir. Tümleyen aritmetikte sayının negatifliği
sayının kendi içinde tutulur. Bundan dolayı, sonuçta işaret kavramından vazgeçilir. Bunun anlamı tümleyen
metoduna göre yazılmış sayılarda çıkartma işleminin de toplayıcılar ile yapılmasıdır. Tümleme işlemi 2 şekilde
gerçekleştirilir. Taban’a tümleme (2’ye tamamlama), Taban –1’e (1’e tamamlama ) tümleme.
15
Sayı 01010101 11011011
1’e tümleyen 00101010 10100100
2’e tümleyen 00101011 10100101
Soldaki sayı +85’dir. Sağdaki sayı ise –91’dir. En soldaki bit yani işaret biti tamamlama işleminde değişmez. 1’li
tamamlama işaret biti değişmeden diğer bitlerin tamlayanının (1’se 0, 0’sa 1) alınmasıdır. Bunun anlamı şudur;
tüm büyüklük bitleri için 1’li tamlamaya dönüşüm donanımda kolayca sağlanır. 2’li tamlama ise 1’li tamlayanla
1’in toplanmasıdır. Bu EXOR kapısı ve bazı toplayıcı devrelerle gerçekleştirilir. İkili sayı sisteminde çıkarma
işlemi için çıkan sayının ikili tümleyen ile çıkarılan sayı toplanır. Aşağıda buna bir örnek verilmiştir.
14 00001110
- 5 + 11111011
100001001
Dikkat edilirse çıkarmanın sonucunun bir taşma veya taşma bitine sahip olduğu görülür. Sonuç aynı zamanda
negatif sayıların ikili tamlayan gösterimi ile işaretli bir büyüklük şeklindedir. Bu örnekte taşma biti
kullanılmamaktadır bu yüzden atılmaktadır (Tamamlayıcı toplama yoluyla çıkartma işlemlerine göz gezdirerek
deneye gelinmelidir.)
İkili sayı sisteminde çarpma ise on tabanlı sayı sistemindeki kurallara benzer olarak yapılmaktadır. İkili tabanda
çarpma için kurallar aşağıdaki gibidir:
• ikili tabandaki bir sayı 1 ile çarpılırsa sonuç sayının kendisidir.
• ikili tabandaki bir sayı 0 ile çarpılırsa sonuç 0’dır.
Bir örnek 1101 çarpılan
x 101 çarpan
1101 kısmi sonuçlar
0000
+ 1101
1000001 gerçek sonuç
Bu metodun kullanımı kolaydır ve doğru sonucu verir. İkili tabanda sayıların çarpımı için tek yol bu değildir.
Başka bir yöntemde aynı ara sonuçlar bir önceki yöntemdeki gibi yapılır. Ve soldan sağa doğru kaydırılarak
diğer yöntemdeki gibi sonuçlar başarılı bir şekilde elde edilir. Bu metoda bir örnek aşağıda verilmiştir.
1101 çarpılan
x 101 çarpan
1101 kısmi sonuçlar
00000
+ 001101
1000001 toplam sonuç
bu yöntemde diğer yöntem gibi doğru sonuç verir. Bu metod diğer metoda göre bir tane daha az register’e ihtiyaç
duyar ve donanımını gerçekleştirmek biraz daha kolaydır.
İkilik sistemde, bir sayıyı 2 ve 2’nin kuvvetleri ile çarpmanın, o sayıyı birkaç kez sola ötelemekten ibaret
olduğunu da hatırlayınız. Sayısal sistemde iki sayının çarpılması işlemi oldukça zaman alan bir işlemdir. Bunun
için değişik çarpma algoritmaları mevcuttur ve bu konu araştırılmaya devam edilmektedir.
İkili tabanda bölme ise; ikili tabandaki çıkarmanın başarılı bir şekilde yapılmasıdır. Bu şekilde bölme
yapmak doğru sonucu verir fakat özellikle büyük sayılarda yavaş ve biçimsizdir.
1000001/1101 bölümünün sonucu bu yöntemle bulunmak istenirse;
1000001- 1101-1101-1101-110-1101=0
(001)(010) (011) (100) (101) O zaman bu bölmenin sonucu (101)2 'dir.
Ayrıca ikilik sitemde kodlanmış bir sayının 2 ve 2’nin kuvvetlerine bölünmesi işleminin o sayının sağa doğru
kaydırılması ile yapılabileceğini de hatırlayınız.
16
Hexadecimal Aritmetik: İkili taban aritmetiğinde özellikle büyük sayılarla işlem yapıldığında bunu 16'lı
sisteme dönüştürerek işlem yapmak ikili taban aritmetiğine göre çok daha iyi bir performans sağlar. BCD
kodlama, toplama sonuçların displayde 10'lu sisteme göre gösterilmesi gereken sistemlerde sıkça kullanılır.
Hesap makineleri buna güzel bir örnektir. BCD sistemlerinde hexadecimaldeki 6 sayının kullanılmamasından
dolayı bazı ilginç olaylar meydana gelir. Aşağıda bunla ilgili bazı örnekler verilmiştir.
DECİMAL BCD DECİMAL BCD DECİMAL BCD
3 0011 6 0110 8 1000
+ 4 + 1011 + 8 +1000 + 9 + 1001
7 0111 Doğru 14 1110 Yanlış 17 00010001 Yanlış
Bu problemin meydana gelme sebebi 10'lu tabanda 9'dan büyük toplamlar için elde biti meydana gelir fakat
BCD'de 15den büyük toplamlar için elde biti oluşur. Bunu düzeltmek için 9'dan büyük tüm toplamlara 6 daha
eklenir. Bu işlemleri yapmak için toplamlardan hangisinin 9'dan büyük olduğunu bulan ve bulduklarına 6
ekleyen bir ek sisteme ihtiyaç vardır. Toplamı 9'dan az olanlar BCD aritmetiğinde doğru sonucu verirler. ( Bu
konunun öğrenci tarafından gözden geçirilmesi tavsiye olunur.) Oysa Hexadecimal sayılar, ikilik sistemde tam
kodlama şeklinde kodlandığından toplama işlemi her zaman daha basit ve doğrudur.
Yarım Toplayıcı
Yukarıda özet olarak anlatılan algoritmaları gerçekleştiren donanımın çekirdeği yarım toplayıcılardır. Yarım
toplayıcının şeması ve doğruluk tablosu aşağıda gösterilmiştir. Şemadan da anlaşılacağı üzere yarım toplayıcı ,
birer bitlik iki sayıyı toplayan iki girişli iki çıkışlı bir devredir. Çıkışlardan birisi sonuç diğeri ise elde biti
çıkışıdır.
Dikkat edilirse devrenin iki girişi ve iki çıkışı vardır. EXOR toplamayı gerçekleştirir. AND ise iki giriş birden 1
olduğu zaman elde bitini oluşturur. Buna yarım toplayıcı denmiştir çünkü bir önceki basamaktan gelen elde
bitini işleme alamamaktadır. Yani en sağdaki basamakta toplama işlemi yapabilirler.
Tam toplayıcı:
Tam toplayıcı üç girişe ve bir çıkışa sahiptir. Girişlerden ikisi toplanacak olan iki bit, diğer giriş ise bir önceki
toplamdan gelen elde bitidir. Tam toplayıcının çıkışları ise toplam ve elde bitidir. Tam toplayıcının şeması ve
doğruluk tablosu aşağıda verilmiştir. Tam toplayıcı her basamakta toplama işlemini başarabilir.
Paralel Toplayıcılar:
Bu tip toplayıcılar çok bitli ikili tabandaki sayıların toplanmasında iyi performans sağlarlar. Bu fonksiyonu
17
gerçekleştiren TTL lojik ailesinden olan 7483 entegresidir. Bu devrenin tartışılması gereken bazı özellikleri
vardır.
7483 entegresi hızlı elde biti elde eden 4 bitlik binary toplayıcıdır. Elde bitinin hızlı bir şekilde elde edilmesi
look ahead (ileriyi gören) denilen elde devresi tarafından mümkün kılınır. Bu devre tüm tek toplayıcıların
çıkışlarından örnek alarak bunları kaydederken tüm toplayıcıların eldesini gösteren ripple için bir zaman
gerektirir. 7483 aynı zamanda doğru lojiksel duyarlılıkta üstün bir matematiksel performans sağlar. Bunun
anlamı şudur tüm çıkışlar doğru olacaktır. 1’e tümleme aritmetiği için bunun anlamı şudur; son çevrim eldesi
direkt işleme girer. İki farklı işaretli sayının toplamı pozitifse bu son çevrim elde bitine ihtiyaç vardır. 7483'ün
blok diyagramı aşağıda gösterilmiştir.
BCD Toplayıcı :
BCD toplayıcı iki tane dört bitlik toplayıcı ve bazı ek devrelerden oluşur. BCD toplayıcının şeması aşağıda
gösterilmiştir. Dikkat edilirse ilk toplayıcının basitce toplama yaptığını ikinci toplayıcının ise toplamı 9 veya
daha büyük olanlara 6 eklediği görülür. İkinci toplayıcı, birinci toplayıcının çıkışın 9 veya daha büyük olması
durumunda AND ve OR bağlaçları tarafından kontrol edilir.
Binary Çarpıcılar
TTL lojik familyasında mantıklı değişik entegre çarpıcılar vardır. Bu çarpıcılar hızın önemli olduğu
uygulamalarda kullanılır.bu tip devreye bir örnekte iki bitlik bir sayı ile 4 bitlik bir sayıyı çarpabilen 5 bitlik bir
çıkışı 26 nS. de verebilen 74LS261 entegresidir. Bu devreler çarpma fonksiyonu ve lojik fonksiyonlarını ve diğer
aritmetik fonksiyonların performansını artırmak için kullanılır.
74LS181 entegresi ise; ALU'( Aritmetic Logic Unit) ya bir örnektir. Bu iki tane 4 bitlik binary sayılardaki
aritmetik ve lojik işlemlerini yapar (Öğrencinin ALU ünitesinin fonksiyonlarını araştırıp öğrenerek gelmesi
gerekir.)
Ön Hazırlık Soruları
1- (101) ve (011)'in toplamı kaçtır. 2 -(011) ve (010) 'in farkını hesaplayınız.
3- 120'yi BCD'ye çeviriniz 4- (111001)/(10010)=?
5- (101)x(110) =? 6- 16'lık tabandaki FF'i binary'ye çevirin?
7- 16'lık tabandaki FF'i desimale çevirin? 8- ALU ve yaptığı iş nedir?
9-120 nin birli ve ikili tamamlayanını yazınız
Deney.1 BİNARY TOPLAYICILAR
Bu deneyde binary toplayıcıların çalışması incelenecektir. Deneyde kullanılacak elemanlar:
C.A.D.E.T (Deney seti),74LS86 EXOR Entegresi,74LS08 AND E ,74LS32 OR.
1- 74LS08 ve 74LS86 deneyin ilk kısmında kullanılacaktır.
2- İlk başta aşağıda şekli verilen yarım toplayıcıyı verilen elemanlarla gerçekleştiriniz.
18
3- Anahtar LS1 ve LS2 yi girişler olarak kullanın .
4- LS1 ve LS2 LOW(düşük) durumuna anahtarlayınız. LI1 veLI2 yi toplamı ve elde bitini izlemesi için seçiniz.
Bu devrenin tanım tablosunu sağlayıp sağlamadığına bakınız.
5- Deneyin ikinci kısmında ise 74LS32 (OR) entegresinide boarda yerleştirin.
6- Yukarıda verilen devreyi gerçekleştirin.
7- LS1, LS2 ve LS3 anahtarlarını LOW (düşük) konumda tutunuz. Gücü uygulayınız.
8- LS1 , LS2 ve LS3'ü A ve B girişleri ve elde biti olacak şekilde ayarlayınız. LI1 veLI2'yi toplam ve elde bitini
izlemesi için seçiniz. Devrenin doğruluk tablosunu çıkartınız.
Deney.2 PARALEL BİNARY TOPLAYICILAR
Bu deneyde 4 bitlik paralel entegre toplayıcı kullanıp öğreneceğiz. Bu toplayıcıyı birli tamamlayan aritmetik
için kullanacağız.
Deneyde kullanılacak malzemeler: C.A.D.E.T set,7483 4 bitlik binary hızlı tam toplayıcılar,74LS86 Quad iki
girişli EXOR kapısı
1-Bu deney için 74 LS86 ve 7483 entegrelerini kullanacağız. Her iki entegreyi de boarda yerleştirip her ikisini de
topraklama ve güç bağlantılarını yapacağız. 16 pinli DIP'nin 12. Bacağına topraklamayı 5. Bacağına da gücü
bağlayınız.
2- Devreyi aşağıda şekilde verilen biçimde kurunuz.
3-Bu devrenin bazı özelliklerinin açıklanması lazımdır; 74 LS86'nın 4 kapısı tamamlama ( tümleme) devresini
düzenlemek için kullanılır. Buda bize farklı işaretteki sayıların toplanabilmesine izin verir.
4-Devrenin tamamlanmasından sonra bu yüzden girişler işaretsiz büyüklükler olarak yer alır. LS1-LS4 'ü A1-A4
girişleri olarak, LS5-LS8'i B1-B4 girişleri L11-L14'üde çıkıştaki toplam olarak ve LI8'ide elde biti olarak
kullanın. Bu devreyi ve yaptığı işleri izleyip açıklayınız.
5- Şimdi bu devreyi çıkarma için tasarlayın. 74LS86'nın 2,5,9,13 .bağlanmış bacaklarını son topraklamadaki
toprağa yeniden bağlayın.
6-Bu teli +5 volta bağlayın bu tamlama kapısını tamamlama çıkışını aktif hale getirir.
7-7483'ün 13. Pini ve toprak arasındaki bağlantıyı kaldırın. Bu bağlantıyı 7483'ün 13. ve 14. Pinlerine bağlayın.
Bu değişiklikle 1’e tamlama aritmetiği için gerekli olan en son elde biti elde edilir.
8-Tüm lojik girişlerini düşük konumuna getir. gücü ver ve gördüklerini kaydet 5. Adımdaki aynı giriş ve çıkışları
kullan LS5 ve LS8 girişlerini şu an değişme LS1 ve LS4 girişlerinin toplayıcıya birli tamlayan şeklinde girdiğini
hatırla.
9- LS5- LS8 girişlerini çıkarılan LS1 ve LS4 girişlerini ise çıkan olarak kullan devrenin yaptığı işi anlat.
19
Deney . 3 BCD TOPLAYICI
Deneyde kullanılacak elemanlar: 7483 (2),74LS08,74LS04,74LS27,7447 , LTS312 .
1-Tüm entegreleri boarda yerleştirip topraklama ve güç bağlantılarını yapın.
2-Şekilde gösterilen (soldaki) devreyi kurunuz.Tüm lojik girişleri LOW konumuna getir.
3- LS1-LS4'i birinci toplayıcı ve LS5-LS8'i diğer toplayıcının girişi olarak kullan. LI1 -LI4 toplamı gösterdiği
sürece LI8 eldeyi gösterir. Birçok sayıyı toplayıp sonuçları kontrol ediniz.
4-Gücü kesiniz. L1-L4 arasındaki bağlantıyı kaldırıp şekilde görüldüğü gibi 7447'nin
7,1,2,6.pinlerine bağlayın. L7'den L8'e olan bağlantıyı kaldırıp bunları 74LS27'nin 1. ve 2.
Pinlerine bağlayın. 74ls27'nin 13. Pinini toprağa bağlayın. 74LS27'nin 12.Pinini 74LS04'ün
3. Pinine bağlayın. 74ls04'ün 4. Pinin şekilde görüldüğü gibi led1'e bağlayın.
5- Tüm lojik anahtarlarını düşük konumuna getirin. Gücü açınız.4.adımdaki aynı girişleri
kullanın fakat LED1'le 7 segmentli displayi çıkış olarak kullanın. Ve sonuçları izleyin.
Deney.4 ALU (ARİTHMETİC LOGİC UNİT)
Deneyde kullanılacak elemanlar: C.A.D.E.T. , 74181 ALU entegresidir. 74181, işlemleri iki tane 4 bitlik giriş
üzerinden yapar ve sonuçta 4 bitlik bir çıkışla buna ait bir elde biti verir. Bir elde giriş biti vardır. Ve bu bit LS1-
LS4 ve M girişi tarafından kontrol edilir.
1-74181 board a yerleştirerek güç ve topraklama bağlantılarını şekildeki gibi kurun.
2-Tüm lojik anahtarlarını düşük konumuna getirip gücü açın .
3- LS1-LS4'ü A girişi olarak kullanın, LS5-LS8'i B girişi olarak kullanın , LI1-LI4'ü F çıkışı ve LI8'ide elde bit
çıkışı olarak kullanın.
4-74181 diğer değişik fonksiyonlarda da kullanılabilir. Fonksiyon seçimi LS1 ve LS4 girişleri üzerinde olduğu
sürece fonksiyon tipinin performansı M girişi tarafından kontrol edilir.
5- 3-6 arasındaki bağlantıları kaldıralım. 3 ve 6 pinlerini toprağa bağlıyalım ve 4 ve 5 pinlerine +5 volt verelim.
Tüm lojik anahtarları kapalı duruma getirelim.
6- Daha önce kullandığımız aynı giriş ve çıkışları kullanalım. Devrenin sonuçlarını izleyelim
ve bazen hatalı sonuçlar verdiğine dikkat edelim.
7-Gücü keselim ve 7. Pini toprağa bağlayalım. Bu durumda devreyi tekrar açıp devrenin davranışlarını izleyin ve
halen hatalı sonuç verip vermediğine tekrar bak.
20
F.Ü.MÜH.FAK
BİLGİSAYAR MÜH. BÖL.
SAYISAL ELEKTRONİK LAB.
DENEY NO: 4
FLİP-FLOP’LAR VE ARDIŞIL DEVRE TASARIMI
Deneyin Amacı
Bu deneyin amacı Flip-Flop (FF)’ların fonksiyonlarının tanınması ve senkron ardışıl devre
tasarım aşamalarının uygulanarak devre tasarımı yapılmasıdır.
Ön Bilgi
Flip-floplar bir bitlik bilgiyi saklama kabiliyetine sahip olan devrelerdir. FF’ların diğer
önemli bir özelliği de frekans bölücü olarak kullanılabilmesidir. FF’lar yapısal olarak, tek
hücreli (latch), kapılı tip (saatli - Clock girişli ) ve çift hücreli olmak üzere 3 tipdir.
Fonksiyon itibariyla dört çeşit FF vardır: S-C (R) tipi FF, D-tipi FF, T-tipi FF ve J-K
FF. J-K FF’larda tanımsız durum olmadığından ve D ve T FF’lar elde edilebildiğinden bu
FF’ların kullanılması daha uygundur. Bu deneyde J-K flip-floplar kullanılacaktır. ( FF’ların
yapısal ve fonksiyonal özelliklerinin araştırılması ve bilinmesi öğrencinin
sorumluluğundadır.)
21
Latch ( Mandal ) : Latch’ler temel FF devreleridir. Latch’e bilgi yazmak veya silmek
her zaman mümkün olabildiği için bu bir asenkron devre elemanıdır. Yani girişler her zaman
için açıktır. Çok kullanılan Latch tipleri Şekil 4.1. de verilmiştir. Bunların çalışmasını, tanım
tablolarının oluşturulmasını ve avantaj ve dezavantajlarını inceleyip öğreniniz.
Şekil 4.1. NOR ve NAND Latch yapıları.
NOR latch’in girişlerine aynı anda HI işaret uygulanamaz. NAND Latch girişlerine
aynı anda LO işaret uygulanamaz. Bu mahzuru ortadan kaldıran Latch yapısı Şekil 4.2’de
verilmiştir. Çalışmasını ve tanım tablosunu inceleyiniz.
Şekil. 4.2. D-Latch’in yapısı ve sembolik gösterilişi.
Kapılı tip ( Saat – Clock modlu ) FF’lar.
Latch’lerin her zaman için giriş işaretlerine açık olmaları dezevantajlı bir durumdur.
Önemli olan FF’ya yazma ve silme işlemlerinin kontrol edilebilmesidir. Yani FF’nun bir Clok
işaretiyle senkron olarak çalışabilmesidir. Böyle bir yapı Şekil 4.3’te verilmiştir. Şekilden
görüldüğü gibi saat modu altında çalışan S-C FF’u iki tane fazladan NAND kapısı
kullanılarak elde edilir.
Şekil 4.3 Saat modlu S-C FF
Bu devre sadece FF’ları saat modlu yapmaktadır. FF’un durumları değişmemektedir.
İki tane durumu hala kullanılamaz durumdadır. Set ve Clear girişleri saat sinyali HI
durumunda olduğu zaman flip-flobun ana kısmına geçerler. Diğer durumda geçemezler.
Set
Clear
Clock
Q
Q
Clear
Set
Q
Q Q
Q
Clear
Set
Q
Q
D
Şematik Sembol
C
S
D Q
Q
Q
Q
D
Şematik Sembol
C
S
D Q
Q
22
Saat Modlu T Flip-Flop
Saat modlu T tipi flip-flop saat modlu S-C flip-flobun değiştirilmiş şeklidir. Şekil 4.4’
da görüldüğü gibi çıkış ve tümleyeni geri beslemeli giriş olarak kullanılmaktadır. Bu girişler
Set ve Clear girişleri gibi davranmaktadırlar.
Şekil 4.4 Saat modlu T Flip-Flop
Flip-flop HI yapıldığında Q çıkışı reset girişi olarak kullanılır. Bir sonraki saat darbesi
geldiğinde, latch sıfırlanır. HI Q çıkışı set girişine geri besleme olarak gelir. Bundan sonraki
saat darbesinde flip-flop set edilir. Çıkış durumunu Set durumundan Clear durumuna almak
ve oradan tekrar Set durumuna almak için iki tane saat darbesine ihtiyaç vardır. Bu tip
devrelere T flip-flop denir çünkü çıkış her saat darbesinde bulunduğu durumun tümleyeni
olur. T flip-flop için zamanlama diyagramı Şekil 4.5’ te görülmektedir.
Şekil 4.5 T Flip-Flop Zamanlama Diyagramı
Çıkış sinyalinin frekansı giriş sinyalinin
frekansının yarısıdır. Bu tip devrelere genelde 2’
den 1’ e frekans bölücü denir. T tipi flip-flopların TTL teknolojisi ile yapılanı yoktur, bununla
birlikte elde bulunan devrelerle bu tip flip-floplar dizayn edilebilirler.
Saat Modlu D Tipi Flip-Flop
D latch daha önce anlatılmıştı. Dikkat edilirse Set girişi ile Q çıkışı arasına doğrudan
bağlantı yapılabilir ve bu girişin bir invertör’e bağlanarak invertör çıkışı
Q
çıkışı olarak
kullanılabilir. Q çıkışına saydam denir çünkü devrede sanki D girişi ile Q çıkışı arasında
doğrudan bağlantı varmış gibi görünür. Bu devre bu durumu ile kullanışsızdır, birkaç
değişiklik ile kullanışlı hale getirilebilir.
Başlangıçta S-C flip-flopunda olduğu gibi girişin önüne bir AND kapısı ekleme
düşünülebilir. Bu çalışmaz çünkü D girişinin durumuna bakmaksızın saat LO olduğunda D
latch girişi hemen LO olmaktadır. D latch girişi için devre Şekil 4.6’ de görülmektedir.
Q
D
D
Clock
D
C
Q
Q
Lojik Diyagram Şematik
Sembol
H
H
H
H
L
L
L
L
Clock
Set
Reset
Q
Q
Q
T
Q
Q Q
T
S
R Q
Lojik Diyagram Şematik Sembol
23
Şekil 4.6 Saat modlu D flip-flop
Dikkat edilecek olursa, saat sinyali HI olduğu zaman D girişi doğrudan Q çıkışı
olmaktadır. Saat sinyali LO olduğu zaman D girişi bloke edilmektedir ve saat LO durumuna
geçerken Q çıkışı latch tarafından muhafaza edilmektedir.
Başlangıç durumunu ayarlamaya elverişli D tipi flip-floplar eş zamansız Preset ve
Clear girişleri olan TTL devrelerden yapılır.
J-K Flip-Floplar
En son görülecek olan flip-floplar J-K flip-floplardır. Bu flip-floplar saat modlu S-C
flip-flop olarak, saat modlu D flip-flop olarak, T flip-flop olarak ve özelleştirilmiş
fonksiyonlar için kullanılabilirler. J-K flip-floplar belirsiz giriş ve çıkış durumuna sahip
değillerdir. J-K flip-flop devresi Şekil 4.7’ de görülmektedir.
Şekil 4.7 J-K Flip-Flop
J-K flip-flopların çalışması şu şekilde özetlenebilir.
1- J ve K girişleri LO: saat sinyali LO olduğunda hiç bir şey olmaz.
2- J girişi HI, K girişi LO: saat sinyali LO olduğu zaman, Q çıkışı HI olur veya HI
durumunda kalır.
Q
çıkışı LO. J girişindeki HI doğrudan Q çıkışına verilir.
3- J girişi LO, K girişi HI: saat sinyali LO olduğu zaman, Q çıkışı LO olur ve
Q
çıkışı HI olur. J girişindeki LO değeri doğrudan Q çıkışına verilir.
4- J ve K girişleri HI: Devre T flip-flop gibi davranır.
J-K flip-floplar çok esnektirler ve daha önce anlatılan bir çok flip-flop fonksiyonu için
kullanılabilirler. Bu fonksiyonları J-K flipfloplarla gerçekleme şekli Şekil 4.8’ de
görülmektedir.
Q Q
Q Q
S
R
CK
Lojik Diyagram
Şematik
Sembol
CK J K Q
L
L
L
L
H
H
H
H
H
L
T
Q0
Doğruluk Tablosu
T:Toggle
J
J
K
K
CK
Q Q
Q Q
Q Q
Q Q
S S
C
C C
C C
J J
J
J
K
K
K K
Vcc CK
CK
D
T
Vcc
Eşzamansız
S-C
Saat Modlu
S-C
Toggle Saat Modlu
D-Tipi
24
Şekil 4.8 J-K Flip-Flop Konfigürasyonu
Master-Slave FF’lar
J ve K girişleri Master flip-flopun durumunu belirler. Saat sinyali her iki flip-flop için
kullanılmaktadır, fakat tersi alındıktan sonra Slave FF’a verilmektedir. Bu durum Şekil 4.9’da
görülmektedir.
Şekil 4.9. J-K Master-Slave Flip-Flop
Devre Diyagramı
Devrenin saat sinyaline göre durum değiştirdiği kabul edilsin. Saat sinyali HI olduğu zaman
Master flip-flop J ve K girişlerine bağlı olarak durum değiştirir. Bu zaman süresince, tersinir
olan saat sinyalinden dolayı Slave flip-flop Master flip-flopa cevap vermez. Belli bir zaman
saat sinyali HI durumunda kaldığında Master flip-flopun durumu durağan hale gelir ve hala
Slave flip-flop Master flip-flopun çıkışına cevap veremez. Saat sinyali HI durumundan LO
durumuna geçiş yaptığı zaman, Master flip-flop J ve K girişlerine cevap veremez çünkü saat
sinyali LO dır. Bu durumda Slave FF’un C girişi HI seviyesine çıkacağından, Master FF’un
çıkışlarına göre ( Slave FF’un J-K girişlerine uygulanmıştır), Slave FF’un çıkışları da değişir.
Yani Saat işaretinin HI süresince Master’a kaydedilen bilgi, LO süresince Slave’e aktarılır.
Bu tip bir devrenin doğru çalışması için saat sinyali HI olduğu durumda J ve K
girişlerinin durağan hale gelmesi gerekir.
FF’larda tetikleme:
Bir FF’un durumu (Çıkışı ), giriş işaretindeki geçici bir değişmeyle değiştirilir. Bu
anlık değişmeye tetikleme denir. Tek hücreli (latch ) asenkron FF’lar giriş işaret seviyesindeki
değişime göre tetiklenen tiptedirler. Bu duruma seviye tetiklemeli yapı denir. Saatli FF’lar ise
darbe (pals )’ler ile tetiklenir. Darbe lojik 0 süresi lojik 1 süresine göre çok uzun olan ( küçük
duty cycle’a sahip) bir işarettir. Darbe süresi küçük bir değerde olmasına rağmen bu süre
boyunca FF’lar istenmeyen girişlere de açık olabileceğinden problemler oluşabilmektedir. Bu
problemin üstesinden gelebilmek için, FF’un darbe süresinin tam케amı yerine, darbenin
sadece (pozitif veya negatif kenar) geçişinde tetiklenmesi ( kenar tetiklemesi) sağlanabilir.
FF’un darbe geçişinde tetiklenmesi için bir yol FF’un saat girişine bir RC elemanı
Q
Q
C
J
K
Q
Q
C
J
K
Clock
Master Slave
25
bağlamaktır. Fazla kullanılmaz. Kenar tetiklemesi için ikinci bir yol bir çift hücreli FF
kullanmak veya kenar tetiklemeli bir FF kullanmaktır(Bu yapıların öğrenilmesi öğrencin
sorumluluğundadır ).
FF’larda asenkron (doğrudan )girişler.
FF’larda sadece saat girişi ile senkron çalışan girişlere ( D, T, S-R,J-K v.b) senkron girişler
veya uyarma girişleri denir. Asenkron girişler ise sat işaretinden bağımsız olarak çalışan ve
aktif hale getirildiklerinde FF’çıkışlarını doğrudan sıfırlayan veya birleyen girişlerdir. Bunlar
Preset ( P ) ve Clear ( Cl ) girişleridir.
FF’larda sadece saat girişi ile senkron çalışan girişlere ( D, T, S-R,J-K v.b) senkron girişler
veya uyarma girişleri denir. Asenkron girişler ise sat işaretinden bağımsız olarak çalışan ve
aktif hale getirildiklerinde FF’çıkışlarını doğrudan sıfırlayan veya birleyen girişlerdir. Bunlar
Preset ( P ) ve Clear ( Cl ) girişleridir.
Sayma ve Frekans Bölme
Genelde yapılan iki tane J-K flip-flop uygulaması frekans bölme ve saymadır. Daha
önce tartışıldığı gibi, bir J-K flip-flop T flip-flop olarak konfigüre edilebilir. Bu devre çıkış
sinyalinin frekansı giriş saat sinyal frekansının yarısı olan bir devredir. Birden fazla bu flipfloplardan birbirine bağlanarak ve bir önceki flip-flopun Q çıkışı bir sonraki flip-flopun saat
sinyalinin yerine bağlanarak ikinin kuvveti olan bir frekans bölücü elde edilebilir.
Benzer devreden basit bir sayıcı yapılabilir. T flip-flop oluşturmak için J ve K çıkışları
HI değerine bağlıdırlar. Bir önceki seviyenin Q çıkışı bir sonraki seviyenin saat sinyali yerine
bağlanır. Q çıkışı sayıcının ikili değerini gösterir. İlk Q 1 değeri, ikinci Q 2 değerine, üçüncü
Q 4 değerine sahiptir ve böyle devam eder. Bu tip bir sayıcıya “binary ripple up-counter”
denir. Eğer doğru bir sayma işlemi yapılmak isteniyorsa bütün flip-flopların başlangıç
değerlerinin sıfır yapılması gerekir.
Ardışıl Devreler:
Devrenin herhangi bir andaki çıkışı hem o andaki girişlere ve hemde devrenin daha
önceki durumlarına da bağımlı ise bu tür devrelere ardışıl (Sıralı) devreler denir. Ardışıl
devrelerin kombinasyonal devrelerden en önemli farkı devrede hafıza elemanlarının
bulunması gereğidir. Bu FF’ların çıkışlarına durum değişkenleri (bağımlı giriş büyüklükleri),
durum değişkenlerinin her bir kombinasyonuna da devrenin iç durumu denir. Devrenin
çıkışları durum değişkenleri olabildiği gibi çoğu zamanda bağımsızdır.
Bir ardışıl devrenin çözümü; verilen problemi sağlayabilmek için bağımlı ve bağımsız
giriş büyüklülerini kullanarak FF’ların uyarma giriş fonksiyonlarının ve çıkış fonksiyonlarının
elde edilmesi işlemidir.
Bir senkron ardışıl devre probleminin çözüm aşamaları aşağıdaki gibidir.
Problemin sözlü anlatımından durum diyagramının çıkartılması, durum sayısına göre
kullanılacak FF sayısının (durum değişkenin) belirlenmesi. Durum tablosunu kullanarak
kodlanmış durum ve çıkış tablosunun hazırlanması, durum geçiş tablosu hazırlanması, durum
geçiş tablosu ve kullanılacak FF’un geçiş tablosunu kullanarak FF’ların uyarma
fonksiyonlarının bulunması ve indirgenmesi, Çıkış fonksiyonlarının bulunması ve
indirgenmesi, lojik çizim ve uygulama.
Hazırlık Soruları
1- Flip-flop nedir?
26
2- D, T, S-R ve J-K FF’ların tanım tabloları ve geçiş tablolarını açıklayınız.
FF’ların sembollerinin anlamlarını açıklayınız.
3- Deney esnasında herhangi bir FF’un katalog bilgilerinin okunup nasıl
değerlendirileceği hakkındaki soruları cevaplamak için ve katalogları
kullanabilmek için katalog bilgileri hakkında araştırma yapınız.
4- Senkron ve Asenkron ardışıl devreleri tarif edip farklarını belirtiniz.
5- FF’lu devrelerin üstünlüklerini açıklayınız.
6- FF’larda tutma-durma süresi, kayıt yerleşim süresi nedir?
Deneyin Yapılışı
Deney 1: NAND kapıları kullanılarak bir hücreli bir mandal oluşturulması.
NAND bağlaçlarını kullanarak bread-board üzerinde NAND latch oluşturunuz. Devreyi
kontrol ettikten sonra enerji uygulayıp NAND latch’in tanım tablosunu çıkartınız.
Deney 2: Saat modlu flip-flop tasarımı
D tipi flip-flop için NAND ve NOT kapılarını kullanarak aşağıdaki saat modlu flip flop’u
tasarlayınız ve tanım tablosunu çıkarınız?
D
CP
Q
Q’
Şekil 4.10. Saat modlu flip-flop
Sorular
1- İlk iki deneyden hangi sonuçları çıkartınız?
2- 8-bitlik bir sayıyı uzun bir süre saklayacak bir hafıza nasıl yapılır?
3- Yüksek frekanstaki bir sinyalin frekansını arzu edilen seviyeye nasıl düşürürsünüz?
4- Master-Slave flip-flop tasarımını NAND Latch’ gerçekleştirimini EWB programında
hazırlayınız?
Deney 3: 3 tabanlı sayı sisteminde ileri ve geri sayma yapabilen bir senkron ardışıl devre
tasarımı.
Herhangi bir sayı tabanında n basamaklı sayıları saymak için izlenen yol herhangi
basamakta sayma işlemi yapabilecek bir sayıcı tasarlamak ve bunları ard arda kaskat bir
şekilde bağlamaktır. Bu uygulamada her basamakta kullanılabilecek, ileri yönde
..0,1,2,0,1,2... geri yönde ..2,1,0,2,1,0.. şeklinde sayım yapabilen bir sayıcı tasarımı
yapılacaktır.
Bunun için, senkronlama girişi dışında C ve D gibi iki serbest girişi olan bir çıkışı
olan ileri ve geri yönde doğal ikili kodda sayım yapabilen bir sayıcıyı J-K FF’lar ve NAND
bağlaçlarıyla gerçekleştirilecektir.
C=0, D=0 ise sayma yok, C=0, D=1 ise ileriye doğru,C=1, D=0 ise geriye doğru,
C=1,D=1 ise sayma yok kurallarını göz önüne alarak ve bu devrenin 3 tabanlı bir sayı sistemi
27
için her basamakta kullanılabileceğini düşünerek devreyi tasarlayıp gerçekleştiriniz. Devreyi
gerçekleştirmek için J-K FF’lar ve NAND bağlaçları kullanınız.
Deneye gelmeden önce, Problemi, ardışıl devre tasarım adımlarına uygun olarak
tasarlayıp EWB paket programında çalıştırınız. Deneye başlamadan önce tasarım adımlarını
ve sonuçlarını deney sorumlusu ile tartışınız. Daha sonra tasarladığınız problemi deney
setinde gerçekleştirip enerji uygulayınız. Çalışmasını deney sorumlusu ile birlikte inceleyiniz.
Devrenin saat işareti olarak deney setindeki tek darbe üreteci butonunu kullanınız.
28
Ek:
DUAL flip-flop 74LS76 doğruluk tablosu ve bacak bağlantısı

GİRİŞ ÇIKIŞ
PR CLR CLK J K Q Q
L H X X X H L
H L X X X L H
L L X X X H
* H
*
H H L L Q0 Q0
H H H L H L
H H L H L H
H H H H TOGGLE
H H H X X Q0 Q0

* Bu durum stabil değildir.
Not: Ekte bacak bağlantısı verilen entegrenin şematik diyagramını çiziniz.
F.Ü.MÜH.FAK.
BİLGİSAYAR MÜH.BÖL.
SAYISAL ELEKTRONİK LAB.
DENEY NO: 5
SAYICILAR (COUNTERS) VE KAYITÇILAR (REGISTERS)
Deneyin Amacı :
Bu deneyde sayıcılar ve kayıtçıların (registers-kaydedici) çalışma mantığı incelenecektir.
Sayıcılar ve kayıtçılar flip-flop lardan oluşmaktadır.Sayıcılar, sayıcı girişine uygulanan
29
darbeleri saymak amacı ile, kayıtçılar ise sayıları depolamak ve kullanmak (manipulate) amacı
ile kullanılmaktadır. Bu deneyde değişik tip sayıcılar ve kayıtçılar üzerinde durulup
uygulaması yapılacaktır.
Ön Bilgi :
Bu bölüm sayıcı ve kayıtçıların kullanımını içermektedir. İlk olarak değişik sayıcı tipleri
tartışılacak ve daha sonra kayıtçıların kullanımı üzerinde durulacaktır.
SAYICI ÇEŞİTLERİ
Ripple Counters : Bu sayıcılar en basit sayıcı tipleridir. Flip-flop’lar birbirlerine kaskad olarak
bağlanırlar. Öndeki flip flop’un çıkışı bir sonraki flip-flop’un clock girişine bağlanarak
gerçekleştirilir.
Bu tip sayıcıların maksimum sayma frekansının hangi kriterlere bağlı olup nasıl
belirlendiği öğrenci tarafından araştırılacaktır.
Mod Sayıcılar : İsminden de anlaşılacağı üzere bu sayıcılar kullanılarak istenilen modda
sayma işlemi gerçekleştirilebilir. 7490 TTL entegresi kullanılarak değişik modlarda sayma
işlemi gerçekleştirilebilir.
Geri Sayıcılar : Sayıcılar ileri sayacak şekilde tasarlandığı gibi, geri sayacak şekilde de
tasarlanabilirler. Bunun için kaskad bağlı flip-flop’ların çıkışının değilinin ( Q ) bir sonraki flipflop girişine bağlanması yeterlidir.
Paralel Sayıcılar : Bu tip sayıcılarda flip-flop çıkışları bir sonraki flip-flop’un girişine
bağlanmaz. Bütün flip-flop’ların clock girişleri aynı hattan beslenir. Bu nedenle bu sayıcılar
senkron sayıcılar olarak da isimlendirilirler.
Paralel İleri Geri Sayıcılar : Birçok uygulama hem ileri hem de geri sayıcılara ihtiyaç
duymaktadır. Bu sayıcıların ayrı ayrı tasarlanmasından ziyade sayıcıya bazı lojik devre
eklemeleri yapılarak sayıcının hem ileri hem de geri sayması sağlanmış olur. 74193 entegresi
ileri geri sayma için tasarlanmıştır.
30
Presentable Sayıcılar : Şimdiye kadar ele aldığımız sayıcılar sıfırdan başlayıp ileri ve geri
sayan sayıcılardı. Presentable sayıcılar kullanılarak sayma işlemine istenilen bir sayıdan
başlanabilir.
SHIFT REGISTERS
Shift register’ler hafıza sistemleri için oluşturulmuş olup flip-flop içermektedirler. Shift registerlerde
bilgi bir hücreden bitişik hafıza hücresine istenildiği zaman kaydırılabilir.
Universal shift register olarak bilinen özel registerler sağa, sola kaydırma işlemi için
veya bilgilerin seri veya paralel giriş çıkışları için kullanılırlar.
Shift registerler aşağıdaki gibi sınıflandırılabilirler.
a- serial-in/serial-out : SISO
b- serial-in/parallel-out : SIPO
c- parallel-in/serial-out : PISO
d- parallel-in/parallel-out : PIPO
Integrated Circuit Register : Değişik shift registerler IC (integrated circuit) olarak
bulunmaktadırlar. Ayrı elemanlar kullanılarak shift register oluşturmaktansa bu IC’leri
kullanmak çok daha kolaydır. Aynı zamanda performans açısından daha çok avantajlıdırlar.
74174 D tipi flip-flop’lardan oluşmuş parallel-in/parallel-out için kullanılan bir IC’dir.
Diğer tip IC 7494 ise serial-in/serial-out veya parallel-in/serial-out için kullanılabilir. Bu
IC RS flip-flop’lardan oluşmaktadır.
Serial-in/parallel-out için 74164 kullanılabilir.
Hazırlık Soruları
1- MOD sayıcıların çalışma mantığını açıklayınız.
2- İleri ve geri sayıcıların yapısal farkını açıklayınız.
3- Ripple counter ile synchronous sayıcıların farkını açıklayınız.
4- Universal shift registerlerin ne olduğunu açıklayınız.
5- Deneye gelmeden önce aşağıdaki deney devrelerini EWB’ paket programında
gerçekleştirip diskete kaydediniz. İsendiğinde deney sorumlusuna teslim ediniz.
DENEY-1
İleri Geri Sayıcılar
31
a- 74LS76 entegresi kullanarak şekil-1 deki bağlantıyı kurunuz.
b- PB2 butonu ile saat darbeleri (clock pulse) vererek L11 ve L12 çıkışlarını kaydediniz.
c- Devre geri sayıcı olacak şekilde bağlandıktan sonra L11 ve L12 çıkışlarını kaydediniz.
Şekil-1 Ripple counter ile ileri sayıcı
DENEY-2
Senkron Sayıcılar ile İleri Geri Sayıcılar
a- 74LS76 IC kullanarak şekil-2 deki bağlantıyı yapınız.
b- PB2 butonu ile saat darbeleri vererek L11 ve L12 çıktılarını kaydediniz.
c- Devreyi geri sayıcı olacak şekilde bağladıktan sonra L11 ve L12 çıkışlarını kaydediniz.
Şekil-2 Senkron sayıcı ile ileri sayıcı
Soru : Deney-1 de kullanılan ripple sayıcı ile deney-2’d e kullanılan senkron sayıcının
birbirlerine olan üstünlüklerini tartışınız.
DENEY-3
74193 Entegresi Kullanılarak İleri-Geri Sayıcılar
a- Şekil-3 de gösterilen bağlantıları yapınız.
b- Bu entegrede LS1 ve LS5 anahtarları kullanılarak sayma işlemine istenilen sayıdan
başlanabilir. LS1-LS4 anahtarları ile başlangıç sayısı ayarlanıp LS5 anahtarı aktif yapılarak
bu sayının yüklenmesi gerçekleştirilir.
32
c- LS6 anahtarı ile entegre çıkışlarını temizleyip uygun konuma getiriniz. Aynı şekilde L1-L4
anahtarlarını kullanıp gerekli başlangıç sayısı girildikten sonra (eğer girilecekse) L5
anahtarını aktif konuma getiriniz.
d- Yukarıda verilen bilgiler ışığında ileri ve geri sayma işlemlerini gerçekleştirip bu sayma
işlemlerindeki anahtar konumlarını belirleyiniz.
Şekil-3 74193 Entegresi ile ileri geri sayıcı
DENEY-4
Seri-giriş/Seri-çıkış ve Paralel-giriş/Paralel-çıkış Deneyleri
a- Şekil-4 de gösterilen bağlantıyı yapınız.
b- Sistemi çalıştırıp PB1 butonuna basınız.
c- LS1 anahtarını bilgi girişi için, PB2 butonunu clock pulse için, L13’ü ise çıkış olarak
kullanınız. Devrenin çalışmasındaki gözlemlerinizi kaydediniz.
d- PB1’e basınız. LS1’i high yapınız ve L13 high oluncaya kadar PB2’ye basınız gözlemlerinizi
kaydediniz.
33
e- 4,5,6 nolu flip-flop ları kullanarak paralel-giriş/paralel-çıkış’ı gerçekleştiriniz.
Şekil-4 Seri-giriş/Seri-çıkış shift register
DENEY-5
Paralel-giriş/Seri-çıkış ve Seri-giriş/Seri-çıkış Deneyleri (74165 Entegresi ile)
a- Şekil-5 de gösterilen bağlantıyı yapınız.
b- LS1-LS7’yi low LS8’i high konuma getirip sistemi çalıştırınız.
34
c- PB1 butonunu bilgi yüklemek için kullanınız. PB2 butonunu clock girişi olarak kullanınız.
LS1-LS2 paralel bilgi girişi, L0 ise seri bilgi çıkışıdır. Devrenin çalışmasındaki gözlemlerinizi
kaydediniz.
d- Devreyi kapatıp 10 nolu pini toprağa bağladıktan sonra tekrar enerji veriniz. Bütün lojik
switchleri low yaptıktan sonra devrenin çalışmasını gözleyip, gözlemlerinizi kaydediniz.
Şekil-5 Paralel-giriş/Seri-çıkış shift register
DENEY-6
Shift Register Kullanılarak Seri-giriş/Paralel-çıkış Uygulaması
a- Şekil-6 da gösterilen bağlantıyı yapınız.
b- LS2 anahtarını high konumuna getiriniz. LS1 anahtarını bilgi girişi için kullanınız. Bu
bağlantıda, PB1 temizleme girişi (clear input) PB2 clock girişi ve L11-L18 çıkışlardır.
Devrenin çalışmasını gözlemleyip gözlemlerinizi kaydediniz.
c- LS1 girişini high yapıp LS2’yi bilgi girişi için kullanınız. Devrenin çalışmasını gözleyerek
gözlemlerinizi kaydediniz.
Şekil-6 Seri-giriş/Paralel-çıkış shift register (74164)
35
DENEY NO:6
VERİ ÇEVİRİMİ
Deneyin Amacı:
Fiziksel dünyadaki analog sinyaller ile sayısal sinyaller arasındaki farkı ve ikisi arası
dönüşmenin nasıl yapılacağının anlatılması ve uygulamasıdır.
Ön Bilgi:
Sıcaklık, hız, basınç gibi temel ölçülen özellikler analog sinyallerdir. Elektriksel, mekanik veya herhangi
bir fiziksel sistemden alınan işaret büyük bir çoğunlukla sürekli zamanlı Analog elektriksel işaretlerdir. Bu
işaretlerin sayısal sistemlerde işlenmesi için genlik ve zaman bakımından kuantalanması yani sayısal sözcükler
haline getirilmesi gerekir. Bu işlemi yapan elemana (ADC: Analog Digital Converter) Analog-Digital (A/D)
Çeviriciler denir. Veriler değerlenirilip üzerinde işlemler yapıldıktan sonra ya tekrar analog ortama geri
sunumuna veya bu verilere bakılarak yeni bir sinyal analog ortama sunulma ihtiyacı olabileceği açıktır. İşte bu
işlemi yapan yani sayısal sinyali analog sinyale çeviren cihazlara da (DAC: Digital Analog Converter) Digital
Analog (D/A) Çeviriciler denir.
D/A Çeviriciler:
Çoğu aynı temel devre elemanlarını kullanan çok çeşitli D/A çeriviciler mevcuttur. Şekil
1.’de bir D/A çeviricinin blok diagramı verilmiştir. Genelde bölücü devre bit ağırlığına göre
bölme yapan bir direç devresinden ibarettir. Doğru orantılı olarak en anlamlı hane çıkışı en
fazla en anlamsız hanede çıkışı an az etkileyecek şekilde tasarlanır. Şekil 2.’de böyle bir devre
verilmiştir.
Kaydedici
Sayısal
Anahtarlayıcı
Bölücü
Devre
Yükselteç
Temel
Güç
Kaynağı
Analog
Çıkış
Sayısal
Girişler
F.Ü. MÜH. FAK.
BİLGİSAYAR MÜH. BÖL.
SAYISAL ELEKTRONİK LAB.
36
Şekil 1. Temel D/A Çevirici Blok Diagramı.
Şekil 2. Basit D/A Çevirici.
Genelde anahtarlama elektronik anahtarlar aracılığıyla olur. Bu direnç dizisindeki direnç
değerleri bit değerinin onlu tabandaki karşılığı kadar bölme yaparak çıkışı etkilemesini sağlar.
Pratikte bu devrenin gerçekleştirilmesi için gerekli dirençleri doğru değerde bulmak mümkün
değildir. Bu tür bir devre yerine Şekil 3.’te verilen merdiven 4 bitlik tipli D/A çevirici
kullanmak çok daha kullanışlıdır. Dikkat edilirse bu devre iki çeşit direnç içerdiğinden çok bitli
çeviricilerin tümleşik olarak yapılmasına müsaade eder.
Şekil 3. Merdiven tip D/A çevirici.
2R 2R
2
8
R
2R
2
4
2R
2
1
R
2R
2
0
R
Va
Vb Vc Vd
VA
MSB LSB
VA
R0 / 8 R0 / 4 R0
/2 R0 RL>>R0
Toprak
Vref
0 1 0 1 0 1 0 1
2
3
2
2 2
1 2
0
MSB LSB
37
Bu devrede, çıkıştan bakıldığında eşdeğer direncin her noktada 2R olduğu kolayca gözükür. 8
bitlik benzer bir çevirici devrenin herhangi bir sayısal sözcüğün analog karşılığı şöyle olur:
Analog Çıkış=(Vref/28
)(28A1+27A2+  2
1A7+20A8)
Bir D/A çeviriciye verilerin işlendikten sonra analoğa çevirmede ihtiyaç duyulacağı açıktır. Bu nedenle çoğu
A/D çevirici devreler bünyelerinde D/A çeviriciyide barındırırlar.
A/D Çeviriciler:
Temelde iki prensibe göre çalışan çeviriciler vardır. Paralel olarak çalışan eş zamanlı veya
flaş çeviriciler ile seri olarak çalışan ardışıl çeviricidirler. Flaş çeviriciler gerilim bölücü ve
karşılaştırıcılar kullanırlar. Yapılması çalışma açısından çok hızlı, gerçekleştirme açısından
pahalı olan bir yapı arzederler. Karşılaştırıcı yığınında her bir karşılaştırıcının gerilim
bölücüden gelen bir girişi vardır. Karşılaştırıcı çıkışında elde edilen değerler kodlanarak ikili
tabanda analog gerilime karşı gelen değer bulunmuş olur. Böyle bir flaş çeviricinin yapısı Şekil
4.’te verilmiştir.
Şekil 4. Bir Flaş Çevirici yapısı.
Ardıl Yaklaşımlı (Successive Aproximation) A/D Çeviriciler:
Ardıl yaklaşımlı A/D çeviriciler A/D çevirici devrelerinden en çok rastlanan türdür. Bu tip çeviriciler bir
çevrim zamanı sahip olup giriş geriliminin mutlaka sabit olmasını gerektirirler. Bir ardıl çeviricinin gerektirdiği
devreler Şekil 5.’te verilmiştir.
+
-
+
-
1 k
1 k
1 k
1 k
1 k
1 k
1 k
1 k
1 k
1 k
+
-
+
-
+
-
+
-
+
-
+
-
+
-
+
-
+
-
KODLAYICI
1
2
3
4
5
6
7
8
9
10
Ikili
Say isal
Ciki.iki;
38
Şekil 5. Ardıl Yaklaşımla A/D çeviriciler.
Temel elemanlar şunlardır;
1. Kontrol Lojiği
2. Ardıl Yaklaşım Kaydedici ( Successive Approximaton Register:SAR),
3. DAC (Digital Analog Converter)
4. Latch (Tutucu).
Sistemin çalışması;
SAR’ın MSB’si 1 yapılır. Bu değer DAC tarafından analoğa çevrilir ve çevrimi yapılacak analog giriş ile
karşılaştırılır. Eğer SAR’da oluşturulan değer, giriş değerinden büyük ise, SAR sıfırlanır, değilse MSB’deki bu
bir değeri tutularak bir sonraki MSB’nin karşılaştırılmasına geçilir. Bir sonraki bit bir yapılarak karşılaştırmaya
devam edilir. En son LSB de işlem gördükten sonra SAR’daki değer sayısallaştırılmış giriş gerilimidir. Bundan
sonra 3 durumlu tutucu devre yardımıyla sistem veri yoluna veri aktarılır.
Yukarıda anlatılan işlemlerin yapılması belirli bir zaman gerektiriri. Bu zaman süresince de girişteki analog
sinyal değerini değiştirmemelidir ki sayısallaştırma doğru yapılmış olsun. İşte çevrim süresince giriş geriliminin
değişimini engellemek için örnekleme ve tutma devreleri (Sample and Hold Circuits) kullanılır. Böyle bir devre
Şekil 6.’da gösterilmiştir.
Şekil 6. Örnekleme ve Tutma Devresi.
Bu devre isminden de anlaşılacağı üzere belirli bir örnekleme frekansı ile analog girişten örnekler alır ve
bu değerin sayısallaştırılabilmesi için bir kapasite yardımıyla bu değeri tutar. Bu devrede kullanılan iletim kapısı
ile analog girişten örnek alınmakta ve kapasite üzerinde saklanmaktadır. Kapasitenin herhangi bir direnç
üzerinden boşalıp değerini kaybetmesini engellemek için yüksek giriş dirençli C-MOS türü işlemsel yükselteç
kullanılmıştır.
Kontrol
Lojigi
D/A Cevirici
MSB SAR LSB
3 Sev 'y el'
tutucu
Paralel
Sayisal
Cikislar
8 4 2 1
0 0 0 0
Saat
Analog Giris Analog
Cikis
Karsilastirici
Latch Enable
Cevrimi Baslatma
3-State Enable
Saat
Bit
Reset
Successiv e
Approximawtion
Register (SAR)
Ser
Say isal
Cikis
39
Veri çevirileri değerlendirmede çeviricinin RESOLUTION'undan bahsedilir. Mesela bir
DAC için girişine uygulanan 1 LSB'lik değişimin çıkışta meydana getirdiği değişime
RESOLUTION (Duyarlılık-Çözünürlük) denir. Çözünürlük DAC'in bit sayısına ve referans
gerilimine bağlıdır. Çıkış gerilimindeki bu bir bitlik değişim ne kadar düşük ise o DAC'in
çözünürlüğü o kadar iyidir denir. Bir DAC için Çözünürlük = Maksimum çıkış voltajı / (2n
-
1)’dir. Benzeri değerlendirme ADC'ler için yapılırsa 1 LSB'lik değişimi çıkışta meydana getiren
gerilim miktarıdır.
Microişlemci Uyumlu ADC ve DAC'ler:
ADC ve DAC'lerin pratikte sıkça kullanılan tiplerinden biride microişlemci uyumlu
olanlarıdır. Şekil 7.'de ZN428 DAC'in prensip şeması verilmiştir. Şekilden de anlaşılacağı gibi 8
bitlik bir sözcüğün analoğa çevrilmesini sağlayan bu dönüştürücü 3 ana üniteden oluşur.
Bunlar sözcüğün analoğa çevrilmesi işlemini sağlayan R-2R merdiven devresi, sayısal sözcüğü
belirli bir süre hafızalayan ünite ve sayısal sözcüğün bit değerlerine göre R-2R devresini süren
anahtarlama ünitesidir. Ayrıca dönüştürücüde referans gerilim üreten ünitede mevcuttur.
Şekil 7. Microişlemci uyumlu bir DAC entegresinin prensip şeması
Mikroişlemci uyumlu DAC'lerde DAC'ün microişlemcinin anlayacağı bazı işaretleri
göndermesi şarttır. Bu işaretler; DC, Data Bus ve ENABLE uçları olabilir. Microişlemci için DAC
R-2R LADDER
SWITCHES
DATA LATCH
+2.5V
REFERENCE
VREF OUT
ANALOG
GROUND
DIGITAL
GROUND
+VCC
BIT 8 7 6 5 4 3 2BIT1
ANALOG
OUTPUT
VREF IN
ENABLE
2 1 16 15 14 13 12 11
10
9
5
6
7
8
4
+2.5V
REFERENCE
VREF OUT
VCC(+5V)
GROUND
REXT
CK RC OR
EXT
CLOCK
9
10
5
7
CLOCK
GENERATOR
INTERFACE
AND
CONTROL
LOGIC
SUCCESSIVE
APPROXIMATION REGISTER
3-STATE BUFFERS
6
4
8-BIT DAC
D B 7 6 5 4 3 2 1 D B0
11 12 13 14 15 16 17 18
VREF IN
ANALOGUE
INPUT
COMPARATOR
RD
BUSY
WR
3
4
1
2
6
8
40
sadece yazılabilen bir birim olarak kabul edilir.
Şekil8 . Microişlemci uyumlu bir ADC entegresinin prensip şeması
Şekil 8.'de ise microişlemci uyumlu bir ADC'nin prensip şeması verilmiştir.
Microişlemciler için ADC'ler sadece okunabilen (ROM) memoriler gibidirler. Yani işlemci bu
elemanları sadece okuyabilir. Microişlemci uyumlu ADC'lerde çevrimin bittiğini ve okunmaya
hazır olduğunu işlemciye bildiren çıkış vardır. Ayrıca CS ve CE uçları, birden fazla ADC
kullanıldığında işlemcinin seçebilmesi için kullanılır. Rve W uçları ise dönüştürme çevrimin
başlatılması veya bufferdaki bilgilerin işlemci tarafından okunabilmesi için kullanılır.
Prensip şeması verilen microişlemci uyumlu bu ADC 3 ana kısımdan oluşan ardıl
yaklaşımlı (Successive Approximation) bir ADC'dir. Bu tür ADC'ler deneme yanılma tekniği ile
işlem yapan geri beslemeli bir sistem biçimidir. Sistem bir gerilim karşılaştırıcısına, ardıl
yaklaşım registeri ve DAC üzerinden bir geri besleme uygulanarak kurulmuştur.
Karşılaştırıcının diğer girişine ise analog işaret girilmiştir. ADC'lerde bir örenğin sayısal bir
koda dönüştürülmesi için geçen zamana çevrim zamanı (Conversion Time) denir. Dönüşüm
süresinin kısa olması tercih edilmelidir.ADC'lerin kod sözcüğündeki bit sayısıda kuantalama
adımını küçülmesine dolayısıyla çözünürlüğün iyileşmesine etki eden önemli bir faktördür.
Hazırlık Soruları
1. Şekil 2’deki devrede Vref=12V ve giriş Hex B ( yani Binary 1011 ) olmak üzere VA analog çıkış gerilimini
hesaplayınız.
2. Şekil 3’deki devrenin VA çıkışını Va , Vb , Vc , Vd cinsinden süper pozisyon yöntemini kullanarak
hesaplayınız.
3. 2’de hesapladığınız VA denkleminde Va =12V, Vb =12V, Vc =0V, Vd=12V olması durumunda
VA gerilimi hesaplayınız.
4. Flaş A/D çevirici ile ardıl yaklaşımlı A/D çeviriciler arasında farklar nelerdir?
5. Ardıl yaklaşımlı A/D çeviricide çevrim zamanı nedir?
6. Örnekleme ve tutma devresi nedir, niçin kullanılır?
Deneyin Yapılışı:
D/A Çeviriciler:
Bu deneyde sayısal analog çevirici olarak DAC 0808 entegresi
1. DAC 0808 ve MC1774 entegrelerini borda yerleştiriniz.
41
2. Bu adım bordun üç güç kaynağını da kullanmayı gerektirir. + ve - kaynaklar 1.3 ve 15 volt
arasında ayarlanabilirler. Voltmetre yardımıyla +12V ve –12V güç kaynaklarını 12V’a
ayarlayınız (Yüksek voltaj entegrenin yanmasına sebep olacaktır!). Ayarladıktan sonra
kaynağı kapatınız.
Şekil 9. D/A çevirici deneyi bağlantı şeması.
3. Şekil 9.‘daki deney bağlantı şemasına göre bağlantıları yapınız.
4. DAC 0808 girişlerini (5-12 nolu uçlar) anahtarlara bağlayıp anahtarları LOW (0V) ve HI(5V)
durumlarına getirerek çeşitli girişler için çıkış voltajını ölçerek bir tablo oluşturunuz.
Değerlendirme Soruları:
1. Devredeki işlemsel yükselteç ne iş yapmaktadır?
2. Bu devrede maksimum çıkış voltajı nedir?Niçin?
3. Devrenin çözünürlüğü, çıkışta oluşturulacak gerilim değerleri arasıdaki gerilim farkı en
küçük olabilir?
A/D Çeviriciler:
1. ADC 0809, A/D çeviriciyi borda yerleştiriniz.
2. Şekil 10’da verilen bağlantı şemasına göre bağlantıları yapınız.
3. LS1-LS3’ü alçak seviye olan toprağa çekiniz. Saat frekansını 100kHz ayarlayınız. Voltmetrei
ADC 0809’un 26 nolu ucuna bağlayınız.
4. Devreye enerji veriniz.
5. ADC 0809’un 26 nolu ucuna bağlı potansiyometreyi 2.5V’a ayarlayınız.
6. PB1 push buttona basıp LI1-LI8 sayısal çıkışları gözleyiniz.
42
7. 26 nolu uçtaki gerilimin çeşitli değerleri için sayısal çıkışları kaydederek bir tablo
oluşturunuz.
8. Giriş gerilimine göre sayısal değerlerin değişimini gösteren grafiği çiziniz.
Şekil 10. A/D çevirici deneyi bağlantı şeması.
Değerlendirme Soruları:
1. Devrenin teorik ve pratik çözünürlüğü nedir? Yani en az kaç voltu algılayabilir?
2. ADC 0809’un çevrimini tamamlayabilmesi için kaç saat periyoduna ihtiyaç duyar?
3. Bu devre ile sayısala çevrilecek analog sinyalin maksimum frekansı nedir? Yada sayısala
çevrim için analog sinyal girişte en az kaç saniye mevcut olmalıdır?
43
ADC0808 Analog Sayısal Çevirici
44
45
DAC 0808 / MC1408 Sayısal Analog Çevirici Blok Diagramı
MC1747 Dual Op-Amp.
MC 1747
1
2
3
4
5
6
7
14
13
12
11
10
9
8
Inv Input
Non Inv
Input
Offset
Adj A
VEE
Offset
Adj B
Non Inv
Input
Inv Input
Offset
Adj A
VCC A
Output A
Output B
N.C.
Offset
Adj B
VCC B
- + - +
Current Sw itches
Bias Circuit
5 6 7 8 9 10 11 12
A1 A2 A3 A4 A5 A6 A7 A8
R 2R Ladder
Referance
Current
Amplifier
Range
Control
14
15
13
16
2
4
1
MSB LSB
GND
IO
Compen
VEE 3
NPN Current
Source Pair
VCC
46
MÜH.FAK.
BİLGİSAYAR MÜH. BÖLÜMÜ
SAYISAL ELEKTRONİK LAB.
DENEY NO:7
KARE DALGA ÜRETEÇLERİ
Deneyin Amacı:
555 entegre devresini veya kapı entegrelerini kullanarak astabil, monostabil işaretler
üretmek ve bunları sayısal devrelerin Clock işareti v.b. maksatlar için kullanmak.
Ön Bilgi:
555 Zamanlayıcı, IC olarak gerçekleştirilmiş, yaygın olarak çok yönlü bir şekilde kullanılan bir
devredir. İçinde 23 transistör, 2 diyot, ve 16 direnç vardır. Toplam 8 bacaklı olup tek chip üzerine monte
edilmiştir. 556 entegresi ise iki tane 555 entegresinin birleştirilmiş halidir ve 14 bacaklıdır. 555 entegresinin
devre şeması ve bacak bağlantıları Şekil 7.1’ de görülmektedir.
Şekil 7.1. 555 IC blok diagramı ve bacak bağlantısı
555 entegresi, iki temel işletim moduna sahiptir; Astable ( kararsız multivibrator- kare
dalga üreteci) ve monostable (Tek kararlı) modlar.
47
Monostable mod’da, cihaz, one-shot (tek-vuruşlu, mono flop- Tek kararlı devre)
olarak çalışır. Basit olarak tek-adımlı işlem olarak işletilebilir. Yani dışarıdan bir uyarma
gelmediği müddetçe çıkış işareti kararlı konum seviyesinde bekler. Tipik uygulamaları;
zamanlayıcılar, darbe detektörleri ve dokunmatik anahtarlardır.
555, astable veya serbest-modda’ da çalıştırılabilir. Bu modda, cihaz bir osilatör olarak
çalışır (Kare dalga osilatörü). Yani çıkış işareti kararlı bir seviyede durmaz devemlı olarak
kendiliğinden 0 ve 1 seviyelerine değişir. Bilinen uygulamalar; LED, lamba flaşörleri, darbe
üreteci, mantık kilitleyiciler, ve tone üretecidir. Burada tartışılan uygulamalar, daha çok
mantık devrelerle ilgili olarak kullanılan uygulamaların sadece bir kaçıdır.
Astabil Multivibratör (Kare dalga üreteci) devresinin 555 Entegresi ile gerçekleştirilmesi:
555 entegresi ile kare dalga üretmek için birçok devre vardır. Bunlardan en çok bilinen ve
kullanılanı Şekil 7.2’de görülmektedir. Bu devrede kare dalga çıkış işaretinin lojik1 ve lojik 0
süreleri ve periyodu kullanılan komponentlere bağlı olarak değişmektedir.
Şekil7.2. 555’li kare dalga üreteci devresi
Bu devrenin çıkış işaretinin,
Frekansı ;
48
Periyodu;
Lojik 1 ve Lojik 0 süreleri;
Geçerlilik oranı (Duty Cycle);
Formulleriyle hesaplanır. Formüllerden de anlaşılacağı gibi; MΩ mertebesinde direnç ve μF
mertebesinde kondansatör seçimi hz mertebesinde frekans oluşturur. Yine kΩ mertebesinde
direnç ve μF mertebesinde kondansatör seçimi khz mertebesinde frekans oluşturur.
Ayrıca, R1 ve R2 arasındaki ilişkinin lojik1 ve lojik0 sürelerinde etken olduğunu, R2 ≥ 20*R1
durumunda sürelerin yaklaşık eşit olacağını, devrenin güvenli çalışması açısından R1
direncinin en az 100Ω seçilmesinin tavsiye edildiğini göz ardı etmeyiniz.
49
Şekil 7.2.b – 555’li kare dalga üretecinin çıkış işareti (EWB ortamında)
555 devresi ve en az komponent kullanılarak oluşturulabilecek bir kare dalga üreteç devresi
de Şekil7.3’te verilmiştir.
Şekil 7.3. En az komponent kullanılan kare dalga üreteç devresi
Bu devrenin çıkış kare dalga işaretinin frekansı;
İle hesaplanır. İşaretin Lojik 0 ve Lojik 1 süreleri biribirine eşittir. Ve bu süreler,
50
L0 = L1 = 0.69x(R1xC)
Monostabil (Tek kararlı) devrenin 555 entegresi ile gerçekleştirilmesi:
Bu devre de değişik şekillerde gerçekleştirilebilir. En çok kullanılanlardan biri Şekil 7.4’te
görülmektedir.
Şekil 7.4. 555 entegresi ile monostabil devresinin gerçekleştirilmesi
Bu devrenin çıkış işaretinin kararlı konumu Lojik 0 seviyesidir. Devrenin tetikleme
anahtarından işaret uygulandığı andan itibaren çıkış işareti kararsız konuma (Lojik1
seviyesine) geçer, kararsız konumda bekleme süreci
İle hesaplanır. Devre çıkışı bu zaman sonunda tekrar kendiliğinden kararlı konumuna (Lojik
0) gelir ve yeni bir tetikleme işareti uygulanana kadar bu konumda bekler. R direncinin Ω,
kapasitenin F mertebesinde seçimi çıkış kararsız konumunu saniyeler, R direncinin kΩ,
kapasitenin μF mertebelerinde seçimi çıkış kararsız konumunun ms mertebesine getirdiğini
de göz önüne alınız..
51
Şekil7.4.b. 555’li monostabil devrenin tetikleme ve çıkış işareti (EWB ortamında)
Lojik kapılarla oluşturulan Multivibratörler
Astabil veya Monostabil işaret üretici devreleri kombinasyonal lojik kapı devreleri ile de
gerçekleştirilebilir.
a) Astable Multivibratör ((Kararasız ikililer)
Astable Multivibratörler, devreye çalışma gerilim uygulandığı andan itibaren dışarıdan
herhangi bir tetikleme sinyaline gerek kalmadan devredeki zamanlama elemanlarının
belirledikleri zaman aralıklarında devamlı durum değiştiren devrelerdir. Şekil 7.5'de bir
astable multivibratör devresi verilmiştir.
Şekil 7.5. Astable multivibratör devre şeması.
Bu devrede çıkış kare dalga işaretinin periyodu (T)
52
T = 2.2 x (RxC)
Şekil 7.5.b NAND’li Astabil devresinin çıkış gerilimi (EWB ortamında)
b) Monostable (Tek Kararlı) Multivibratör
Monostable Multivibratörler, girişlerine tetikleme sinyali uygulandığında konum
değiştirip zamanlama elemanlarının belirledikleri sürece bu konumda kalan, süre sonunda
tekrar ilk duruma (kararlı konuma) dönen devrelerdir. Şekil 7.6'da bir monostable
multivibratör devresi verilmiştir.
53
Şekil 7.6 İki NAND kapılı monostable multivibratör.
Bu devrede çıkış işaretinin kararsız durumda bekleme süresi;
T = 0.7xRxC
Şekil 7.6.b İki NAND kapılı monostable devrenin giriş ve çıkışı (EWB ortamında)
Hazırlık Soruları
1. Astable Multivibratör nasıl çalışır? Nereler de Kullanılır? Çeşitlerini araştırınız.
2. Monostable Multivibratör nasıl çalışır? Nerelerde Kullanılır?Çeşitlerini araştırınız.
54
3. Bistabil Multivibrator nedir? Nasıl çalışır? Çeşitlerini araştırınız.
4. Uygulamalar kısmındaki deneyleri EWB ortamında gerçekleştirerek deneye geliniz.
UYGULAMALAR:
Uygulamalarda 555 entegresi ile ve lojik kapılar ile astabil ve monostabil devreler
gerçekleştirip elde edilen işaretler incelenecektir.
Gerekli malzemeler:
CADET, 555 IC, 7400 IC , 47kΩ, 2.2 kΩ,10 kΩ, 22 kΩ potansiyometrik direnç, 100 Ω v.b direnç,
22uf, 200nf, 250uf, 10uf kondansatör.
1- 555 IC ile Astabil Multivibratör (Kare Dalga Üreteci) Tasarım Deneyi
1) Yaklaşık 1 khz’lik bir kare dalga elde etmek için; 555 entegresi ve değerlerini
hesaplayacağınız uygun komponentler ile; Şekil 7.2 ’deki devreyi bord üzerinde
oluşturunuz. Sorumlu nezaretinde devreye enerji veriniz.
a) Devrenin çıkış işaretinin frekansını osiloskop aracılığı ile belirleyiniz.
b) İşaretin lojik 1 ve 0 sürelerini osiloskopta ölçüp tabloya kaydediniz.
2) Devredeki direnç ve kondansatör değerlerini değiştirerek 2 farklı frekanslı çıkış işareti
elde ediniz. Bu işaretlerin frekans, periyot, geçerlilik oranı ve kullanılan devre
elemanlarının değerlerini bir tablo halinde kayıt ediniz.
3) Devrenin çıkışını bord üzerinde bir LED’e bağlayarak durumu gözleyip yorumlayınız.
Not: Devrenin çıkış işaretinin frekansının yaklaşık f = 1 khz olması için, R1= 1 kΏ alarak R2
ve C’yi hesaplayabilirsiniz.
2- 555 IC ile Monostabil Multivibratör (Tek kararlı işaret üreteci) Tasarım Deneyi
Kararsız konumda yaklaşık 100ms kalan devre için gerekli komponent değerlerini hesaplayıp
(C=10uf alınız), Şekil7.4’deki devreyi bord üzerinde oluşturunuz. Sorumlu nezaretinde
devreye enerji veriniz.
1) Devrenin tetikleme işaretini ve çıkış işaretini eş zamanlı olarak osiloskopta inceleyiniz.
Çıkış işaretinin kararsız konumda beklediği süreyi ölçünüz ve kaydediniz.
2) Değişik R ve C değerleri için deneyi tekrarlayıp değerleri bir tabloya
kaydediniz.Yorumlayınız.
3) Devrenin çıkışını bord üzerindeki LED’e bağlayınız ve durumu gözleyiniz.
b) Kapı Entegreleri Kullanılarak Astable ve Monostable Tasarım Deneyi
1. Astable Multivibratör (Kare Dalga Üreteci)
Şekil 7.5’teki devrenin çıkış kare dalga işaretinin periyodunun, yaklaşık 10 ms olması için
devrede kullanacağınız komponent değerlerini hesaplayınız.
1. Devreyi bord üzerinde gerçekleştirdikten sonra , sorumlu nezaretinde enerji veriniz.
2. ÇıkıştaÜretilen işaretin periyodunu, genliğini, frekansını osiloskop kullanarak belirleyiniz.
3. Farklı R ve C değerleri için 1 ve 2'inci şıktaki işlemleri tekrarlayınız.
55
4. Aldığınız tüm değerleri tablo halinde yazınız.
2. Monostable (Tek Kararlar) Multivibratör
Kararsız konumda yaklaşık 100ms bekleyen monostabil için R ve C değerlerini hesalayınız.
1. Şekil 7.6'deki devreyi hesap ettiğiniz komponentler ve 7400 entegresi kullanarak bord
üzerinde gerçekleştiriniz. Sorumlu gözetiminde devreye enerji veriniz.
2. T tetikleme girişine bord üzerindeki kare dalga üretecinden işaret uygulayınız.
3. Tetikleme girişi ve Çıkış işaretini, osiloskopta gözleyiniz.
4. Darbe genişliklerinin sürelerini tespit ediniz. Bu devre çıkışının kararlı konumu hangi
seviyedir.
5. R ve C değerlerini değiştirerek bu dalga şekillerinin değişimini gözleyiniz.
6. Aldığınız tüm değerleri tablo halinde yazınız.
Değerlendirme soruları
1. Astable ve monostable devrelerinde RC değerleri devreyi nasıl etkilemektedir?
ORTAK TEMEL DENEY
Deneyin Amacı:
Bu deneyde ilk olarak laboratuarın tanıtımı, Ölçü aletleri, Osiloskop, Güç kaynakları,
CADET deney seti tanıtılacaktır. Daha sonra elektrik ve elektronik devre elemanları tanıtılıp,
anahtarlama modunda çalışan bir transistorün çalışması incelenecektir. Ayrıca, Elektronik
devre elemanları kullanılarak mantıksal bağlaçlar oluşturulup incelenecek. Daha sonra en çok
kullanılan TTL ve CMOS familyasının özellikleri ve beraber kullanılması uygulamalı olarak
incelenecektir.
Ön Bilgi:
Osiloskop, Ölçü aletleri, güç kaynakları ve deney seti ile ilgili ön bilgiler ve kullanım
bilgileri deney esnasında uygulamalı bir şekilde ilgili öğretim üyesi tarafından açıklanacaktır.
A. Diyotlar
Diod iki yarı iletkenden teşekkül eden elektronik devrelerde oldukça geniş bir uygulama alanına sahip bir
devre elemanıdır. Bu eleman teorik çalışmalarda ideal kabul edilirken pratik uygulamalarda gerçek diyot
kullanılır.

a) Diodun sembol gösterimi. b) Diodun karakteristik grafiği.
Şekil 1. Diyot gösterimi ve karakteristiği
F.Ü. MÜH. FAK.
BİLGİSAYAR MÜH. BÖL.
SAYISAL ELEKTRONİK LAB.
56
• Yarı iletken diyotun bir eşik gerilimi vardır.
• Yarı iletken diyot iletimde iken üzerinden sınırlı bir akım akıtabilir.
• Yarı iletken diyotun anoduna, katoduna göre belli bir değerin üzerinde negatif gerilim uygulanırsa yarı
iletken diyot tahrip olabilir.
Diyotun iletime geçmesi için anoduna uygulanan gerilimin katoduna uygulanan gerilimden daha pozitif
olması gerekir. Bu sınıra diyot eşik gerilimi denir. Bir diyodun eşik gerilimi ortalama 0.6~0.7 volt arasındadır.
B. Transistörler
Transistör diyottan farklı olarak üç yarıiletkenden meydana gelir. Transistörün çalışması sırasında bu
üç yarıiletkenden de akım akar. Bu akımlar, baz akımı (Ib), emitör akımı (Ie) ve kolektör akımı (Ic)'dır.
Akımların yönü, transistörün PNP veya NPN oluşuna göre farklıdır. NPN ve PNP transistörler için devre
şemalarında kullanılan semboller Şekil 2.'de gösterilmiştir. Transistörler kullanılarak yükselteçler
gerçekleştirilebildiği gibi, statik anahatar elemanı olarak sayısal sistemlerde ( mantıksal bağlaçlar v.b.
gerçekleleştirmeler de) yaygın olarak kullanılırlar.
a) NPN Transistörün Gösterimi. b) PNP Transistörün Gösterimi.
Şekil 2. Transitörün Sembolik Gösterimleri
Transistörlerin Çalışma Bölgeleri
Transistörlerin çalışma bölgeleri denince; transistörün içinden hiç akım akmadığı kesim durumu, içinden
maksimum akımın geçtiği doyum durumu ve bu iki çalışma biçimi arasında akımın ayarlanabildiği aktif çalışma
durumu akla gelir. Bir tansistör için çalışma durumları Şekil 3.’de bölge bölge gösterilmiştir.
Şekil 3. Transistörün çalışma bölgeleri karakteristiği
Aktif Bölge
57
Transistörü normal bağladığımız zaman örneğin, NPN bir transistörün kollektörü
pozitif, emitörü kollektöre göre negatif ve beyzi emitöre göre pozitif olduğu zaman aktif
bölgede çalışır.
Aktif bölgede kollektör akımı IC, kollektör voltajından bağımsızdır. Kollektör voltajı VCC
değiştirilirse IC akımı değişmez. IC akımı IB akımına bağlı olarak değişir. VCE voltajı VCC voltajının
yarısı civarında yada VCC den küçük, 1-2 volttan büyüktür.
Doyum (Saturation) Bölgesi
Emitör ve Kollektör voltajları birbirine çok yaklaştığına (burada bazen CB arası düz
bayasta olabilir) transistör doyum bölgesine geçer. Doyum bölgesinde IC akımı artık en büyük
değere ulaşmıştır. IB tarafından kontrol edilemez hale gelir. VCE voltajı çok küçülür. Transistör
hızla ısınarak bozulabilir. Bu nedenle transistörler özellikle doyum bölgesinde uzun süre
çalıştırılmamalıdır.
Kesim (Cut-Off) Bölgesi
Beyz ve Emitör arası ters bayaslandığı zaman yada Beyz ve Emitör arası voltaj
transistörün VBE açma voltajına eşit yada küçük olduğu zaman transistör artık kesim
bölgesindedir. Bu durumda VCC voltajı ne olursa olsun IC akımı akmaz. VCE voltajı VCC voltajına
eşit olur. Kesim bölgesindeki transistörün elektronik devrelerde uygulaması vardır.
C. Sayısal Entegre devreler:
Bir Silisyum kristali üzerinde, Kimyasal ve mikrooptik teknikler kullanılarak birçok elektronik
devre elemanları ve devreler oluşturmak mümkündür. Bu şekilde oluşturulan devrelere
entegre devre ( İntegrated Circuit- Tümleşik Devre ) denir. Burada sadece sayısal integre
58
devrelerden bahsedilecektir. Sayısal entegre devreler birçok farklı özelliklerde gerçekleştirilir.
Burada en çok kullanılan TTL ve CMOS sayısal entegre ailelerinden bahsedilecektir.
TTL ( Transistor – Transistor Lojik ) MANTIK AİLESİ : Temel devresi Şekil 4.’de görülmektedir.
Şekil 4. TTL familyasından 2 girişli NAND bağlacı (Totem Pole çıkış katlı)
Standart TTL Mantık Karakteristikleri
TTL Karakteristikleri ( Bu değerler tipik karakteristik değerlerdir)
Mantık tipi: Akım çekmeli ( Current sinking – Akım alan )
Yayılma Gecikmesi (Propagasyon gecikmesi ) : 10ns
Güç Harcaması: 10mW
Fan out (Besleyebileceği maksimum kapı giriş sayısı. ): 10
Gürültü Bağışıklığı: Yüksek
Mantık Seviyeleri (Tipik değerler) : Lojik 0 = +0.4V
Lojik 1 = 3.6V
Temel Kapı Şekli: Pozitif NAND/Negatif OR
59
Besleme Gerilimi: Vcc +5V (%10)
Hali hazırda TTL' in iki mantık seviyesinin; Yüksek seviye (HI – Lojik 1) için Vcc ( 5 v Besleme
gerilimi ) ve düşük seviye (LO – Lojik 1) için 0 v dc ideal değerler olduğu bilinmektedir. Pratik TTL
devrelerinde mantıksal LO, 0 ile 0.8V, HI ise 2.8 ile 5.5V arasında kabul edilebilir değerler arasında
değişebilmektedir
TTL' in çıkışı düşük seviye durumunda iken (Vol ), Iol akımı ( Düşük seviye kapı çıkış
akımı ) Vcc' den kapı çıkışına, çıkışa bağlı elemanın giriş ucu üzerinden akar (Şekil 5.a). Bu
durum, akım çekmeli ( current sinking) sürme tipi olarak bilinir. Standart bir TTL' de sink
akımı 16mA' dir.
TTL' in çıkışı HI durumunda iken, Ioh akım Vcc' den kapı çıkışına doğru, oradan da çıkışa
bağlı kapının girişine doğru akar ( Şekil 5.b ). Bu durum akım göndermeli (current sourcing )
sürme tipi olarak bilinir,.TTL' de bu akım 0.4 ma civarındadır.
a) b)
Şekil 5. a)Sink akımı, b)Kaynak akımı.
Çıkış akımı özelliklerine ilave olarak her bir kapı; iki giriş akım özelliğine de sahiptir. Bunlar, mantık LO akımı
Iil ve mantık HI akımı Iih' dir. Standart TTL' ler için Iil = 1.6ma ve Iih = 0.04ma' dir.
TTL Yükleme Kuralları
Mantık HI ve LO şartları için kapının akım yetenekleri, belli bir mantık ailesine bağlı kapının,
sürebildiği kapıların sayısını belirtme açısında çok önemlidir. Fan-out terimi tek bir kapı
çıkışından sürülebilen kapı girişlerinin sayısını belirtir. Fan-out, giriş ve çıkış mantık
akımlarından hesaplanabilir.
Mantık HI akımları için, fan-out = Ioh/Iih = 0.4/0.04 = 10' dur. Mantık LO akımları için
fan-out = Iol / Iil = 16ma / 1.6ma = 10 olarak hesaplanabilir. Dikkat edilirse LO ve HI için fanout aynıdır. Bunun nedeni aynı mantık aileleri üyeleri için fan-out' un aynı olacağıdır. Aileler
ve alt aileler karıştırılıp birlikte kullanıldığında, fan-out değeri mantık akımlarından
hesaplanmalıdır.
60
Açık Kollektör Çıkışları
Şekil 6. Açık kollektörlü TTL Kapısı
Açık kollektörlü (open collector) yapı genellikle akım göndermeli sürme yöntemiyle çalışır ve çıkışları
dışarıdan ortak bir R yüküne bağlandıktan sonra çıkış transistörlerinin kollektörleri paralel bağlanmış olur. Açık
kolektörlü devre bir veri yoluna birkaç kapı çıkışı bağlamanın en kolay yoludur. Şekil .7’de böyle telleVE’lenmiş (wired) bir devre görülmektedir.
Şekil 7. Telli Mantık Örnekleri
Telli (Kablolu) mantık çok karmaşık gözükebilir. Ancak aşağıdaki maddeler hatırlandığında
basitleşecektir;
1. Herhangi bir kapı çıkışı LO durumuna geçerse, o zaman bütün çıkışlar LO’ ya çekilir.
2. Veri yolu sadece bütün çıkışlar HI olduğunda HI olabilir.
TTL ailesinin önemli alt üyeleride mevcuttur. Bunlar 54 / 74 LS ( Low Power Schottky), 54 / 74
S ( Schottky ), 54 / 74 L ( Low Power ), 54 / 74 H ( High speed ), 72 / 82, 75 / 85, 71 ls / 81 LS
ve en hızlı TTL üyesi 74F serisi olarak gösterilebilir. Bu serilerin özellileri öğrenci tarafından
araştırlıp deney esnasında ve deney föyünde cevaplandırılacaktur.
CMOS MANTIK AİLESİ
MOSFETLER, daha çok LSI devreler olarak bulunmaktadır. Aynı yarıiletken yonga
üzerinde hem P ve hem de N kanalı bir MOS yapısını bulunduran yapılar CMOS olarak
bilinmektedir. Bu dokumanda bulunan çoğu yapılar CMOS şeklindedir. CMOS sayısal mantık
61
devreleri, sayısal IC devreler için TTL’ ler ile rekabet içindedir. CMOS devrelerinin en büyük
avantajı; yüksek gürültü bağışıklığı ve düşük güç harcamasıdır. CMOS devrelerinin
karakteristik özellikleri aşağıdadır.
Mantık tipi: Akım çekmeli ve akım gönderemeli
Yayılım gecikmesi: 30-100n nanosaniye
Güç Harcaması: 0.01 mW (static)
1mW (1mhz’ de)
Fan out: 50
Gürültü bağışıklılığı: Çok yüksek, (% 45 VDD)
Mantık Seviyeleri: Lojik 0 = 0V
Lojik1 = +VDD
Temel Kapı Şekli: Pozitif NOR / Negatif NAND
Güç Kaynağı: VDD:+3 ile +15V arası.
Halen CMOS ailesi geniş bir şekilde kullanılmaktadır. Bunlardan bazıları; 4000 ailesinin
A ve B tipleri ve 74C ailesidir. 4000 serisi CMOS, en yavaş ve en eski olanıdır. 4000A ailesi
tamponlanmamış mantık devrelerini ihtiva eden ve daha çok UB olarak bilinen bir gruptur.
4000B serisi ise tamponlanmış mantık devrelerini ihtiva eder.
74HC (High speed CMOS ) serisi hızlı ve yeni CMOS ailesidir. HC, HCU ve HCT aileleri
vardır. Bunlar sırasıyla yüksek hızlı, tamponlanmış çıkışa sahip ve TTL uyumlu özeliklere
sahiptir. 74C4XXX ve 74C14XXX alt aileleri CD4XXX ve MC14XXX serisi devrelerin eşdeğer
fonksiyonelliğini sağlar. Daha yeni bir CMOS serisi olan AHC (Advanced High speed CMOS )
ise HC serisinden üç kat daha hızlı kullanışlı bir CMOS serisidir. Öğrenci CMOS familyasındaki
tüm serilerin özelliklerinin araştırılması, deney esnasında ve deney föyünde açıklanması ile
yükümlüdür.
CMOS devrelerde mantık 0 için en az 1.5V ve mantık 1 için en az 3.5 V gereklidir. Güç
kaynağı 3-18V arasındadır. Kullanılmayan CMOS girişler toprağa veya VDD’ye bağlanır. CMOS’
ların fan-out değeri 50 ve daha yukarısıdır.
CMOS ve TTL Arabirimleri
62
TTL ve CMOS ailelerine ait entegrelerin birlikte kullanılması durumunda, biribirlerine uyum
sağlamalrı için arabirim kullanılması gerekir. Çünkü ikisinin arasındaki mantık seviyeleri
aynı değildir. Şekil .8’ de iki cihaz arasındaki arabirim yöntemlerinden bazıları verilmiştir. Bu
yöntemlere ek olarak, özel seviye kaydırıcılar da dahil edilebilir. MOS’ ların iki giriş ucu
arasında, dışarıdan bir insan tarafından dokunulması suretiyle oluşan gerilim ölçüldüğünde 4-
15KV olduğu görülmüştür. Bu gerilim CMOS’ a zarar verebilecek bir değerdir. Bu sebepten
CMOS entegre devreler bir yerden başka bir yere taşınırken hiç bir bacağına
dokunulmaz ve uçlar biri birine bağlanarak taşınır. Bunun nedeni dışarıdaki
elektrostatik olaylardan etkilenmesini önlemektir. Eğer tutmak gerekiyorsa tutan kişiler ve
cihazlar iyi bir şekilde topraklanmalıdır. Normalde taşınırken orijinal taşıyıcı kılıfları içinde
olmalıdır.
Şekil 8. TTL ve CMOS arasındaki Arabirim Yöntemleri
DENEYLER
A. Transistörün Anahtarlama Modunda NOT (Değil) bağlacı olarak kullanımı
a) Hazırlık Soruları
Aşağıdaki örnekte transistörlü bir devrenin hangi bölgede çalıştığını bulunuz. Devredeki
transistörün özellikleri; NPN Silisyum (VBE=0,6V), ß=100 ,VCC=12V, RC=2,7K, RB=200K, VBB=5V
Şekil 9. Transistörün çalışma bölgesi incelemesi için devre şeması.
63
1. Şekil 9. ‘deki devrede; Icmax, Ic, Ib akımlarını ve Vce voltajını hesaplayınız. Q çalışma
noktasını grafik üzerinde belirleyerek transistörün hangi bölgede çalıştığını belirleyiniz.
2. Şekil 9. ‘deki devrede; Rb dirençinin değerini 100 K seçerek Icmax, Ic, Ib akımlarını ve Vce
gerilimini hesaplayınız. Q çalışma noktasını grafik üzerinde belirleyerek transistörün hangi
bölgede çalıştığını belirleyiniz.
3. Şekil 9. ‘deki devrede ;sadece Vbb gerilimini 0.6 V yaparak, Icmax, Ic, Ib akımları ve Vce gerilim değerini
hesaplayınız. Q çalışma noktasını grafik üzerinde belirleyerek transistörün hangi bölgede çalıştığını
belirleyiniz.
b) Deneyin Yapılışı:
Rc=100
Rb=100
Vbb=0-5V
Vcc=5V
B
E
C
Giriş
Çıkış
Şekil 10. Transistörün NOT Kapısı olarak Kullanılması.
1. Şekil 10.'deki devreyi BC237 transistörünü kullanarak kurunuz.
2. Girişe 0V uygulayarak Vbe ve Vce gerilimlerini osiloskopta ölçünüz.
3. Girişe 5V uygulayarak Vbe ve Vce gerilimlerini osiloskopta ölçünüz.
4. Girişe TTL işareti uyguluyarak, Vbe ve Vce gerilimlerinin değişimini osiloskopta
inceleyiniz.
B. Temel Mantık Elemanları
a) Hazırlık Soruları: Lojik skala, yasak bölge nedir?, Yarıiletken elemeanlala gerçekleştirlen bağlaç
çıkışlarındaki lojik 0 ve lojik 1 gerilim seviyeleri niye 0v veya +vcc değildir?
c) Deneyin Yapılışı
1. "VE" KAPISI
64

a) Diyodlu "VE" Kapısı. b) Transistörlü "VE" Kapısı.
Şekil 11. "VE" kapısı gerçekleme türleri.
1. Şekil 11. a)'daki diyotlu "AND" kapısı devresini kurarak doğruluk tablosu çıkartınız.
2. 1. adımda gerçekleştirdiğiniz diyotlu AND kapısı çıkışına Şekil 10.'deki NOT kapısını ekleyerek bu devre
için doğruluk tablosunu elde ediniz.
2. VEYA Kapısı (OR Gate)
.
a) Diodlu "VEYA" Kapısı. b) Transistörlü "VEYA" Kapısı.
Şekil 12. "VEYA" kapısı gerçekleme türleri.
1. Şekil 12. a)'daki diyotlu "OR" kapısı devresini kurarak doğruluk tablosu çıkartınız.
2. 1. adımda gerçekleştirdiğiniz diyotlu OR kapısı çıkışına Şekil 10'deki NOT kapısını ekleyerek bu devre için
doğruluk tablosunu elde ediniz.
d) Değerlendirme Soruları:
1. Transistörlü AND kapısı gerçeklemesinde NOT kapısı ekledikten sonra elde ettiğiniz
doğruluk tablosu neyin doğruluk tablosudur?
2. Transistörlü OR kapısı gerçeklemesinde NOT kapısı ekledikten sonra elde ettiğiniz
doğruluk tablosu neyin doğruluk tablosudur?
C) TTL Yükleme Kuralları
Sorular
1. İki önemli mantık devresi ismi veriniz.
2. TTL devrelerin mantık seviyelerini belirtiniz.
3. Yayılım (propagasyon ) gecikmesinden kaçınmak mümkün müdür? Tedbirleri nelerdir.
65
4. Yükselme zamanından kaçınmak mümkün müdür.?
5. Açık-kolektör çıkışlar nerelerde kullanılır?
6. TTL familyasının alt üyeleri ve özellikleri nelerdir. TTL familyasından herhangi bir üyeye ait
entegrenin tanınması ve okunması hakkında deney esnasında bilgi veriniz.
7. CMOS familyasının alt üyeleri ve özellikleri nelerdir. CMOS familyasından herhangi bir
üyeye ait entegrenin tanınması ve okunması hakkında deney esnasında bilgi veriniz.
Gerekli Malzemeler:
CADET, 74LS04 Hex Inverters IC, DC Voltmetre, Bağlantı Kabloları
Deneyin Yapılışı
1)74LS04 ü board üzerine yerleştirerek güç kablosu ve toprak bağlantısını yapınız.
2)LI1 ile LI4’ ü ve LI5 ile LI8’ i biri birine bağlayınız. Giriş olarak 74LS04’ ün 1. bacağına LS1 ‘ i
bağlayınız. 74LS04’ün çıkışındaki yaklaşık 5V’luk gerilimi ölçmek için 2. bacağa bir voltmetre
bağlayınız (aynı ölçümü osilaskop kullanarak yapınız).
3)LS1’i LO’ ya anahtarlayınız. Gerilimi veriniz.
4) Inverterin çıkışındaki (2. bacak) gerilimi ölçerek kaydediniz.
5) Tümleşik devrenin 2. Bacağına LI1-LI4 led’ lerini bağlayınız.
6) LI1-LI4 ledleri şu an yanmalıdır. 4. Adıma geri gidiniz.
7) LI5-LI8 bağlantısını 2. pin’ e bağlayınız.
8) Bütün ledler yanmalıdır. Tekrar 4. Adıma gidiniz.
9) Elektriği kapatarak set üzerindeki elemanları sökünüz.
D) Açık Kolektör’ lü Mantık Kapıları
Gerekli Malzemeler:
CADET, 74LS05, 1Kohm direnç, DC Voltmetre/DMM-02
Deneyin Yapılışı
1)74LS05’ i set üzerine yerleştirerek güç ve toprak bağlantısını yapınız.
2)LS2 ‘ ye pin1’ i ve LI2’ ye pin2’ yi bağlayınız.
3)LS2’ yi LO durumuna getiriniz. Gücü açınız.
66
4)LS2’ yi önce HI sonra LO ve daha sonra tekrar HI durumuna anahtarlayınız.LI2’ deki inverter
çıkışını gözlemleyerek bunları kaydediniz.
5) Pin 2’ye bir voltmetre bağlayınız ve LS2 değiştiğinde bu değeri kaydediniz.
6) Gücü kapatarak pin 2 ile Vcc arasına 1Kohm direnç bağlayınız. LS2’ yi HI durumuna
getiriniz. Ve gücü tekrar açınız.
7) LS1 ‘ i durum değiştiriniz ve LI2 hakkındaki gözlemlerinizi kaydediniz.
8) Gücü kapatınız .
9) Ls3’ ü pin3’ e ve pin4’ ü LI2’ ye bağlayınız.
10)LS2 ve LS3’ ü HI durumuna getriniz. Gücü açınız.
11)LS2 ve LS3 giriş olarak ve LI2 çıkış olarak kullanarak bu fonksiyon için devrenin doğruluk
tablosunu oluşturunuz.
E) TTL ve CMOS Ara birimlendirme
Gerekli Malzemeler:
CADET, 74LS04,TC4049,74LS00,MC4011,2 tane 1Kohm direnç,, bağlantı kabloları
Deneyin Yapılışı
1)Deneyi yaparken özellikle CMOS olan elemanların bacaklarına dokunmayınız.
2) 4011 ve 74LS04’ ü board üzerine yerleştiriniz. Toprak ve güç bağlantılarını yapınız.
3)Şekildeki devreyi oluşturunuz. Kullanılmayan bacak bağlantılarını mutlaka toprak ucuna
bağlayınız.
4)LS12 ve LS2’ yi LO’ ya anahtarlayınız. Gücü açınız. Giriş olarak LS1,LS2 ve çıkış olarak LI1’ i
kabul ediniz. Ve yukarıdaki devre için doğruluk tablosunu oluşturunuz.
5) Gücü kapatınız. Devredeki 4011 ve 74LS04’ü çıkararak 74LS00 ve 4049 entegre devrelerini aşağıdaki
şekildeki gibi bağlayınız.
67
6) LS1 ve LS2’ yi giriş ve LI1’ i çıkış olarak kullanarak devrenin doğruluk tablosunu çıkarınız.
NOT: Her deneyden önce yapılması gerekenler "Hazırlık Soruları" başlığı altında verilmiştir. Soruların
gerektirdikleri, deneye gelmeden önce yapılacaktır.Deneye gelmeden önce tüm deneyler EWB ‘de
gerçekleştrilecek ve gerçekleştrilen deneyler diskete kaydedilip deney esnasında deney sorumlusuna
verilecektir.

74LS00 NAND entegresi Pin Konfigrasyonu 74LS04 NOT entegresi Pin
Konfigrasyon
68
74LS02 NOR entegresi Pin Konfigrasyonu
Ortak deney 1.Hafta Yapılacaklar
A) Deney ortamının tanıtılması
1- Kullanılacak deney seti detaylı olarak tanıtılacaktır.
2- Ölçü aletleri, avometre, osilaskop ve sinyal jeneratörlernin kullanımı tanıtılacaktır.
3- Direnç, diyot, transistör v.b devre elemanlarının temel özellikleri ve uçlarının tanımı kısaca
anlatılacaktır.
4- Set üzerindeki veya sinyal jeneratöründen seçeceğiniz elektriksel işaretlerin (Tercihan
sinozoidal ve kare dalga işaretleri) osiloskopta analizi (Genlik, periyod, frekans, zaman
üzerindeki ansal değerin nasıl ölçüleceği v.b) uygulamalı olarak öğrenciye gösterilecektir.
5- Avometre İle Gerilim Ölçme (Avometre Devreye Parelel Olarak Bağlanır) uygulamalı olarak
öğrenciye gösterilecektir.
6- Her bir öğrenciden osiloskopta ve avometrede ölçme yapması istenip denetlenecektir.
Bu işlemler 30 dakikada bitirilmelidir.
B) Transistörün Anahtarlama Modunda NOT (Değil) bağlacı olarak kullanımı
1-) Deneyin yapılışı
69
Şekil 10. Transistörün NOT Kapısı olarak Kullanılması.
5. Şekil 10.'deki devreyi BC237 transistörünü kullanarak kurunuz.
6. Girişe 0V uygulayarak Vbe ve Vce gerilimlerini osiloskopta ölçünüz.
7. Girişe 5V uygulayarak Vbe ve Vce gerilimlerini osiloskopta ölçünüz.
8. Girişe TTL işareti uyguluyarak, Vbe ve Vce gerilimlerinin değişimini osiloskopta inceleyiniz.
9. Bu değerler ile transistorün hangi çalışma modunda çalıştığını söyleyebilirsiniz
10. Rb= 1000ohm yaparak Vbb gerilimini 0v ve 5 v uygulayınız. Vce gerilimini osiloskopta inceleyerek
yorum yapınız.
Ölçmeleri öğrenci kaydederek yorumlamalı ve aldığı değerleri raporuna yazmalıdır.
Bu deney 25 dakikada yapılmalıdır.
Dikkat bu deneyi sette uygun bir yere kurunuz. Daha sonra kullanılacaktır.
B. Temel Mantık Elemanları
a) Hazırlık Soruları: Lojik skala, yasak bölge nedir?, Yarıiletken elemanlarla gerçekleştirlen bağlaç
çıkışlarındaki lojik 0 ve lojik 1 gerilim seviyeleri niye 0v veya +vcc değildir?
b) Deneylerin Yapılışı
1- VEYA Kapısı (OR Gate).

Şekil 11. DİYOD’lu VEYA bağlacı, NOR bağlacı
3. Şekil 11.deki diyotlu "OR" kapısı devresini kurarak doğruluk tablosu çıkartınız.
4. 1. adımda gerçekleştirdiğiniz diyotlu OR kapısı çıkışına Şekil 10'deki NOT kapısını ekleyerek bu devre için
doğruluk tablosunu elde ediniz.
Bu deneyler 25 dakikada yapılmalıdır.
2. VE KAPISI
70
Şekil 12. Diyodlu "VE" kapısı, NAND kapısı
3. Şekil 12. deki diyotlu "AND" kapısı devresini kurarak doğruluk tablosu çıkartınız. Doğruluk tablosu
ölçülecek gerilimler cinsinden verilecektir.
4. 1. adımda gerçekleştirdiğiniz diyotlu AND kapısı çıkışına Şekil 10.'deki NOT kapısını ekleyerek bu devre
için doğruluk tablosunu elde ediniz ( Rb direncini kaldırıp transistor ün bazını F noktasına bağlayınız şekil
12.b)
Bu deneyler 25 dakikada yapılmalıdır.
c) Değerlendirme Soruları:
3. Transistörlü AND kapısı gerçeklemesinde NOT kapısı ekledikten sonra elde ettiğiniz doğruluk
tablosu neyin doğruluk tablosudur?
4. Transistörlü OR kapısı gerçeklemesinde NOT kapısı ekledikten sonra elde ettiğiniz doğruluk
tablosu neyin doğruluk tablosudur?
Ortak deney 2.Hafta Yapılacaklar
71
1- İlk hafta tanıtılan Osiloskopla, değişik işaretlerin genlik, periyot, frekans ölçümlerinin her öğrenci
tarafından en az 1 defa tekrarlanması. 20 dakika
2- TTL (Transiztör Transistor Lojik ) Familyası SSI entegre devrelerin tanıtılması ve kullanılması.
ZZ:Üretici firma belirteci
• TI :Texas İnsruments
• SN: Motorola, N :Nationa
CC:Çalışma sıcaklığı
74: 0 -70 C0
54 :-55, 125C0
XX: Alt özellik
L:Düşük güçlü,
LS: düşük güçlü Scohtky diyodlu
H:yüksek hızlı
NNN: Entegrenin fonksiyonu
P: Paket (kılıf) malzemesi: P:plastik, JD:Seramik
Deneyin Yapılışı
a) TTL Familyası entegreler
1)74LS04 entegresini board üzerine yerleştirerek +5v ve toprak bağlantısını yapınız.
2) Giriş olarak 74LS04’ ün 1. bacağına S1 (0 veya 1 veren) anahtarını bağlayınız. 74LS04’ün 2.bacağına
Osiloskopun probunu bağlayınız. Gerilim uygulayınız.
S1 anahtarı L ve H konumunda iken Osiloskopta ölçtüğünüz gerilimleri kaydediniz ( Bir invers
bağlacın çalışması)
72
3) Aynı işlemleri 2. bacağa bir LED bağlayarak yapıp yorumlayınız.
4) 74LS04’ün 2. bacağını 3. bacağa (3.pin’e) bağlayınız. 1. bacağa L ve H gerilimleri uyguluyarak 4.
bacağın gerilimlerini ölçünüz yorumlayınız. Çıkışta ölçtüğünüz Lojik 0 ve lojik 1 gerilim seviyeleri TTL
familyası için uygunmudur.?
5) 74LS00 entegresini borda uygun şekilde yerleştirip +5v ve Toprak bağlantılarını yapınız.
6) Entegrenin 4. ve 5. pinlerini anahtarlara bağlayınız. 6.pinini Osiloskop probuna bağlayınız.
7) 4.ve 5 pine bağladığınız anahtarlar ile girişlere 00, 01,10, 11 gerilim seviyeleri uygulayarak tüm
durumlar için çıkışta olçtüğünüz gerilimleri tablo halinde veriniz. Bu 2 girişli bağlacın fonksiyonu
nedir?
b) Açık Kolektörlü TTL bağlaç deneyi.
74LS05 Entegresi açık kollektörlü invers bağlaçtır.
Gerekli Malzemeler:
74LS05, 1Kohm direnç, DC Voltmetre, Osilaskop
Deneyin Yapılışı
1)74LS05’ i set üzerine yerleştirerek + 5v ve toprak bağlantısını yapınız.
2)1.pine lojik anahtar (S) bağlayınız. 2.pini osiloskopa bağlayınız. Gücü açınız, lojik anahtarı L ve H
konumlarına alarak çıkış gerilimini ölçüp kaydediniz. Çıkış niye devamlı 0v’da kalıyor?
3) Aynı işlemleri 2.pine voltmetre bağlayarak yapıp ölçü değerlerini kaydediniz.
6) Gücü kapatarak pin 2 ile Vcc arasına 1Kohm direnç bağlayınız. Pin2’nin gerilimini ölçmek için
osiloskopa bağlayınız. Gücü açıp, Lojik anahtarı L ve H konumuna alarak çıkıştan (2.pinden) yaptığınız
ölçmeyi kaydediniz. Doğruluk tablosunu çıkartınız. Yormunuz nedir?
c) Tanım Tablosunun elde edilmesi
1 adet 74LS00 ve 1 Adet 74LS04 kullanarak aşağıdaki fonksiyon denklemini gerçekleştiriniz ve a,b,c,d
girişlerine bağlayacağınız lojik anahtarlar ile, devre giriş kombinasyonlarının hepsi için çıkış değerlerini
kaydederek problemin tanım tablosunu elde ediniz.
d) TTL ve CMOS Ara birimlendirme
Gerekli Malzemeler:
73
74LS04,MC4049,74LS00,MC4011,2 tane 1Kohm direnç, bağlantı kabloları
Deneyin Yapılışı
1)Deneyi yaparken özellikle CMOS olan elemanların bacaklarına dokunmayınız.
2) 4011 ve 74LS04’ ü board üzerine yerleştiriniz. Toprak ve güç bağlantılarını yapınız.
3)Şekildeki devreyi oluşturunuz. Kullanılmayan bacak bağlantılarını mutlaka toprak ucuna bağlayınız.
4)LS12 ve LS2’ yi LO’ ya anahtarlayınız. Gücü açınız. Giriş olarak LS1,LS2 ve çıkış olarak LI1’ i kabul
ediniz. Ve yukarıdaki devre için doğruluk tablosunu oluşturunuz.
5) Gücü kapatınız. Devredeki 4011 ve 74LS04’ü çıkararak 74LS00 ve 4049 entegre devrelerini aşağıdaki
şekildeki gibi bağlayınız.
6) LS1 ve LS2’ yi giriş ve LI1’ i çıkış olarak kullanarak devrenin doğruluk tablosunu çıkarınız.
74
TTL Familyasının gerilim değerleri
V 2 3.4 - IH
VIL
- 0.2 0.8
VOH 2.4 3.6 -
VOL - 0.1 0.4
Minimum(v) Tipik(v) Maksimum(v)
V 2 3.4 - IH
VIL
- 0.2 0.8
VOH 2.4 3.6 -
VOL - 0.1 0.4
Minimum(v) Tipik(v) Maksimum(v)
75
F.Ü.
MÜHENDİSLİK FAKÜLTESİ
BİLGİSAYAR MÜHENDİSLİĞİ BÖLÜMÜ
SAYISAL ELEKTRONİK LABORATUVARI DERSİ
DENEY RAPORU
DENEY TARİHİ: ………………………………………………………….
DENEY NO VE İSMİ:……………………………………………………..
ÖĞRENCİ GRUBU:………………………………………………………
DENEYİ YAPAN NO, İSİM:……………………………………………….
GRUP ÜYELERİ :…………………………………………………………
…………………………………………………………..
………………………………………………………….
DENEY SORUMLUSU: ……………………………………………………………
DENEYDE KULLANILAN MALZEMELER:
76
BMÜ-232 SAYISAL ELEKTRONİK LABORATUVARI DERSİ
SAYISAL ENTEGRE (TÜMLEŞİK)
DEVRELER
Digital İntegrated Circuits (IC)
Yarıiletkenler
• 1950’li yıllarda transistörlerin icad edilmesiyle
elektronikte bir devrim oluştu.
• 1965’li yıllardaki SSI entegre devreleri
bulunmasıyla da 2. önemli gelişme başlamış
oldu.
• Şu anda 2cm2 yüzeye yaklaşık 800 milyon
transistör yerleştirilebilen IC’ler üretilmektedir.
• Konuyu anlayabilmek için yarı iletken devre
elemanlarını özetlememiz gerekir.
DİYOT
Transistörler

Transistörlerin Çalışma Bölgeleri
• Transistörlerin çalışma bölgeleri denince;
• Transistörün içinden hiç akım akmadığı kesim durumu,
• içinden maksimum akımın geçtiği doyum durumu
• Bu iki çalışma biçimi arasında akımın ayarlanabildiği aktif
çalışma durumu akla gelir.
• Aktif Bölge
• Transistörü normal polarlandığında örneğin, NPN bir transistörün kollektörü pozitif,
emitörü kollektöre göre negatif ve beyzi emitöre göre pozitif olduğu zaman aktif
bölgede çalışır.
• Aktif bölgede kollektör akımı IC, kollektör voltajından bağımsızdır. Kollektör voltajı
VCC değiştirilirse IC akımı değişmez. IC akımı IB akımına bağlı olarak değişir. VCE
voltajı VCC voltajının yarısı civarında yada VCC den küçük, 1-2 volttan büyüktür.
• Doyum (Saturation) Bölgesi
• Emitör ve Kollektör voltajları birbirine çok yaklaştığında, transistör doyum bölgesine
geçer. Doyum bölgesinde IC akımı artık en büyük değere ulaşmıştır. IB tarafından
kontrol edilemez hale gelir. VCE voltajı çok küçülür. Transistör hızla ısınarak
bozulabilir. Bu nedenle transistörler özellikle doyum bölgesinde çalıştırılırken,
taşıyabileceği akımın dışarıdan sınırlanması gerekir.
• Kesim (Cut-Off) Bölgesi
• Beyz ve Emitör arası ters bayaslandığı zaman yada Beyz ve Emitör arası voltaj
transistörün VBE açma voltajına eşit yada küçük olduğu zaman transistör artık kesim
bölgesindedir. Bu durumda VCC voltajı ne olursa olsun IC akımı akmaz. VCE voltajı
VCC voltajına eşit olur.
Sayısal Elektronik İçin Transistörün Anahtarlama modunda
çalışması önemlidir.
• Transistörler çalışma şekli olarak 2 modda
çalıştırılırlar.
• Lineer modda Çalışma : Transistörün aktif
bölgede çalışmasıdır. Lineer uygulamadır.
• Anahtarlama modunda çalışması:
Transistör ya tam iletimde (Doyumda) Ya
tam kesimde (açık devre) olarak çalışır.
Transistörün anahtarlama
modunda Çalışması
• Rc=1000ohm,
Vcc=5v,VBB=5v,
β = Ic/Ie =100 olan bir
NPN transistörün
anahtarlama modunda
çalışması için RB
direnci ne olmalıdır.
VBE=0.7v,
VCESat=0.1v
Çıkış işaretindeki gecikme
Lojik işaret
Sayısal Entegre devre?
Entegre devre teknolojisi, bir saf
yarıiletken yüzey üzerine kimyasal
yollarla, transistör, diyot v.b
elektronik elemanları bir devre
oluşturacak şekilde
gerçekleştirme işlemidir.
Oluşan bu devrenin uygun
yerlerinden dışarıya bacaklar
(pinler) çıkarılır. Daha sonra
yonga metal veya plastik bir kılıfla
kaplanarak dış etkenlerden
korunur. Böylece bir entegre
devre elde edilmiş olur. Analog ve
sayısal entegre devreler vardır.
Entegre devre yapım aşaması

1960 lı yıllardan itibaren gelişen Sayısal IC teknolojisi,
• SSI (Small Scalae IC - Küçük boyutlu IC): İçinde en fazla 9 adet kapı
elemanı bulunan IC’lerdir. Her bağlacın giriş ve çıkışları biribirinden
bağımsız şekilde IC’nin dışına çıkartılmıştır. Bu elemanlar tek başına
bir işlem yapamazlar.
• MSI(Medium Scalae IC-Orta boyutlu IC): Bu yapıdaki IC’lerin içinde
yaklaşık 10-100 adet bağlaca denk gelen eleman vardır. Bu şekilde
oluşturulan IC’ler küçük çaplı sonsuz tane problemi tek başına
çözebilecek durumdadırlar. MUX,DEMUX, Sayıcı, Kodlayıcı v.b
devreleri bunlara örnek gösterebiliriz.
• LSI(Large Scalae IC): Büyük kapasiteli IC: Bu IC’ler büyük çaplı
karmaşık sayısal probleri çözmek için üretilirler. Örneğin hesap
makinalarının temel IC’leri, saat IC’leri v.b. İçlerinde yüzbin transistör
gerçekleştirilmiştir.
• VLSI(Very Large Scalae IC): Çok büyük çaplı IC: İçlerinde milyonlarca
transistör gerçekleştirilmiştir. Çoğu zaman yazılım destekli olarak
sonsuz tane sayısal problemi çözerler. Mikroişlemciler, Büyük
kapasiteli RAM hafıza devreleri bunlara örnek verilebilir.
• ULSI(Ultra Large Scalae IC): Ultra büyük çaplı IC: Milyonlarca kapı
eşdeğeri bulunan IC devrelerdir.
SSI IC’ye örnek
Logic kapılar DIP (Dual inline packages)
denilen, genellikle plastik paketler içerisinde
bulunurlar.
ENTEGRE DEVRELERLE İLGİLİ BAZI TEMEL TANIMLAR-1
• Her familya için geçerli olan,kataloglarında belirtilen temel tanımlar vardır.
• 1-Vin1(ViH): Yüksek seviye giriş voltajı:Kapı girişinde Lojik 1 için belirlenmiş
en düşük gerilim seviyesi.
• 2-Vin0(ViL): Düşük seviye giriş voltajı:Kapı girişinde Lojik 0 için belirlenmiş
en yüksek gerilim seviyesi.
• 3-Vout1(VoH): Yüksek seviye Çıkış voltajı:Kapı çıkışında Lojik 1 için
belirlenmiş en düşük gerilim seviyesi.
• 4-Vin0(ViL): Düşük seviye çıkış voltajı:Kapı çıkışında Lojik 0 için belirlenmiş
en büyük gerilim seviyesi.
• 5-I
in1(IiH): Yüksek seviye giriş akımı: Kapı girişine Lojik 1 için belirlenmiş
gerilim seviyesi uygulandığında girişten çekilen akım değeri.
• 6-I
in0(IiL): Düşük seviye giriş akımı: Kapı girişine Lojik 0 için belirlenmiş
gerilim seviyesi uygulandığında girişten çekilen akım değeri.
ENTEGRE DEVRELERLE İLGİLİ BAZI
TEMEL TANIMLAR-2
• Fan out: Bir kapı çıkışının garanti olarak besleyebileceği
kapı girişi sayısıdır.
• Gecikme zamanı: Bir bağlacın, girişine uygulanan işarete
göre, çıkışının vereceği tepki sürecidir. İki tip
gecikmeden bahsedilebilir.
• tpd1(tpLH): Lojik 0’dan Lojik 1’e giderken meydana gelen
gecikme
• tpd0(tpHL): Lojik 1’den Lojik 0’a giderken meydana gelen
gecikme.
• Gürültü Bağışıklığı (Noise İmmunity): Devrenin
elektriksel gürültüye karşı duyarsızlık ölçütü.
Sayısal IC familyaları
• Sayısal entegre devre seçiminde gözönünde
bulundurulacak temel özellikler şunlardır.
1- Besleme gerilimi, çektiği güç.
2- Cevap hızı.
3-Fan-out.
4-Gürültüye bağışıklık.
Yukarıdaki özelliklere göre Sayısal IC
familyalarını aşağıdaki gibi sıralayabiliriz.
Lojik
familya
Temel
Devre
Besleme
Voltajı(V)
Sarf gücü
(mw)
Darbe
gecikmesi(ns)
Fan-out Gürültü
duyarlığı
DTL NAND 5±%10 8-12 30 8 İYİ
RTL NOR 3,6 ±%10 12 12 5 ORTA
TTL NAND 5±%10 1-22 3-33 10 İYİ-Ç.İYİ
CTL NAND 4 2 25 6 İYİ
HTL NAND 15±1 55 150 10 Ç.Ç.İYİ
ECL OR-NOR -5.2 ±%20 20-60 1-4 25 ORTA
MOS NAND-NOR 3-18 .5 200 25 İYİ
CMOS NAND-NOR 3-18 .8µW/HZ 150 25 Ç.İYİ
Mantık devreleri ve sayısal elektronik laborauvarı dersleri
için, önemli familyalar, TTL, MOS ve CMOS ‘tur.
• TTL (transistor-transistor Lojik Familyası):
• Temel devresi NAND bağlacıdır. Diğer
bağlaçlar bundan türetilir.
TTL NAND bağlacı
(Totem-Poole, Open Collector)
TTL IC ‘nin okunması
ZZ:Üretici firma belirteci
• TI :Texas İnsruments
• SN: Motorola, N :National
CC:Çalışma sıcaklığı
74:0-70 C0
54:-55,125C0
XX: Alt özellik
L:Düşük güçlü,
LS: düşük güçlü Scohtky diyodlu
H:yüksek hızlı
NNN: Entegrenin fonksiyonu
P: Paket malzemesi
P:plastik
JD:Seramik
TTL NAND
•
1----ag1
•
2----ag2
•
3----aç
•
4----bg1
•
5---bg2
•
6---bç
•
7---Toprak
•
8--- cç
•
9---cg1
• 10---cg2 • 11---dç • 12---dg1 • 13---dg2 • 14---+Vcc

TTL familyasının temel özellikleri
Minimum(v) Tipik(v) Maksimum(v)
VOL - 0.1 0.4
VOH 2.4 3.6 -
VİL - 0.2 0.8
VİH 2 3.4 -
74 ailesi
• 74XXX ailesi (Standard TTL) : yavaş ve güç
kayıpları çok fazla olan en eskileridir.
• 74LXXX ailesi (Low Power TTL): bu serinin güç
kayıpları daha azdır.
• 74SXXX ailesi (Schottky TTL ): bu seri entegrelri
hızlıdır fakat güç kayıpları da fazladır
• 74LSXXX ailesi (Low Power Schottky TTL ):
hızlı ve düşük güç kayıplarına sahip
• 74ALSXXX (Advanced LS TTL ): Hız-güç
kayıpları oranı çok iyidir.
• 74FXXX ailesi (FAST TTL): Güç kayıpları ve Hız
açısından en iyi TTL entegresidir.
Hibrit TTL serisi
• 74HC tipi entegreler yüksek hızlı CMOS devrelerdir. TTL hızı
ile çok az güç tüketen 4000 serisinin birleştirilmesi ile
oluşturulmuştur.
• 74LS ailesiyle aynı pin çıkışları olacak şekilde düzenlenmiştir.
74 HC girişlerinin 74LS çıkışları ile sürülmesi güvenli değildir.
çünkü lojik 0 için kullanılan Voltaj aralığı uygun değildir. bunun
yerine 74HCT kullanılmalıdır.
• 74HCT ailesi 74HC ve 74LS TTL ailesinin özel olarak
birleştirilmiş bir versiyonudur dolayısıyla 74HCT serisi bir
entegre uygun bir şekilde 74 LS ile aynı sistemde güvenle
kullanılabilir. aslında 74HCT ailesi birçok devrede 74LS yerine
kullanılabilir.
• Bu entegreler statik elektrik açısından hassastırlar. Bir bacağa
dokunmak statik olarak şarj olmasına sebep olabilir ve
entegre devreyi bozabilir. entegre devreler kullanma
zamanına kadar koruma kılıflarında tutulmalıdır
74HC ve 74HCT ailesi Genel karakteristikleri
• 74HC besleme: 2 ile 6V düşük salınımlar tolere
edilmiştir.
• 74HCT besleme : 5V ± 0.5V regüleli kaynak
kullanılmalıdır..
• Girişleri yüksek empedansa sahiptir. Bu iyi bir özelliktir.
çünkü bağlandığı devrenin bölümüne etki etmez. Fakat
bağlanmayan pinler kolayca elektriksel gürültüleri
toplayabilir. ve bu durum entegrenin kararsız
davranmasına sebep olabilir ve kaynak akımını önemli
derecede artırabilir. Bunu engellemek için kullanılmayan
girişler +Vs yada 0 V a bağlanmalıdır.
• Kapı yayılım zamanı: Yaklaşık 10ns dir
• Frekans: 25MHz e kadar.
• Güç Tüketimi :çok düşüktür µW seviyesindedir bu güç
değeri örneğin yaklaşık 1MHz frekans değerindedir.
74LS Ailesi TTL Karakteristik özellikleri:
• Besleme: 5V ±0.25V besleme salınımsız olmalı ve en
iyisi regüleli kaynak kullanılmalı. Normal bir besleme için
bir tane 0.1µF kondansatör kullanılmalıdır. bu sayede pik
ler engellenmiş olur.
• Çıkışlar: 16 mA e kadar. daha yüksek akım gerektiğinde
transistör bağlanmalıdır.
• Fan-out (çıkış Kapasitesi):: 1 tane çıkış 10 adet 74LS
girişini sürebilir eğer sürülecek giriş 74HCT serisinden
ise bu sayı daha fazladır..
• Kapı yayılım zamanı Yaklaşık 10 ns
• Frekans: yaklaşık 35MHz e kadar.
• Güç tüketimi :µW seviyesindedir.



CMOS (Complementary Metal-Oxide Silicon)
Entegreler
• Yapıları FET türü transistörlerden
oluşur. Besleme gerilimleri 3V ile
15V arasında olabilir.
• TTL’den çok daha az güç kayıpları
vardır.
• 40XX ailesi: En eski CMOS,
yavaş, güç kaybı çok az.
•74HCTXXX ailesi: TTL uyumlu
(besleme gerilimi 5V), CMOS’un
avantajları (çok düşük güç
kayıpları) ile TTL’in avantajlarını
(çok hızlı) birarada bulundurur. En
popüler entegre.
Silikon CMOS
• CMOS terim olarak tamamlayıcı MOS Lojik (Complementary Metal Oxide
Semiconductor) ifadesinin kısaltılması olarak kullanılmaktadır. Entegre
devrelerinin tasarımında alan etkili transistörler kullanılmıştır.
• Logic fonksiyonlar aynı kalmakla beraber TTL ve CMOS yapım
teknolojilerinde kullanılan araçlar farklıdır. Devre teknolojileri lojik
fonksiyonlarda değil sadece performans karakteristiklerinde değişiklik
gösterir.
• CMOS ailesi temel olarak metal kapılı CMOS ve silikon kapılı CMOS olmak
üzere iki ayrı işlem teknolojisi katagorisine ayrılır.
• Eski metal kapılı teknoloji 4000 serisinden oluşurken, Yeni silikon kapılı
teknolojiler ise 74C, 74HC ,74HCT serisinden oluşur.
• CMOS ailesine ait bütün 74 serisi, TTL’ ler ile bacak ve fonksiyon
uyumludur. Yani TTL ve CMOS entegreler aynı sayıda ve benzer giriş, çıkış,
besleme gerilimine (Vcc) sahiptir.
• Ayrıca 74HCT serisi TTL ile voltaj seviyesi uyumludur. 74HCT serisinin 74C
ve 74HC serileri ile bağlanması için özel bir gereksinim yoktur.
• TTL ile CMOS ailesi arasındaki farklılıklar performans karakteristiklerinde
yatar.





CMOS ENTEGRELERİ BAŞKA DEVRELERE BAĞLARKEN
KULLANILACAK (interface) ARABİRİMLER
1. Besleme voltajları birbirlerine eşit olduğu taktirde:
• TTL veya LS entegre ile bir CMOS devrenin girişi (input)
sürülecekse, TTL veya LS entegrenin çıkışı ve CMOS entegrenin
girişi bir Rpu (Pullup) direnciyle VDD'ye bağlanır. CMOS'u süren
entegre TTL serisi bir entegre ise, Rpu'nun değeri 470-4.7 K ohm
civarında olmalıdır. LS türü bir entegre kullanılıyorsa, Rpu'nun
değeri 1 - 10 K ohm arasında olmalıdır.
CMOS ENTEGRELERİ BAŞKA DEVRELERE BAĞLARKEN
KULLANILACAK (interface) ARABİRİMLER - 2
2. Besleme voltajları farklı değerlerde olursa:
• TTL veya LS türü bir entegre tarafından sürülen bir CMOS entegrenin en az 5V
ile beslenmesi gerekir. TTL veya LS türü entegrenin beslemesi 5V olduğu için,
5V'dan düşük DC gerilimiyle beslenen bir CMOS'un sağlıklı bir şekilde
sürülebilmesi için araya beslemesi CMOS'un beslemesiyle aynı olan bir
transistör konur. Transistörün kollectöründen CMOS'un girişine bağlantı yapılır
ve CMOS entegrenin girişi maksimum kendi besleme voltajında sürülür.
• 3-15V ile beslenen bir CMOS ile 5V'da çalışan bir TTL entegresini sürebilmemiz
için arayüz (interface) olarak 4049 veya 4050 entegresi kullanılmalıdır. Bu
entegreler 5V'da çalışırken daha yüksek voltajda sinyallerle sürülebilirler.
Beslenmeleri 5V ile yapıldığı için, çıkış sinyal seviyeleri 5V'u geçmez ve TTL
entegre girişini sürmek için uygun bir seviyedir.
Yapılacak Deneyler
No Deney İsimleri
O.Deney 1 Deney setinin ve ölçü aletlerinin tanıtımı ve ölçmeler (Ortak deney föyünden)
O.Deney 2 Entegre devrelerin kullanımı için bazı uygulamalar (Ortak deney Föyünden)
Deney 1 Lojik Kapılar ve Kombinasyonal Lojik Devreler
Deney 2 Orta Ölçekli Entegre Devreler ve uygulamaları
Deney 3 Sayısal Aritmetik
Deney 4 Flip-Floplar ve Ardışıl Devre Tasarımı
Deney 5 Sayıcılar ve Kayıtcılar
Deney 6 Veri Çevrimi
Deney 7 Kare dalga üreteçleri
ORTAK DENEYLER
• Bu deneylerde, laboratuarın tanıtımı, Ölçü
aletleri, Osiloskop, Güç kaynakları, deney setleri
tanıtılıp, bunların kullanılmasında dikkat edilecek
konular belirtilecektir. Transistörlerin anahtar
olarak çalıştırılması, diyod v.b..
• Ayrıca, Elektronik devre elemanları kullanılarak
mantık devre elemanları gerçekleştirmek ve
bazı temel mantık devrelerini bu gerçekleştirilen
elemanlar ile incelenmesi yapılacaktır. TTL ve
CMOS IC’lerin ortak kullanılması.
DENEY NO: 1
LOJİK KAPILAR VE KOMBİNASYONAL LOJİK DEVRELER
Deneyin Amacı :
• Bu deneyde Boolean cebirinde kullanılan
operatörlerin (mantık kapıları ) tanınması,
boolean cebirindeki eşitliklerin mantıksal kapılar
ile gerçekleştirilmesi, kombinasyonal lojik devre
tasarımı ve fonksiyon denklemlerininin
oluşturulması incelenecektir.
• Ayrıca Min. Terimlerin toplamı veya
Max.Terimlerin çarpımı şeklinde oluşturulmuş
fonksiyon denklemlerinin NAND veya NOR
bağlaçları ile gerçekleştirilmesine ait
uygulamalar yapılacaktır.
DENEY 2
ORTA ÖLÇEKLİ ENTEGRE DEVRELER VE UYGULAMALARI
Deneyin Amacı
• MSI (Medium Scale İntegrated Circuit-Orta
Ölçekli Entegre Devre) devrelerin
tanınması, özelliklerinin sınanması
• MSI devreleri ile uygulamalar yapılması
(decoder, mux v.b)
DENEY 3
SAYISAL ARİTMETİK
Deneyin Amacı
• Bu deneyde işaretli ve işaretsiz sayılar için ikili sayı
sistemindeki toplama işleminin anlaşılması, işlem
performansını artırabilmek için iki tabanındaki sayıların
ikili tamlayan (complement) biçiminin anlaşılması,
• ikili sistemdeki sayıların çarpılıp bölünmesi işlemlerinin
anlaşılması hedeflenmiştir.
• Ayrıca 16 (Hexa decimal ) tabanlı sayı sistemi ve BCD
kodundaki sayılar ile aritmetik işlemlerin yapılması
üzerinde durulacaktır.
DENEY NO : 4
FLİP-FLOP’LAR VE ARDIŞIL DEVRE TASARIMI
Deneyin Amacı
• Bu deneyin amacı Flip-Flop (FF)’ların
fonksiyonlarının tanınması ve senkron
ardışıl devre tasarım aşamalarının
uygulanarak devre tasarımı yapılmasıdır.
DENEY NO: 5
SAYICILAR (COUNTERS) VE KAYITÇILAR (REGISTERS)
• Deneyin Amacı :
• Bu deneyde sayıcılar ve kayıtçıların (registerskaydedici) çalışma mantığı incelenecektir.
Sayıcılar ve kayıtçılar flip-flop lardan
oluşmaktadır.Sayıcılar, sayıcı girişine uygulanan
darbeleri saymak amacı ile, kayıtçılar ise sayıları
depolamak ve kullanmak (manipulate) amacı ile
kullanılmaktadır.
• Bu deneyde değişik tip sayıcılar ve kayıtçılar
üzerinde durulup uygulaması yapılacaktır.
DENEY NO 6
VERİ ÇEVİRİMİ
• Deneyin Amacı:
• Fiziksel dünyadaki analog sinyaller ile
sayısal sinyaller arasındaki farkı ve ikisi
arası dönüşmenin nasıl yapılacağının
anlatılması ve uygulamasıdır.
• ADC ve DAC’lerin çalışmalarının
öğrenilmesi için uygulamalar.
DENEY NO : 7
555 ZAMANLAYICI DEVRESİ
• Deneyin Amacı:
• 555 entegre devresini kullanarak astabil,
monostabil işaretler üretmek ve bunları
sayısal devrelerin Clock işareti v.b.
maksatlar için kullanmak.
Deneyelere hazırlık
• Öğrenci yapacağı deneye önceden hazırlanarak
gelmelidir.
• İlgili deneyin föyündeki problemleri EWB (Electronic
Work Banch) ortamında tasarlamış olarak gelmelidir.
• Deney raporunda EWB çıktısı ile beraber yaptığı deneyin
çıktılarını da yorumlayarak vermelidir.
• Deney süresince sadece kendi deneyi ile ilgilenmeli,
başka masalarla ilgilenmemelidir.
• Elektrikle çalışıldığı için, gerek sağlığınıza gerekse
deney cihazlarına, yanlış uygulamalardan dolayı
zarar gelmemesi için dikkatli çalışılmalı, deney
sorumlusu gözetiminde deney ortamına enerji
uygulamalısınız.
Kazancınız
• Bu laboratuvarın yapılması sürecinde, öğrenci
donanımsal konuların alt yapısını oluşturan
elektrik, elektronik devre elemanları, ölçü
aletleri,sayısal entegre devreleri uygulamalı
olarak tanıyacaktır.
• Bilgisayarın temel ünitelerini oluşturan
kombinasyonal ve ardılış lojik devreleri pratik
olarak gerçekleştirerek daha karmaşık sistemler
için mantık yürütebilecek seviyeye gelmesi
amaçlanmıştır.
• BAŞARILAR DİLERİZ…..
Sayısal Elektronik Laboratuvarı Dersi
Son
Yapay Zeka Dersi
Giriş
Etmenler - Ajanlar
(Agents)
M.Fatih AMASYALI
Yapay Zeka Ders Notları
Rasyonel Ajan
İnsan gibi
düşünmek
Rasyonel
düşünmek
İnsan gibi hareket
etmek
Rasyonel
hareket etmek
PEAS
• Bir etmen dizayn ederken ilk önce karar vermemiz
gereken parametreler
• PEAS:
– Performance measure (Performansı nasıl ölçeceğiz?)
– Environment (Ortama ait özellikler neler?)
– Actuators (Ortamı etkileyecek hareketlerimiz? )
– Sensors (Ortamı nasıl algılayacağız?)
Ajan: Harita çıkaran robot
• P: Haritanın doğruluğu, işlem hızı, statik /
dinamik ortamlarda çalışabilmesi
• E: Duvarlar, bina içi, dış ortam, statik /
dinamik, engeller
• A: Tekerlerin yönü ve hızı, kamera kontrolü
• S: Lazer / sonar / kızılötesi uzaklık
algılayıcılar, kamera
Ajan: Otonom bir taksi sürücüsü
• P: Güvenilir, hızlı, yasal, konforlu sürüş
• E: Yollar, trafikteki diğer araçlar, yayalar,
müşteri
• A: Direksiyon, gaz, fren, sinyal lambaları,
korna
• S: Kamera, uzaklık ölçücü, hız ölçücü,
gidilen yolun ölçümü, motor sensörleri,
klavye, fare
Ajan: Tıbbi tehşis uzmanı
• P: Hastanın sağlığı, minimum gider,
yasalara uygunluk
• E: Hasta, hastane, diğer çalışanlar
• A: Ekran (sorular, testler, teşhis, tedavi,
tavsiye)
• S: Klavye (semptonların, hastanın
cevaplarının girilmesi)
Ajan: Bantta ilerleyen balıkları
türlerine göre ayırıcı
• P: Doğru yerdeki balık yüzdesi
• E: Konveyor bantın üzerinde ilerleyen
balıklar, balıkların konduğu kasalar
• A: X eklemli tutucu
• S: Kamera, eklem açısı sensörleri
Ajan: İngilizce öğretmeni
• P: Öğrencilerin testlerdeki başarısı
• E: Bir grup öğrenci
• A: Ekran (denemeler, tavsiyeler,
düzeltmeler)
• S: Klavye
Ortam Özellikleri
• Fully observable (vs. partially observable): ajanın
sensörleri ortamın tamamını algılayabiliyorsa
• Deterministic (vs. stochastic): Ortamın bir sonraki
durumu sadece şu anki durum ve ajanın yaptığı
hareketle belirleniyorsa (ortamın bir sonraki
durumuna diğer ajanların hareketleri de etkiyorsa
strategic)
• Episodic (vs. sequential): Yapılan bir hareket
ileriye doğru etkimiyorsa (klasik arama motoru,
parmak izi tanıma vs.)
Ortam Özellikleri
• Static (vs. dynamic): Ajan hareketine karar
verirken ortam değişmiyorsa (ortam
değişmiyor sadece ajanın performans skoru
değişiyorsa semidynamic)
• Discrete (vs. continuous): Sınırlı sayıda,
açıkça belirlenmiş algı ve hareketler varsa
• Single agent (vs. multiagent): Ortamda tek
ajan varsa
Ortam Özellikleri
Süreli satranç Süresiz satranç Taksi şöförü
Fully observable Yes Yes No
Deterministic Strategic Strategic No
Episodic No No No
Static Semi Yes No
Discrete Yes Yes No
Single agent No No No
• Ortam türleri ajan dizaynını büyük ölçüde etkilerler.
• Gerçek dünya : partially observable, stochastic, sequential, dynamic,
continuous, multi-agent
Bilgi ve Gösterimleri
M.Fatih AMASYALI
Yapay Zeka Ders Notları
Bilgi Nedir?
• Bilinen her şey.
• Bilmek nedir? Bir şeyi bildiğimizi nasıl
biliriz?
Bilmenin farklı seviyedeki
göstergeleri
• Farkında olma
• Anımsama / Çağrıştırma / Hatırlama
• Tanıma
• Yorumlama
• Açıklayabilir olma
• Kanıtlayabilir olma
• Hakkında konuşabilme
• Yerine getirebilir/yapabilir olma
İşleme /
Yorumlama
Miktarı
Kişiye özel
oluş
Veri’den Bilgiye
Veri’den Bilgiye
Pikseller Bölgesel etiketler Tek bir etiket
2, A
İki yaşlı insan
Bir kadın bir erkek
İkisininde şapkaları var
Birbirlerine sarılmışlar
İkisi de gülümsüyorlar
Mutluluk
Veri’den Bilgiye
Pikseller Bölgesel etiketler Tek bir etiket
Yaşlı bir kadın
Fakir bir kadın
Bir çorba tenceresi tutuyor
Gülümsüyor
Mutluluk, şükran, ?
İki kilit
Bir anahtar
Bir eğik çizgi
Gülen bir yüz
Bilginin Özellikleri (meta bilgi)
• Alan (özel - genel)
• Doğruluk (doğru - yanlış)
• Kesinlik (kesin - belirsiz)
• Doğrulanabilirlik / yanlışlanabilirlik
(bilimsel bilgi - metafizik)
• Güncellik (güncel - eski)
• Tamlık (tam - eksik)
• Ekonomiklik (elde edilmesi, ondan
beklenenden pahalı - değersiz)
• Yaygınlık (çokça bilinen – hiç bilinmeyen)
Bilgi Gösterim Türleri
• Kurallar (Rules)
• Anlamsal Ağlar (Semantic net)
• Yüklem mantığı (Predicate Logic)
• Çerçeveler (Frames)
• Sahneler (Scripts)
Kurallar
-Genel format
IF condition THEN conclusion (action)
-Genelde sonlu sayıda birçok kuralımız olur.
IF condition is Ai THEN conclusion is Bi
-Genelde kurallarımız çok değişkenlidir.
IF condition1 and condition2 or …. and conditionn THEN conclusion
Kurallar; ilişkileri, tavsiyeleri, direktifleri ifade
edebilir:
 İlişki
IF the ‘fuel tank’ is empty
THEN the car is dead
 Tavsiye
IF the season is autumn
AND the sky is cloudy
AND the forecast is drizzle
THEN the advice is ‘take an umbrella’
 Direktif
IF the car is dead
AND the ‘fuel tank’ is empty
THEN the action is ‘refuel the car’
Kurallarla Çıkarım
if A and C then E.
if D and C then F.
if B and E then F.
if B than C
if F then G.
A.
B.
Geriye doğru zincirleme:
G doğru mudur?
İleri doğru zincirleme:
Ne doğrudur?
İleri doğru zincirleme (Forward chaining)
 data-driven reasoning
 Bilinen bir bilgi ile başlar.
 Uygun kurallardan en üstte olan uygulanır
(ateşlenir).
 Kural uygulandığında, database’e bir gerçek ekler.
 Tüm kurallar sadece bir kez uygulanır.
 Çıkarım uygulanabilecek (ateşlenebilecek) kural
kalmayıncaya kadar devam eder.
İleri doğru zincirleme
Match Fire
Knowledge Base
Database
A B C D E
X
Match Fire
Knowledge Base
Database
A B C D E
X L
Match Fire
Knowledge Base
Database
A C D E
L Y
B
X
Match Fire
Knowledge Base
Database
A C D E
Y Z
B
X L
Cycle 1 Cycle 2 Cycle 3
X & B & E Y
Y & D Z
C L
L & M
A X
N
X & B & E Y
Y & D Z
C L
L & M
A X
N
X & B & E Y
Y & D Z
C L
L & M
A X
N
X & B & E Y
Y & D Z
C L
L & M
A X
N
Geriye doğru zincirleme (Backward chaining)
 goal-driven reasoning.
 Sistemin doğruluğunu aradığı bir hedefi vardır.
 Hedefler, alt hedeflere bölünerek kanıtlanmaya
çalışılır.
 Tüm alt hedefler kanıtlandığında hedefte
kanıtlanmış olur.
Geriye doğru zincirleme
Match Fire
Knowledge Base
Database
A B C D E
X
Match Fire
Knowledge Base
Database
A C D E
X Y
B
Sub-Goal: X Sub-Goal: Y
Knowledge Base
Database
A C D E
Y Z
B
X
Match Fire
Goal: Z
Pass 2
Knowledge Base
Goal: Z
Knowledge Base
Sub-Goal: Y
Knowledge Base
Sub-Goal: X
Pass 1 Pass 3
Pass 4 Pass 5 Pass 6
Database
A B C D E
Database
A B C D E
Database
A B C D E
Z Y
?
X
?
X & B & E Y
C L
L & M
A X
N
Y & D Z
X & B & E Y
Y & D Z
C L
L & M
A X
N
C L
L & M N
X & B & E Y
Y & D Z
A X
X & B & E Y
Y & D Z
C L
L & M
A X
N
X & B & E Y
C L
L & M
A X
N
Y & D Z
X & B & E Y
Y & D Z
C L
L & M
A X
N
 Eğer alanın uzmanı;
 Önce bilgi toplayıp sonra olası sonuçları arıyorsa
ileri doğru zincirleme
 Önce hipotezler üretip, sonra bunların
doğruluğunu araştırıyorsa geriye doğru
zincirleme
kullanılır.
Ne zaman hangisi kullanılmalı?
Bilgi tabanında aşağıdaki 3 kuralın yer aldığını
düşünelim:
 Rule 1:
IF the ‘traffic light’ is green
THEN the action is go
 Rule 2:
IF the ‘traffic light’ is red
THEN the action is stop
 Rule 3:
IF the ‘traffic light’ is red
THEN the action is go
Anlaşmazlıkların çözümü
(Conflict resolution)
 Database’deki bilgilere göre ateşlenebilecek
kuralların oluşturduğu kümeye çatışma /
anlaşmazlık kümesi denir.
 Anlaşmazlık kümesi içinden hangi kuralın
uygulanacağının/ateşleneceğinin seçimine
anlaşmazlık / çatışma çözümü denir.
Anlaşmazlıkların çözüm metotları
• Sıralama: Kurallar önemliliklerine göre sıralanır.
Kümedekilerden en yukarıda yer alan ateşlenir.
• Durumla eşleşme: Duruma en çok uyan kural ateşlenir.
– A.
– B.
– if A or B or C then X
– if A then Y
– Yukarıdaki durumda X gerçekleştirilir.
• Güncellik: Kurallardan en günceli (bilgi tabanına en son
ekleneni) ateşlenir.
• Meta Kurallar (kurallar hakkında kurallar):
– Kuralın kaynağı (uzmanlık dereceleri) kuralın önceliğini belirler
– İnsan hayatı ile ilgili kurallar, diğer kurallardan yüksek önceliklidir.
Anlamsal Ağlar
(Semantic Nets)
• Bir Anlamsal Ağ bilgiyi, birbirine değişik tipte
bağlarla bağlanmış bir küme düğüm şeklinde
gösterir. Tipik olarak düğümler kavramları, bağlar
ise kavramlar arasındaki ilişkileri gösterir.
• Düğümler arası linkler ilişkiyi gösterir.
– “instance of”
– “is a”
– “ has a”
– “part of”
• Anlamsal ağların popülerliğinin en büyük sebebi
grafiksel gösterime çok uygun olmalarıdır.
Anlamsal Ağlar
mother(john,sue)
age(john,5)
wife(sue,max)
age(max,34)
...
Sue john 5
age
mother
34
age
father
Max
age
Bazı tür ilişkiler çıkarıma uygundur.
Ör: isa yollarında has ilişkileri
Anlamsal Ağlar
• Tanımlarla programlama
• Problemin kural ve gerçeklerinin
tanımlanması
• Çıkarım mekanizmaları gerçekleri ve
kuralları birlikte kullanarak çıkarım
yaparlar.
• Örnek: Prolog
Yüklem Mantığı
Predicate Logic
Çerçeveler
Frames
• Çerçeve: Nesneye yönelik programlamadaki
object kavramının AI’daki kullanımı
• class  sınıf çevçeve, object nesne çerçeve
• Bir çerçeve, öznitelikleri (slot) olan bir kavramı
belirtir.
• Bir öznitelik ait olduğu çerçeveye ait çeşitli
türdeki bilgileri tutar. Ör: çokluk kısıtları,
varsayılan değer, çeşitli prosedürler
• Ref: Marvin Minsky, 1975
25
slotlar
Çerçeve / Öznitelik / Yuva
• Bir çerçevenin çeşitli öznitelikleri (slot)
vardır.
• Bir özniteliğin çeşitli yuvaları (facets)
olabilir.
Öznitelik / Yuva (Slot / Facet)
• Yuva türleri
– Değer: tek / çok kavram / sayı
/ metin
– Varsayılan değer
– Değer aralığı: alabileceği
değerin alt / üst sınırı, alabileceği
değerler kümesi
– Değerin türü
– Prosedür: (if-needed, if-added,
if-removed) (değerin
doldurulması istenirse, bir değer
girilirse, bir değer silinirse
çağrılacak prosedür)
– Önem katsayısı: Slot’un ait
olduğu çerçeve için önemi
– Çerçeve: Bazı sistemlerde yuva
bir başka çerçeveyi gösterebilir.
• İnsan çerçevesinin ayak sayısı
özniteliğinin (slot) yuvaları
(Facets):
– Değer: 2
– Varsayılan değer: 2
– Değer aralığı: [0,1,2]
– Değerin türü: sayı
– if-added: değer Є değer
aralığı
– if-removed: değer =
varsayılan değer

Çerçeveler arası ilişkiler
Panda
Type: Animal
Colour: Black and white
Food:
EatFunc: ……..
Name:
Height:
Age: 0
Sibling
Bamboo
Type: Plant
GrowFunc: ……..
Location:
Height: 2
Jenny
Name: Jenny
Height: 1.6
Age: 5
Sibling:
Vicky
Name: Vicky
Height: 0.7
Age: 1
Sibling:
Sahneler
Scripts
• Belirli bir durumda, basmakalıp bir olaylar
dizisinin ifade edilmesi
• Örnek sahneler: Lokantada yemek yemek,
otobüse binmek, sinemaya gitmek, sınava
girmek vs.
• Ref:Roger Shank, 1980
Sahneler’in amacı
• Gerçek dünyadaki olaylar genelde
basmakalıp dizilimleri takip eder. İnsanlar
bu dizilimleri yaşamları boyunca öğrenirler,
bilgisayarlar ise sahneleri kullanabilirler.
• Sahneler gözlemlenmeyen olayları tahmin
edebilirler.
Bir Sahnenin Bileşenleri
• Sahne ismi
– Başlama şartları: Bu sahnenin ne zaman aktif
olacağı, sahne başlamadan önceki durum
– Roller
– Nesneler
– Alt sahne 1
– Alt sahne 2
– …
– Sonuç, sahne bittikten sonraki durum
Lokanta Sahnesi
Sahne ismi:
Lokanta
Nesneler:
Masalar
Menü
Yiyecek
Para
Roller:
Müşteri
Garson
Ahçı
Kasiyer
Lokanta sahibi
Giriş Koşulları:
Müşteri aç
Müşterinin parası var
Sonuçlar:
Müşteri tok
Müşterinin daha az parası var
Lokanta sahibinin daha çok parası var
Müşteri memnun
Lokanta Sahnesi
Alt sahne 1: lokantaya giriş
Müşteri lokantaya girer
Boş yer arar
Boş yeri görür
Boş masaya gider
Masaya oturur
Alt sahne 2: sipariş
Müşteri menüyü alır
Müşteri menüyü okur
Müşteri yiyecek kararını verir
Müşteri garsonu çağırır
Müşteri yiyeceği garsona
söyler
Alt sahne 3: yiyeceğin
hazırlanması
Garson siparişi ahçıya söyler
Ahçı yemeği hazırlar.
Ahçı garsona haber verir
Alt sahne 4: yemeğin yenmesi
Garson yemeği müşteriye getirir.
Müşteri yemeği yer.
Alt sahne 5: lokantadan
ayrılma
Müşteri garsonu çağırır
Müşteri garsondan hesabı ister
Garson müşteriye hesabı getirir
Müşteri parayı verir
Garson parayı kasiyere verir
Müşteri lokantadan ayrılır
“Closed World” Sistemler
• “Closed World” bir sistemde, sistemde
varolmayan bilgilerin yanlış olduğu kabul
edilir.
• Örneğin sistemde, “Alex’in Bob ve Jane
adlı çocukları vardır” bilgisi varsa, Alex’in
sisteme girilmemiş çocukları yok sayılır ve
“Alex’in iki çocuğu vardır.” sonucuna
varılır.
“Open World” Sistemler
• “Open World” bir sistemde, sisteme
girilmemiş bilgilerin yanlış olduğu
sonucuna varılmaz.
• Bu bilgiler eksik veya yanlıştır.
• Bir önceki örnekte, sistem “open world” ise
ve sistemde Alex’in çocukları ile ilgili bir
sayı kısıtı yoksa “Alex’in iki çocuğu vardır”
sonucuna varılamazdı.
Kaynaklar
• Yapay Zeka, Vasif Nabiyev, Seçkin Yayıncılık, 2003
• “What’s in a Link: Foundations for Semantic Nets”; Woods,
W.A. In Representation and Understanding: Studies in
Cognitive Science; edited by D. Bobrow and A. Collins;
Academic Press; 1975
• “A Framework for Representing Knowledge” M. Minsky,
Mind Design; J. Haugeland, editor; MIT Press; 1981.
• www.baskent.edu.tr/~msagsan/downloads/Oturum_1.ppt
• Negnevitsky, Michael. Articial Intelligence. A Guide to
Intelligent Systems. Pearson, 2002
Çıkarım
M.Fatih AMASYALI
Yapay Zeka Ders Notları
Çıkarım nedir? Ne yapar?
• Çıkarım, elde olan bilgilerle elde olmayan bilgiyi
üretme sürecidir.
• Bir çıkarım mekanizması iki şey yapabilir:
Kendi bilgi tabanını kullanarak yeni bilgiler
üretebilir. (ileriye doğru zincirleme)
Eldekiler: AB, A, BC
İstenen: Neler doğrudur?
Verilen bir bilginin, kendi bilgi tabanına göre
doğru olup olmadığını söyleyebilir. (geriye doğru
zincirleme)
Eldekiler: AB, A, BC
İstenen: C doğru mudur?
Çıkarım Türleri
Tümdengelim (Deduction): sebeplerden sonuca
Bu kutudaki tüm toplar siyahtır.
Bu toplar bu kutudandır.
Bu toplar siyahtır.
Abduction: sonuçtan olası sebebe
Bu kutudaki tüm toplar siyahtır.
Bu toplar siyah.
Bu toplar bu kutudandır.
Tümevarım (Induction): örneklerden olası kurala
Bu toplar bu kutudandır.
Bu toplar siyah.
Bu kutudaki tüm toplar siyahtır.
A => B
A
---------
B
A => B
B
-------------
Possibly A
Whenever
A then B
-------------
Possibly
A => B
1-
Kediler memelidir.
Memeliler hayvandır.
 Kediler hayvandır.
2-
Yaşamak için havaya ihtiyacın var.
Uzayda hava yok.
 Uzayda yaşayamazsın.
3-
Kapıyı itmek kapıyı açar.
Ali kapıyı itti.
 Ali kapıyı açtı.
4-
Ali şu an araba kullanıyor.
 Ali’nin ehliyeti var.
 Ali’nin arabası var.
5-
X’in A,B,C’sinin olduğunu
biliyorum.
Y’nin B,C’sinin olduğunu
biliyorum.
 Y’nin A’sı olabilir.
6-
Gördüğüm A’ların B’si var.
Tüm A’ların B’si var.
7-
Ali 1971’de attan düştü.
 Ali 1972’de attan düşmedi.
Diyebilir miyiz?
8-
Ali 1971’de öldü.
 Ali 1972’de attan düşmedi.
Diyebilir miyiz?
Çıkarım Örnekleri
Ali bugün kopya çekerken yakalandı.
• Ali öğrencidir.
• Ali bugün en az bir sınava girmiştir.
• Ali bugün okula gitmiştir.
• Ali dün çok ders çalışmamıştır.
• Ali bugün bir sırada oturmuştur.
• Ali dersten kalacak.
• Ali bugün üzülmüştür.
• Ali’nin midesi vardır.
• Ali’nin annesi vardır.
• ...
Çıkarım Örnekleri-devam
• Tüm serçeler kuştur.
• Tüm kuşlar uçabilir.
• Tweety uçamaz.
• Tweety serçe midir?
• Tweety uçabilseydi ona serçe diyebilir
miydik?
Yanlış ! mantık
• Temel’in mantıkçı fıkrası
Belirsizliğin kaynakları
• Belirsiz girişler eksik, hatalı, gürültülü bilgi
• Bir sebebe ait çok sayıda olası sonucun olması
• Bir sonuca ait çok sayıda olası sebebin olması
• Bir sebep ortaya çıktığında sonucunun belli bir
olasılıkla ortaya çıkması
• Çıkarım türü olarak tümevarım ve abduction
kullanılması
Belirsizlik ortamında karar
• Rasyonel davranış:
– Her olası hareketin, olası sonuçlarını belirle
– Olası sonuçların olasılık oranlarını belirle
– Olası sonuçların kar / zarar değerini belirle
– Her olası hareketin olasılık oranı ile
ağırlıklandırılmış kar / zarar değerini belirle
– Bu değerlerden en yükseğine / düşüğüne sahip
hareketi seç
(Maximum / Minimum Expected Utility)
Mahatma Gandhi
Söylediklerinize dikkat edin, düşüncelerinize dönüşür…
Düşüncelerinize dikkat edin, duygularınıza dönüşür…
Duygularınıza dikkat edin, davranışlarınıza dönüşür…
Davranışlarınıza dikkat edin, alışkanlıklarınıza dönüşür…
Alışkanlıklarınıza dikkat edin, değerlerinize dönüşür…
Değerlerinize dikkat edin, karakterinize dönüşür…
Karakterinize dikkat edin, kaderinize dönüşür…
Bir tümevarım klasiği...
Genetik Algoritmalar
M.Fatih AMASYALI
Yapay Zeka Ders Notları
Genetik Algoritmalar
• Genetik algoritmalar, evrim mekanizmasına (en iyinin
yaşaması) dayanır.
• Amaç, uygunluk fonksiyonunun (fitness function)
maksimizasyon / minimizasyon optimizasyonudur.
• Uygunluk fonksiyonu: Toplumdaki her kromozomun /
birey / durum ne kadar iyi olduğu gösteren fonksiyondur.
Büyük değer, iyi / uygun birey.
• K adet rasgele üretilmiş kromozom / durum / çözüm
hipotezi ile başlar. Durumlar kümesine popülasyon denir.
• Kromozom / durumlar sırala ya da sırasız karakter
kümeleri ile temsil edilir. Genelde sayılar ya da 0 ve
1’lardan oluşur.
Genetik Algoritmalar
Yeni kromozom / durumların üretilmesinde kullanılan
operatörler;
– Seçme (selection) : Bir sonraki nesli üretecek
kromozomların seçilmesidir.
– Yeniden kopyalama (reproduce) : Yeni çözümler
üretmek için çaprazlama (crossover) işlemi yapılır.
– Değiştirme (mutation) : Kromozom’un bazı değerlerini
rasgele değiştirir.
Genetik Algoritma
function GENETIC_ALGORITHM( population, FITNESS-FN) return an individual
input: population, a set of individuals
FITNESS-FN, a function which determines the quality of the individual
repeat
new_population  empty set
loop for i from 1 to SIZE(population) do
x  RANDOM_SELECTION(population, FITNESS_FN)
y  RANDOM_SELECTION(population, FITNESS_FN)
child  REPRODUCE(x,y)
if (small random probability) then child  MUTATE(child )
add child to new_population
population  new_population
until some individual is fit enough or enough time has elapsed
return the best individual
Paralel Tepe Tırmanma - Local
beam search
• Ana Fikir: Tek bir durumu izlemek yerine K
taneyi izle
• K adet rasgele üretilmiş durumla başla
• Her bir iterasyonda k durumun hepsiden
gidilebilecek durumları üret.
• Bu durumlardan biri hedefse dur. Değilse,
en iyi k tanesini mevcut durumlar olarak
ata ve bir önceki adıma dön.
GA vs. Paralel Tepe Tırmanma?
Genetik Algoritma iş başında
8 vezir
• 8 vezirde kromozomların ifade edilmesi:
• Herbir sütunda bir vezir var.
• State = her bir vezirin sütündaki yeri
=> 8 x log2(8) bits = 24 bits (ikili gösterimde)
Genetik Algoritma iş başında
8 vezir
• Uygunluk fonksiyonu - Fitness function: Birbirini tehdit
etmeyen vezir çiftlerinin sayısı (min = 0, max = 8 × 7/2 =
28)
• 24/(24+23+20+11) = 31%
• 23/(24+23+20+11) = 29% vs.
8 vezirde çaprazlama
Kromozom Seçim Türleri
1. Rulet tekeri seçimi
• Bireylerin (kromozomların) uygunluk değerine göre seçim.
• Fakat uygunluk değeri en büyük olanın seçileceği garanti değil,
seçilme şansı fazla.
• Her bir kromozomun seçilme şansı, kendi uygunluk değerinin tüm
bireylerin uygunluk değerlerinin toplamına oranıdır.
2. Sıralama seçimi
• Rulet tekeri seçimi, uygunluklar çok farklıysa problemlere yol açar.
(Örneğin, en iyi kromozomun seçilme şansı %90 ise diğer
kromozomlar çok az seçilme şansına sahip)
• Sıralama seçimi önce populasyonu uygunluk değerlerine göre
küçükten büyüğe sıralar. Her kromozomun sıra değeri uygunluk
değeri olarak atanır. En kötü 1, en iyi N. Seçilme şansı yine
uygunluk değerinin toplam uygunluk değerine oranı ile bulunur.
• Böylelikle bütün kromozomlara seçilme şansı verilir. Fakat bu
yöntemde en iyi kromozomların seçilme şansı diğerlerinden çok
farklı olmadığından çözüme yaklaşma yavaş olacaktır.
Farklı Olasılıklarla Seçim?
• Seçilme şansları toplamı=100
• Bir aralığı 100 parçaya böl.
• Seçilme şanslarına göre parçaları
kromozomlara ata.
• 1-100 arasında rasgele bir sayı üret.
• O sayının karşı geldiği aralığın atandığı
kromozomu seç.
• Seçilme şansları %44.34355 şeklinde
olursa?
Gezgin Satıcı Problemi
Traveling Salesman Problem
Şehirler arası bir rota bulmak
– Rota her şehirden geçmeli
– Toplam gidilen yol minimum olmalı
Gezgin Satıcı Probleminde
Kromozomların Gösterimi
Şehirlerin sıralı listesi. 8 şehir varsa:
1) Berlin 3) Stuttgart 5) Cologne 7) Dusseldorf
2) Munich 4) Wesbaden 6) Hanover 8) Breme
Olası iki kromozom / çözüm hipotezi
CityList1 (3 5 7 2 1 6 4 8)
CityList2 (2 5 7 6 8 1 3 4)
30 şehirli gezgin satıcı problemi
0
20
40
60
80
100
120
0 10 20 30 40 50 60 70 80 90 100
x
y
Çözüm i
(Toplam yol = 941)
TSP30 (Performance = 941)
0
20
40
60
80
100
120
0 10 20 30 40 50 60 70 80 90 100
x
y
Çözüm j
(Toplam yol = 800)
44
62
69
67
78
64
62
54
42
50
40
40
38
21
35
67
60
60
40
42
50
99
TSP30 (Performance = 800)
0
20
40
60
80
100
120
0 10 20 30 40 50 60 70 80 90 100
x
y
Çözüm k
(Toplam yol = 652)
TSP30 (Performance = 652)
0
20
40
60
80
100
120
0 10 20 30 40 50 60 70 80 90 100
x
y
En iyi Çözüm (Toplam yol = 420)
42
38
35
26
21
35
32
7
38
46
44
58
60
69
76
78
71
69
67
62
84
94
TSP30 Solution (Performance = 420)
0
20
40
60
80
100
120
0 10 20 30 40 50 60 70 80 90 100
x
y
Crossover’da Problem
Olası iki kromozom / çözüm hipotezi
CityList1 (3 5 7 | 2 1 6 4 8)
CityList2 (2 5 7 | 6 8 1 3 4)
Standart crossover uygularsak:
Yeni nesil:
CityList1 (3 5 7 6 8 1 3 4)
CityList2 (2 5 7 2 1 6 4 8)
Gezgin satıcı için bu problem.
Çözüm: ?
Uniform Crossover
Kromozom boyutunda rastgele 1 ve 0’lardan oluşan template
oluştur.
Template’deki 0’lar için P1 ve P2’nin yerlerini değiştir.
1’ler için aynen al.
Gezgin satıcıya çözüm mü?
Sıra Tabanlı Crossover
Order-based Crossover
Kromozom boyutunda rastgele 1 ve 0’lardan oluşan template oluştur.
Child1 için:
Template’de 1 olan indislerin Parent1’deki değerlerini al. Child1’in aynı
indisine koy. Child1’de bazı boşluklar kalır.
Template’de 0 olan indislerin Parent1’deki değerlerini al. (A D E G)
Bu listedekileri Parent2’deki sıralarına göre diz. (E D G A)
Elde edilen diziyle Child1’in boşluklarını bu sırayla doldur.
Child2 için:
Aynı prosedür (E C F A)  (A C E F)
Problem: f(x)=cos(x/3)*sin(x/4) x[0, 127] şeklinde verilen bir
fonksiyonun maksimum değerini bulmak
Gösterim : 128 farklı değer için 7 bit yeterli
Başlangıç : a : 0000011
b : 1110111
c : 0010000
d : 0011010
Uygunluk kriteri :f(x)
Fonksiyon iki parametreli olursa?
F(x,y)=x^2-y^3+xy^2
GA ile fonksiyon optimizasyonu
0 20 40 60 80 100 120 140
-1
-0.8
-0.6
-0.4
-0.2
0
0.2
0.4
0.6
0.8
1
GA ile 8 Taş
8
4
6
5
1
7
2
1
4
7
3 6 3
5
8
S
0
2
G
Operatörler:
L : Boş kare sola
R : Boş kare sağa
U : Boş kare yukarıya
D : Boş kare aşağıya
GA ile çözüm:
Kromozom gösterimi?
Kromozom uzunluğu?
Uygunluk fonksiyonu?
Çaprazlama ve mutasyon nasıl yapılmalı?
GA’nın Performansını Etkileyen Faktörler
• Popülasyon büyüklüğü / Kromozom sayısı: Kromozom
sayısını arttırmak çalışma zamanını arttırırken, azaltmak da
kromozom çeşitliliğini yok eder.
• Mutasyon Oranı: Kromozomlar birbirine benzemeye
başladığında hala çözüm noktalarının uzağında
bulunuyorsa mutasyon işlemi GA’nın sıkıştığı yerden (tüm
kromozomlar aynı platoda) kurtulmak için tek yoludur.
Ancak yüksek bir değer vermek GA’ın kararlı bir noktaya
ulaşmasını engelleyecektir.
• Kaç Noktalı Çaprazlama Yapılacağı: Normal olarak
çaprazlama tek noktada gerçekleştirilmekle beraber yapılan
araştırmalar bazı problemlerde çok noktalı çaprazlamanın
çok yararlı olduğunu göstermiştir.
• Çaprazlamanın sonucu elde edilen bireylerin nasıl
değerlendirileceği: Elde edilen iki bireyin birden kullanılıp
kullanılamayacağı bazen önemli olmaktadır.
• Durum kodlanmasının nasıl yapıldığı: Bir
parametrenin doğrusal yada logaritmik
kodlanması GA’nın performansında önemli bir
farka yol açabilir.
• Başarı değerlendirmesinin nasıl yapıldığı:
Akıllıca yazılmamış bir değerlendirme işlevi,
çalışma zamanını uzatabileceği gibi çözüme
hiçbir zaman ulaşmamasına da neden olabilir.
GA’nın Performansını Etkileyen Faktörler
Değerlendirmeler
• Pozitif yönleri
– Crossover ve mutasyon sayesinde lokal maksimum ve
platolardan kurtulabilir.
– Doğa temelli
• Negatif yönleri
– Ayarlanabilir çok fazla parametreye sahip
• Bir problemde gösterdiği başarıyı başka bir problemde
tekrarlaması zor
– Bazı problem türleri için iyi ama tepe tırmanmayı farklı
başlangıçlarla tekrarlamaktan ya da paralel tepe tırmanmadan
daha iyi olduğuna dair matematiksel bir kanıt yok.
Sezgisel Arama
Bilgisayar Mühendisliği Bölümü
Yapay Zeka Ders Notları
• G.W.Leibniz:
Özel buluşlara çok değer vermiyorum ve en çok arzu
ettiğim şey, icat etme sanatını mükemmelleştirmek ve
problemin çözümlerini bulmaktan ziyade, çözüm
yöntemlerini bulmaktır; çünkü tek bir yöntem, sayısız
çözümleri kapsar.
• Fagenbaum ve Fieldman:
Sezgisellik (sezgisel kurallar, sezgisel yöntem) problemin
durum uzayı çok büyük olduğunda, çözümün aranmasını
kesin biçimde sınırlayan herhangi bir kural, strateji, hile,
sadeleştirme ve diğer etmenler kullanımıdır.
Sezgisel Arama Algoritmaları
• İlk En İyi Arama - Best-first search
• A*
arama
• Lokal arama - Local search algorithms
– Tepe Tırmanma- Hill-climbing search
– Rasgele Başlangıçlı Tepe Tırmanma- Random-restart
hill climbing
– Paralel Tepe Tırmanma - Local beam search
– Benzetimli Tavlama - Simulated annealing search
– Genetik Algoritmalar
İlk En İyi Arama Algoritması
Best first search
• kuyruk = [kök durum]
• bulundu = FALSE
• While (kuyruk <> boş) and (bulundu = FALSE)
– Kuyruktan ilk durum’u (N) çek
– Eğer N hedef durumsa, bulundu = TRUE
– N’den gidilebilecek tüm durumları kuyruğun
sonuna ekle
– Kuyruktaki durumlara değerlendirme fonksiyonuna
göre bir puan ver ve durumları bu puanlara göre
küçükten büyüğe sırala
İlk En İyi Arama Algoritmasının
Değerlendirme Fonksiyonu
• Değerlendirme fonksiyonu
• f(n) = h(n) (heuristic)
• = mevcut durumun hedefe tahmini uzaklığı
• hSLD(n) = mevcut durumun (n) Hedefe kuş
uçuşu mesafesi (SLDShortest Line
Distance)
• Algoritma her adımda hedefe en yakın
gözüken duruma ilerler.
Romanya Haritası
Amaç: Arad’dan Bükreş’e gitmek
İlk En İyi Arama Örneği
İlk En İyi Arama Örneği
İlk En İyi Arama Örneği
İlk En İyi Arama Örneği
Optimum Çözüm
İlk En İyi Arama’nın Çözümü
İlk En İyi Arama’nın Analizi
• Complete? Hayır, Loop’lara takılabilir.
(Örneğin hedefe aynı mesafede iki durum
arasında sonsuz döngü)
• Time? O(bm), Ancak iyi sezgisel kurallar
büyük iyileşmeler sağlayabilir.
• Space? O(bm), Tüm durumlar hafızada
• Optimal? Hayır
A* Arama
• Fikir: Kökten itibaren toplam maliyeti
yüksek durumlara gidişi engellemek
• Değerlendirme Fonksiyonu:
• f(n) = g(n) + h(n)
• g(n) = Kökten mevcut duruma (n) gelişin
maliyeti
• h(n) = Mevcut durumdan (n) hedefe gidişin
tahmini maliyeti
• f(n) = Kökten hedefe n’den geçilerek
gidişin tahmini maliyeti
A* Arama Örneği
A* Arama Örneği
A* Arama Örneği
A* Arama Örneği
A* Arama Örneği
A* Arama Örneği
a) Amaç: S’den başla G’ye git.
b) Tüm durumların hedefe olan Manhattan uzaklıkları (h)
c) Best-First ile bulunan yol. Sadece h’leri kullanır.
d) A* ile bulunan yol. durumlardaki etiketler (h+g)
A*’ın Analizi
• Complete? Evet, Loop’lara takılmaz. (?)
• Time? O(bm), Ancak iyi sezgisel kurallar
büyük iyileşmeler sağlayabilir.
• Space? O(bm), Tüm durumlar hafızada
• Optimal? Evet (ama değerlendirme
fonksiyonlarına bağlı)
8 Taş İçin Sezgisel Kurallar
• h1
(n) = Yerinde olmayan taşların sayısı
• h2
(n) = Taşların hedefteki yerlerine uzaklıkları toplamı (yatay ve
dikey hane toplamları- Manhattan distance)
• h1
(S) = ? 8
• h2
(S) = ? 3+1+2+2+2+3+3+2 = 18
0 1 2
3 4 5
6 7
0 1 2
3 4 5
6 7
0 2 5
3 1 7
6 4
Hedef Durum
h1=1
h2=1
h1=5
h2=1+1+1+2+2=7
Baskınlık / Dominance
• Geçerli iki sezgisel kural için tüm durumlarda
• h2
(n) ≥ h1
(n) ise
• h2 baskındır / dominates h1
• h2 arama için daha uygundur
• 8 taş için Arama Maliyetleri (test edilen durum sayısı
ortalaması):
• d=12 IDS = 3,644,035 node
A*
(h1
) = 227 node
A*
(h2
) = 73 node
• d=24 IDS = çoook node
A*
(h1
) = 39,135 node
A*
(h2
) = 1,641 node
Esnetilmiş Problemler
• Orijinal problemden daha az kısıtlama
içeren problemlere denir.
• 8 taş’ta bir taş istediği yere gidebilir dersek
h1
(n) en kısa çözümü verir.
• 8 taş’ta bir taş istediği komşusuna gidebilir
dersek h2
(n) en kısa çözümü verir.
Yeni Problem
B B B W W W
G: Hedef: Tüm W’ler B’lerin solunda
Operatörler:
1) Bir taş yanındaki taşın diğer yanı boşsa üzerinden
atlayabilir. Maliyeti 2.
2) Bir taş yanındaki boş yere gidebilir. Maliyeti 1.
H önerileri ?
Şekil-2 Farklı şehirlerin G şehrine olan doğrusal uzaklığı
Amaç  S şehrinden G şehrine gitmek
Şekil-1  Farklı şehirler arasındaki yol bağlantısı.
Bağlantılardaki değerler  Şehirler arasındaki mesafe
Arama ağacı
Durum uzayı
[S]
[A1
,D2
]
[D2
,B3
,D4
]
[B3
,D4
,A5
,E6
]
[D4
,A5
,E6
,C7
,E8
]
[A5
,E6
,C7
,E8
,E9
]
[E6
,C7
,E8
,E9
,B10]
[C7
,E8
,E9
,B10,B11,F12]
[E8
,E9
,B10,B11,F12]
[E9
,B10,B11,F12,D13,F14]
[B10,B11,F12,D13,F14,B15,F16]
[B11,F12,D13,F14,B15,F16,C17,E18]
[F12,D13,F14, B15,F16,C17,E18,A19,C20]
[D13,F14, B15,F16,C17,E18,A19,C20,G21]
[F14,B15,F16,C17,E18,A19,C20,G21]
[B15,F16,C17,E18,A19,C20,G21,G22]
[F16,C17,E18,A19,C20,G21,G22,C23]
[C17,E18,A19,C20,G21,G22,C23,G24]
[E18,A19,C20,G21,G22,C23,G24]
[A19,C20,G21,G22,C23,G24]
[C20,G21,G22,C23,G24,F25]
[G21,G22,C23,G24,F25]
BFS={S,D,E,F,G}
Enlemesine Arama
Breadth-first search
Harflerin altlarındaki sayılar, indisleri göstermektedir.
[S]
[A1
,D2
]
[B3
,D4
,D2
,]
[C7
,E8
,D4
,D2
]
[E8
,D4
,D2
]
[D13,F14,D4
,D2
]
[F14,D4
,D2
]
[G22,D4
,D2
]
DFS={S,A,B,E,F,G}
Derinlemesine Arama
Depth-first search
Harflerin altlarındaki sayılar, indisleri göstermektedir.
Düşük Maliyetli Arama
Uniform cost search
[S0
]
[A3
,D4
]
[D4
,B7
,D8
]
[E6
,B7
,D8,A9
]
[B7
, D8,A9
,F10,B11]
[D8,A9
,F10,B11,C11,E12]
[A9
,F10,E10,B11,C11,E12]
[F10, E10,B11,C11,E12,B13]
[E10,B11,C11,E12,B13,G13]
[B11,C11,E12,B13,G13,F14,B15]
[C11,E12,B13,G13,F14,B15,A15,C15]
[E12,B13,G13,F14,B15,A15,C15]
[B13,G13,F14,D14, B15,A15,C15,F16]
[G13, F14,D14, B15,A15,C15,F16,C17,E18]
UCS={S,D,E,F,G} Harflerin altlarındaki sayılar, S’den uzaklıklarını göstermektedir.
A* Arama
f(n)=g(n)+h(n)
[S0
]
[D12.9
,A13.4
]
[E12.9
,A13.4
,A19.4
]
[F13.0
,A13.4
,B17.7
,A19.4
]
[G13.0
,A13.4
,B17.7
,A19.4
]
A*={S,D,E,F,G}
Harflerin altlarındaki sayılar, S’den uzaklıkları + G’ye uzaklıklarını göstermektedir.
A* Arama
S
11+0
SA
A
10.4+3
SD
D
8.9+4
SA
A
10.4+3
SDS
S
11+8
SDA
A
10.4+9
SDE
E
6.9+9
SDS
S
11+8
SDA
A
10.4+9
SDE
E
6.9+9
SAS
S
11+6
SAD
D
8.9+8
SAB
B
6.7+7
SDS
S
11+8
SDA
A
10.4+9
SDE
E
6.9+9
SAS
S
11+6
SAD
D
8.9+8
SABA
A
10.4+11
SABE
E
6.9+8
SABC
C
4+11
SDS
S
11+8
SDA
A
10.4+9
SDE
E
6.9+9
SAS
S
11+6
SAD
D
8.9+8
SABA
A
10.4+11
SABC
C
4+11
SABED
D
8.9+13
SABEB
B
6.7+9
SABEF
F
3+12
SDS
S
11+8
SDA
A
10.4+9
SDE
E
6.9+9
SAS
S
11+6
SAD
D
8.9+8
SABA
A
10.4+11
SABED
D
8.9+13
SABEB
B
6.7+9
SABEF
F
3+12
SABCB
B
6.7+15
SDS
S
11+8
SDA
A
10.4+9
SDE
E
6.9+9
SAS
S
11+6
SAD
D
8.9+8
SABA
A
10.4+11
SABCB
B
6.7+15
SABED
D
8.9+13
SABEB
B
6.7+9
SABEFE
E
6.9+16
SABEFG
G
0+15
Özet
• Sezgisel arama yöntemleri, problem
hakkındaki bilgiden yararlanırlar.
• Sezgi (Heuristic), hedefe ulaşmak için
kalan maliyetin tahminidir.
• İyi bir sezgi, arama süresini, üstelden
doğrusala indirir.
• A*, AI’da anahtar teknolojidir.
Yapay Zeka Dersi
Son
Bilgisayar Sistemleri Laboratuvarı Dersi
Giriş
Fırat Üniversitesi
BMÜ-431
Bilgisayar Mühendisliği Bilgisayar
Sistemleri Laboratuvarı
DENEY NO: 1
LINUX İŞLETİM SİSTEMİ VE BULUT BİLİŞİM
1. GİRİŞ
Linux, açık kaynak kodlu ve ücretsiz bir işletim sistemi çekirdeğidir. Unix’ten
esinlenerek geliştirildiği için Unix-like yani Unix-benzeri denilmektedir. Linux
kerneli üzerine çeşitli yazılımlar eklenerek oluşturulan işletim sistemi Linux
dağıtımı (distrosu) olarak adlandırılır. Örneğin bu deneyde kullanılacak olan
işletim sistemi olan Ubuntu bir Linux dağıtımıdır. Kavramların daha net
anlaşılması açısından açıklamak gerekirse;
- Linux ve Unix farklı kavramlardır. Linux, Unix temel alınarak geliştirilmiştir.
- Linux bir işletim sistemi değildir, işletim sistemi çekirdeğidir. Bu çekirdek
tamamlanarak işletim sistemi yani Linux dağıtımı ortaya çıkar.
- Ubuntu, Pardus, Debian, Slackware, SUSE, Red Hat, Fedora yaygın olarak
kullanılan bazı Linux dağıtımlarıdır.
Günümüzde en yaygın olarak kullanılan işletim sistemi Microsoft Windows’tur.
Peki, Windows işletim sistemi bu kadar popülerken Sistem Laboratuvarı dersinde
Linux’un tercih edilme nedenleri nelerdir?
Linux ağ kavramlarının öğrenilmesi açısından daha elverişlidir:
 Ip adresi değiştirilmesi, yönlendirme (routing) tablolarının oluşturulması,
ağ bağlantısı testleri ve ağ trafiği (gelen/giden paketlerin) incelenmesi
gibi işlemler için basit ve güçlü bir ortam sağlar.
 Server/client uygulamalarının oluşturulması ve çalıştırılması oldukça
basittir.
 Bir Linux bilgisayar kolay bir şekilde router olarak konfigüre edilebilir.
Unix-tabanlı işletim sistemlerinin tecrübe edilmesi önemlidir. Windows en
çok kullanılan işletim sistemi olsa da Unix tabanlı işletim sistemleri de ağ
sunucuları, ağ cihazları ve gömülü sistemlerde oldukça yaygın olarak
kullanılmaktadır. Örneğin bir çok router, switch, özelleştirilmiş bilgisayar
Linux kullanmaktadır.
Ubuntu Linux işletim sistemi ve üzerinde kullanacağımız yazılımlar
ücretsizdir. Hiç biri korsan yazılım değildir.
Günümüzde gittikçe yaygınlaşan Bulut Bilişim ve Büyük Veri
teknolojilerinde Linux sistemler tercih edilmektedir.
1
Linux ortamı ve virüsler:
Unix / Linux sistem açıklarından faydalanan virüsler laboratuvar ortamında
yazılmıştır. Laboratuvar ortamı diyoruz çünkü bu virüslerin hiçbiri ortalıkta
dolaşmıyor, sadece Unix sistemler için virüs olabileceğine dair ispat olsun diye
varlar. Son dönemde Linux çekirdeğindeki açıkları kullanan kök takımı (rootkit)'ler
de yazıldı ancak bu açıklar da hızla kapatıldı. Linux ortamında çalışacak ve
kendisini çoğaltabilecek virüs yazmak teorik olarak çok zor olsa da, olanaksız
değil.
• Linux anti-virüs programlarının büyük çoğunluğu e-posta sunucularında
çalışır. Bunlar e-posta alıp-göndermek istediğinizde istemcinizin bağlandığı
bilgisayarlardır. E-posta, virüs ve truva atlarının yayılmasında kullanılan en
temel yol olduğundan, bu sunucular bilgisayar virüsleri ile olan savaştaki
ön cephe gibidir. Bu sunucuların bir çoğu Linux kullandığından, Windows
virüslerini tespit etmek için bir Linux anti-virüs programının kullanılma
ihtiyacı daha iyi anlaşılır.
• Yetkilendirme sistemi sayesinde, sisteme bir virüs girse dahi kullanıcı ev
dizini dışına ya da farklı bilgisayarlara yayılamamaktadır.
• Linux'ta kullanıcıların, kurmak istedikleri programları, herhangi bir web
sitesi üzerinden değil doğrudan dağıtımın resmi paket depoları üzerinden
(Ubuntu Yazılım Merkezi gibi) temin ediyor olmaları, bu güvenli yapıyı
desteklemektedir.
• Daha çok göz daha az güvenlik açığı demektir. Linux açık kaynaklı bir
yazılımdır, bu da dünyadaki her programcının kodlara bakmasına ve
yardımcı olmasına, ya da geliştiricilere "... Bu bir güvenlik açığı değil
midir?" diyebilmesine, böylelikle hataların hızlıca kapatılmasına olanak
sağlar. Linus Torvalds bu durumu “Hiçbir hata (açık) milyonlarca gözden
kaçamaz” sözü ile ifade etmiştir.
• Pek çok Windows kullanıcısında "Windows çok kullanılıyor onun için bu
kadar çok virüs yazılmakta. Bir gün Linux da yaygınlaşırsa onun için de
virüsler yazılacaktır." şeklinde bir algı vardır. Ancak örneğin açık kaynak
Apache Web Sunucusu yazılımı, dünyada en yüksek market payına sahiptir
ve buna rağmen Microsoft'un sunucusundan çok daha az saldırıya
uğramaktadır.
Bulut Bilişim
İnternetin bulutlardan oluşan gökyüzüne benzemesinden yola çıkarak bulut ismini
alan bulut bilişim için oldukça çeşitli tanımlar bulunmaktadır. Bulut internet
demektir. Ağ diyagramlarında interneti göstermek için bulut resmi kullanılır.
İnternet üzerinden birbirine bağlanmış, birlikte çalışan, dinamik olarak
yönetilebilen, izlenebilen ve bakımı yapılabilen sanal sunucuların oluşturduğu
sistemin adıdır.
Bulut bilişim sağlayıcıları farklı birkaç temel model üzerinden servis sunmaktadır.
Bu modeller sunulan hizmete İngilizcede “servis olarak” anlamına gelen “as a
service” ön eki getirilerek adlandırılmışlardır. Uygulanan 3 temel model Servis
Olarak Altyapı (IaaS), Servis Olarak Platform (PaaS) ve Servis Olarak Yazılım
(SaaS)’dır.
2
Şekil 1- Bulut Hizmet Modelleri
2. UNİX KULLANICI HESAPLARI VE DOSYA HİYERARŞİSİ
Ubuntu ilk başlatıldığında kullanıcı giriş ekranı açılır. Size laboratuvarda verilecek
olan kullanıcı adı ve şifreyi kullanarak giriş yapınız.
Ubuntu’da farklı kullanıcıların farklı yetkileri bulunmaktadır. Bu yetkiler sistem
dosyalarının, diğer kullanıcıların dosyalarının görüntülenmesi veya değiştirilmesi,
işletim sistemindeki önemli parametrelerin değiştirilmesi gibi işlemler için
geçerlidir. En yetkili (tüm izinlere sahip) olan kullanıcı root’dur. Root kullanıcısına
super-user da denilmektedir. Root kullanıcı olarak giriş yapılması doğru değildir
çünki yanlışlıkla sabit diskteki bütün bilgiler silinebilir ve geri dönüşü olmayan
hatalar yapılabilir. Bu nedenle root yetkisi gerektiren işlemler “sudo” komutu ile
yürütülerek sadece o komut için super-user yetkisiyle işlem yapılması sağlanır.
Linux dosya sistemleri ext2, ext3 veya ext4 olabilir. Bu dosya sistemleri sırasıyla
birbirinin daha gelişmiş versiyonlarıdır. Ext3 ve ext4’ün günlükleme desteği
(journaling) vardır. Amaç sistemin çöktüğü durumlarda daha önce yapılan işlemler
log dosyalarından okunarak verilerin kurtarılmasını sağlamaktır. Disk boyutlarının
çok fazla büyümesi üzerinde daha büyük büyüklükte dosyaların saklanabilmesi
amacıyla ext4 geliştirilmiştir.
İşletim sistemlerinin tümünde dizin veya klasör yapısı bulunmaktadır. Bilgisayar
çeşitli bilgileri depolayıp işleyebilmekte ve birden fazla kullanıcı tarafından
kullanılabilmektedir. Bu da çok sayıda dosya ile uğraşmak demektir. Bu
karışıklığın engellenmesi için dosya/dizin yapısı geliştirilmiştir.
Linux, bir UNIX klonu olması itibariyle “Tekil Hiyerarşik Klasör Yapısı”na sahiptir.
Windows’ta olduğu gibi C, D, E bölümleri bulunmaz. Tüm klasörlerin üzerinde kök
dizini olan root klasörü bulunur ve kökten dallara doğru uzanan ağaç yapısındadır.
Root olarak isimlendiren bu başlangıç dizini / (slash) simgesi ile gösterilir ve
3
kendisine bağlı diğer tüm dizinleri barındırmaktadır. Dosya sistemi bir kök dizini
ve kök dizinin çocukları şeklinde devam eden bir hiyerarşi şeklindedir.
Not: Linux’da yönetici (Windows’ta administrator) kullanıcı adı olan root ile kök
dizini olan root birbirinden farklıdır.
Şekil 2- Unix Dizin Hiyerarşisi
Şekil -2‘de kök dizini altında bulunan klasörler gösterilmiştir. / ( Root) başlangıç
dizininin sonrasında bu klasörler yer alır. Windows’ta bir program kurulduğunda
genellikle programa ait dosyalar tek bir dosya içerisinde bulunur. Örneğin Adobe
programı C:\Program Files\Adobe dizininde yar alır. Linux’da ise bu durum
farklıdır. Örneğin programın info dosyaları /usr/share/info dizininde yer alırken
programa ait yardım bilgisi ve dökümantasyon dosyaları
/usr/share/doc/program_ismi dizinine yerleştirilir. Ubuntu’da bu şekilde
gelenekselleşmiş bir dosya organizasyonu bulunmaktadır. Bunun amacı çok
kullanıcılı ve dağıtık bir sistemi güvenli ve kolay bir şekilde kurup yönetebilmektir.
cat, mkdir, cp, ls, mv, rm gibi birçok komut /bin içerisindedir.
Sisteme ilk login yapıldığında /home dizininden başlanır. Bu klasörün içerisinde
her kullanıcının kendi adında bir alt klasörü bulunur. /home klasörünü,
Windows’taki Belgelerim klasörüne benzetebiliriz. Ama ondan daha güvenli bir
yapıdır. Çünkü Linux’ta bir başkasının ev klasörüne müdahale edemezken,
Windows’ta çok zorlanmadan istediğinizi yapabilirsiniz. Home dizinine ~ ismiyle
geçilebilir. Farklı bir kullanıcının \home dizini altındaki alanına geçmek için ~ ile
birlikte kullanıcı adı yazılır.
Not: Diğer dizinlerin özelliklerini kaynaklar bölümünden yararlanarak inceleyiniz.
4
Gerçek/Göreceli Dizin:
Bir dosyanın gerçek dizin root kök dizininden başlayarak dosyaya giden yoldur.
Örnek gerçek dizinler:
/etc/passwd
/home/student/NetBeansProjects
/dev/rdsk/Os3
Bir dosyanın yolu göreceli de olabilir. / ile başlamaz. O an içinde bulunan dizinden
gidilen yoldur.
Belgelerim/ilk_donem
sislab/notlar/deney1
Dosya sistemi hiyerarşisinde nerede olduğunuzu görüntülemek için pwd komutu
kullanılır.
$pwd
/home/student/hadoop/logs
$
3. TEMEL KOMUTLAR
Şekil -3 ‘de bir UNIX sisteminin temel blok diyagramı gösterilmiştir. UNIX
sistemlerin temel bileşenleri şunlardır:
Şekil 3- Unix Blok Diyagramı
5
Kernel: Kernel işletim sisteminin kalbidir. Donanımla ve hafıza yönetimi, task
scheduling, dosya yönetimi gibi bir çok işle etkileşim kurar.
Shell: Terminalde bir komut yazıldığında Shell komutu yorumlar ve istenen
programı çağırır. Shell, bütün komutlar için standart bir sytax kullanır. C Shell,
Bourne Shell ve Korn Shell bir çok Unix türevlerinde var olan, bilinen “Shell”lerdir.
Komutlar ve Hizmetler: cp, mv, cat ve grep gibi birçok komut ve hizmet
bulunmaktadır. 250’nin üzerinde standart komut ve bunun yanında üçüncü
partilerce sağlanan sayısız yazılım mevcuttur. Komutlar genellikle çok sayıda
opsiyona sahiptir.
Dosyalar ve Dizinler: UNIX üzerindeki bütün veri dosya şeklinde organize edilir.
Bütün dosyalar da dizinlerle organize edilir. Daha önce de belirtildiği üzere bu
dizinler dosya sistemi denilen ağaç-benzeri(tree-like) bir yapı oluşturur.
Sistemin Başlatılması
Bir UNIX işletim sistemi yüklü bilgisayarın güç düğmesine basıldığında sistem
başlatılır ve kullanıcı giriş ekranı açılır.
login:
Kullanıcı adı girilir ENTER’a basılır ve şifre girilir ENTER’a basılır. Kullanıcı adı ve
şifre case-sensitive’dir.
login : student
student's password:
Last login: Sun Jun 14 09:32:32 2014 from 62.61.164.73
$
Giriş yapılınca $ işaretiyle başlayan bir komut giriş moduna geçilir. Örneğin
ajandayı göstermeye yarayan cal komutu yazarsak aşağıdaki ekran çıkar:
$ cal
student@student-UnixLab:~$ cal
Ekim 2014
Pa Pz Sa Çr Pr Cu Ct
1 2 3 4
5 6 7 8 9 10 11
12 13 14 15 16 17 18
19 20 21 22 23 24 25
26 27 28 29 30 31
Şifre değiştirme:
Komut satırına passwd yazılır.
Mecvut şifre girilir ve enter’a basılır.
Yeni şifre girilir
Yeni şifre tekrar girilir.
$ passwd
Changing password for student
(current) Unix password:******
New UNIX password:*******
6
Retype new UNIX password:*******
passwd: all authentication tokens updated successfully
Dizinlerin ve dosyaların listelenmesi :
Bir dizindeki tüm dosya ve klasörleri ls komutuyla listeleyebiliriz. Aşağıda
ls komutu -l opsiyonuyla kullanılmıştır.
$ ls -l
total 19621
drwxrwxr-x 2 amrood amrood 4096 Dec 25 09:59 uml
-rw-rw-r-- 1 amrood amrood 5341 Dec 25 08:38 uml.jpg
drwxr-xr-x 2 amrood amrood 4096 Feb 15 2006 univ
drwxr-xr-x 2 root root 4096 Dec 9 2007 urlspedia
-rw-r--r-- 1 root root 276480 Dec 9 2007 urlspedia.tar
drwxr-xr-x 8 root root 4096 Nov 25 2007 usr
-rwxr-xr-x 1 root root 3192 Nov 25 2007 webthumb.php
-rw-rw-r-- 1 amrood amrood 20480 Nov 25 2007 webthumb.tar
-rw-rw-r-- 1 amrood amrood 5654 Aug 9 2007 yourfile.mid
-rw-rw-r-- 1 amrood amrood 166255 Aug 9 2007 yourfile.swf
$
Burada d..... ile başlayan kayıtlar dizin olduğunu gösterir. Burada uml, univ,
urlspedia ve usr dizin, diğerleri dosyadır.
Hangi kullanıcı?
Kim olduğunuz sorusu yani whoami komutu  ile kullanıcı adı gösterilir.
$ whoami
student
$
Hangi kullanıcılar bağlanmış?
Sisteme aynı anda hangi kullanıcıların bağlanmış olduğu görüntülenebilir. Bu
bilgiyi göstermek için users, who ve w gibi komutlar kullanılabilir.
$ users
student admin
$ who
student ttyp0 Oct 8 14:10 (limbo)
admin ttyp2 Oct 4 09:08 (calliope)
$
w komutunu kullanarak sonucu inceleyiniz. Bu komut kullanılarak bağlanmış
kullanıcılar hakkında daha detaylı bilgi gösterilir.
Çıkış yapmak:
Oturumunuz bittiğinde sistemden çıkış yapılarak başkalarının dosylarımıza
erişmesini engellememiz gerekir. Bunun için logout komutu   kullanılır.   Sistem   herşeyi
temizler ve bağlantıyı keser.
Kapatma (Shutdown) komutları: halt, init 0, poweroff, , shutdown
Yeniden başlatma komutları : init 6, reboot
7
Bu komutları kullanabilmek için superuser ya da root olmak gerekir.
Dosyaların listelenmesi:
Bir dizindeki tüm dosya ve klasörleri ls komutuyla listeleyebiliriz. Aşağıda
ls komutu -l opsiyonuyla kullanılmıştır.
$ls
Aşağıda örnek bir sonuç görüntülenmiştir
$ls
bin hosts lib res.03
ch07 hw1 pub test_results
ch07.bak hw2 res.01 users
docs hw3 res.02 work
Aşağıda ls komutu -l opsiyonuyla daha fazla bilgi verir.
$ls -l
total 148
drwxr-xr-x 2 student student 4096 Eki 13 10:06 Desktop
drwxr-xr-x 2 student student 4096 Eyl 17 19:47 Documents
drwxr-xr-x 2 student student 4096 Eki 13 10:06 Downloads
drwxrwxr-x 2 student student 4096 Eki 11 16:33 examples
-rw-r--r-- 1 student student 8980 Eyl 17 19:35 examples.desktop
-rw-rw-r-- 1 student student 77654 Eki 12 16:05 foy2.odt
drwxrwxr-x 12 student student 4096 Eyl 18 17:21 hadoop
-rw-rw-r-- 1 student student 457 Eki 12 16:32 HelloWorld.class
-rw-rw-r-- 1 student student 174 Eki 12 16:32 HelloWorld.java
drwxrwxr-x 8 student student 4096 Eyl 18 11:06 jdk1.8.0_20
drwxr-xr-x 2 student student 4096 Eyl 17 19:47 Music
drwxrwxr-x 14 student student 4096 Eki 12 16:29 netbeans-8.0.1
...
$
Burada d ile başlayan kayıtlar dizin olduğunu gösterir. Örneğin burada Desktop,
Documents, Downloads … dizindir. foy, HelloWorld ise dosyadır.
İlk kolon dosya (veya dizinin) türünü ve izinlerini gösterir. İkinci kolon kaç
memory-block olduğunu gösterir. Üçüncü kolon dosyanın sahibini yani bu dosyayı
oluşturan Unix kullanıcısını gösterir ve dördüncü kolon bu kullanıcının ait olduğu
kullanıcı grubunu gösterir. Bütün Unix kullanıcılarının bağlı olduğu bir grup vardır.
Beşinci kolon byte olarak dosya büyüklüğünü gösterir. Altıncı kolon dosyanın
oluşturulduğu tarih ve saati gösterir. Yedinci kolon dosya adını gösterir.
Meta karakter:
Unix 'te * ve ? Karakterlerinin özel anlamları vardır. Bu karakterlere meta-karakter
denir. Sıfır yada daha fazla karakter için * meta karakteri kullanılır. Tek bir
karakter eşleşmesi için ? kullanılır. Örneğin:
$ls ch*.doc
Komutu ile adı ch ile başlayan ve .doc ile biten bütün dosyalar listelenir.
8
ch01-1.doc ch010.doc ch02.doc ch03-2.doc
ch04-1.doc ch040.doc ch05.doc ch06-2.doc
ch01-2.doc ch02-1.doc c
Gizli dosyalar:
İsminin ilk karakteri . (nokta) olan dosyalar gizli dosyalardır. Unix programları gizli
dosyaları genellikle konfigürasyon dosyası olarak kullanır.
Gizli dosyaları görüntüleyebilmek için ls listeleme komutu -a opsiyonuyla
kullanılır.
$ ls -a
. .profile docs lib test_results
.. .rhosts hosts pub users
.emacs bin hw1 res.01 work
.exrc ch07 hw2 res.02
.kshrc ch07.bak hw3 res.03
$
 tek nokta . : İçerisinde bulunulan dizin demektir.
 çift nokta .. : İçerisinde bulunulan dizinin bir üst dizinini gösterir. (parent)
Dosya oluşturma:
Dosya oluşturmak için birden fazla komut bulunmaktadır. Bunlardan bazıları cat,
touch, nano, vi. nano ve vi aslında metin editörüdür. Örneğin vi edötürü şu
şekilde dosya oluşturur:
$ vi dosyaadi
Bu komutların kullanımı labaratuvarda uygulama ile gösterilecektir.
Bir dosyadaki kelime sayısını bulma:
Bir dosyada kaç tane kelime, satır ya da karakter olduğunu wc komutu
gösterebilir. Aşağıda basit olarak kullanımı gösterilmiştir:
$ wc dosya_adi
2 19 103 dosya_adi
$
İlk kolon (2) : toplam satır sayısını, ikinci kolon (19) toplam kelime sayısını,
üçüncü kolon (103) byte olarak büyüklüğü, dördüncü kolon dosyanın adını
gösterir. Aşağıdaki syntax ile birden fazla dosya için bu bilgiler görüntülenebilir.
$ wc dosya_adi1 dosya_adi2 dosya_adi3
Dosya kopyalama:
Bir dosyayı kopyalamak için cp komutu kullanılır. Syntax'ı aşağıdaki gibidir.
$ cp kaynak_dosya hedef_dosya
9
Dosya yeniden adlandırma:
Dosya ismi mv ile değiştiriliir.
$ mv eski_dosya yeni_dosya
Dosya silme:
Bir dosya rm komutu ile sililebilir. Syntax'ı şöyledir:
$ rm dosya_adi
Dizinin listelenmesi:
$ls dizin_yolu
Örnek:
$ls /usr/local
X11 bin gimp jikes sbin
ace doc include lib share
atalk etc info man ami
Dizin oluşturma:
$mkdir dizin_yolu
$
Dizin silme:
$rmdir dizin_yolu
$
Dizin değiştirme:
Bir dizinden başka bir dizine geçmek için:
$cd dizin_yolu
$
Dizini yeniden isimlendirme:
$mv eski_dizin yeni_dizin
$
. (nokta) ve .. (nokta nokta) dizinleri
. içerisinde bulunulan dizini, .. bu dizinin bir parent yolunu gösterir.
Unix – Dosya izinleri / Erişim modları
10
UNIX'de bir dosyanın sahibinin kim olduğu önemli bir konudur.
İzin belirteçleri:
Bir dosyanın izinleri ls -l komutu ile gösterilebilir.
$ls -l /home/student
-rwxr-xr-- 1 student student 1024 Nov 2 00:10 myfile
drwxr-xr--- 1 student student 1024 Nov 2 00:10 mydir
Burada ilk kolon izinleri gösterir. read (r), write (w), execute (x):
İlk üç karakter (2-4) dosyayı oluşturan kişinin (sahibinin) izinlerini gösterir. Myfile
dosyası için gösterilen -rwxr-xr-- dosya sahibinin read (r), write (w), execute (x)
izinlerinin olduğunu gösteriyor.
(5-7) sırasındaki karakterler dosyayı oluşturan kullanıcının ait olduğu grubun
izinlerini gösterir. rwxr-xr-- grubun read (r) ve execute (x) izinlerinin olduğunu
fakat write (w) izninin olmadığını gösteriyor.
Karakterlerin son üçü (8-10) diğer tüm kullanıcılar için izinleri gösterir. rwxr-xr--
kullanıcı grubunda olmayan diğer kullanıcıların sadece read (r) izninin olduğunu
gösteriyor.
Dosya izin modları:
1. Read: Okuma. Dosyanın içeriğine bakma.
2. Write: Dosyayı değiştirme ve içeriğini silme.
3. Execute: Dosyayı çalıştırma, bir program olarak yürütme.
Dizin izin modları:
Dosya için geçerli olan izin modları geçerli olmak üzere bir kaç farklılığın bilinmesi
gerekir:
1. Read:
Dizindeki dosyaların isimlerini ve içeriğini görebilmektir.
2. Write:
Kullanıcının dizine dosya ekleyebilmesi ya da silebilmesi ve dosyalarda değişiklik
yapabilmesidir.
3. Execute:
Bu izinin dizin açısından pek bir anlamı yoktur.
Bir kullanıcının cd, ls gibi komutları çalıştırabilmesi için bin dizinine erişimi
olmalıdır.
İzinlerin değiştirilmesi:
11
Bir dosya ya da dizinin izinlerinin değiştirilmesi için chmod (change mode)
komutu kullanılır. Bu komut symbolic mode ve absolute mode olarak iki farklı
şekilde kullanılabilir.
chmod – Sembolik Mod:
Aşağıdaki tabloda belirtilen operatörler yoluyla değişiklik yapılır.
Chmod operator Açıklama
+ Dosya ya da dizine belirtilen izni ekler
­ Dosya ya da dizinden belirtilen izni çıkarır
= Belirtilen izinleri atar
$ls -l testfile
-rwxrwxr-- 1 amrood users 1024 Nov 2 00:10 testfile
$chmod o+wx testfile
$ls -l testfile
-rwxrwxrwx 1 amrood users 1024 Nov 2 00:10 testfile
$chmod u-x testfile
$ls -l testfile
-rw-rwxrwx 1 amrood users 1024 Nov 2 00:10 testfile
$chmod g=rx testfile
$ls -l testfile
-rw-r-xrwx 1 amrood users 1024 Nov 2 00:10 testfile
$chmod o+wx,u-x,g=rx testfile
$ls -l testfile
-rw-r-xrwx 1 amrood users 1024 Nov 2 00:10 testfile
4. SHELL PROGRAMLAMA
Shell(terminal) interaktiftir program yürütme birimidir. Yani terminale klavyeden
komutlar girilir ve bu komutlar sırayla çalıştırılır. Bunun yerine çalıştırılacak
komutlar bir dosyaya kaydedilip sırasıyla çalıştırılabilir. Komutların bu şekilde
yürütüldüğü programlara “Shell script” denir. Bu programlamanın en önemli
avantajları şunlardır:
 Shell script kullanıcıdan, dosyadan giriş alabilir ve ekranda görüntüleyebilir.
 Kendi komutlarımızı üretmemize imkan tanır.
 Zaman kazandırır.
 Günlük rutin işlerin otomatikleştirilmesini sağlar.
12
 Sistem yönetimi işlerinin otomatikleştirilmesini sağlar.
Linux yüklü makineler terminal ekranı ile Shell’e erişim verir. Eğer işletim sistemi
“metin modu” (text mode) da ise sistem başladığında Shell otomatik olarak açılır.
Eğer Desktop versiyon bir Linux yüklüyse Shell bir GUI tarafından açılır. Genellikle
“Uygulamalar->Araçlar->Terminal” şeklinde açılır. Eğer uzak bir makineye
(örneğin bir sunucuya) bağlanıp üzerinde Shell komutları çalıştırmak için Secure
Shell yani SSH kullanılır. Buraya aynı zamanda komut satırı da denilir.
Şekil 4- Kernel ve Shell
Şekil-4’de görüldüğü üzere Kernel Shell ve diğer uygulamar ile donanım arasında
köprü görevi görmektedir. Bir Linux makinesinin kaynakları Kernel tarafından
yönetilir. I/O yönetimi, Dosya Yönetimi, Process Yönetimi ve Memory Yönetiminden
Kernel sorumludur. Kullanıcı Shell ile bir kaynak üzerinde gerçekleştirilmek üzere
bir istekte bulunduğu zaman, bu kaynağı kullanma iznine, ne kadar
kullanabileceğine Kernel karar verir.
Sistemde yüklü Shell programlarının adlarının ekrana yazdırılması:
student@student-UnixLab:~/examples$
$ cat /etc/shells
# /etc/shells: valid login shells
/bin/sh
/bin/dash
/bin/bash
/bin/rbash
Aktif olan shell’in gösterilmesi :
Eğer yukarıdaki gibi birden fazla Shell programı listelendiyse bu sisteminizin
birden fazla Shell’i desteklediğini gösterir. Sistemdeki geçerli Shell programının
hangisi olduğunu aşağıdaki şekilde öğrenebilirsiniz.
$ echo $SHELL
/bin/bash
13
Bir Shell programı, sırayla çalıştırılmak üzere yazılmış komut satırlarından oluşur.
İyi bir Shell programı açıklama satırlarına sahip olmalıdır. Bu şekilde adımları daha
net anlaşılabilir. Açıklama satırı başına # simgesi getirilir.
Shell script’de şartlı yapılar (A, B’den büyük ise gibi), döngüler, değişkenler,
fonksiyonlar mevcuttur.
Shell script derlenmez, yorumlanır. compile yerine interpret aşaması vardır.
Shell script programları sh uzantılı dosyalara yazılır, çalıştırma izni verilir ve
çalıştırılır.
Örnek Script:
Bir test.sh isimli script oluşturalım. Bir script dosyasında herşeyden önce ( #! )
yazılır. Bu şekilde sisteme script’in başladığı haber verilir. Oluşturduğunuz test.sh
dosyasına aşağıdaki satırları yazıp kaydedin.
Not: #!/bin/bash ile sisteme gelecek komutların Bash Shell tarafından
çalıştırılacağını söylenir. (Eğer Python olsaydı #!/usr/bin/python yazılırdı vb…).
#!/bin/bash
# Author : student
# Unix LAB
# Fırat -CENG
pwd
ls
Bu dosya aşağıdaki şekilde çalıştırılabilir hale getirilir.
$chmod +x test.sh
Çalıştırılmaya hazır olan test.sh dosyası aşağıdaki şekilde çalıştırılır.
$./test.sh
Note: Bir dizinde bulunan programlar ./program_adi şeklinde çalıştırılır.
Bir Shell programı tabi ki bu kadar basit olmayıp değil değişkenlerin, kontrol
yapılarının vb. kullanıldığı daha karmaşık işler için kullanılır. Shell gerçek bir
programlama dilidir. Fakat komutlar ne kadar karmaşıklaşırsa da bütün satırların
ardışıl olarak çalıştırıldığı bir yapı söz konusudur.
Aşağıdaki script read konutunu kullanarak kılaveden değer girişi alır ve bu değeri
PERSON değişkenine atar. Son olarak da PERSON değişkeninin değeri ekrana
yazılır.
#!/bin/sh
echo "What is your name?"
read PERSON
echo "Hello, $PERSON"
Programın örnek bir çıktısı şöyledir:
14
$./test.sh
What is your name?
student
Hello, student
$
Shell – Değişkenlerin kullanılması
Değişkenlere karakter, sayı, metin, dosya adı vb. her türlü değer atanabilir.
Shell’de değişken oluşturma, değer atama ve silme işlemleri yapılabilir.
Değişken isimleri sadece harf (a’dan z’ye ya da A’dan Z’ye), rakam (0’dan 9’a) ya
da altçizgi ( _ ) karakteri içerebilir. Unix Shell değişkenleri bir gelenek olarak
büyük HARFLERDEN oluşur.
Aşağıdaki örnek değişken isimleri verilmiştir:
_ALI
TOKEN_A
VAR_1
VAR_2
Aşağıdaki hatalı değişken isimleri verilmiştir:
2_VAR
-VARIABLE
VAR1-VAR2
VAR_A!
!,*, ya da – gibi karakterlerin kullanılamamasının nedeni bu karakterlerin Shell için
özel anlamlara sahip olmasıdır.
Değişkenler aşağıdaki gibi tanımlanır:
değişken_adı = değişken_değeri
Örnek:
NAME="Bilgisayar Mühendisliği"
Yukarıdaki örnekte NAME değişkeni tanımlanmış ve bu değişkene “Bilgisayar
Mühendisliği” değeri atanmıştır. Bu şekildeki değişkenlere skalar değişken denir.
Yani hem string hem de sayı tutabilir:
VAR1="Bulut"
VAR2=100
Değişkenlere erişim:
Değişken kullanılacağı zaman önüne dolar işareti olan $ getirilerek değerine
ulaşılır. Aşağıdaki örnekte NAME değişkenine atanan “Bulut Bilişim” değeri echo
komutu ile ekrana yazdırılır.
#!/bin/sh
NAME="Bulut Bilişim"
15
echo $NAME
Read-only Değişken:
Read-only yani sadece okunabilen değişkenlerin değerleri değiştirilemez. Örneğin
aşağıdaki kod dosyası çalıştırıldığında hatayla karşılaşılır.
#!/bin/sh
NAME="student"
readonly NAME
NAME="Ali"
/bin/sh: NAME: This variable is read only.
Unsetting Variables:
Shell’in değişken listesinden bir değişkeni kaldırmak yani silinmesini sağlamak
için aşağıdaki syntax kullanılır.
unset değişken_adı
Global ve Local Değişken:
Aşağıdaki örnek incelenip çalıştırıldığında VAR değişkenine dikkat edilirse Global
ve Local değişken farkı gözlenebilir.
#!/bin/bash
#Bu değişken globaldir ve script’in her yerinde kullanılabilir
VAR="global değişken"
function bash {
#Bu değişken localdir ve sadece bu fonksiyon içerisinde değerini korur
local VAR="local değişken"
echo $VAR
}
echo $VAR
bash
# Global değişkenin değiştirilmediğine dikkat ediniz
# "local" Shell’de özel bir tanım kelimesidir.
echo $VAR
Programın çalıştırılması :
$ ./degiskenler.sh
global değişken
local değişken
global değişken
Shell programına parametre göndermek:
Shell programına nasıl parametre gönderildiğinin anlaşılabilmesi içim öncelikle
aşağıdaki özel Shell değişkenleri incelenmelidir.
Değişken Açıklama
16
$0 Yürütülen script’in adı.
$n $1 , $2 gibi $n tane parametrenin sırasıyla değerini gösterir.
$# Bir script’in kaç tane parametre ile çağrıldığının değerini verir.
Bu değerlerin kullanımını aşağıdaki programla gözleyebiliriz.
#!/bin/sh
echo "Dosya adi: $0"
echo "1. Parametre : $1"
echo "2. Parametre : $2"
echo "3. Parametre : $3"
echo "Toplam parametre sayısı : $#"
Programın çalıştırılması:
./dene.sh bir iki
Dosya adi: ./dene.sh
1. Parametre : bir
2. Parametre : iki
3. Parametre :
Toplam parametre sayısı : 2
Yukarıdaki örnek bir Shell programına nasıl parametre gönderildiğini ve bu
parametrelere program içerisinde nasıl erişildiğini göstermektedir. Buna ek olarak
aşağıdaki program kodundaki parametre erişim yöntemlerini inceleyiniz.
#!/bin/bash
# Gelen parametreler bir dizide tutulabilir
args=("$@")
echo ${args[0]} ${args[1]} ${args[2]}
#$@ kullanılarak bütün parametreler tek seferde yazdırılabilir
echo $@
Programın çalıştırılması:
$ ./passarg.sh Param_Bir Param_İki Param_Üç
Param_Bir Param_İki Param_Üç
Param_Bir Param_İki Param_Üç
Shell programı içerisinde komut kullanmak:
#!/bin/bash
# kesme sembolü " ` ` " içerisinde komut yazılarak Shell'de çağrılır:
echo `date`
# kesme olmadan kod:
echo date
Programın çalıştırılması:
$ ./shell_komut.sh
Sun Oct 19 18:42:36 UTC 2014
date
17
Şartlı İfadeler
Shell programlamada şartlı ifadeler aşağıdaki gibidir:
# Temel if yapısı # if­else yapısı # if­else if yapısı
if şart ; then
komutlar
fi
if şart ; then
komutlar
else
komutlar
fi
if şart ; then
komutlar
elif şart ; then
komutlar
fi
#!/bin/bash
sayı=1
if [ $sayı = "1" ]; then
echo "sayı eşittir bir"
fi
#!/bin/bash
sayı=1
if [ $sayı = "1" ]; then
echo "sayı eşittir bir"
else
echo "sayı birden farklı"
fi
Aritmetik karşılaştırmalar:
Shell programlamada küçüktür, büyüktür, eşittir gibi ifadelere aşağıdaki tablodaki
operatörlerle karılaştırılabilir. Aşağıdaki programı diğer operatörleri de kullanarak
deneyiniz.
#!/bin/bash
# NUM1 ve NUM2 sayılarının karşılaştırılması
NUM1=2
NUM2=1
if [ $NUM1 -eq $NUM2 ]; then
echo "Sayılar birbirine eşittir"
elif [ $NUM1 -gt $NUM2 ]; then
echo "NUM1 NUM2’den büyüktür"
else
echo "NUM2 NUM1’den büyüktür"
fi
String karşılaştırma:
Stringlerin karşılaştırılmasında aşağıdaki tabloda verilen operatörler kullanılır.
#!/bin/bash
#String tanımla S1
S1="Bash"
18
-lt <
-gt >
-le <=
-ge >=
-eq ==
-ne !=
= eşittir
!= eşit değildir
< küçüktür
> büyüktür
-n s1 s1 string’i boş
değildir
-z s1 s1 string’i
boştur
#String tanımla S2
S2="Scripting"
if [ $S1 = $S2 ]; then
echo "Stringler aynı"
else
echo "Stringler birbirinden farklıdır"
fi
Not: Birden fazla karşılaştırmayı aynı satırda yapmak için || (or) ya da && (and)
operatörü kullanılır. Örneğin aşağıdaki satırda YAŞ değişkeninin 20’den küçük
veya 50’den büyük olduğu şart oluşturulmuştur.
if [ "$YAŞ" -lt 20 ] || [ "$YAŞ" -ge 50 ]; then
Dosyalar için karşılaştırma operatörleri:
Dosyalar üzerinde şartlı ifadelerle kullanılabilecek bazı önemli operatörler ve
anlamları aşağıdaki tabloda verilmiştir.
#!/bin/bash
#test.sh dosyasının var olup olmadığını test
eden Shell programı
file="./test.sh"
if [ -s $file ]; then
echo "Dosya mevcut"
else
echo "Böyle bir dosya yok"
fi
Döngüler:
Shell programlamada for, while, select ve until döngüleri bulunmaktadır. Burada
for ve while döngülerinin kullanımı gösterilecektir. Diğer döngüler bu deneye dahil
değildir.
#!/bin/bash
#1’den 10’a kadar olan sayıları while döngüsü kullanarak ekrana yaz
sayi=0
while [ $sayi -lt 10 ]
do
sayi=$((sayi+1))
echo $sayi
done
#!/bin/bash
#1’den 10’a kadar olan sayıları for döngüsü kullanarak ekrana yaz
#for i in 0 1 2 3 4 5 6 7 8 9
#yukarıdaki şekilde veya aşağıdaki gibi olabilir
for i in {1..10}
do
echo $i
done
19
-s dosya mevcut
ve boş değil
-f dosya mevcut
ve dizin değil
-d dizin mevcut
-x dosya
çalıştırılabilir
-w dosya yazılabilir
-r dosya
okunabilir
#bulunduğu dizindeki dosyaların isimlerini ekrana yazan program
#!/bin/bash
for i in $( ls ); do
echo item: $i
done
Shell programlamada metod kullanımı
#!/bin/sh
# Kendisine gelen 2 parametreyi Merhaba ile ekrana yazan ve 100 değerini döndüren
# Merhaba metodu tanımlanıyor.
Merhaba () {
echo "Merhaba $1 $2"
return 100
}
# Metodun çağrılması
Merhaba Unix LAB
# Metodun dönderdiği değeri ekrana yazdır
echo $?
Program çıktısı:
$ ./fonksiyon.sh
Merhaba Unix LAB
100
Not: Shell fonksiyonları aslında return ile değer döndürmez. Fakat “ $? “ ile
yürütülen son komutun değeri yakalanabilir. Bu da ancak sayısal bir değer
dönendirildiğinde mümkündür.
DENEY SORULARI
1. Ekrana “merhaba dünya” yazan Shell programını yazınız
2. Bir kullanıcının bütün dosyalarını yedekleyen bir komut yazınız. İpucu: tüm
dosyalar bir tar dosyası olarak saklanabilir)
3. Dışarıdan bir dizini parametre olarak alıp bu dizinin var olup olmadığını
ekrana yazdıran Shell programınını yazınız.
4. Ekrana tarih, saat, kullanıcı adı ve içerisinde bulunan dizini yazan Shell
programını yazınız.
.
5. Kullanıcıdan şifre girişi yapmasını isteyip, şifre “unixstudent” ise ekrana
“şifre doğru” değilse “şifre hatalı” yazan Shell programını yazınız.
6. Kullanıcıdan dosya ismi (diziniyle birlikte) girmesini isteyip dosya mevcutsa
dosya içeriğini ekrana yazan, mevcut değilse dosyayı oluşturup içerisine
“merhaba dünya” yazan Shell programını yazınız.
7. "bulut" kullanıcı isimli ve "193.255.124.68" ip adresine sahip bir linux
bilgisayara bağlanmak için gerekli komutu yazınız (SSH bağlantısı
sağlamak için openssh-server kurulumu gerçekleştiriniz).
20
8. Yazılım ve donanım kaynaklarının hizmet olarak sunulabilmesini sağlayan
açık kaynak bulut bilişim yazılımları nelerdir?
9. Ornek.c
#include <stdio.h>
int main(void)
{
printf("merhaba");
return 0;
}
Ornek.c dosyasındaki kodu derleyen Linux komutunu yazınız.
10. “cat /etc/resolv.conf” ve “ping firat.edu.tr” komutlarını açıklayınız.
KAYNAKLAR
1. http://en.wikipedia.org/wiki/Unix
2. http://wiki.ubuntu-tr.net/
3. http://www.tutorialspoint.com/unix/index.htm
4. http://www-h.eng.cam.ac.uk/help/tpl/unix/scripts/node2.html
5. aws.amazon.com/ec2/
21
Fırat Üniversitesi BMÜ-431
Bilgisayar Mühendisliği Bilgisayar Sistemleri Laboratuvarı
Deney No: 2
Ağ Güvenliği ve Etik Saldırı
1
Deneyin Amacı: Etik saldırının ve ağ güvenliğinin yapısının ve adımlarının anlaşılması ve
bu saldırıda kullanılan yöntemlerin ve araçların incelenmesi ve kullanımıdır. Ayrıca ağ
güvenliğinin yapısının incelenmesi ve kullanıcı protokollerinin tanımlanabilmesidir.
Deney Hazırlık
• Penetrasyon testi nedir ve bu test hangi adımlardan oluşur inceleyin.
• Penetrasyon testinde her adımda kullanılabilecek araçları araştırın.
• Penetrasyon test araçlarından kendi belirlediğiniz iki taneyi ayrıntılı araştırın ve deney
esnasında uygulayacak şekilde hazırlıklı yapın.
• TCP ve UDP protokolü hakkında bilgi edinin.
• TCP 3-way handshake nedir araştırın.
• WinPcap ve jNetPcap (veya tercih ettiğiniz bir platform ve başka bir dildeki ) paket
programları indirin ve inceleyin.
1. Penetrasyon Testi Nedir?
Penetrasyon Testi; pen test, etik hack, beyaz şapkalı hack olarak da adlandırılabilir. Bu
test; bilgisayar ağının ya da sisteminin içeriden ya da dışarıdan gelebilecek saldırılara karşı ne
kadar güvende olduğu konusunda fikir edinilmesini sağlar. Bu test sistemin güvenli olmasını
sağlamak amacıyla, yasal ve izinli olarak açıklarının aranmasıdır. Bu sayede sistemin zayıf
noktalarının tespiti ve saldırı düzenlenerek sistemin gerçek bir hacker’ın saldırısına karşı
savunmasız olup olmadığı belirlenir. Sonuç olarak sistemin ve verilerin ne kadar güvende
olduğu sorusu spesifik bir sorudur ve cevabı görecelidir. Penetrasyon testi bu sorulara objektif
cevaplar bulmaya yardımcı olur.
Penetrasyon testi; dos, application (uygulama), internet, intranet, process gibi farklı
bölümler içerebilir. Bu test bu bölümlerin birini veya bir kaçını kaplayacak şekilde yapılabilir.
• Dos testinde şirketin herhangi bir saldırıda hizmetlerinin çöküp çökmeyeceği ve bu
saldırıya karşı dayanıklılığı test edilir.
Fırat Üniversitesi BMÜ-431
Bilgisayar Mühendisliği Bilgisayar Sistemleri Laboratuvarı
Deney No: 2
Ağ Güvenliği ve Etik Saldırı
2
• Application (uygulama), kısmında kullanılan uygulamalar ve kodlarında açık taraması
yapılır. Kullanılan uygulamaların güncelliğinin korunması, iç ağın durumunun test
edilmesinde bu testler kapsamındadır.
• Dış ağın penetrasyon testinde(intranet) yapılanmanın dış dünyadan gelebilecek
herhangi bir tehdide karşı durumu tespit edilir. Örnek olarak web siteye gelebilecek
herhangi bir saldırı bu kapsamdadır.
Şirketler pentest ile her türlü saldırıya karşı kendilerini hazırlayabilir ve saldırıya gerekli
tedbiri alabilirler. Böylelikle bir saldırı durumunda ya hiç etkilenmezler ya da en az zararla
saldırıyı atlatabilirler. Dışarıdan saldırgan bakış açısıyla güvenlik açıklarının kontrolü ve
raporlanması güvenlik açısından önemlidir. Şirketlerin kendi içlerindeki güvenlik tedbirleri
çoğunlukla yeterli olmamakta ve önlemler güncelliğini koruyamamaktadır. Ayrıca kötü niyetli
hackerların sayısının artması ve bilgi düzeylerinin genellikle birçok şirket çalışanından önde
olması pentestin önemini ortaya koymaktadır. Pentest bir şirketin bilişim sistemleri için iç ve
dış tehditlere karşı güncel önlemler alınmasını ve zafiyetlerin giderilmesini sağlar. Bununla
birlikte bu testlerin faydaları aşağıdaki gibi sıralanabilir.
• Saldırılara karşı daha dirençli bir bilişim altyapısı
• Kullanıcı bazlı olarak bilgi güvenliği farkındalığının artması
• Sistemlerin durdurulma veya kaynak doldurmaların engellenmesi
• Yasal olarak uyum sağlama
• Kurum prestijinin ve marka değerinin korunması sağlanır.
• BT kaynaklı risklerinin azalması
Pen testinde Hack sanatında üç terimin sıklıkla kullanılır. Bunlar Beyaz şapkalı (White
hats), siyah şapkalı (black hats) ve gri şapkalı (gray hats). Beyaz şapkalılar art niyetli olmayan
ve sistemlerin savunmalarını güçlendirmek amacıyla pen test yapan hacker’lardır. Siyah
şapkalılar aynı zamanda crackers olarak da adlandırılırlar ve art niyetli amaçlar için hack’i
kullanırlar. (Kredi kartı bilgilerinizi çalarak satmak ya da firma sırlarını çalmak gibi…) Bu
amaçla beyaz şapkalıların siyah şapkalıların kullandıkları araç ve yöntemleri bilmeleri
önemlidir böylece siyah şapkalıların bir adım önünde kalarak art niyetli eylemlerini
engelleyebilirler. Gri şapkalılara ise beyaz ve siyah şapkalıların kombinasyonudur ve genellikle
yapabildikleri için ya da meydan okumayı sevdikleri için hack’lerler.
Fırat Üniversitesi BMÜ-431
Bilgisayar Mühendisliği Bilgisayar Sistemleri Laboratuvarı
Deney No: 2
Ağ Güvenliği ve Etik Saldırı
3
1.1. Penetrasyon Testinin Adımları
• Bilgi toplama: Sistem hakkında ön bilgi edinmek. internet, rakip bilgileri, WHOIS,
DNS, ağ, web sitesi, e-posta, Google yoluyla olabilir. Whois, bize aradığımız hedefin
alan adı bilgilerini ve dns sunucularını verir. Alan adları ve yapıları bize hedef hakkında
önemli bilgiler verir.
• -Tarama: Sistemi tarayarak bilgi edinmek. (Sistemdeki bilgisayarlar ve network
cihazlarını tespit etmek, sistemdeki cihazlarda bulunan açık portların tespiti, sistemdeki
açıklarının taranması vs.)
• -Erişim Sağlama: Sistemde bulunan açıklar kullanılarak sisteme izinsiz erişim
sağlanması. (yetki yükseltme, sistem durdurma, kaynakların doldurulması, yetkisiz
erişim sağlama)
• -Erişim Koruma: Elde edilen erişimin korunması. (sistem üzerinde elde edilen erişim
haklarını kalıcı kılma, sistem üzerinde yetkili bir kullanıcı oluşturma, arka kapı açma).
• -İzleri yok etme: Hedef sistem üzerinde ilk dört adımda yapılan işlemlerin bıraktığı
izler (log kaydı gibi) temizlenir veya kirletilir. (APT-Advanced Persistent Threat).
2. Penetrasyon Test Araçları
Bilgi güvenliği, özellikle e-ticaret ve e-devlet uygulamalarının yaygınlaşmasıyla birlikte
oldukça önemli bir hâle gelmiştir. Bilginin güvenli bir şekilde iletilmesi, işlenmesi ve
saklanması bilişim uzmanlarının başlıca görevlerinden birisi olmuştur. İletilen bilginin veya
bilgiyi ileten sistemin gerekli güvenlik özelliklerini sağlayıp sağlamadığını test etmek ve
denetlemek için ağ güvenliği test ve denetim araçları kullanılmaktadır. Bu araçlardan bazıları
ücretsizdir, bazıları ise belirli bir ücretlendirmeye tabidir. Ağ güvenliği test ve denetim
araçlarının birçoğu Backtrack altında toplanmıştır. Backtrack, Linux işletim sistemi üzerine
kuruludur ve CD’den boot edilerek kullanılmaktadır.
Ağ güvenliği test ve denetim araçları aşağıdaki başlıklar altında gruplandırılabilir:
1. Ağ dinleme araçları
2. Port tarayıcılar
3. Şifre kırma araçları
4. Web güvenliği test araçları
5. Genel Amaçlı Güvenlik Açığı Tarayıcılar
Fırat Üniversitesi BMÜ-431
Bilgisayar Mühendisliği Bilgisayar Sistemleri Laboratuvarı
Deney No: 2
Ağ Güvenliği ve Etik Saldırı
4
2.1. Ağ Dinleme Araçları
Ağ ve sunucu trafiğini izlemek için ve ağ dinlemek için kullanılan araçlardır. Ağ dinleme
araçları arasında en çok kullanılan ve en yaygın olanı Wireshark programıdır. Wireshark açık
kaynak kodlu bir yazılımdır ve internetten ücretsiz olarak indirilebilir. Hem Windows hem de
Linux işletim sistemleri üzerinde çalışmaktadır. Wireshark trafiği kaynak adres, hedef adres,
kaynak port, hedef port gibi belirli kriterlere göre yakalayabilmektedir. Ayrıca izlenen trafik
sonradan incelenmek üzere kaydedilebilir. Bu program aynı zamanda kablosuz ağları da
dinleyebilmektedir. Wireshark’ın kurulumu kullanımı ile ilgili geniş anlatıma sahip bir kayağa
http://www.enderunix.org/docs/wireshark.pdf
Ping ve Ping Sweeps
Ping özel bir network paketi olup ICMP packet olarak adlandırılır. Ping sweep(ping
taraması) yapmanın en kolay yolu FPing adlı aracı kullanmaktır. FPing’i kullanmak için
terminali açarak;
fping –a –g 172.16.45.1 172.16.45.254>hosts.txt
2.2. Port Tarayıcılar
Hedef makine de ne kadar çok açık port varsa, açıklık potansiyeli de o kadar fazla
olmaktadır. Bu yüzden kullanılmayan portların kapatılmış olması gerekir. Hedef bilgisayar
üzerinde açık olan portlar, port tarayıcı yazılımlar ile tespit edilmektedir.
En yaygın olarak kullanılan port tarayıcı program Nmap yazılımıdır Nmap, açık kaynak
kodlu bir yazılım olup ücretsizdir. Hem Windows hem de Linux üzerinde çalışabilmektedir.
Nmap programının en önemli özellikleri şunlardır:
• TCP ve UDP port taraması yapabilmektedir.
• İşletim sistemi tespiti yapabilmektedir.
• Çalışan servisleri tespit edebilmektedir.
• Yazılımların sürümünü tahmin edebilmektedir.
• Bir ağdaki canlı bilgisayarları tespit edebilmektedir.
• Raporlama yeteneği bulunmaktadır. Test sonucunda HTML formatında raporlar
çıkarmaktadır.
Fırat Üniversitesi BMÜ-431
Bilgisayar Mühendisliği Bilgisayar Sistemleri Laboratuvarı
Deney No: 2
Ağ Güvenliği ve Etik Saldırı
5
• Nmap, komut satırıyla çalışan bir programdır. Ancak, Zenmap isminde kullanıcı
arayüzüne sahip olan sürümü de çıkmıştır
Kullanımı için;
Nmap –p 192.168.56.101
-p hedef makinedeki tüm portların taranması anlamını taşır.
HTTrack
Pen testimize hedef siteyi gözden geçirerek başlamak isteriz. Bu amaçla HTTrack adlı araç
kullanılarak web sitesinin sayfa sayfa kopyası çıkarılabilir. HTTrack web sayfasının sayfa sayfa
ofline kopyasını çıkaran ücretsiz bir programdır. Kopyalanan web sitesi tüm sayfaları, linkleri,
resimleri ve orijinal web sitesinin kodlarını içerir ancak tüm bunlar sizin lokal bilgisayarınızda
bulunur. HTTrack gibi bir araç kullanarak siteye offline erişim sağlanması şirketin web
sunucusunda uzun zaman geçirerek dikkat çekmenin önün geçer. Ve sitenin içeriklerine geniş
ulaşım imkânı sağlar. HTTrack işini bitirince hedef sitenin tam bir offline kopyası inceleme
için bilgisayarınızda hazır bulunacaktır.
2.3. Şifre Kırma Araçları
Hedef cihazda çalışan bir servise ait kullanıcı adını ve parolayı kırmak için şifre kırma
araçları kullanılmaktadır. Örneğin bir yönlendiricinin yönetimini ele geçirmek için şifre kırma
araçları kullanılabilir. Bu araçlar vasıtasıyla yönlendiriciyi yönetmek için kullanılan kullanıcı
adı ve parola elde edilebilir. Bu araçlara örnek olarak Cain and Abel, Brutus, Hydra ve
L0phtCrack programları verilebilir.
Bu araçlardan Cain and Abel, ücretsiz bir yazılımdır (Linkleri Görebilmek İçin Üye Olun
veya Giriş Yapın.). Sadece Windows işletim sistemleri üzerinde çalışabilmektedir.
Medusa
Medusa brute force (kaba kuvvet) yöntemini kullanarak şifreyi tahmin etmeye çalışan ve
uzak servislere erişim sağlayan bir araçtır. Medusa FTP, http, MySQL, Telnet, VNC, Web Form
ve daha pek çok servise saldırı yapma yeteneğine sahiptir. Medusanın kullanılabilmesi için belli
bilgilere ihtiyaç duyulur bu bilgiler;
-Hedef IP adresi
Fırat Üniversitesi BMÜ-431
Bilgisayar Mühendisliği Bilgisayar Sistemleri Laboratuvarı
Deney No: 2
Ağ Güvenliği ve Etik Saldırı
6
-Girişi yapmak için kullanılacak kullanıcı adı veya kullanıcı adı listesi
-şifre yada şifre olarak kullanılacak bir sözlük
-Giriş yapmak istediğini servisin adı
Medusa Backtrack 5’de yüklü olarak gelmektedir. Ancak başka bir sürüm yada dağıtım
kullanıyorsanız yüklemek için konsolda ;
apt-get update apt-get install medusa
Daha önceki bölümlerde yapılan araştırmalardan (reconnaissance,scanning) elde edilen email adresleri yada hesap isimleri ve şifreler bu bölümde medusaya girilir. Medusa gibi
programlar bu kullanıcı isimlerini ve şifreleri kullanarak başarılı olana kadar denerler. Burada
dikkat edilmesi gereken önemli bir nokta günümüz sistemlerinin belirli sayıdaki denemenin
ardından saldırınızı fark edip IP’nizi kilitleyebileceğidir. Elbette ki dijital izleriniz kayıt altına
alınacak ve sistem yöneticisi uyarılacaktır. Şifresini denediğiniz kullanıcı adının kilitlenmesi
de ihtimal dâhilindedir.
Çeşitli şifre listeleri(sözlükler-dictionary) internette bulanabileceği gibi sıklıkla kullanılan
şifreleri içeren bir liste Backtrak’da mevcuttur;
/pentest/passwords/wordlists/
Brute-force saldırıyı gerçekleştirmek için konsolda;
medusa –h target_ip –u username –P path_to_password_dictionary –M service_to_attack
-h Hedef hostun IP adresi
-u Medusanın kullanacağı tek kullanıcı adı
-P şifre listesi-Kelime sözlüğü-dictinary file- yolu
-M saldırılacak servis
2.4. Web Güvenliği Test Araçları
Günümüzde uygulama güvenliği diğer güvenlik araçlarının da önüne geçmiştir. Çünkü
uygulamalar genellikle sınırlı bir ekip tarafından geliştirilmekte ve test edilmektedir. Bu da
bilinen genel güvenlik yazılım ya da donanımlarına göre daha çok açıklık barındırmalarına
sebep olmaktadır. Bu yüzden piyasada bu tür araçlar hızla artmaktadır. Web uygulama
Fırat Üniversitesi BMÜ-431
Bilgisayar Mühendisliği Bilgisayar Sistemleri Laboratuvarı
Deney No: 2
Ağ Güvenliği ve Etik Saldırı
7
güvenliği alanında en önemli araçlardan bazıları şunlardır. Paros, açık kaynak kodlu bir yazılım
olup platform bağımsız çalışmaktadır
Genellikle internet tarayıcı ara yüzünden girilmesine izin verilmeyen karakterlerin
uygulama yazılımına gönderilmesi için kullanılır. Aynı şekilde uygulama yazılımına paketler
gönderilirken yakalanarak içerikleri değiştirilip gönderilebilir. Ya da daha önceden yakalanmış
olan paketler gönderilir. Bunların sonucunda uygulama devre dışı bırakılmaya zorlanabilir ya
da uygulamanın yapısı hakkında bilgi toplanabilir. Paros kullanılarak ağın haritası çıkarılabilir.
Buradan ağın haritasına bakılarak hangi sayfaların olduğu kolayca görülebilir. Web testi
kısmında ise injection, oturum numarası tahmin etme gibi birçok açıklığı uygulama üzerinde
deneyebilir. FireBug, Mozilla Firefox’un bir uzantısı olarak çalışır Platformdan bağımsız olarak
çalışır. Web sayfasının istenilen herhangi bir yerine gelindiğinde o kısımla ilgili kodu
gösterebilir ve o kısımda inceleme yapılabilir. O kısmın kodu kolayca değiştirilebilir. Bu araç
hem geliştiriciler hem de testçiler tarafından etkin olarak kullanılabilir.
Ticari bir yazılım olan Acunetix, Windows işletim sistemi üzerinde çalışmakta olup version
check, CGI kontrol, parametre değişimi, dosya kontrolü, dizin kontrolü gibi testleri
yapmaktadır Bu testleri yaparken istenilen testler için profiller oluşturularak sadece seçilen
testlerin yapılması sağlanmaktadır. Uygulama açıklığı taraması yapmaktadır. İstenilen
açıklıkları ekleyebilme yeteneği mevcuttur. Yapılan açıklıklarla ilgili detaylı raporlar
üretmesinin yanında tek tuşla internetten güncellenebilmektedir.
Netsparker
Netsparker, bir web uygulaması güvenlik tarayıcısıdır. Otomatik olarak bir web sitesini
uygulama seviyesindeki güvenlik açıklarına karşı analiz edip güvenlik açıklarını raporlar. Ek
olarak raporlamanın bir adım da ötesine geçip güvenlik açıklarını kullanarak aynı bir saldırgan
gibi sistemden veri çıkartabilir ya da sisteme tam erişim sağlayabiliyor. Bu sayede SQL
Injection, Cross-site Scripting gibi açıkları bulmayı sağlar.
Acunetix Web Vulnerability Scanner
Sadece web uygulamalarını denetlemekle kalmamakta, aynı zamanda web uygulamasının
bulunduğu sunucu da tüm saldırı yöntemlerine göre denetlemektedir. Serverda bulunan
Fırat Üniversitesi BMÜ-431
Bilgisayar Mühendisliği Bilgisayar Sistemleri Laboratuvarı
Deney No: 2
Ağ Güvenliği ve Etik Saldırı
8
güvenlik açıklarını bize belirtmektedir. Kendi Crawler’ı ile bize web sunucu tipini ve dilini
göstermektedir. Tüm kodlama dillerinin güvenlik açıklarını tarar.
Webinspect
WebInspect, web uygulamalarındaki güvenlik açıklarını, kodlama hatalarını bulup çözüm
önerileri getirerek güvenlik duvarı ve saldırı tespit sistemleri için tamamlayıcı bir rol oynar.
WebInspect çözümünün kolay yönetilen arayüzü, genişletilebilen fonksiyonları ile ister test
ortamında, ister gerçek ortamında, web uygulamalarınızı ve web servislerinizi güvenlik
değerlendirmesinden en doğru sonuçları elde ederek geçirebilir. WebInspect kullanıcılara,
herhangi bir web uygulamasının ve/veya web servisin in teknolojilerinin uygulama günveliği
açısından denetleme ve olası riskleri bulma olanağı sunar.
2.4. Genel Amaçlı Güvenlik Açığı Tarayıcılar
Metasploit
Bu penetrasyon testi için en gelişmiş ve en popüler olanıdır. Güvenlik önlemlerini aşmak
ve belli bir sisteme girebilecek “Exploit” kavramına dayalıdır. Eğer hedef bir makinede başarılı
olduysa, penetrasyon testi için mükemmel bir kod çalıştırır. Web uygulamaları, ağlar, sunucular
ve benzerleri üzerinde kullanılabilir.
Qualys
Açık tespiti için kullanacağınız programların yanında doğrudan bu iş için tasarlanmış web
sitelerine bağlanarak çevrimiçi açık tespiti yapabilirsiniz. Qualysguard Enterprise Intranet
Scanner hizmeti böylesi bir açık hat web sitesidir
Nessus
Linux’ta sıkça kullanılan, kapsamlı bir güvenlik açığı tarama yazılımıdır. Kişisel ve hertür
kurumsal olmayan kullanım için ücretsizdir. Genel amacı, bilgisayar sistemlerinde ve bilgisayar
ağlarında potansiyel güvenlik açıklarını tespit etmektir. Nessus bir port tarama yazılımından
çok daha üstün özelliklere sahiptir. Nessus, servislerdeki açıkları eklentilerinin güncelliğine
bağlı olarak test edebilir. Çalışma prensibi istemci/sunucu biçimini kullanır ve test edilecek
sistemde nessus sunucu yazılımının açık olması daha derinlemesine test ve analiz imkânı sunar.
Fırat Üniversitesi BMÜ-431
Bilgisayar Mühendisliği Bilgisayar Sistemleri Laboratuvarı
Deney No: 2
Ağ Güvenliği ve Etik Saldırı
9
3. Deney
WinPcap
WinPcap network kartlarına erişerek paket bazında işlem yapmaya olanak sağlayan C
dilinde yazılmış bir dll’dir. WinPcap, Windows ortamlarında bağlantı katmanı ağ erişimi için
endüstri standardı bir araçtır: Protokol yığını atlayarak ağ paketlerini yakalama ve aktarmasını
sağlar ve çekirdek düzeyinde filtreleme paket, bir ağ istatistikleri motoru ve destek gibi ek
yararlı özelliklere sahiptir.
WinPcap paket yakalama ve birçok açık kaynak, protokol analizi, ağ izleme, ağ saldırı tespit
sistemleri, izleyiciler, trafik jeneratör ve ağ cihazları da dahil olmak üzere ticari ağ araçları,
filtreleme motoru içerir. Wireshark, Nmap, Snort, ntop gibi bu ağ araçlarından bazılarıdır.
jNetPcap
jNetPcap açık kaynak kodlu bir kütüphanedir ve nerdeyse bütün libpcap kütüphanesi için
bir wrapperdır. Aynı zamanda WinPcap Programını da destekler. Bu paket program gerçek
zamanlı olarak yakalanan paketlerin çözülmesini sağlar. jNetPcap daha iyi performans için
içerisinde bu kütüphanaler ve java uygulamaları beraber kullanılır. Ayrıca Java SDK’sını
kullanarak java dilinde kullanıcıların kendi protokollerinin geliştirilmesine olanak sağlar. Bu
program ile ilgili kaynak koda, örnek uygulamalara ve dökümanlara; http://jnetpcap.com/
internet sitesinden ulaşabilirsiniz.
Ödev
Aşağıda verilen ve daha önce bahsettiğimiz işleri ya da benzerlerini yapan kendi paket
inceleme programınız gerçekleştirilecektir.
Örnek Uygulamalar;
1. Ping sweep işlemini gerçekleştirecek bir Windows uygulamasını jNetPcap ile
gerçekleştiriniz.
2. TCP Port tarama işlemini gerçekleştirecek bir Windows uygulamasını jNetPcap ile
gerçekleştiriniz.
3. UDP Port tarama işlemini gerçekleştirecek bir Windows uygulamasını jNetPcap ile
gerçekleştiriniz.
Fırat Üniversitesi BMÜ-431
Bilgisayar Mühendisliği Bilgisayar Sistemleri Laboratuvarı
Deney No: 2
Ağ Güvenliği ve Etik Saldırı
10
4. Ağda görünen kullanıcı adı ve şifreleri bir log dosyasına yazan Windows uygulamasını
jNetPcap ile gerçekleştiriniz.
5. Ağ trafiğinin istatistiğini çıkaran bir Windows uygulamasını jNetPcap ile
gerçekleştiriniz.
6. Ağdaki DHCP trafiğini yakalayarak ağ bilgisi çıkaran Windows uygulamasını jNetPcap
ile gerçekleştiriniz.
7. SMTP protokolü için kaba kuvvet saldırısı ( brute force attack ) yapan Windows
uygulamasını jNetPcap ile gerçekleştiriniz.
8. FTP protokolü için kaba kuvvet saldırısı ( brute force attack ) yapan Windows
uygulamasını jNetPcap ile gerçekleştiriniz.
4.1. Kullanılacak araçlar
-Microsoft Windows
-Microsoft Visual Studio 2010 yada sonraki sürümleri
-Winpcap ( http://www.winpcap.org/ )
- jNetPcap (http://pcapdotnet.codeplex.com/ )
4.2 Puanlama :
50 puan -- Deneye Hazırlık ve Deney Esnasındaki Çalışmalar
50 puan -- Uygulama ve Uygulama Kontrol Esnasındaki Çalışmalar
Uyarı! Ödevler şahsidir ve özgünlük esastır. Uygulama için platform ve dil seçimi isteğe bağlıdır.
Aynı ya da şüphe duyucu şekilde benzer olan ödevler için gerekli yasal prosedür uygulanır.
Kaynak:
1. http://backtracktutorials.com/backtrack-basics
2. “METASPLOIT The Penetration Tester’s Guide” by David Kennedy, Jim O’Gorman,
Devon Kearns, and Mati Aharoni
3. “The Basics of hacking and penetration Testing Ethical hacking and penetration Testing
Made Easy” by Patrick Engebretson
4. "jNetPcap: http://jnetpcap.com/
1
F.Ü. MÜH. FAK.
BİLGİSAYAR MÜH. BÖL.
BİLGİSAYAR SİSTEMLERİ LAB.
DENEY NO : 3
BİLGİSAYAR AĞ CİHAZLARININ YAPILANDIRILMASI
1. GİRİŞ
Bu deneyin amacı Cisco 1760 Router ve Cisco Catalyst 2950 switch kullanarak:
• Router ve Switch üzerindeki arabirimleri ve portları tanımak, işlevlerini anlamak Ve
konfigürasyonlarının nasıl yapılacağını öğrenmek
• Yerel Alan Ağı (LAN, Local Area Network) oluşturmak
• Statik, default ve dinamik yönlendirme kavramlarını öğrenmek
• RIP, IGRP, EIGRP gibi yönlendirme algoritmalarını öğrenmek
• Bu algoritmaları routerlar üzerinde yapılandırmaktır.
Deneye gelmeden önce aşağıdaki konuların ve özellikle yönlendirme algoritmaları
protokolleri ve metric(ölçüt) lerinin kesinlikle bilinmesi gerekmektedir.
• Ağ arabirim kartı (Network interface card)
• IP adresleri ve Ağ maskeleri
• Ağ topolojisi
• Ağ protokolleri
• OSI modeli ve katmanları
• TCP/IP modeli
• Kablo türleri ve özellikleri
• Routing algoritmaları,metrikleri ve protokolleri (RIP, IGRP, EIGRP)
• Statik ve Dinamik yönlendirme
• Uzaklık Vektörü Algoritması (Distance Vector Routing)
• Bağlantı Durumu Algoritması (Link State Algorithm)
2. Router
2.1. Router’ın Çalışması
Aynen PC’ler gibi Router’larda ilk açıldıklarında POST işlemini gerçekleştirir. Yani CPU,
hafıza, arabirim devreleri gibi sistem donanımlarını kontrol eder. Tüm donanımın düzgün
çalıştığından emin olunduktan sonra POST işlemi ROM’da tutulan bootstrap yazılımını çalıştırır.
Bootstrap programı Flash’da bulunan IOS’u bulur, sıkıştırmasını açar (decompress) ve bu IOS’u
Flash’dan RAM’e yükler. Bazı router’lar yeterli hafızaya sahip olmadıkları için IOS’u RAM’e
yüklemeden doğrudan Flash’dan çalıştırırlar. Eğer router herhangi bir geçerli IOS bulamazsa
RAM’daki RXBoot olarak adlandırılan mini IOS’u yükler. Eğer bu işlemde başarısız olursa ROM
2
Monitor (ROMMON) moduna düşer. IOS yüklendikten sonra NVRAM’da bulunan başlangıç
konfigürasyonlarını (startup configuration) yükler. Eğer herhangi bir sebepten ötürü
konfigürasyon dosyası bulamazsa IOS, “NVRAM invalid” mesajını verir ve IOS otomatik olarak
“setup dialog” olarak adlandırılan konfigürasyon işlemini başlatır.
Router’ların üzerinde IOS (Internetwork Operating System) işletim sistemi çalışır. Bu
işletim sisteminde temel olarak iki farklı komut modu vardır.
User exec
Privileged exec
Bu modların haricinde başka modlarda vardır. Modlar’ın hiyerarşik yapısı şekil-3’deki
gibidir. Router’a bağlanıp ,yönetmek için değişik seçenekler mevcuttur. Birincisi router’a
doğrudan konsol portundan bağlantı yapılır. İkincisi uzaktan modem yoluyla router’ın AUX
portuna bağlanılır. Üçüncü seçenek ise Router aktif olan LAN veya WAN portunda telnet aracılığı
ile bağlanılır. Fakat telnet ile bağlantı kurulacak Router’ın bazı öncelikli ayarlarının yapılması
(örneğin interface’lerin up duruma getirilip adreslerinin atanmış olması) gerekir. Router’a ilk
login olunduğunda user exec modda olunur. Bu modda sadece bilgi görüntülenebilir. Yani
herhangi bir konfigürasyon değişikliği yapılamaz. Herhangi bir değişiklik yapılması istenilirse
privileged exec modun kullanılması zorunludur. User exec moddan privileged moda geçmek için
enable komutu kullanılır.
2.2. Hyperterminal
Ağ cihazlarını konfigüre etmek için kullanılan bir terminal emülasyon yazılımıdır. Bu
yazılım Win 95/98 ve Win NT ile birlikte geldiği için en çok kullanılan terminal emülasyon
programıdır. Bu program kullanılarak router’a bağlanailmekiçin PC’nin herhangi bir seri portuna
takılan (COM1 veya COM2) DB-9-RJ45 dönüştürücüye rollover kablo takılır. Hyperterminal
programı çalıştırılır, bağlantı ismi verilir, bağlantının kurulacağı seri port seçilerek portun
özelliklerinin belirlendiği pencereye uygun değerler girilerek bağlantı kurulur.
2.3. Router’ın Kurulması
Router’ın açılması sırasında router konfigürasyon dosyasını arar. Eğer herhangi bir
konfigürasyon dosyası bulamazsa sistem konfigürasyon işlemi başlar. Bu işlem sırasında
aşağıdaki sorulara “Yes” diye cevap verilirse router soru temelli konfigüre edilebilir.
Continue with configuration dialog? [yes/no]
Would you like to see the current interface summary? [yes/no]
Bu konfigürasyon türünde router bir takım sorular sorar ve bu soruların cevaplarını ister.
Sorulan soruların varsayılan cevapları soru sonundaki köşeli parantezlerin (*+) içinde verilmiştir.
Varsayılan cevapları kabul etmek için gereken tek şey Enter’a basılmasıdır. Eğer soru cevap
tabanlı konfigürasyondan herhangi bir zamanda çıkılmak istenirse o zaman Ctrl+C tuşlarına
basılması yeterlidir.
Eğer yukarıda sorulan sorulara “No” diye cevap verilirse router komut satırından konfigüre
edilecek demektir. Bu durumda komut satırı aşağıdaki şekildedir.
3
Router>
İlk karşılaşılan mod “user exec” moddur. Varsayılan olarak konfigüre edilmemiş tüm
Router’ların adı Router’dır ve “privileged exec” moda geçmek için herhangi bir şifre
tanımlanmamıştır. Router üzerinde herhangi bir konfigürasyon değişikliği yapmak istenilirse
privileged moda geçilmesi gerekir. Bunun için komut satırına aşağıdaki komut yazılır.
Router>enable
Router#
Fast-Ethernet arabirimini konfigüre etmek için, global kanfigürasyon mod içerisindeki
aşağıda verilen komutların kullanılması gerekir.
Router#configure terminal
Router(config)# interface fastethernet 0/0 (fast Ethernet arabirimi için konfigürasyon
moda girme)
Router(config-if)# ip address 20.20.20.20 255.255.255.0 (Fast Ethernet arabirimi için IP
adres ve alt ağ maskesi atama)
Router(config-if)# no shutdown (Fast Ethernet arabirimini aktif hale getirme)
Router(config-if)# exit (Fast Ethernet arabirimi için konfigürasyon modundan çıkma)
Konfigurayon ayarlarını kontrol etmek için;
Router# show running-config
3. Yerel Alan Ağları
Yerel alan ağları, aynı çalışma ortamında birbirleriyle ilgili işlerde çalışan bir topluluk içinde
kaynakların paylaşılması amacıyla kurulur. LAN’larda temel özellik, sistemlerin aynı ortamda
veya birbirlerine yakın mesafede olmasıdır. LAN uygulamasında kablolama alt yapısı oldukça
önemlidir; kablo türü, seçilecek teknolojiyi, ağın yayılabileceği fiziksel genişliği ve portlar
arasındaki iletişim hızını belirlemede baskın parametrelerdir. LAN’lar aşağıdaki bileşenlerden
oluşur.
• Bilgisayarlar
• Ağ arabirim kartları
• Paralel cihazlar
• Kablolar
• Ağ cihazları
Şekil 1. Ağ cihazları.
4
LAN uygulamalarında Ethernet, Token Ring ve FDDI sıkça kullanılan teknolojilerdir.
ETHERNET en sık kullanılan LAN teknolojisidir ve bu deneyde de ETHERNET LAN teknolojisi
kullanılacaktır. Şekil 1’de LAN’larda sıkça kullanılan ağ cihazları verilmiştir.
4. Yönlendirme
Bu bölümde yönlendirmenin ne olduğu tanımlanarak statik ve dinamik yönlendirme
arasındaki farklar açıklanacaktır. Bir router hedef ağa paketleri sevk etmek için yönlendirmeyi
kullanır. Router, paketin hedef IP (destination IP) adresine bakarak karar verir. Yol boyunca tüm
cihazlar paketi doğru hedefe ulaştırmak için hedef IP adresini kullanır. Doğru kararlar alabilmek
için, Routerlar hedef ağlara nasıl ulaşacaklarını öğrenmek zorundadırlar. Routerlar dinamik
yönlendirmeyi kullandıkları zaman, uzak ağlara ulaşmak için gerekli yönlendirme bilgisini diğer
routerlardan öğrenir. Statik yönlendirmeyi kullandıkları zaman ise, bu bilgi ağ yöneticisi
tarafından yapılandırılır.
Statik yönlendirme el ile yapılandırıldığından, ağ yöneticileri herhangi bir topoloji değişikliğini
yansıtmak için statik route’ları ekleyip silmek zorundadırlar. Büyük ağlarda yönlendirme
tablolarını (routing tables) el ile sürdürme çok büyük yönetim zamanı gerektirir. Birkaç olası
değişimin olduğu küçük ağlarda statik yönlendirme daha sık kullanılır. Statik yönlendirme ekstra
yönetici ihtiyacından dolayı dinamik yönlendirme kadar kullanışlı değildir. Bazen büyük ölçekli
ağlarda belirli bir amacı gerçekleştirmek için statik route’lar dinamik yönlendirme protokolleri ile
birlikte yapılandırılır.
4.1 Statik Yönlendirme
Bu bölümde statik yönlendirmenin nasıl yapılacağı anlatılacaktır. Statik yönlendirme üç kısım
içerisine bölünebilir.
• Ağ yöneticisi yönlendirmeyi yapılandırır.
• Router yönlendirmeyi yönlendirme tablosuna kurar.
• Statik yönlendirme, paketleri yönlendirmek için kullanılır.
Bir yönetici statik yönlendirmeyi el ile yapılandırmak için ip route komutunu kullanır. Bu
komut için doğru sözdizimi şekil-2 deki yapı için aşağıda verilmiştir.
5
Şekil-2 Ağ şeması
Şekilde Hoboken routerın ağ yöneticisi diğer routerlar üzerindeki 172.16.1.0/24 ve 172.16.5.0/24
ağlarına statik yönlendirmeyi yapılandırma ihtiyacı duyar. Yönetici bunu başarmak için aşağıdaki
iki komutu kullanmak zorundadır.
Komut söz diziminde çıkış arabirimleri s1 ve s0 geçityolları (gateway) ile belirtilmiştir.
Aynı statik yönlendirme için diğer bir komut söz dizimi ise aşağıdaki gibidir.
4.2 Default-Statik Yönlendirme
Bu bölümde default statik yönlendirmenin nasıl yapılacağı anlatılacaktır. Default
yönlendirme, hedef IP yönlendirme tablosundaki hiçbir giriş ile eşleşmediği durumda kullanılır.
6
Default yönlendirme söz dizimi aşağıdaki gibidir. Şekil-3 Waycross router için default
yönlendirmeyi göstermektedir.
ip route 0.0.0.0 0.0.0.0 [gelecek -hop-adres | çıkış arabirimi ]
Şekil-3 Default-statik yönlendirme
4.3 Dinamik Yönlendirme
Bu bölümde bir yönlendirme protokolünün nasıl yapılandırılacağı açıklanacaktır. Bir
router üzerinde IP yönlendirme protokolünü yapılandırmak için global ve yönlendirme
parametrelerinin yapılandırılması gerekir. Global parametreler olarak RIP, IGRP, EIGRP veya
OSPF gibi yönlendirme protokollerinin seçimi gereklidir. Yönlendirme yapılandırma modundaki
(global configuration mode) başlıca görev IP ağ numarasının belirtilmesidir. Bir yönlendirme
protokolü aşağıdaki gibi yapılandırılır.
7
router komutu bir yönlendirme protokolünü tanımlar. network alt komutu ise her bir
yönlendirme işlemi için zorunlu bir yapılandırma komutudur ve yönlendirme tablolarını hangi
arabirimden gönderilip alınacağını belirler. Ağ numarası (network number) doğrudan bağlantılı
ağı belirlemek için kullanılır. IGRP ve EIGRP yönlendirme algoritmaları bir otonom numarası
(Autonomous number) gerektirirken, OSPF bir işlem ID’si gerektirir. RIP hiçbirini gerektirmez. Bir
yönlendirme yapılandırma örneği şekil-4 deki yapı için aşağıdaki gibi tanımlanır.
Şekil-4 Dinamik yönlendirme için örnek yapı.
8
GAD(config)#router rip
GAD(config-router)#network 172.16.0.0
4.3.1 RIP Yönlendirme Algoritması
Bu bölümde RIP yönlendirme algoritmasının nasıl yapılandırılacağı açıklanmıştır. router
rip komutu yönlendirme protokolü olarak RIP’i yetkilendirir. network komutu hangi arabirim
üzerinde RIP algoritmasının çalışacağını routera söylemek için kullanılır. Yönlendirme işlemi ağ
adresleri ile belirli arabirimleri ilişkilendirir ve bu arabirimler üzerinden RIP güncellemelerinin
(update) alınıp gönderilmesini başlatır. RIP, yönlendirme güncelleme mesajlarını (routingupdates messages) düzenli aralıklarla gönderir. Router herhangi bir değişimi gösteren bir
güncelleme aldığında, yeni güncellemeyi yansıtmak için kendi yönlendirme tablosunu günceller.
Şekil-5’teki ağ için RIP dinamik yapılandırılması aşağıda verilmiştir.
Şekil-5 RIP yönlendirme algoritması ve router üzerindeki yapılandırılması
4.3.2 IGRP Yönlendirme Algoritması
Bu bölümde IGRP yönlendirme algoritmasının nasıl yapılandırılacağı açıklanmıştır. IGRP
yönlendirme işlemini yapılandırmak için router igrp yapılandırma komutu kullanılır. IGRP
yönlendirme işlemini sonlandırmak için bu komutun no formu kullanılır. Aşağıda IGRP
yönlendirme algoritması için komut söz dizimi verilmiştir.
RouterA(config)#router igrp as-number
RouterA(config)#no router igrp as-number
9
Burada AS (Autonomous system) numarası IGRP işlemini tanımlar. Aşağıda AS no 101
için IGRP’nin nasıl yapılandırılacağı gösterilmiştir.
5. RIP ve IGRP Yapılandırmasını Doğrulama
Bu bölümde RIP, IGRP ve diğer yönlendirme işlemlerinin doğru yapılandırılıp
yapılandırılmadığını öğrenmek için gerekli komutların söz dizimi ve amaçları tanımlanacaktır. İki
komut show ip route ve show ip protocols mevcuttur. show ip protocols komutu router
üzerinde IP trafiğini hangi yönlendirme protokolünün taşıdığını gösterir. Şekil-6 show ip
protocols komutunun çıktısını göstermektedir.
Şekil-6 show ip protocols komutunun çıktısını
10
show ip route komutu yönlendirme algoritması vasıtasıyla komşu routerdan alınan yönlendirme
bilgilerinin doğrulanması için kullanılır. Şekil-7’de show ip route komutunun çıktısı verilmiştir.
Şekil-7 show ip route komutunun çıktısı
11
DENEYLER
1. Aşağıdaki verilen ağ yapısını RIP yönlendirme algoritmasını kullanarak yapılandırınız?
2. Aşağıdaki verilen ağ yapısını EIGRP yönlendirme algoritmasını kullanarak yapılandırınız?
DENEY 1 – LİNUX
Bulut Bilişim: 3 modeli vardır. Servis olarak altyapı - platform – yazılım
Kernel: İşletim sisteminin kalbi, donanımla ve hafıza yönetimi, dosya yönetimi bir çok işle
iletişim kurar.
Shell: Terminalde bir komut yazdığınızda Shell bu komutu yorumlar ve istenen programı
çağırır. Bütün komutlar için standart syntax kullanır.(C Shell,Korn Shell)
Örnek komutlar:
ls ch*.doc ; ch ile başlayan .doc ile biten tüm dosyaları listeler.
wc dosyadi ; dosyadaki kelime sayısını getirir.
chmod o+wx,u-x,g=rx testfile ; izin atamaları gerçekleştirildi.
Shell Programlama:
Shell(Terminal) program yürütme birimidir. Terminalden komutlar sırayla çalıştırılır
bunun yerine komutlar öncesinde 1 dosyaya kayıt edilip çalıştırılmasına “Shell scripting”
denir.
Avantaj: kullanıcıdan, dosyadan giriş alıp ekranda görüntüleyebilir, zaman kazandırır, kendi
komutlarımızı üretiriz, günlük rutin işlerin ve sistem yönetimi işlerininin otomatikleşmesini
sağlar.
Örnek bir Shell programı;
#!/bin/bash
sayı=1
if [ $sayı = "1" ]; then
echo "sayı eşittir bir"
else
echo "sayı birden farklı"
fi
DENEY 2 – AĞ GÜVENLİĞİ
Penetrasyon Testi: Bilgisayar ağının dışarıdan/içeriden gelebilecek saldırılara karşı ne
kadar güvende olduğunu anlamak adına yapılır. Dos testi ile saldırılarla sistemin çöküp
çökmeyeceği, application ile kodlar taranır, dış ağın testinde gelebilecek saldırılara karşı
durum tespiti yapılır.
Faydası: Dirençli altyapı, bilgi güvenliği, kaynakların korunumu, kurum marka prestiji
Test adımları:
• Bilgi toplama: Sistem hakkında önbilgi
• Tarama: Sistemdeki bilgisayarları, ağ cihazlarını, tespit etme
• Erişim sağlama: Yetki düzeltme, sistem durdurma, yetkisiz erişim
• Erişim koruma: Sistem üzerinde yetkili 1 kullanıcı oluşturup bunu koruma
• İzleri yok etme: Log kayıtlarını silme / kirletme
Test Araçları:
1. Ağ Dinleme Araçları: Wireshark
2. Port tarayıcılar: NMAP / Httrack
3. Şifre kırma : Medusa
4. Web güvenliği : Netsparker / Webinspect
5. Genel amaçlı : Nessus
DENEY 3 – AĞ CİHAZLARI
Router’ın Çalışması: Router ilk açıldığında POST işlemi olur, CPU vs kontrol eder, sonra bu
işlem ROM’da tutulan bootstrap yazılımını çalıştırır, bu yazılım flashda bulunan IOS u alıp
extract edip RAM’e yükler.
Dinamik yönlendirmede aynı protokolü kullanan Router’lar birbiri ile haberleşerek
birbirini günceller, statik yönlendirmede bu işlem manuel olarak yönetici tarafından
yapılmaktadır.
Router Yönlendirme Kodu
DENEY 5 – GÖMÜLÜ PROGRAMLAMA
Gömülü Sistem: Büyük bir sistem içinde belirli kontrol işlevleri için tasarlanmış bilgisayar
sistemi. Banka atmleri, cep telefonları, hesap makineleri, yazıcılar, çamaşır makinesi vb.
Özellikleri:
• Arayüz genellikle yoktur. Yazılım ve donanım olmak üzere 2 kısım.
• Verimlilik önemli, güç tüketimi vs masaüstü prog. bu özellikle ayrılır.
• Sürekli olarak yürütülür.
• Gerçek zamanlı kısıtlamaları karşılamak amacıyla tasarlanmıştır.
Masaüstü programlalar ile arasındaki farklar;
Sınırlı kaynak, bileşenler farklı, tipik olarak daha küçük, az güç tüketimi, donanıma daha fazla
bağımlı.
Arduino: Gömülü sistem programlama için kullanılabilecek araçlardan birisidir. Uno, mega,
Lillypad, nano gibi çeşitleri vardır. Temel olarak çevresiyle kolay etkileşime girer, atmega328
mikrodenetleyici kullanılır, sensörden gelen veri kullanılabilir, ses vb çıktı üretebilir, a/d dönüşüm
yapılır.
Örnek kod;
DENEY 6 – DAĞITIK PROGRAMLAMA
Dağıtık sistemler : Katmanların 1-1lerinden uzak yerlerde bulunduğu, farklı bilgisayarlara
ait donanım ve yazılım bileşenleri arasında yanlızca mesajlaşma yöntemleri kullanarak
haberleşme ve koordinasyon sağlanabildiği network sistemidir.
Niçin Dağıtık Programlama:
• Hesaplamayı hızlandırma
• Kaynak paylaşımı
• Güvenilirlik
• Ölçeklenebilirlik
• Belli donanıma sahip pclerde çalışma imkanı
• Erişim kontrolleri kolay
• Süper sanal bilgisayarlar oluşturulabilir.
Java ile Dağıtık Programlama Nasıl Gerçekleştirilir ?
1- Server bilgisayarda bir adet ServerSocket nesnesi oluşturularak müsait bir port dinlenir
(şekilde port numarası 1992 seçilmiş).
2- Client bilgisayarda bir adet Socket nesnesi oluşturularak server bilgisayarın açılan portuna
bağlantı denemesinde bulunulur (ipAdresi,1992 parametreleri ile).
3- Porta ulaşılınca 4. Adıma geçilir.
4- ServerSocket nesnesi accept() fonksiyonu aracılığıyla boş bir port açarak gelen isteği bu port
ile eşleştirir.
5- İki bilgisayar açılan portlar aracılığıyla iletişim sağlar (2071 ve 5064 portları).
DENEY 7 – GÖRÜNTÜ İŞLEME
• imread: çalışılmak istenen resim matlabda açar
• imtool : bazı işlemler yapabileceğin alan açar(clear all, all, clc)
• warp : görüntüyü belli yüzeylerde gösterir.
• rgb2gray : renkli görüntüyü griye çevirir.
• graythresh: parlaklık eşiği otomatik belirlenir.
• im2uint8 : uint8 renk hassasiyetine dönüştürür.
• Bwboundaries : binary modda bölge sınırlarını belirler.
• Edge : özel filtreler yardımyla gri seviyedeki görüntü sınırları belirlenir.
• imadjust: görüntü yoğunluğu değerini ve renk haritasını ayarlar.
• histeq: histogramı eşitleyerek kontrastı artırır.
• adapthisteq: kontrastı artırır.
• medfilt2: 2 boyutlu medyan filtreleme yapar.
• wiener2: 2 boyutlu adaptif gürültü temizleme filtresidir
İki resim arasındaki benzerlik kodu
Fırat Üniversitesi BMÜ-431
Bilgisayar Mühendisliği Bilgisayar Sistemleri Laboratuvarı
DENEY NO: 4
MOBİL UYGULAMALAR
1. DENEYİN AMACI
Bu deneyde Android tabanlı akıllı telefonlarda uygulama geliştirmek için gerekli temel bilgilerin
edinilmesi ve bazı örnek uygulamaların yapılması amaçlanmaktadır.
2. UYGULAMA GELİŞTİRMEYE GİRİŞ
2.1 Android Programlama
Bu bölümde android projenin temel bileşenlerinden bahsedilecektir. Android uygulama geliştirme
ortamı için Android Studio kullanılacaktır. Android Studio ortamında bir android projesinin dosya ve
klasörleri aşağıdaki şekildeki gibidir. Devam eden bölümde proje klasörü içerisindeki bazı temel
bileşenlerden bahsedilecektir.
Şekil 1 Android Studio proje klasör ve dosyaları
• src klasörü: Kaynak dosyaları burada yer alır. Bu klasörün içinde Java dosyalarını
tutulmaktadır.
• res klasörü: Kaynak kod dışında resimler, videolar, stiller, layout’lar gibi görsellikle ilgili her şey
res klasöründe tutulur. Uygulamanın farklı cihaz konfigürasyonlarına göre kaynak kodu
değiştirmeden kolay bir şekilde güncellenmesi sağlanır. Örneğin ekranı uzun olan ve geniş olan
iki ayrı telefon için iki ayrı layout tanımlanarak uygulamanın iki cihaz için de uyumlu olması
sağlanabilir. Res klasörü altında aşağıdaki klasörler bulunur.
o drawable klasörleri: Bu klasörler uygulamada kullanılan resim dosyalarını içerir. Bu
dosyalar PNG ya da JPEG formatında olabilir. Klasörün yanındaki hdpi (high dpi), ldpi (low
dpi), mdpi (medium dpi) ve xhpi (extra hight dpi) cihaza özel ekran çözünürlüklerine göre
dosya çağırmamızı sağlar. Örneğin uygulamanın çalıştığı cihaz eski modelse ve ekranı
düşük çözünürlük destekliyorsa ldpi klasörü içindeki resim dosyaları kullanılacaktır. Ama
uygulama yeni nesil geniş ekran bir cihazda çalışıyorsa ona uygun olarak yüksek
çözünürlüklü bir klasörde bulunan dosyalar kullanılır. Eğer uygulamanızda düzgün bir
tasarım varsa ve geniş yelpazede cihazlar destekliyorsanız dosyalarınızın tüm farklı
çözünürlüklere göre uygun formatlarının bulunması gerekir.
o layout klasörü: Burada ekranlara dair tasarım dosyaları bulunur. xml formatındaki bu
dosyalar her ekrana ait tasarımları barındırır. Bir ekran Activity ile
oluşturulduğunda onCreate metodu içinde ilgili layout çağırılır ve ekranda yer alacak
öğeler oluşturulur.
o menü klasörü: Eğer bir ekranda cihazın Menü tuşuna basıldığında bir menü çıkmasını
istiyorsak, menü elemanlarını bir xml dosyasında tanımlayarak bu klasör içine saklarız.
o values klasörü: Uygulamada kullanılan sabit değişkenler burada saklanabilir. strings.xml
dosyası uygulamada kullanılan ve ekranlarda kullanıcıya gösterilen her türlü metni saklar.
Anahtar – veri mantığıyla saklanan bu değerler kod içinde ya da layout dosyalarında
çağırılır. Aynı zamanda bu değerler R.java dosyasında işaretlenir. styles.xml dosyası ise
ekranlarda kullanılan ve yine layout dosyalarından çağrılan stilleri içerir. values klasörünün
bir başka özelliği de cihazın ayarlanmış ana diline göre yerelleşebilmesidir.
• AndroidManifest.xml dosyası: Manifest dosyasının temel görevi uygulama bileşenlerinin
sisteme bildirilmesidir. Uygulamayla ilgili her türlü özellik ve uygulamanın işletim sisteminden
talep edeceği bütün izinler burada tanımlanır. Aynı zamanda uygulama içinde kullanılan her
ekran burada kaydedilip tanımlanmak zorundadır. Aşağıdaki örnek bir AndroidManifest. xml
dosyası verilmiştir.
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
package="com.example.simpleproject"
android:versionCode="1"
android:versionName="1.0" >
<uses-sdk android:minSdkVersion="8" android:targetSdkVersion="19" />
<application
android:allowBackup="true"
android:icon="@drawable/ic_launcher"
android:label="@string/app_name"
android:theme="@style/AppTheme" >
<activity
android:name=".MainActivity"
android:label="@string/app_name" >
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
</application>
</manifest>
Bu örnekte bir tane activity tanıtılmış ve intent-filter ile bu activity’nin başlangıçta çalıştırılacak
activity olduğu belirtilmiştir. Yeni bir proje oluşturulduğunda varsayılan olarak bir tane
MainActivity eklenmektedir ve AndroidManifest dosyası otomatik bir şekilde Android Studio
tarafından oluşturulmaktadır.
Manifest dosyasında uygulamanın ihtiyaç duyduğu kullanıcı izinleri (user permissions)
belirlenmekte, uygulamanın ihtiyaç duyduğu minimum API Level, donanımsal ve yazılımsal
özellikler deklare edilmekte (kamera, bluetooth vs.), ihtiyaç duyulan api kütüphaneleri
belirtilmektedir.
Örneğin bir uygulama kameraya ihtiyaç duyuyor ve Android 2.1 (API Level 7)’den itibaren
ortaya çıkan api’leri kullanıyorsa manifest dosyasında aşağıdaki gibi belirtilmelidir.
<manifest ... >
<uses-feature android:name="android.hardware.camera.any"
android:required="true" />
<uses-sdk android:minSdkVersion="7" android:targetSdkVersion="19" />
...
</manifest>
Uygulamanın ihtiyaç duyduğu şeylerin manifest dosyasında belirtilmesi sayesinde Google Play
arama sonuçlarında bu ihtiyaçları barındırmayan telefonlara söz konusu uygulamayı
göstermeyecektir.
Bir uygulamada, gelen SMS mesajlarının görüntülenmesine ihtiyaç duyuluyorsa aşağıdaki gibi
sms’lere erişim izni manifest dosyasında belirtilmelidir.
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
package="com.android.app.myapp" >
<uses-permission android:name="android.permission.RECEIVE_SMS" />
...
</manifest>
• strings.xml dosyası: Farklı stil ve formatta global olarak erişilebilen string değişkenlerin
tanımlandığı yerdir. Kullanımı ile ilgi aşağıda bir örnek verilmiştir.
res/values/strings.xml dosyasına aşağıdaki xml kodun yazıldığını düşünelim.
<?xml version="1.0" encoding="utf-8"?>
<resources>
<string name="hello">Hello!</string>
</resources>
hello string değişkeni layout dosyasında aşağıdaki gibi çağrılır.
<TextView
android:layout_width="fill_parent"
android:layout_height="wrap_content"
android:text="@string/hello" />
Kod içerisindeki kullanımı ise aşağıdaki gibidir.
String string = getString(R.string.hello);
• Activity sınıfı: Activity sınıfı android programlamanın temel bileşenlerinden biridir. Android
uygulamada kullanıcının herhangi bir şey yapmak için etkileşimde bulunduğu her ekran bir
activity’dir. Activity’lerin uygulamada kullanılabilmesi için manifest dosyasında tanıtılması
gerekmektedir. Aşağıdaki örnekte bir activity tanımlaması verilmiştir.
<manifest ... >
<application ... >
<activity android:name=".ExampleActivity"
android:label="ExampleActivity"/>
</application ... >
...
</manifest >
android:name java class’ının adı, android:label activity’nin uygulamada görünen ismidir.
• intent sınıfı: Bir Android uygulaması birçok farklı Activity içerir. Her Activity yeni arayüzler
gösterirken belirli bir görevi (haritanın gösterilmesi, fotoğraf çekilmesi gibi) yerine getirir.
Kullanıcıyı bir Activity'den diğerine geçirmek için uygulamanızda Intent sınıfını kullanmalısınız.
Uygulamanızın yapacağı herhangi bir işte "amacı" belirtmek için Intent sınıfını kullanmalısınız.
Uygulamanızda startActivity() metoduyla sisteme Intent geçirdiğinizde, sistem doğru
uygulamayı ve eylemi belirlemek için bu Intent'i kullanır. Intent sınıfı, farklı uygulamalar
tarafından kullanılan bir activity'yi çalıştırmaya da şans verir.
Bir Intent belli bir bileşeni başlatmak (örneğin: belirli bir Activity'yi) için açık (explicit) olabilir.
Explicit intent oluşturulurken başlatılacak bileşenin class adı mutlaka verilmelidir. Bu bileşen
uygulumanız içindeki bir activity ya da servis olabilir.
Uygulama geliştirirken sıklıkla activity başlatmaya ihtiyaç duyulacaktır. Aşağıda bir activity
içerisinde başka bir activity’nin explicit şeklinde çağrılması gösterilmiştir.
Intent intent = new Intent(this, SignInActivity.class);
startActivity(intent);
Hedeflenen amacı cihazda gerçekleştirebilecek (örn: fotoğraf çekilmesi) herhangi bir
uygulamayı başlatmak için örtülü (implicit) intent kullanılır. Kendinizin gerçekleştirmediği
ancak ihtiyaç duyduğunuz bir işi cihazda yapabilen başka bir uygulamaya yaptırmak için
implicit intent kullanılır. Örneğin yaptığınız uygulamada bir içeriği kullanıcının diğer insanlarla
paylaşabilmesini istiyorsunuz. Bunun için ACTION_SEND action’ı ile bir intenti aşağıdaki gibi
oluşturabilirsiniz.
// Create the text message with a string
Intent sendIntent = new Intent();
sendIntent.setAction(Intent.ACTION_SEND);
sendIntent.putExtra(Intent.EXTRA_TEXT, textMessage);
sendIntent.setType("text/plain");
// Verify that the intent will resolve to an activity
if (sendIntent.resolveActivity(getPackageManager()) != null) {
startActivity(sendIntent);
}
Bu şekilde intenti oluşturduğunuz adnroid sistem diğer insanlara text paylaşılabilen
uygulamaları kullanıcıya gösterir. Örneğin sms, whatsapp, gmail vb. Kullanıcı da hangi
uygulama üzerinden text mesajı paylaşacağını seçer.
Uygulamanızda email, sms gönderme, durum güncelleme, veri kullanımı gibi bazı olaylar
gerçekleştirmek isteyebilirsiniz. Bunları gerçekleştirmek için bu işleri yapan activity’lerin sizin
activiy’niz olması gerekmez. Intent ile gerçekleştirmek istediğiniz işleri yapacak activity’leri
başlatabilirsiniz. Örneğin kullanıcıya uygulamanızda email göndermek istiyorsanız aşağıdaki
gibi implicit intent oluşturabilirsiniz. Dikkat edilecek olursa intent oluşturulurken başlatılacak
bileşenin class adı verilmemiş sadece yapılacak eylemin türü ACTION_SENDTO verilmiş.
public void composeEmail(String[] addresses, String subject) {
Intent intent = new Intent(Intent.ACTION_SENDTO);
intent.setData(Uri.parse("mailto:")); // only email apps should handle this
intent.putExtra(Intent.EXTRA_EMAIL, addresses);
intent.putExtra(Intent.EXTRA_SUBJECT, subject);
if (intent.resolveActivity(getPackageManager()) != null) {
startActivity(intent);
}
}
Bazen activity’lerden bir geri dönüş değeri almak isteyebilirsiniz. Bunun için startActivity()
yerine startActivityForResult() metodu kullanılır. Sonuç almak için onActivityResult() callback
metodunun override edilmesi gerekmektedir. Başlatılan activity, işini tamamladığında intent
içindeki sonuç ile onActivityResult() metoduna geri döner. Aşağıda rehberden bir kişinin
getirilmesi örneği verilmiştir.
private void pickContact() {
// Create an intent to "pick" a contact, as defined by the content
provider URI
Intent intent = new Intent(Intent.ACTION_PICK, Contacts.CONTENT_URI);
startActivityForResult(intent, PICK_CONTACT_REQUEST);
}
@Override
protected void onActivityResult(int requestCode, int resultCode, Intent
data) {
// If the request went well (OK) and the request was
PICK_CONTACT_REQUEST
if (resultCode == Activity.RESULT_OK && requestCode ==
PICK_CONTACT_REQUEST) {
// Perform a query to the contact's content provider for the
contact's name
Cursor cursor = getContentResolver().query(data.getData(),
new String[] {Contacts.DISPLAY_NAME}, null, null, null);
if (cursor.moveToFirst()) { // True if the cursor is not empty
int columnIndex = cursor.getColumnIndex(Contacts.DISPLAY_NAME);
String name = cursor.getString(columnIndex);
// Do something with the selected contact's name...
}
}
}
Android'in uygulamalara sağladığı önemli özelliklerinden biri de kullanıcıyı gerçekleştirmek
istedikleri "eyleme göre" başka bir uygulamaya yönlendirme olanağı sunmasıdır. Örneklemek
gerekirse, çeşitli resim işleme eylemleri yaptığınız bir uygulamada fotoğraf çekmek için bir
activity yazmanıza gerek yoktur. Bunun yerine fotoğraf çekilmesi için bir Intent oluşturmanız
ve çalıştırmanız yeterlidir. Sistem sizi kamera uygulamasına kendiliğinden yönlendirecektir.
Uygulamanızın Activity'leri arasında geçmek için Intent kullanmalısınız. Bunu genellikle adresi
belli intent'ler (explicit intent) kullanarak, çalıştırmak istediğiniz bileşenin class ismini
kullanarak yaparsınız, fakat başka uygulamada bir eylem gerçekleştirmek istediğinizde,
örneğin "haritayı göster" gibi, üstü kapalı intent (implicit intent) kullanmak zorundasınız.
Üstü kapalı (Implicit) intent oluşturma
Üstü kapalı intent, çalıştırmak istediğiniz bileşenin class'ını çağırmak yerine gerçekleştirmek
istediğiniz eylemi belirttiğiniz intent türüdür. Belirttiğiniz eylem ne yapılacağını belirtir,
örneğin bir şeyi göster (view), gönder (send), getir (get) gibi. Intentler eylemle ilgili çeşitli
bilgiler de taşır. Örneğin göstermek istediğiniz adres, e-posta atılacak kişi, aranacak numara
gibi. Oluşturmak istediğiniz Intent'e göre bu veri Uri veya diğer veri tiplerinin biçiminde olabilir
veya Intent'in hiçbir veri taşımaya ihtiyacı da olmayabilir.
Eğer veriniz Uri şeklindeyse, basit bir Intent() yapılandırıcı metoduyla (constructor) eylemi ve
verileri tanımlayabilirisiniz.
Örneğimizde bir telefon araması yaparken Uri verisini nasıl kullandığımızı görebilirsiniz.
Uri number = Uri.parse("tel:5323334455");
Intent callIntent = new Intent(Intent.ACTION_DIAL, number);
Uygulamanız startActivity() ile callIntent isimli Intent'i çağırdığında Telefon uygulaması ilgili
numarayı arar.
Uygulama seçim diyalogu gösterme
Bir Activity'yi oluşturduğunuz Intent'i startActivity() metoduna geçirerek başlattığınızda ve
Intent'inize yanıt verebilecek birden fazla uygulama olduğunda kullanıcı varsayılan olarak
kullanılacak uygulamayı seçebilir. (Diyalog pencereciğinin altındaki seçenek kutusunu seçerek;
Bkz: Resim 1) Bu durumlarda oluşan pencereden kullanıcı her zaman kullanacağı uygulamayı
seçebilir. Web sitesi açılışlarında kullandığı web tarayıcıyı veya fotoğraf çekmek için kullandığı
kamera uygulamasını insanlar genelde değiştirmek istemezler. Bu gibi durumlar için hoş bir
özelliktir.
Resim 2: Seçim diyalogu
Bunun yanında bazı uygulamalarda bu tercih sık sık değişebilir, örneğin paylaşma aksiyonunu
bazen Bluetooth, bazen e-posta bazen mesaj tercih edilebilir. Bunun gibi değişkenlik gösteren
isteklere karşı bir seçim ekranı kullanmanız ve her zaman kullanmanız gereklidir.
Seçim pencereciğini göstermek için createChooser() metodunu kullanarak bir Intent
oluşturup, startActivity()'ye geçirebilirsiniz. Örneğin,
Intent intent = new Intent(Intent.ACTION_SEND);
...
// arayüz metinleri için her zaman string kaynakları kullanın
// örneğin burada title değişkenine "Fotoğrafı şununla paylaş"
// metnini atamış oluyoruz
String title = getResources().getString(R.string.secici_basligi);
// seçici ekranı göstermek için Intent oluşturuyoruz
Intent chooser = Intent.createChooser(intent, title);
// Intent'in en az bir Activity çözümleneceğini doğruluyoruz
if (intent.resolveActivity(getPackageManager()) != null) {
startActivity(chooser);
}
Bu kodla createChooser() metoduna geçirilmiş Intent'e karşılık gelebilecek uygulamaların
listesini gösteren bir diyalog pencereciğinde gösterilir ve R.string.secici_basligi değişkeninden
sağlanan metin diyalog başlığı olarak kullanılır.
Diğer Uygulamaların Sizin Activity'nizi Başlatmasına İzin Vermek
Bundan önceki eğitim içeriklerinde genelde şunu yapıyorduk: kendi uygulamamızda başka
uygulamaların Activity'sini başlatıyorduk. Uygulamanız başka bir uygulama için kullanışlı
olabilecek bir eylemi gerçekleştiriyorsa, onu başka uygulamalardan gelen isteklere yanıt
verecek şekilde hazırlamanız gerekir. Örneğin kullanıcının arkadaşlarıyla mesaj veya fotoğraf
paylaştığı bir sosyal ağ uygulaması yapıyorsanız, ACTION_SEND Intent'ini desteklemelisiniz ki,
kullanıcılar başka bir uygulamadaki "paylaş" eylemini kullandıklarında bu tür eylemleri
uygulamanız üzerinden gerçekleştirebilsinler.
Diğer uygulamaların Activity'nizi başlatmasını sağlamak için manifest dosyasında uygun
<activity> elementinin içine <intent-filter> elementini koymalısınız.
Uygulamanız cihaza yüklendiğinde, sistem, uygulamanızın Intent filter'ına bakarak buradan
ürettiği bilgileri kurulu uygulamaların Intent'lerinden oluşan dâhili bir kataloğa ekler. Başka bir
uygulama startActivity() ya da startActivityForResult() metotlarını örtülü (implicit) Intent ile
çağırdığında, sistem hangi Activity'lerin çağrıyı cevaplayabileceğini bu kataloğa bakarak bulur.
Intent filter ekleme
Activity'nizin karşılayabileceği Intent'leri belirtmek için her birine (Activity'nin kabul ettiği veri
ve eyleme özel şekilde) özel intent filter'ı uygun şekilde mümkün mertebe spesifik
tanımlamalısınız.
Aşağıdaki örnekte, ACTION_SEND Intent'ine, veri tipi metin veya resim oldukça karşılık
verebilen Activity için tanımlanmış intent filter'ını görüyorsunuz:
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND"/>
<category android:name="android.intent.category.DEFAULT"/>
<data android:mimeType="text/plain"/>
<data android:mimeType="image/*"/>
</intent-filter>
</activity>
Uygulamaya gelecek her Intent bir eylem ve bir veri tipiyle gelir. Fakat tanımladığınız her
<intent-filter>'ın içinde <action>, <category> ve <data> elementlerinin örneklerini birden fazla
ilan edebilirsiniz ki, bu sorun oluşturmayacaktır.
Herhangi iki eylem ve veri çifti birbiriyle çakışıyorsa, onları kabul ettikleri veri tiplerine göre iki
ayrı intent filter olarak ayırmalısınız.
Örneğin, Activity'nizin ACTION_SEND ve ACTION_SENDTO Intent'leriyle metin ve resme
karşılık verebildiğini varsayın. Böyle bir senaryoda iki ayrı intent filter tanımlamalısınız çünkü
ACTION_SENDTO Intent'i send veya sendto Uri şemasını kullanarak, alıcının ismini tanımlarken
Uri verisini kullanmaya ihtiyaç duyar. Örneğimizi inceleyelim:
<activity android:name="ShareActivity">
<!-- metin göndermeye uygun intent-filter; SENDTO eylemini sms URI
şemalarıyla kabul eder -->
<intent-filter>
<action android:name="android.intent.action.SENDTO"/>
<category android:name="android.intent.category.DEFAULT"/>
<data android:scheme="sms" />
<data android:scheme="smsto" />
</intent-filter>

<!-- metin veya resim göndermek için intent-filter; SEND eylemini metin
veya resim verisiyle kabul eder -->
<intent-filter>
<action android:name="android.intent.action.SEND"/>
<category android:name="android.intent.category.DEFAULT"/>
<data android:mimeType="image/*"/>
<data android:mimeType="text/plain"/>
</intent-filter>
</activity>
A.ş linklerde activity’ler arası veri gönderimi örnekleri vardır.
http://developer.android.com/training/basics/firstapp/starting-activity.html
http://www.youtube.com/watch?v=SaXYFHYGLj4
2.1.1 Layout’lara giriş
Layout’lar her ekrana ait tasarımları barındırır. Aşağıda örnek bir layout verilmiştir.
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
android:layout_width="fill_parent"
android:layout_height="fill_parent"
android:orientation="vertical" >
<TextView android:id="@+id/text"
android:layout_width="wrap_content"
android:layout_height="wrap_content"
android:text="Hello, I am a TextView" />
<Button android:id="@+id/button"
android:layout_width="wrap_content"
android:layout_height="wrap_content"
android:text="Hello, I am a Button" />
</LinearLayout>
Bu layout res/layout/main_activity.xml olarak kaydedildikten sonra bir Activity’de
yüklenmesi için onCreate() metodunda aşağıdaki kodun yazılması gereklidir.
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.main_activity);
}
Resources kod içinde R ile çağrılır. Yukarıdaki örnekte görüldüğü gibi res/layout klasörü
altındaki main_activity.xml layout dosyası R.layout.main_activity şeklinde çağrılmıştır.
android:layout_height ve android:layout_width attribute’leri ya birim değer, (ör: 10dp) ya da
match_parent, fill_parent, wrap_content anahtar değerlerinden birini alırlar.
match_parent ile fill_parent aynı amaç için kullanılır elemanın parent’inin boyutlarını alırlar.
wrap_content içerik için ihtiyaç duyulan minimum boyutu alır.
layout_weight ile yatay ya da dikey olarak ekranda kalan alanın elemanlara hangi oranda
verileceğini belirlenir. Aşağıda layout_weight ile ilgil bir örnek verilmiştir.
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
xmlns:tools="http://schemas.android.com/tools"
android:layout_width="match_parent"
android:layout_height="match_parent"
android:orientation="horizontal">
<EditText android:id="@+id/edit_message"
android:layout_weight="1"
android:layout_width="0dp"
android:layout_height="wrap_content"
android:hint="@string/edit_message" />
<Button
android:layout_width="wrap_content"
android:layout_height="wrap_content"
android:text="@string/button_send" />
</LinearLayout>
Yukarıdaki kodun ekran görüntüsü aşağıda verilmiştir.
Yukarıdaki örnekte EditText aşağıdaki gibi değiştirilirse
<EditText android:id="@+id/edit_message"
android:layout_width="wrap_content"
android:layout_height="wrap_content"
android:hint="@string/edit_message" />
Aşağıdaki görünüm elde edilir.
Yaygın layout’lar: Linear, Relative ve Web View’dir. Linear layout ile elemanlar yatay ya da dikey
doğrultuda yerleştirilir. Relative layout’da elemanların konumları birbirlerine göre tanımlanır.
Örneğin B elemanının konumu A elemanın solundadır şeklinde tanımlanabilir. Web view ile web
sayfaları görüntülenir.
Relative layout’un bazı özellikleri aşağıda verilmiştir.
android:layout_alignParentLeft="true",elemanın sol kenar hizasını parent elemanın sol kenar
hizasına getirir.
android:layout_alignParentTop="true", elemanın üst kenar sol hizasını parent elemanın üst kenar
hizasına getirir.
android:layout_below="@id/name", elemanı id’si “name” olan elemanın altına yerleştirir.
android:layout_toLeftOf="@+id/times", elemanı id’si “times” olan elemanının soluna yerleştirir.
Aşağıda relative layout ile ilgili bir örnek verilmiştir.
2.1.2 Basit Bir Proje Yapma ve Telefona Yükleme
Basit bir örnek yapmak için 3. Bölümde anlatılan Android Studio Kurulumu ve Akıllı Telefon
yapılandırılması adımlarını uygulayınız.
Bu bölümde başka bir activity başlatma ve activity’ler arası veri gönderme örneği yapılacaktır.
Örneği http://developer.android.com/training/basics/firstapp/index.html adreslerindeki adımları
takip ederek de deneyebilirsiniz.
Activity ekranları aşağıdaki şekildeki gibidir.
Şekil 2 Örnek uygulamanın ekran görüntüleri
Android Studio ortamında yeni bir proje açıp proje adını giriniz.
Şekil 3 Yeni proje ekranı
Uygulamanızı Google Play Store’ye yüklemeyi düşünürseniz, uygulamanızın paket adı (package
name) Google Play Store’de bulunan uygulamalarla aynı isimde olmamalıdır. Başka uygulamalarla
karıştırılmaması için mümkün olduğunca kendine has bir isim verilmelidir. Minimum Required SDK ile
yaptığımız uygulamanın hangi minimum SDK’da çalışabileceği belirlenmektedir. Burada seçilen min
SDK’nın altındaki SDK’larda uygulama çalışmayacaktır. Next’lerle ilerleyip projeyi oluşturunuz.
Aşağıdaki gibi bir ekran gelecektir.
Şekil 4 Android Studio proje ortamı
Uygulamayı Telefonda çalıştırmak için Run > Edit Configurations kısmında Target Device olarak
USB device seçiniz.
Telefonunuzu bilgisayara bağlayıp run butonu ile uygulamayı telefonunuzda çalıştırınız.
res/values/string.xml dosyasına edit_message, button_send değişkenlerini aşağıdaki gibi
ekleyiniz.
res/layout/activity_main.xml dosyasına EditText ve Button elemanlarını aşağıdaki gibi ekleyiniz.
Button elemanının onClick event’ine sendMessage fonksiyon adını veriniz. Bu fonksiyonun java
tarafındaki tanımını ileride verilecektir.
Şimdi projeye yeni bir Activity daha eklenecektir. Sol taraftaki java dosyalarının bulunduğu pakete
sağ tıklayıp New>Activity>Blank Activity’i seçip aşağıdaki gibi isim verip Hierarchical Parrent’ten
projedeki MainActivity’yi seçiniz.
Şekil 5 Yeni bir activity ekleme penceresi
res/layout/activity_display__text_message.xml dosyasında TextView ya da başka bir eleman varsa
siliniz. Dosyanın içinde aşağıdaki gibi olacaktır.
MainActivity.java dosyasına EXTRA_MESSAGE adında bir string ve sendMessage metodunu
ekleyiniz. Bu metot ile Display_TextMessage activity’si başlatılmakta ayrıca bu activity’ye bir string
mesaj gönderilmektedir. Eklenilen kodlar için gerekli kütüphaneleri de import ile ekleyiniz.
public final static String EXTRA_MESSAGE = "com.mycompany.myfirstapp.MESSAGE";
Display_TextMessage.java dosyasının onCreate metodunda gelen intent nesnesini ve gönderilen
string mesajını alınız. Gelen mesajı bir TextView’de gösteriniz. Eklenilen kodlar için gerekli
kütüphaneleri de import ile ekleyiniz.
Bu aşamada activity’ler arası string mesajı için gerekli kodlamalar tamamlanmıştır. Şimdi sıra
uygulamayı çalıştırmaktadır. Uygulamanın emülatör ortamında mı yoksa bilgisayara bağlı bir
telefonda mı çalıştırılacağı Run menüsü altındaki Edit Configurations ile belirlenmektedir.
2.1.3 Accelerometer Sensor Örneği
Bu bölümde Accelerometer Sensor (ivme ölçer sensör) kullanımı ile ilgi bir örnek yapılacaktır.
Accelerometer sensor koordinat eksenlerine (x,y,z) göre ivmeyi ölçmek için kullanılmaktadır. Telefon
dik bir şekilde tutulduğunda koordinat eksenlerinden y ekseni yukarı ve aşağı yönlerini, x ekseni sağ
ve sol yönlerini z ekseni de ileri ve geri yönlerini göstermektedir. Telefon yatay bir şekilde
tutulduğunda ise telefonun dikey konumdaki durumuna göre y ve z eksenleri yer değiştirmektedir.
Şekil 6 Telefon konumuna göre koordinat eksenleri
Telefon hangi yönde ivmeli hareket ederse bu değer sensörlere hemen yansıtılmaktadır.
Acceleromer sensör yerçekimini de dikkate almaktadır. Telefon resimdeki gibi sabit bir şekilde
tutulduğunda sensörün gönderdiği değerler y ekseni için 9.8m/s2, x ve z eksenleri için 0m/s2
olacaktır.
Aşağıda kodları verilen uygulama x, y ve z eksenleri için accelerometer sensörünü dinlemekte
ve değerleri anlık olarak göstermektedir. Uygulama telefona yüklenip telefon eksenlerden
herhangi bir yöne doğru ivmeli hareket ettirildiğinde değerlerin önceki değerlere göre bariz bir
şekilde değiştiği görülecektir. Uygulamanın ekran görüntüsü aşağıdaki görüntüye benzer
olacaktır.
Şekil 7 Accelerometer sensör örneği ekran görüntüsü
Uygulamada sensör kullanımı için Activity sınıfınıza SensorEventListener arayüzünü ekleyiniz.
public class MainActivity extends Activity implements SensorEventListener
Activity içerisindeki onCreate metodunda sistem servislerinden sensör servisini çağırarak
Accelerometer sensörünü dinleyici olarak atayınız.
sm = (SensorManager) getSystemService(Context.SENSOR_SERVICE);
accelerometer = sm.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
sm.registerListener(this, accelerometer, SensorManager.SENSOR_DELAY_NORMAL);
Burada yapılan işlem sonrasında Accelerometer adlı sensörden gelen hareketler
onSensorChanged metodu içerisinde dinlenmeye başlanacaktır. registerListener metodu içerisinde
tanımlanan SENSOR_DELAY_NORMAL değişkeni sensörün duyarlılığını belirler. Burada
kullanabileceğimiz değerler aşağıdaki gibidir:
SENSOR_DELAY_NORMAL: Kullanıcının basit hareketlerini düşük duyarlılıkla takip eder. (215 - 230 ms)
SENSOR_DELAY_FASTEST: Sensörden gelen hareketlerin mümkün olduğu kadar fazla kısmının
değerlendirilmesini sağlar. (15-20 ms)
SENSOR_DELAY_GAME: Oyun uygulamaları için yüksek duyarlılıkla dinleme gerçekleştirir. (35-40 ms)
SENSOR_DELAY_UI: Normal kullanım için idealdir. (85-90 ms)
Örnek uygulamanın kodları aşağıda verilmiştir.
#MainActivity.java
package com.example.accelerometer;
import android.app.Activity;
import android.content.Context;
import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorEventListener;
import android.hardware.SensorManager;
import android.os.Bundle;
import android.widget.TextView;
public class MainActivity extends Activity implements SensorEventListener {
Sensor accelerometer;
SensorManager sm;
TextView acceleration;
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);
sm = (SensorManager) getSystemService(Context.SENSOR_SERVICE);
accelerometer = sm.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
sm.registerListener(this, accelerometer,
SensorManager.SENSOR_DELAY_NORMAL);
acceleration = (TextView) findViewById(R.id.acceleration);
}
@Override
public void onSensorChanged(SensorEvent arg0) {
if (arg0.sensor.getType() == Sensor.TYPE_ACCELEROMETER) {
float[] values = arg0.values;
float x = values[0];
float y = values[1];
float z = values[2];
acceleration.setText("X: " + x + "\nY: " + y + "\nZ: " + z);
}
}
@Override
public void onAccuracyChanged(Sensor arg0, int arg1) {
// TODO Auto-generated method stub
}
}
activity_main.xml layout’una x,y,z eksenlerindeki ivmeleri göstermek için bir TextView ekleyiniz.
#activity_main.xml
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
xmlns:tools="http://schemas.android.com/tools"
android:layout_width="match_parent"
android:layout_height="match_parent"
tools:context="${relativePackage}.${activityClass}" >
<TextView
android:id="@+id/acceleration"
android:layout_width="wrap_content"
android:layout_height="wrap_content"
android:text="X: \nY: \nZ:" />
</RelativeLayout>
2.1.3 Telefon Arama Örneği
Bu örnekte girilen telefon numarasını arayan uygulama yapılmıştır. Uygulamanın ekran görüntüsü
aşağıdaki gibidir.
MainActivity.java
package com.example.ertan.phonecall;
import android.content.Intent;
import android.net.Uri;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.view.View;
import android.widget.EditText;
import android.widget.ImageButton;
import android.widget.Toast;
public class MainActivity extends AppCompatActivity {
private static final int RESULT_PICK_CONTACT = 855;
private EditText numara;
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);
numara = (EditText) findViewById(R.id.id_numara);
ImageButton ara_button = (ImageButton)
findViewById(R.id.id_call_image);
ara_button.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Intent call_intent = new Intent(Intent.ACTION_CALL);
call_intent.setData(Uri.parse("tel:" + numara.getText()));
try{
startActivity(call_intent);
}catch(android.content.ActivityNotFoundException e){
Toast.makeText(getApplicationContext(), "yourActivity
is not founded", Toast.LENGTH_SHORT).show();
}
}
});
}
}
activity_main.xml
Arama butonu imageButton’dur. İmage drawable klasörü içindedir, drawable/call.png.
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
xmlns:tools="http://schemas.android.com/tools"
android:layout_width="match_parent"
android:layout_height="match_parent"
android:paddingLeft="@dimen/activity_horizontal_margin"
android:paddingRight="@dimen/activity_horizontal_margin"
android:paddingTop="@dimen/activity_vertical_margin"
android:paddingBottom="@dimen/activity_vertical_margin"
tools:context=".MainActivity"
android:orientation="vertical">
<EditText
android:layout_width="wrap_content"
android:layout_height="wrap_content"
android:id="@+id/id_numara"
android:hint="Arayacağınız numarayı giriniz"/>
<ImageButton
android:id="@+id/id_call_image"
android:layout_width="wrap_content"
android:layout_height="wrap_content"
android:src="@drawable/call"
android:layout_alignParentBottom="true"
android:layout_alignParentRight="true"
/>
</LinearLayout>
AndroidManifest.xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
package="com.example.ertan.phonecall" >
<uses-permission android:name="android.permission.CALL_PHONE"/>
<application
android:allowBackup="true"
android:icon="@mipmap/ic_launcher"
android:label="@string/app_name"
android:supportsRtl="true"
android:theme="@style/AppTheme" >
<activity android:name=".MainActivity" >
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER"
/>
</intent-filter>
</activity>
</application>
</manifest>
3. ANDROİD STUDİO KURULUMU VE TELEFON AYARLARININ YAPILMASI
3.1 Android Studio Kurulumu
1) Aşağıdaki linkten Android Studio’yu kurunuz.
http://developer.android.com/sdk/index.html
2) Tools menüsü altında Android > SDK Manager ’ı çalıştırıp
http://developer.android.com/sdk/installing/adding-packages.html adresinde belirtilen
güncellemeleri yapınız.
3.2 Akıllı Telefon Ayarlarının Yapılması
1) Eğer işletim sistemi akıllı telefonunuzun USB sürücüsünü yükleyememişse
http://developer.android.com/tools/extras/oem-usb.html#Drivers adresinden telefonunuzun USB
sürücüsünü yükleyiniz.
2) Telefonun Ayarlar> Güvenlik > Bilinmeyen kaynaklar kısmını aktif ediniz.
3) Androdi 4.2 ve sonrasında Geliştirici seçenekleri default olarak gizlidir. Bunu açmak için
Ayarlar> Genel >Cihaz Hakkında bölümüne girip Yapım numarası kısmına arka arkaya birkaç kez
tıklayınız.
Daha sonra Ayarlar > Genel > Geliştirici seçenekleri kısmında USB hata ayıklama (USB debugging)
kısmını aktif ediniz.
3) Son adımda Android Studio ortamından telefonunuza uygulama yüklemek için güvenlik iznini
onaylayınız.
4. UYGULAMA ÖDEVLERİ
Android Ödev Uygulamalarında sensörler kullanılacaktır. Bu nedenle uygulama sınavı sırasında
accelerometer sensöre sahip android telefon bulundurulmalıdır. Uygulama sınavı öncesi hazırlık
çalışmalarının da gerçek telefon üzerinden yapılması tavsiye edilmektedir.
4.1 Y-Ekseni Boyunca Adım Sayıcı Uygulaması
Telefon Şekil 8’deki gibi yatay tutulup y ekseni boyunca hareket ettirildiğinde accelerometer
sensörünü dinleyiniz belirlediğiniz uygun bir eşik değeri ile adım atma hareketini yakalayıp adım
sayısını ekranda gösteriniz. Uygulamaya “Başla”, “Bitir”, “Hedef Belirle”, “Geçmişi Göster”
butonlarını ekleyiniz. Adım sayıcıyı “Başla” butonuna tıklandığında başlatınız ve ekranda atılan adım
sayısını anlık olarak gösteriniz. “Bitir” butonuna tıklandığında adım sayıcıyı sonlandırıp adım sayısını
gösteriniz; tarih, saat ve adım sayısı bilgilerini bir dosyaya yazınız. “Hedef Belirle” butonuna
tıklandığında hedeflenen adım sayısını kullanıcıdan alınız, hedeflenen adım sayısına yaklaştıkça
kullanıcıya “son 50 adım”, “son 10 adım” gibi uyarı veriniz. “Geçmişi Göster” butonuna basıldığında
dosyaya kaydedilen tarih, saat ve adım sayısı kayıtlarını yeni bir activity’de gösteriniz.
Şekil 8 Y-ekseninde adım sayıcı için telefonun yatay pozisyonu
4.2 Yukarı, Aşağı, Sağa ve Sola Doğru Yapılan Hareketleri Tanıyan Servis Uygulaması
Yukarı, aşağı, sağa ve solo yöne doğru yapılan hareketleri tanıyan bir android servis uygulaması
yapınız. Telefon dik şekilde tutulup y-ekseninde + yönde (yukarı) ivmeli bir hareket ettirildiğinde
telefonun sesini kısınız, aşağı yönde ivmeli hareket ettirildiğinde ise telefonun sesini azaltınız, sağa
doğru hareket ettirildiğinde telefonun varsayılan müzik çaları çalıyorsa sonraki müziği başlatınız, sola
doğru hareket ettirildiğinde telefonun varsayılan müzik çaları çalıyorsa önceki müziği başlatınız.
Yaptığınız uygulamayı telefonun varsayılan müzik çaları ile test ediniz.
4.3 Telefonu Titretme Oyunu
-Uygulamada oyuncunun ismi alınacak ya da var olan daha önce eklenen oyuncu isimlerinin ve
skorlarının tutulduğu listeden bir oyuncu seçilecektir.
-Başla butonuna tıklanıldığında 10 sn’lik bir bir sayaç başlatınız. Süre içerisinde telefon titretildikçe
belirlenen bir eşik değerinin üstündeki titretme sayısını tutunuz.
-Süre bittiğinde titretme hareketini saymayı sonlandırınız ve titretme sayısını gösteriniz.
-Oyuncu listesinde oyuncuların isimleri ve yapmış oldukları maksimum titretme sayısı tutulacaktır.
-Yeni bir rekor kırıldığında oyuncunun adı ve rekoru notification(bildirim) olarak gösteriniz.
4.4 Telefonu Sallama Hareketini Tanıyan ve Müzik Çalan Uygulama
Telefonu sallama hareketini tanıyan (shake detection) ve bu hareket olduğunda müzik çalan bir
android uygulama yapınız. Uygulamada çalınacak müzik kullanıcı tarafından seçilecektir. Bunun için
uygulamaya bir dosya seçici (file chooser) ekleyiniz. Telefon sallandığında kullanıcının seçtiği mp3
dosyasını MediaPlayer sınıfını kullanarak yürütünüz, ekranda “çalıyor” yazısını gösteriniz. Telefon
tekrar sallandığında media player’i durdurup ekranda “durduruldu” yazısını gösteriniz. Telefon
sallandıkça çalma ve durdurma işlemleri tekrar edilecektir. Müzik bittiğinde ise “bitti” uyarısını
gösteriniz.
Not: Düzgün bir şekilde test yapmak için müzik içerisinde duraklamaların olmadığı bir mp3 dosyası
kullanınız.
4.5 Android Kayıt Defteri Uygulaması
Uygulama Kayıt Ekle, Listele, Depola, Yükle işlemlerinden oluşacaktır.
- Ana Ekran
Ana aactivty’de uygulamada yapılacak
işlemler buttonlarla gösterilecektir. Çıkış
buttonuna tıklanıldığında veriler dosyaya
kaydedilmişse dosyaya kaydedilip program
kapatılacak. Dosya adı olarak daha önce bir şey
girilmemişse dosya adına sistem tarihi verilecek.

- Kayıt Ekle
Kayıt Ekle activity’de Ekle buttonuna
tıklanıldıkça girilen kayıtlar bellekte istenildiği
şekilde tutulacak, Tamam buttonuna basılınca
Ana Ekran’a geri dönülecek.
- Depola
Depola activity’de bellekte tutulan veriler
girilen dosya adında bir dosyaya “isim,yaş,D.Yeri
“ formatında satır satır kaydedilecektir
- Yükle
Yükle activity’de daha önceden kayıtlı
dosyalar listelenecek. Seçilen dosyadaki veriler
belleğe yüklenecek.
- Listele
Listele activity’de bellekte tutulan kayıtlar
listelenecek.
4.6 Mp3 Çalar
-Uygulamada belirtilen klasördeki mp3 dosyaları oynatılacak.
- Oynatma ekranına “SeekBar” eklenecek, oynatılan müziğin herhangi bir anına geçiş yapılabilecek
-Oynat, durdur, sonrakini öncekini oynat işlemleri yapılacak.
29
-Çalma listesi oluşturulabilecek. Çalma listesi ekranında daha önce oluşturulan listeler listelenecek,
seçilen liste oynatılabilecek, yeni liste oluşturulabilecek.
-Çalma listesine geçiş oynatma ekranındaki menüden yapılacaktır.
4.7 Resim Galerisi
-Uygulamada belirtilen dosyadaki resimler
GridView, GridViewAdapter kontrolleri
kullanılarak küçük boyutlarda listelenecektir.
Örnek ekran görüntüsü aşağıda verilmiştir.
30
-GridView içindeki herhangi bir resme
tıklanıldığında başka bir ekranda resmin büyük
hali gösterilecektir.


- GridView içindeki herhangi bir resme basılı
tutulduğunda resmin oluşturulma tarihi, boyutu,
yolu gibi ayrıntı bilgileri pop up pencerede
gösterilecektir.
4.8 Telefon Sallandığında Arama Yapan Servis Uygulaması
-Accelerometer sensörü kullanılarak telefonda sallama hareketini (shake detection) tanıyan
-Sallama hareketi olduğunda son aranan numarayı arayan
-Arama bittiğinde arama süresini notification (bildirim) olarak gösteren Servis uygulaması yapınız.
31
32
5. UYGULAMA SINAVI
5.1 Uygulama Sınavında Bulunması Gerekenler
Uygulama sınavına girecek her öğrenci Android Studio programlarının kurulu olduğu bir bilgisayar
ve accelerometer sensöre sahip android tabanlı bir akıllı telefon getirmelidir.
5.2 Uygulama Sınavında Bilinmesi Gerekenler
-Android Ödev Uygulamalarında sensörler kullanılacaktır. Bu nedenle uygulama sınavı sırasında
accelerometer sensöre sahip android telefon bulundurulmalıdır. Uygulama sınavı öncesi hazırlık
çalışmalarının da gerçek telefon üzerinden yapılması tavsiye edilmektedir.
-Android programlamanın temel bileşenleri hakkında aşağıdaki dokümanlar okunacaktır.
http://developer.android.com/guide/components/fundamentals.html
http://developer.android.com/guide/practices/compatibility.html
http://developer.android.com/guide/topics/security/permissions.html
http://developer.android.com/guide/components/intents-filters.html
http://developer.android.com/guide/components/activities.html
(Not: Uygulama sınavında bu kaynaklarla ilgili sorular sorulacaktır.)
-Her öğrenci kendisine verilen ödevde istenilen şeylerle ilgili temel bileşenlerin nasıl kullanıldığını
bilmelidir. Bu bileşenlerin kullanımı ile ilgili küçük bir uygulama veya ödevde değişiklik istenecektir.
-Android uygulamaları için temel arayüz elemanlarının (text field, buton, list) kullanımı, ekranlar
arası geçiş ve veri aktarımı gibi temel işlemlerin ve ivme sensörü kullanımının öğrenilmesi
beklenmektedir.
Her öğrenci kendisi için belirlenen ödevi yapacaktır. Ödevlerde yapılacaklar “4. UYGULAMA
ÖDEVLERİ” bölümünde açıklanmıştır.
5.3. Birinci Öğretim Ödev Dağılımları
“4.1 Y-Ekseni Boyunca Adım Sayıcı Uygulaması” ödevini ödev detayında açıklanan şekliyle eksiksiz
gerçekleştiriniz.
Her öğrenci kendisine verilen ödevde istenilen şeylerle ilgili temel bileşenlerin nasıl kullanıldığını
bilmelidir. Bu bileşenlerin kullanımı ile ilgili küçük bir uygulama veya ödevde değişiklik istenecektir.
5.4. İkinci Öğretim Ödev Dağılımları
“4.3 Telefonu Titretme Oyunu” ödevini ödev detayında açıklanan şekliyle eksiksiz gerçekleştiriniz.
Her öğrenci kendisine verilen ödevde istenilen şeylerle ilgili temel bileşenlerin nasıl kullanıldığını
bilmelidir. Bu bileşenlerin kullanımı ile ilgili küçük bir uygulama veya ödevde değişiklik istenecektir.
33
6. KAYNAKLAR
6.1. Genel kaynaklar
• http://developer.android.com/training/index.html
• http://developer.android.com/samples/index.html
• http://developer.android.com/guide/index.html
• http://www.vogella.com/tutorials/android.html
• http://www.tutorialspoint.com/android/
• http://www.coreservlets.com/android-tutorial/
• http://androidexample.com/Android_Basic_Tutorial/index.php?view=category&categoryid=2
3
• https://www.technopat.net/tag/android-programlama/
• http://www.devfright.com/
• https://gelecegiyazanlar.turkcell.com.tr/konu/android/egitim/android-201/android-cihazlarve-android-isletim-sistemi-uzerine-genel-bilgiler
6.2 Yabancı üniversitelerden kaynaklar
• http://cs76.tv/2012/spring/
• http://www.youtube.com/watch?v=HgSMtGXq1aA&index=1&list=PLxrgvRt_aRIEum8eeVp0a
peML4AZMapJ5
6.3 Android Sensor için kaynaklar
• http://www.vogella.com/tutorials/AndroidSensor/article.html
• http://nebomusic.net/androidlessons/Pedometer_Project.pdf
• http://jasonmcreynolds.com/?p=388 (ShakeDetector)
6.4 Android Servis uygulaması için kaynaklar
• http://developer.android.com/guide/components/services.html
• http://developer.android.com/training/best-background.html
• http://developer.android.com/samples/RepeatingAlarm/AndroidManifest.html
• http://www.vogella.com/tutorials/AndroidServices/article.html
6.5 Android dosya seçici için kaynak
• https://github.com/iPaulPro/aFileChooser/blob/master/aFileChooserExample/src/com/ipaul
pro/afilechooserexample/FileChooserExampleActivity.java
1
Fırat Üniversitesi BMÜ-431
Bilgisayar Mühendisliği Bilgisayar Sistemleri Laboratuvarı
DENEY NO: 5
GÖMÜLÜ SİSTEM PROGRAMLAMA
1. GİRİŞ
Gömülü sistemler için kesin bir tanım yapmak kolay değildir. Ama basitçe gömülü sistemi, daha
büyük bir sistem içinde belirli kontrol işlevleri için tasarlanmış bilgisayar sistemi olarak tarif edebiliriz.
Gömülü sistemler genelde mekanik ve donanım yapısını da içeren bir cihazının parçasını oluşturur. Bu
sistemler, gömüldüğü cihazın kontrolü, izlenmesi veya çalışmasına yardımcı olması için kullanılır.
Gömülü sistem, bilgisayarın kendisini kontrol eden cihaz tarafından içerildiği özel amaçlı bir sistemdir.
Genel maksatlı, örneğin kişisel bilgisayar gibi bir bilgisayardan farklı olarak, gömülü bir sistem kendisi
için önceden özel olarak tanımlanmış görevleri yerine getirir. Sistem belirli bir amaca yönelik olduğu
için tasarım mühendisleri ürünün boyutunu ve maliyetini azaltarak sistemi uygunlaştırabilirler.
Gömülü sistemler genellikle büyük miktarlarda üretildiği için maliyetin düşürülmesinden elde
edilecek kazanç, milyonlarca ürünün katları olarak elde edilebilir.
Gömülü bir sistemin çekirdeğini, belirli bir sayıda görevi yerine getirmek için programlanan
mikroişlemciler ya da mikro denetleyiciler oluşturur. Kullanıcıların üzerinde istediği yazılımları
çalıştırabildiği genel maksatlı bilgisayarlardan farklı olarak, gömülü sistemlerdeki yazılımlar yarı
kalıcıdırlar ve firmware ismiyle anılırlar. Gömülü sistemlere aşağıda maddeler halinde verilen çeşitli
örnekler sunulabilir:
• Banka ATM’leri
• Cep telefonları
• Yönlendirici (router), timeserver ve güvenlik duvarı (firewall) gibi bilgisayar ağ ekipmanları
• Bilgisayar yazıcıları
• Hesap makineleri
• Mikro dalga fırınlar, çamaşır makinesi, televizyon setleri ve DVD oynatıcı/kaydedici gibi ev
elektroniği ürünleri.
Şekil 1. Gömülü sistem içeren çeşitli örnekler
2
1.1. Özellikleri
1. Genellikle ya hiç ya da çok kısıtlı kullanıcı ara yüzüne sahiptirler.
2. Verimlilik gömülü istemler için büyük önem taşır. Güç tüketimi, kod boyutu ve yürütme
zamanı gibi kriterlerin, maliyet açısından optimize edilmesi gerekir. Bu özelliği ile masaüstü
bilgisayar uygulamalarından ayrılır.
3. Gömülü sistem programları sürekli olarak yürütülür.
4. Gömülü sistemler genellikle gerçek zamanlı kısıtlamaları karşılamak üzere tasarlanmıştır.
5. Yazılım ve donanım olmak üzere iki ana kısımdan oluşurlar.
2. GÖMÜLÜ SİSTEM PROGRAMLAMA
Gömülü sistem programlama masaüstü bilgisayarlar üzerinde geliştirilen uygulamalardan
faklıdırlar. Bu iki sistem arasındaki ana farkları aşağıdaki gibi sıralayabiliriz.
• Gömülü cihazlar sınırlı kaynağa sahiptirler.(sınırlı ROM, Sınırlı RAM, düşük işlemci gücü, sınırlı
yığın alanı gibi)
• Gömülü sistemler ile bilgisayarda kullanılan bileşenler farklıdır.
• Gömülü sistemlerde tipik olarak daha küçük ve daha az güç tüketen bileşenler kullanılır.
• Gömülü sistemler daha fazla donanıma bağlıdırlar.
Gömülü Programlamada göze çarpan en önemli iki özellik kodun hızı ve büyüklüğüdür. Kodun hızı
işlemci gücü, zamanlama kısıtlamaları ile yönetilirken, kodun boyutu mevcut program hafızası ve
kullanılan programlama diline bağlıdır. Gömülü sistem programlamadaki hedef Minimum alan ve
minimum zamanda maksimum özellikli program elde etmektir.
2.1. Gömülü Sistemde Kullanılan Diller
Gömülü sistemler farklı tür diller kullanılarak programlanırlar.
• Makine kodu
• Düşük seviyeli diller (assembly)
• Yüksek seviyeli diller (c, c++,java, ada)
• Uygulama Düzeyi Diller(Visual Basic, Access)
Gömülü sistem programlamada temel olarak kullanılan dil C ile programlamadır. Bu amaçla
gömülü C adı verilen programlama dili kullanılmaktadır. Normal yapıdaki C dili ile neredeyse aynı
özelliklere sahip olan bu programlama dili ile gömülü sistem programlaması yapılabilmektedir. Başka
bir deyişle gömülü C mikro denetleyici tabanlı uygulamalar için, C ise masaüstü bilgisayarlar için
kullanılmaktadır.
Gerçekleştirilecek bu deney çalışmasında gömülü C programlama dili kullanılacak ve işlemler bu dil
üzerinden yapılacaktır.
3. ARDUINO NEDİR?
Bu bölümde Arduino’nun kurulumu, geliştirme ortamı ve özelliklerinden bahsedilecektir. Temel
olarak Arduino gömülü sistem programlama için kullanılabilecek araçlardan birisidir. Arduino
elektronik sistemler ve interaktif projeler gerçekleştirebileceğiniz bir elektronik prototip geliştirme
aracıdır. Arduino’nun UNO, Mega, Mega ADK, LilyPad ve Nano gibi çeşitleri bulunmaktadır. Bütün bu
Arduino kartları aynı şekilde programlanabilmekle beraber yetenekleri ve fonksiyonları arasında bazı
farklılıklar bulunmaktadır.
3
Tablo 1. Arduino çeşitleri ve örnekleri
Arduino Uno Arduino Mega
Üzerinde 14 dijital, 6 analog giriş-çıkış pini
bulunur. USB üzerinden Arduino geliştirme
ortamıyla programlanabilmektedir.
Üzerinde UNO modelinkinden farklı bir
mikrodenetleyici bulunmaktadır. UNO’dan farkı
daha fazla giriş çıkış pinine sahip olmasıdır. Fazla
sayıda giriş/çıkış pini gerektiren uygulamalarda
kullanılmaktadır.
Arduino LilyPad
Lilypad modeli kumaş ve giysiler üzerinde
dikilebilen ilginç projelerde kullanılmak üzere
geliştirilmiş bir Arduino modelidir. Üzerinde
USB–Seri dönüştürme çipi olmadığından harici
bir modülle programlanabilmektedir.
Arduino Nano”yu Mini-USB kablosu üzerinden
programlamayabilir ve devre tahtası üzerinde
uygulamalar gerçekleştirilebilmektedir.
Arduino temel olarak nedir ve onunla neler yapabiliriz?
• Kolay bir şekilde çevresiyle etkileşime girebilen sistemler tasarlayabileceğiniz açık kaynaklı bir
geliştirme platformudur.
• Arduino kartları üzerinde Atmega firmasının 8 ve 32 bit mikrodenetleyicileri (arduino due)
bulunur.
• Arduino üzerinde Atmega328 mikrodenetleyici bulunmaktadır.
• Arduino kütüphaneleri ile mikrodenetleyicileri kolaylıkla programlayabilirsiniz.
• Analog ve dijital girişleri sayesinde analog ve dijital verileri işleyebilirsiniz.
• Sensörlerden gelen verileri kullanabilirsiniz
• Dış dünyaya çıktılar (ses, ışık, hareket vs…) üretebilirsiniz.
4
Arduino Uno’nun özellikleri aşağıda maddeler halinde verilmiştir:
• Arduino Uno, ATmega328 tabanlı bir mikroişlemci geliştirme kartıdır. En çok kullanılan
Arduino çeşididir.
• Kartta,14 dijital giriş/çıkış pini bulunur, bunlardan 6′sı PWM çıkışı olarak kullanılabilir ve 6
analog giriş pinine sahiptir.
• 16 MHz kristal osilatörü, USB bağlantısı, 2.1mm güç girişi, ICSP başlığı ve reset butonu vardır.
• Bilgisayar ile USB portu üzerinden bağlamanız kartın çalışması için yeterlidir, pil, adaptör ya
da DC 7~12V güç kaynağına bağlayarak kullanılabilir.
Arduino’nun en önemli özelliklerinden biriside ek kartlara yani shield diye adlandırılan çeşitli
arabirimlere sahip olmasıdır. Başka bir deyişle, örneğin projenizde wireless ile ilgili bir bölümü
gerçekleştireceğinizi ve Arduino üzerinde bu tip bir özelliği destekleyen modül bulunmadığını
varsayalım. Dışarıdan hazır olarak alacağınız wireless shield’ı Arduino’nuza bağlayarak sisteminize bu
tür bir özelliği kazandırabilmektesinizdir. Bu ve bunun gibi shield listesine http://shieldlist.org/
sitesinden bakabilir ve projelerinize uygun ek kartları temin edebilirsiniz.
3.1. Arduino Yükleme Yönergesi
• Arduino’lar Windows / Linux / Mac platformlarında çalışabilmektedir. Bu bölümde Windows
işletim sistemi için kurulum işlemi anlatılacaktır.
• http://arduino.cc/en/Main/Software adresinden Windows’a tıklayıp gerekli yazılımı indirin.
• Arduino’nuzu USB kablosuyla bilgisayarınıza bağlayın.
• Bilgisayarınız Arduino’yu tanımaya çalışacak, fakat bir süre sonra başarısız olacaktır. Sırasıyla
Başlat > Denetim Masası > Aygıt Yöneticisi adımlarına girin. COM & LPT Portları altında
Arduino’nuzu bulun (Arduino UNO (COMxx) şeklinde yazacaktır).
• Sağ tıklayıp “Sürücüyü güncelle” seçeneğini seçin. “Sürücüyü kendim seçmek istiyorum”
seçeneğini seçin.
• Windows sürücünün nerede olduğunu soracaktır. İndirdiğiniz .zip dosyasını bir klasöre açıp o
klasörde Arduino/drivers dizini altındaki “arduino.inf”i seçin ve tamama basın.
• Yükleme işleminin ardından arduino’nuzu kullanabilirsiniz.
• Uygulamayı çalıştırmak için arduino.exe dosyasının çalıştırılması yeterlidir.
• Buraya kadar herhangi bir sorunla karşılaşmadıysanız Tools > Serial Port’tan Arduino’nuzu
bağladığınız USB portunu seçin. Seçmediyseniz yazdığınız programı Arduino’ya yüklerken
sorduğunda da seçebilirsiniz.
• Tools > Board menüsünden kullandığınız Arduino çeşidini işaretleyin.
• Ayrıca File > Examples menüsünde önceden yazılmış birçok farklı programı inceleyebilirsiniz.
3.2.Proteus Isis’e Ardunio Kütüphanesi Ekleme
• Tasarımımızın düzgün çalışıp çalışmadığını, bir hata yapmışsak nerede hata yaptığımızı
simülasyonda çok rahat görebiliriz.
• Öncelikle aşağıdaki bağlantıdan sıkıştırılmış dosyamızı indirelim.
• https://drive.google.com/file/d/0B5vddbSlyKoZeXlJNUV5QmNlSlE/edit
• Dosyaları klasöre çıkarttığımızda oluşan iki adet dosyayı;
• Proteus 7 kullanıyorsak: C:\Program Files\Labcenter Electronics\Proteus 7
Professional\LIBRARY dizinine
• Proteus 8 kullanıyorsak: C:\ProgramData\Labcenter Electronics\Proteus 8 Professional\LIBRARY
5
• C:\Program Files\Labcenter Electronics\Proteus 8 Professional\LIBRARY veya sistemimiz 64 bit
ise C:\Program Files (x86)\Labcenter Electronics\Proteus 7 Professional\LIBRARY dizinlerine
kopyalıyoruz.
• Böylece Arduino kütüphanemizi İsis programında tanımlamış olduk. Artık İsis programını açıp
projemize Arduinoyu ekleyebiliriz.
4. ARDUINO İLE PROGRAMLAMA
Arduino’da yazılan programlara genel olarak sketch denilmektedir. Bu bölümde File > Examples >
Basics > Blink adımlarını izleyerek belirtilen kod parçacığını açınız ve şekil 2’de verilen bu kod
parçasını ve açıklamalarını inceleyiniz.
Şekil 2. Örnek kod parçası
Arduino programları temel olarak iki kısımdan oluşmaktadır. Bunlar setup() ve loop()
fonksiyonlarıdır. Setup fonksiyonunda board ile ilgili gerekli ayarlamalar yapılmaktadır ve bu kısım
program ilk yüklendiğinde icra edilmektedir. Loop fonksiyonunda ise programın sürekli olarak icra
edeceği bölümler yer almaktadır.
Yukarıdaki program incelenecek olursa, setup fonksiyonu içerisinde yer alan pinMode komutu ile
13. pinin çıkış olacağı belirtilmiştir. Arduino Uno’lar da 13. pin led’dir. Bu işlemin ardından loop
fonksiyonu yürütülmektedir. Bu fonksiyonda digitalWrite komutu ile 13. pin high konumuna
getirilmekte ve led yakma işlemi gerçekleştirilmektedir. Delay komutu ile gecikme işlemi
gerçekleştirilmekte ve yine digitalWrite komutu ile 13. pin low konumuna çekilmektedir. Son olarak
tekrar bir gecikme işlemi gerçekleştirilmekte ve program sonlandırılmaktadır. Bu program parçacığı
6
ile 13 numaralı led 1 sn aralıklarla yakılıp, söndürülmektedir. Kodun çalıştırılmasının ardından
yapılacak işlem bu kod parçacığının derlenerek karta yüklenmesi işlemidir. Şekil 3’de bu işlemi
gösteren bir ekran görüntüsü verilmektedir. Öncelikle Tik işaretine tıklanarak kodun doğrulanması
işlemi gerçekleştirilir. Bu işlemden sonra sağ yönlü ok işaretine tıklanarak kod parçacığının karta
gömülmesi işlemi gerçekleştirilir.
Şekil 3. Doğrulama ve yükleme işlemleri
4.1. Lab. Hazırlık Soruları
1. Arduino Uno’nun dijital çıkış pinlerini kullanarak trafik ışıklarını simüle eden uygulamayı
oluşturunuz?
2. Arduino Uno üzerinde bağlı butona basıldığında led’i yakan, aksi durumda söndüren
uygulamayı veriniz?
3. 8 bitlik ikilik sayıcıyı butona bağlı olarak gerçekleştiren ve 8 bitlik led dizisi üzerinde
gösterecek uygulamayı veriniz?
4. 7-Segment display kullanarak onluk sistemde 0-9 arası sayan sayıcı uygulamasını
gerçekleştiriniz?
5. 4. soruda istenen uygulamayı 0-99 arası sayabilecek şekilde geliştiriniz?
6. Arduino Uno’ya 2x16 LCD bağlayarak, bu LCD üzerinde ilk satıra adınız ve soyadınızı, ikinci
satıra ise okul numaranızı yazdırınız?
7. Arduino üzerine bağlamış olduğunuz LCD’ye kayan yazı oluşturacak şekilde adınızı yazdırınız?
8. C# .Net platformu üzerinde gerçekleştireceğiniz bir arayüz programı aracılığıyla arduino uno
üzerindeki 13 numaralı led’i yakan ve söndüren bir uygulamayı veriniz?
KAYNAKLAR
[1] http://tr.wikipedia.org/wiki/G%C3%B6m%C3%BCl%C3%BC_sistem
[2] http://www.fpganedir.com/embedded/index.php
[3] Coşkun TAŞDEMİR, “Arduino”, 288 syf, İstanbul, 2012.
[4] http://arduino.cc/
7
[5] http://arduinoturkiye.com/
[6] http://arduinoturkiye.com/arduino-web-seminerleri/
[7] http://shieldlist.org/
[8] http://www.atmel.com/Images/doc8161.pdf
F.Ü. Mühendislik Fakültesi
Bilgisayar Mühendisliği Bölümü
Bilgisayar Sistemleri Laboratuvarı
DENEY NO: 6
JAVA İLE DAĞITIK PROGRAMLAMA
Deneyin Amacı:
Bu deneyde nesne tabanlı bir programlama dili olan JAVA’nın genel yapısı ve ağ ortamında
dağıtık programlama (client/server) için Java’nın nasıl kullanıldığını görmek amaçlanmıştır.
Bunun için deneyde önce dağıtıklık kavramı anlatılmış daha sonra uygulamalara geçilmiştir.
1. Dağıtık Sistem Nedir
Katmanların birbirinden uzak yerlerde bulunduğu sistemlere dağıtık sistemler (distributed
systems) adı verilir. Dağıtık sistemler, farklı bilgisayarlara ait donanım ve yazılım bileşenleri
arasında yalnızca mesajlaşma yöntemleri kullanılarak haberleşme ve koordinasyonunun
sağlanabildiği, ortak bir amaca hizmet eden network sistemleridir. Başka bir deyişle, fiziksel
olarak bağımsız bilgisayarların kullanıcıya tek bir bilgisayar gibi görünerek, iş yükünün
paylaşıldığı sistemlerdir. Bir dağıtık sistem, kurumsal bir şirketteki yapılanmaya
benzetilebilir. Şirket kendi içerisinde alt birimlere ayrılmış, iş paylaşımı yapmış olsa da,
müşteri şirket ile muhatap olmaktadır. Şekil 1’de kullanıcı ana bilgisayar ile muhatap
olmakta, ana bilgisayar işi alt bilgisayarlara bölüştürmektedir. Sonucu kullanıcıya yine ana
bilgisayar gösterir.
Bilgisayar 1
(Client)
Bilgisayar 2
(Client)
Bilgisayar 3
(Client)
Bilgisayar 4
(Client)
Ana Bilgisayar
(Server)
Kullanıcı
Şekil 1. Dağıtık Sistem Mimarisi
Dağıtık sistemlerdeki en önemli nokta süreçler arası haberleşmedir. Süreçler arasında mesaj
iletimi önemli ve zor bir konudur. Sistem içindeki bilgisayarlar arası mesafe, networkun
durumu (hatların yoğun olması) ve diğer fiziksel şartlar mesaj iletimini etkileyebilmektedir.
Bu nedenle mesaj iletimini düzenlemek amacıyla çeşitli orta katman yazılımları ve mesaj
gönderme protokolleri oluşturulmuştur. RPC (Remote Procedure Call) ve RMI (Remote
Object Invocation) bu orta katman yazılımlardan önemli iki tanesidir. TCP ve UDP de en çok
kullanılan mesaj transfer protokolleridir. Bilgisayarı bu protokoller yardımıyla birbiriyle
haberleştirmek için öncelikle aynı ağa bağlı olmaları gerekmektedir.
2. Niçin Dağıtık Programlama?
Kaynak Paylaşımı: Eğer farklı kapasitelerdeki farklı siteler, diğer bir siteye bağlı ise, bir
sitedeki bir kullanıcının, diğer sitede mevcut kaynakları kullanması mümkün olabilir.
Örneğin; A sitesindeki bir kullanıcı, B sitesinde bulunan bir lazer yazıcıyı kullanıyor olabilir.
Bu sırada, B’deki kullanıcı da A’da bulunan bir dosyaya erişebilir.
Hesaplamayı Hızlandırma: Belli bir hesaplama, eş zamanlı olarak çalışabilen alt
hesaplamalar şekilde bölümlenebilirse, dağıtık bir sistem farklı siteler arasında alt
hesaplamaları dağıtmaya izin verir, alt hesaplamalar eş zamanlı olarak çalıştırılabilir ve
böylece hesaplamalarda hızlanma sağlanır. Ek olarak, eğer belli bir site işlerle aşırı
yüklenmişse, işlerin bir kısmı hafif yüklü diğer sitelere taşınabilir. Buna da yük paylaşımı
denir.
Güvenilirlik: Dağıtık bir sistemde bir site başarısız olursa, kalan siteler çalışmaya ve daha
güvenilir sistemler vermeye devam ederler. Eğer bir sistem, birden çok, büyük ve özerk
sistemlerden oluşuyorsa (yani genel amaçlı bilgisayarlarsa), onların birinin başarısızlığı geri
kalanını etkilemez. Fakat eğer, sistem küçük makinelerden oluşuyorsa, onların her biri de bazı
önemli sistem fonksiyonlarından sorumlu ise (örneğin; dosya sisteminin ya da giriş/çıkışın
terminal özelliği), tek bir hata böyle sistemlerin çalışmasını durdurabilir. Genel olarak,
sitelerin bazılarında başarısızlıklar olsa bile, (hem donanım hem de verinin) yeteri kadar
yedeklenmesiyle sistem çalışmasına devam edebilir.
Dağıtık programlamanın getirdiği avantajlar şu şekilde özetlenebilir:
• Ölçeklendirilebilirliği (sisteme ekleme-çıkarma yapma kolaylığını) artırır.
• Sadece belli donanımlara sahip bilgisayarlarda çalışan yazılımlardan bir sistem
oluşturabilme imkanı sağlar.
• Servisleri ayrı bilgisayarlarda çalıştığından sistem daha güvenli olur ve erişim
kontrolleri daha kolay yapılır.
• Bilgisayarların işlem güçlerini birleştirerek süper sanal bilgisayarlar oluşturulabilir.
(https://boinc.berkeley.edu/ - BOINC isimli süper bilgisayar projesinde, kullanıcılar
yükledikleri uygulamalar ile CPU, ram gibi kaynaklarını proje kapsamında çözülmesi
amaçlanan problemler için kullandırtabilmektedir.)
3. Java ile Dağıtık Programlama Nasıl Gerçekleştirilir?
Dağıtık programlama bir işin birden fazla bilgisayar tarafından yapılmasını hedefler. Ortada
birden fazla eleman varsa, bunların birlikte çalışabilmesi için aralarında haberleşmesi gerekir.
Dağıtık programlama temel olarak sistemdeki bilgisayarların haberleşmesine dayalıdır. Bu
haberleşme ağ bağlantıları sayesinde gerçekleştirilir. Dağıtık programlama deneyini
gerçekleştirmek için öncelikle kullanacağımız bilgisayarların aynı ağa bağlı olması gereklidir.
Aralarında ağ bağlantısı bulunan bilgisayarlardan biri server biri client olarak ayarlanarak
bağlantı test edilir. Bağlantının gerçekleştirilme aşamaları şekil 2’de gösterildiği gibi olur.
Server Client
ipAdresi
portlar
1992
2071 5064
1
3
2
4
5
Şekil 2. Server-Client Arasında Bağlantının Sağlanması
1- Server bilgisayarda bir adet ServerSocket nesnesi oluşturularak müsait bir port
dinlenir (şekilde port numarası 1992 seçilmiş).
2- Client bilgisayarda bir adet Socket nesnesi oluşturularak server bilgisayarın açılan
portuna bağlantı denemesinde bulunulur (ipAdresi,1992 parametreleri ile).
3- Porta ulaşılınca 4. Adıma geçilir.
4- ServerSocket nesnesi accept() fonksiyonu aracılığıyla boş bir port açarak gelen isteği
bu port ile eşleştirir.
5- İki bilgisayar açılan portlar aracılığıyla iletişim sağlar (2071 ve 5064 portları).
Yukardaki adımları gerçekleştirmek için server tarafında yazılması gereken Java kodu
aşağıdaki gibidir:
// Belirtilen PORT_NUMARASI‘nı yöneten yeni bir socket nesnesi ouşturulur (Adım 1).
ServerSocket soket = new ServerSocket(PORT_NUMARASI);
System.out.println(“Baglanti Bekleniyor”);
// Belirtilen PORT_NUMARASI’nı dinleyerek yeni bağlantı bekler (Adım 4).
Socket baglanti = soket.accept();
System.out.println(“Baglanti Gerceklesti”);
Bilgisayarlarda 16 bitle ifade edilebilecek sayıda (216 = 65536 adet) port bulunmaktadır. Bu
portlardan ilk 1024 ü özel amaçla ayrılmış portlardır. Bilgisayar sistemlerinde indisler 0’dan
başladığı için 1024. port bizim kullanabileceğimiz portların birincisi, 65535. port ise
sonuncusu olmaktadır. Açılacak olan PORT_NUMARASI bu aralıklarda bir değer alabilir.
Client tarafına ise aşağıdaki kod yazılarak bağlantı sağlanabilir.
Socket baglanti = new Socket(IP_ADRESI, PORT_NUMARASI);
Burada yer alan IP_ADRESI serverin ip adresi ile değiştirilmelidir. Deneme için server ve
client aynı bilgisayarda çalıştırılabilir. Kendi bilgisayarında açılan porta erişmek için
IP_ADRESI kısmına "localhost" yazılmalıdır. Burdaki port adresi serverSocket oluştururken
belirten PORT_NUMARASI değeridir. Şekil 2’deki örnek için PORT_NUMARASI değeri
1992’dir (Adım 2,3,5).
Yukarda yer alan kodlar client.java ve server.java isimli iki ayrı main içerisine atılıp, önce
server sonra client çalıştırıldığında bağlantının başarılı bir şekilde gerçekleşmesi
beklenmektedir. Ancak bağlantı gerçekleştikten sonra bir işlem yapılmadığından programlar
sonlanır.
Server ile Client arasındaki bağlantı kurulduktan sonra her iki taraf da sahip oldukları soket
nesneleri (baglanti) yardımıyla birbiriyle veri alışverişi yapabilirler.
Veri Gönderimi:
PrintWriter output = new PrintWriter(
baglanti.getOutputStream(),true
);
output.println("Gönderilecek Mesaj");
Veri Alımı:
BufferedReader in = new BufferedReader(
new InputStreamReader(baglanti.getInputStream())
);
in.readLine();
Burada in.readLine satır gelmesi için bekler, bir sonraki adıma geçmez. Bunun için
in.readLine komutunda beklemesini istemiyorsak bundan önce in.ready() fonksiyonuyla
okunacak bir şey olup olmadığı kontrol edilir, varsa okuma komutu çağrılır. Sürekli veri
okunması yapılacak ise bu işlem döngüye sokulur.
İki cihazın birbiriyle haberleşmeleri için öncelikle mesaj yapılarını bilmeleri gerekmektedir. A
ile B arasındaki sayılar arasında C’yi arayacağımız bir uygulama olduğunu düşünerek, “A-BC” gibi bir mesaj geldiğini varsayalım. Bu mesajı ayrıştırmak ve değerleri uygun değişkenlere
atamak için string işlemlerinden yararlanılır. Birinci parametre olarak A’yı ikinci parametre
olarak B’yi üçüncü parametre olarak ise C’yi almak için yazmamız gereken kod aşağıdaki
gibi olur. Burada A,B,C’nin tipleri iki bilgisayar tarafından da bilinmeli (haberleşme kuralı).
veri = “2000-200000-deneme”;
String [] x = gelen.split("-"); // veriyi - işaretlerine göre ayır
long A = Long.parseLong(x[0]); // 1. parametre long değer olmalı
long B = Long.parseLong(x[1]); // 2. parametre long değer olmalı
String C = x[2]; // 3. Parametre string değer olmalı
Serverden cliente göndereceğimiz mesaj, cliente yaptırmak istediğimiz komut olacaktır.
String olarak okunan komut ayrıştırılarak ilgili işlemler cliente yaptırılır. Ürettiği sonuç tekrar
servere cevap olarak döndürülür. 1 client 1 server için işlem bu şekilde gerçekleşir. Ancak
soket dinleme işlemi, porta bir bağlantı gerçekleşene kadar alt satıra geçmez. Yani bir
serverde birden fazla client bağlantısı dinlemek istiyorsak, serverde oluşturduğumuz socket
nesnelerini Threadler yardımı ile oluşturup dinlemek gerekmektedir. Thread yardımıyla
birbirinden bağımsız iş parçacıkları kendilerine ait soketleri dinler ve bir veri geldiğinde bunu
algılayabilir. Javada thread oluşturmak için sınıfı Thread sınıfından türetmek ve ardından run
fonksiyonunu override etmek gerekir.
Örnek thread oluşturma :
public class Ornek extends Thread {
public void run() {
int i=0;
while(true){
System.out.print(i++ + " ");
}
}
public static void main(String args[]) {
(new Ornek()).start();
(new Ornek()).start();
}
}
Thread sınıfından türetilen bir nesnenin start metodu çağrıldığında, run içerisine yazdığımız
kodları tetiklenir. Yukardaki kod ile Ornek adında bir thread oluşturduk ve main fonksiyonu
içerisinden bu threadi tetikleyerek çalıştırdık. Hemen ardından aynı threadi bir kez daha
çalıştırdık. Sonuçta oluşturduğumuz sonsuz döngü sistemin tüm kaynaklarını tüketmemiş oldu
ve iki sonsuz döngü aynı anda çalıştırılmış oldu. Thread iki kez tetiklendiğinden dolayı
yukardaki kodun aynı sayıdan ikişer kez yazdırması beklenmektedir. Ancak işlemler eş
zamanlı çalıştığından ekranda gözüken çıktılar sıralı olarak görülmez.
4. Deney Senaryosu
ABC sitesinin kullanıcılarına ait bilgiler veritabanında tutulmaktadır. ABC sitesi kayıt olurken
istediği kullanıcı adını olduğu gibi; şifreyi ise md5 fonksiyonundan geçirerek kaydediyor.
Kullanıcı giriş yapmaya çalıştığı zaman girişte kullanılan kullanıcı adı olduğu gibi, şifre ise
md5 fonksiyonundan geçirildikten sonra veritabanında bu değerlere karşılık bir kayıtın olup
olmadığı kontrol ediyor ve giriş işlemi bu şekilde yapılıyor. Şifre veritabanında hash hali ile
tutulduğundan, veritabanında kayıtlı şifre bilgisi başkaları tarafından ele geçirilse dahi şifrenin
öğrenilmesinin önüne geçilmiş olunuyor.
ABC sitesindeki veritabanı bilgilerinin bir şekilde elimize ulaştığını varsayarak; Md5
fonksiyonundan geçirilmiş şifresini bildiğimiz X kullanıcısına ait şifreyi bulmamız
gerekmektedir. Ancak md5 tek yönlü bir algoritma olduğu için hash halindeki veriden orjinal
şifreyi elde etmemiz mümkün değildir. Bunun için sitede istenen şifrenin 8 basamaklı bir sayı
olduğu bilgisinden de yola çıkarak tek tek tüm olasılıkları md5 fonksiyonundan geçirmemiz
ve sonucu elimizdeki md5li veri ile karşılaştırmamız gerekmektedir (kaba kuvvet
algoritması). Ancak bunu bir bilgisayardan yapmaya çalıştığımızda T süre kadar zaman alır.
Bu süreyi kısaltmak için belirli aralıktaki şifreleri farklı bilgisayarlara denettirerek (dağıtık
programlama) sonuca ulaşmak planlanmaktadır. Deneyimizde bir adet iş dağıtan bilgisayar ve
iş yapan en az iki bilgisayar olacaktır.
5. MD5 (Message Digest 5) Algoritması Nedir?
Tek yönlü bir özütleme (hashing) algoritmasıdır. Girilen veri ister bir karakterden oluşsun
isterse terabaytlar büyüklüğünde bir dosya olsun çıkışta 128 bit (her biri 16’lık tabanda olan
32 rakam uzunluğunda) bir çıktı üretir. Sonsuz giriş kümesine karşılık 1632 kadar çıktı
olacağından aynı sonucu verecek birden fazla girdi bulunacaktır. Ancak şifre gibi küçük
veriler için böyle bir çakışma söz konusu değildir. Bundan dolayı şifreler genellikle
veritabanlarında bu şekliyle tutulur. Girilen şifreler bu fonksiyondan geçirildikten sonra
karşılaştırma yapılır. Tabloda farklı girişler için oluşturulan md5 değeleri verilmiştir.
1 c4ca4238a0b923820dcc509a6f75849b
fırat üniversitesi 44d4177ff9be0f3e45f27847719d1107
Fırat Üniversitesi a9ccc25be1bd49a199a69814d33e7b0d
Md5 fonksiyonu aşağıdaki şekilde verilmiştir. Sizden yapmanız istenilen bir döngü ile
dışardan belirlenen aralıktaki tüm sayıların md5 fonksiyonundan geçirilmiş hallerini, yine
dışardan girilen özütlenmiş değer ile kıyaslamanızdır.
Java Md5 fonksiyonu:
private static String getMd5(long sayi) throws Exception{
String yourString = Long.toString(sayi);
byte[] bytesOfMessage = yourString.getBytes("UTF-8");
MessageDigest md = MessageDigest.getInstance("MD5");
byte[] thedigest = md.digest(bytesOfMessage);
BigInteger bigInt = new BigInteger(1,thedigest);
String hashText = bigInt.toString(16);
while(hashText.length() < 32 ){
hashText = "0"+hashText;
}
return hashText;
}
6. Deneyin Adım Adım Gerçekleştirilme Aşamaları
1. Dışardan başlangıç, bitiş ve özütlenmiş veri bilgilerini alan bir fonksiyon oluşturulur. Bu
fonksiyon başlangıç ve bitiş değerleri arasındaki tüm değerleri md5 fonksiyonundan
geçirerek özütlenmiş halleri bulunur. Bulunan değer, dışardan girilen özütlenmiş veri
bilgisi ile aynı ise fonksiyon o anda aktif olarak işlem gören sayısı geri döndürür.
2. Main metodu içerisinde bir string tanımlanır. Bu string “Başlangıç-Bitiş-a12cdd…” gibi
üç parametreyi aralarına boşluk, tire, virgül gibi bir karakter ekleyerek ifade eder. Bu
stringin çözümlenmesi için bir split metodu yazılarak, ilk değer başlangıç, ikinci değer
bitiş ve üçüncü değer ise özütlenmiş veri yerine konulur ve 1. Adımda oluşturulan
fonksiyon çağrılır.
3. Bilgisayarlar aynı ağa bağlanır.
4. Bir bilgisayar başka bilgisayarların bağlanması için Java Socket sınıfında yararlanarak
port açar ve diğer bilgisayar buna bağlanır. İki bilgisayar arasında mesajlama işlemi test
edilir.
5. Diğer bilgisayarlarda istemciden gelen mesaj 2. Maddedeki formatta gönderilir. Alınan
mesaj 2. Maddedeki string yerine yazılarak kod çalıştırılır.
6. Bir bilgisayar açtığı portu dinlerken tüm kaynakları onun için harcar ve başka bir işlem
yapamaz. Birden fazla bilgisayarın bağlanabilmesi için ana bilgisayarda port dinleme
işlemi thread kullanacak şekilde uyarlanır.
İlk 5 maddenin gerçekleştirilmesi 80 puan,
6. maddenin gerçekleştirilmesi 20 puan üzerinden hesaplanacaktır.
7. Hazırlık Soruları
1- Dağıtık programlama nedir? Dağıtık programlamaya niçin ihtiyaç duyulur?
2- Java’da socket sınıfı ne işe yarar? Dağıtık programlamada niçin socket sınıfı kullanılır?
3- Sunucuda 2010 nolu port açtıran ve istemcinin bağlanmasını bekleyen satırları yazınız (2
satır). İstemci bağlandığı zaman konsolda ‘istemci bağlandı’ yazdırın.
4- İstemciden 192.168.1.128 ip adresine sahip sunucunun 5040. Portuna bağlanmak için
gerekli nesneyi oluşturunuz.
5- Soketten veri göndermek için kullanılan nesneyi oluşturun.
6- Soketten veri almak için kullanılan nesneyi oluşturun.
7- Hash algoritması nedir? Deneyde ne için kullanılmıştır?
8- Thread nedir? Ne işe yarar? Bu deneydeki kullanılma amacı nedir?
9- Java programlama dilinde Thread nasıl oluşturulur?
Fırat Üniversitesi BMÜ-431
Bilgisayar Mühendisliği Bilgisayar Sistemleri Laboratuvarı
DENEY NO: 7
GÖRÜNTÜ İŞLEME UYGULAMALARI
1. GİRİŞ
Elde edilen görüntünün bilgisayara aktarılıp üzerinde herhangi bir işlem yapılması ve
ardından görüntüleyici çıkışa iletilmesine sayısal görüntü işleme adı verilir. Görüntü işleme
teknikleri ile, sayısal görüntüler iyileştirilerek nesne tanıma, hedef tanıma gibi işlemler
gerçekleştirilebilmektedir. Görüntü işleme, amaca göre çeşitli işlemlerden
oluşmaktadır. Görüntü işleme; tasarım, imalat, güvenlik, tıp, elektronik, makine ve jeodezi
gibi alanlarda çok geniş bir uygulama alanı bulmuştur.
• Askeri (hedef tanıma, izleme)
• Tıp (damar analizi, bilgisayarlı tomogrofi, ultrason)
• Güvenlik (nesne takibi, hareket algılama, yüz tanıma)
• Trafik (trafik kontrol, plaka tanıma, trafik ışığı (işareti) tanıma)
• Endüstri (nesne sayma, kalite kontrol, robotik uygulamalar)
• Tarımsal uygulamalar (ekin verimliliği tespiti)
• Astronomi (uydu görüntüleri ile hava tahmini)
• Jeodezi ve Fotogrametri (uzaktan algılama)
• Perakende (insan sayma, davranış analizi, mağaza izleme)
• Çevre güvenliği (çevre kirliliği tespiti)
Sayısal resim haline getirilmiş olan gerçek yaşam görüntüsünün, girdi resim olarak
işlenerek, resmin özelliklerinin ve görüntüsünün değiştirilmesi sonucunda yeni bir
resmin oluşturulması işlemidir. Bir çok amaç için kullanılmaktadır.
• Görüntü İyileştirme
• Görüntü Sıkıştırma
• Biyometrik Tanıma
• Otomatik yüz araç obje tanıma ve takip etme
2. İkili Görüntü (Binary Image)
Bir resmin sayısallaştırılmasının açıklanması amacı ile öncelikle Siyah-Beyaz resim göz
önünde bulundurulmuştur. Siyah-Beyaz resim sadece iki gri değerden oluşan bir resimdir.
Böylesi bir görüntüde her bir piksel ya siyah ya da beyaz olarak oluşur. Burada sembolik
olarak beyaz pikseller 1, siyah pikseller 0 değeri ile gösterilecektir. Renkli görüntüler
bilgisayar ekranlarında 24 bit lik veri olarak görüntülenir. Görüntüleme R(Kırmızı),
G(Yeşil), B(Mavi) kodlanmış aynı objeye ait üç adet gri düzeyli görüntünün üst üstle
ekrana iletilmesi ile oluşur. Elektro-manyetik spektrumda 0,4-0,5 mm dalga boyu mavi
renge; 0,5-0,6 mm dalga boyu yeşil renge; 0,6-0,7 mm dalga boyu kırmızı renge karşılık
gelir. Bu dalga boylarında elde edilmiş üç gri düzeyli görüntü bilgisayar ekranında sırası
ile kırmızı-yeşil-mavi kombinasyonunda üst üste düşürülecek olursa renkli görüntü elde
edilmiş olur.
Şekil 1. RGM Görüntüler
3. Niteliklendirme
Görüntünün piksel değerlerinin belirli aralıklarda olması, meydana gelen görüntünün
niteliğini değiştirir. Örneğin 0 beyazı ve n1 de siyahı temsil ederse ve bu değerler arası gri
tonlarını ifade eder. Burada n= 2^b olmak üzere, b değeri görüntünün 1 pikselini ifade
etmek için gereken bit sayısıdır. Örneğin b=8 ise 256 adet gri tonu bulunmaktadır. B=1 ise
resim sadece 0 ve 1 ‘lerden oluşur ve buna İkili resim(Binary Image) denir.
4. Matlab’da Görüntü İşleme
Söz konusu uygulamaları geliştirmek için kullanılan, Matlab’ın görüntü işleme
komutlarının ve image processing tolls’un bazılarını örneklerle inceleyeceğiz.
imread: imread ile üzerinde çalışılmak istenilen fotoğraf bir değişkene atanarak matlab
workspace için tanımlanır ve ardından imshow ile pencerede gösterilebilir. Workspace’te
imgenin boyutu, çözünürlüğü gibi bilgileri görebilirsiniz.
İmtool: imtool ile bazı işlemlerin yapılabileceği bir pencere açılır. Örnek kodları yazarken
workspacedeki verileri temizlemek için, clear all ve clc komutlarını en başa yazmayı
unutmamamız gerekir.
• I = imread(‘ornek.jpg’)
imshow(I)
imtool(I)
Warp: görüntüyü (içinde yazı olan görüntü daha iyi olur ) belli yüzeylerde gösterir.
• resim = imread('rice.png');
• [x1,y1,z1] = cylinder;
• [x2,y2,z2] = sphere;
• imshow(resim); title('Orijinal resim');
• figure;
• subplot(1,2,1); warp(x1,y1,z1,resim); title('cylinder');
• subplot(1,2,2); warp(x2,y2,z2,resim); title('sphere');
•
Şekil 2. Elde edilen görüntü
4.1. Tür Dönüşüm Komutları
rgb2gray: renkli görüntüyü gri seviyeye çevirir.
graythresh: graythreshold komutu görüntüdeki parlaklık eşiğini otomatik olarak belirler
ve sonuç olarak 0 – 1 arasında bir sayı (level) oluşturur. Görüntüdeki parlaklık sınırları ile
yapacağımız işlemlerde graythreshold’ tan elde ettiğimiz sayıyı kullanırız. Görüntü
üzerinde belirli işlemleri yapabilmemiz için öncelikle gri seviyede çalışmamız gerekir.
Bunun için I= rgb2gray(I) komutu kullanılır.
Bu kod örneği ile görüntünün binary şekli elde edilir.
level = graythresh(I);
bw = im2bw(I,level);
bw = bwareaopen(bw, 50);
figure; imshow(bw);
Şekil 3. Elde edilen görüntü
• im2uint8: uint8 renk hassasiyetine dönüştürür. Genelde görüntüler uint8 türündedir.
Her piksel İşaretsiz 8 bit (0 – 255) arası değere sahiptir.
Diğer dönüşüm komutları; demosaic, gray2ind, grayslice,im2int16, label2rgb
,im2double, im2uint16, mat2gray…
4.2. Görüntü Analizi Komutları
Bwboundaries: binary modda bölgelerin sınırlarını belirler.
Bu örnekte, yeşil çizgiyle sınırlanmış alanların sayısını belirleyebiliriz. Bu örnekle daha
sonra bahsedeceğimiz, morfolojik işlemler gerçekleştirilerek basit nesne sayma
uygulaması yapılabilir.
I = imread('rice.png');
BW = im2bw(I, graythresh(I));
B = bwboundaries(BW);
figure; imshow(BW);
text(10,10,strcat('\color{red}bulunan sınırlar:',num2str(length(B))))
hold on;
for k = 1:length(B)
boundary = B{k};
plot(boundary(:,2), boundary(:,1), 'g', 'LineWidth', 1)
end
Şekil 4. Sınırı belirlenen görüntü
Edge: özel filtreler yardımıyla gri seviyedeki görüntülerin sınırları belirlenir.
I = imread('rice.png');
imshow(I);
BW1 = edge(I,'prewitt');
BW2 = edge(I,'canny');
figure; imshow(BW1);
figure; imshow(BW2);
diğer analiz komutları: hough, houghlines, corner…
4.3. Görüntü İyileştirme Komutları
• imadjust: görüntü yoğunluğu değerini ve renk haritasını ayarlar.
histeq: histogramı eşitleyerek kontrastı artırır.
adapthisteq: CLAHE(kontrast sınırlı adaptif histogram eşitleme) algoritması
kullanarak kontrastı artırır.
I = imread('tire.tif');
A = adapthisteq(I,'clipLimit',0.02,'Distribution','rayleigh');
B = histeq(I);
subplot(231),imshow(I);
subplot(232),imshow(A); title('adapthisteq uygulanmış');
subplot(233),imshow(B); title('histeq uygulanmış');
Şekil 5. İyileştirme uygulanan görüntü
• medfilt2: 2 boyutlu medyan filtreleme yapar.
wiener2: 2 boyutlu adaptif gürültü temizleme filtresidir.
I=imread('eight.tif');
no=imnoise(I,'salt & pepper',0.02);
filt1=medfilt2(no); filt2=wiener2(no);
subplot(2,2,1); imshow(I), title('Orijinal resim')
subplot(2,2,2); imshow(no), title('Gürültülü resim')
subplot(2,2,3); imshow(filt1), title('Medyan filtresi uygulanmış')
subplot(2,2,4); imshow(filt2), title('Wiener filtresı uygulanmış')
5. MATLAB ile Görüntü İşleme Uygulaması
Bu uygulamada resmin içindeki bozuk paraları bulmaya, etiketlemeye ve değerlerine göre
hesaplamaya çalışılmıştır. Görüntü olarak Matlab programında hazır bulunan 'coins.png'
yi kullanılmıştır.
► Matlab' de görüntü işleme ile ilgili uygulama geliştirirken yapmamız gereken ilk
adımlar gri seviyeye, binary seviyeye dönüştürme işlemleridir. Uygulamanın ilk
satırlarında otomatik threshold değerine göre imgeyi binary seviyeye
dönüştürülmüştür.
► Görüntüler im2bw komutu ile binary seviyeye dönüştürüldükten sonra aşağıdaki
resimde görüldüğü gibi birçok küçük alanlar oluşabilir. Görüntüyü bölümleyebilmek
için bu alanları doldurmamız gerekir. Bunun için imfill işlemini gerçekleştirilmiştir.
Şekil 6. coins.png görüntüsü
• Program iki çıktı vermektedir. Birincisinde sınırları çizilen bozuk paraların sayısı
belirlenir; ikincisinde ise bozuk paralara alanlarına göre değer atanıp, değerleri sayılır.
5.1. Bölgelerin belirlenmesi
Sınırlar bwboundaries işlemi ile çizilir. For döngüsü çizim sayısı kadar döndürülerek
çizimlerin resmin üzerinde gösterilmesine olanak sağlar.
► plot işleminin parametreleri değiştirilerek çizimin kalınlığı, rengi istenilen şekilde
belirlenebilir.
B = bwboundaries(coin2);
• text(10,10,strcat('\color{red}Objects Found:',num2str(length(B))))
• hold on;
• for k=1:length(B),
• boundary = B{k};
• plot(boundary(:,2),boundary(:,1),'b','LineWidth',2);
• end
5.2. Alanların hesaplanması
• bwlabel işlemi ile bağlı bileşenlerin (bozuk paralar) bilgileri bir değişkene atanır.
► regionprops ile bölgelerin özellikleri çıkarılır. Daha sonra alanlar hesaplanır (for
döngüsü) alanı belli bir değerin üzerinde olanlar '5 C' ile diğerleri '10 C' ile etiketlenir.
• [Bilgi Number]=bwlabel(coin2);
• prop=regionprops(Bilgi,'Area','Centroid');
• total=0;
• figure; imshow(imread('coins.png'));hold on
• for n=1:size(prop,1)
• cent=prop(n).Centroid;
• X=cent(1);Y=cent(2);
• if prop(n).Area>2000
• text(X-10,Y,'5 C')
• total=total+5;
• else
• total=total+10;
• text(X-10,Y,'10 C')
• end
• End
Şekil 7. Görüntüdeki farklı nesneleri tanıma
Matlab Kodu:
• clc;
• clear all;
• figure; imshow('coins.png');
• coin1 = im2bw(imread('coins.png'));
• coin2 = imfill(coin1,'holes');
• figure; imshow(imread('coins.png'));
• B = bwboundaries(coin2);
• text(10,10,strcat('\color{red}Objects Found:',num2str(length(B))))
• hold on;
• for k=1:length(B),
• boundary = B{k};
• plot(boundary(:,2),boundary(:,1),'b','LineWidth',2);
• end
• [Bilgi Number]=bwlabel(coin2);
• prop=regionprops(Bilgi,'Area','Centroid');
• total=0;
• figure; imshow(imread('coins.png'));hold on
• for n=1:size(prop,1)
• cent=prop(n).Centroid;
• X=cent(1);Y=cent(2);
• if prop(n).Area>2000
• text(X-10,Y,'5 C')
• total=total+5;
• else
• total=total+10;
• text(X-10,Y,'10 C')
• end
• end
• hold on
• title(['Toplam: ',num2str(total),'cent'])
6. DENEY
Bu uygulamada verilen benzer iki resim arasındaki farklar bulunup bu farklar hem
sayıca hesaplanmakta hem de işaretlenmektedir.
Şekil 8. Benzer iki farklı resim
• im1 = rgb2gray(imread(‘resim1.png'));
• im2 = rgb2gray(imread(‘resim2.png'));
• fark = imabsdiff(im1,im2);
• bw = bwareaopen(fark,55);
• bw = imfill(bw,'holes');
• SE = strel('square',1);
• bw2 = imerode(bw,SE);
• fark = regionprops(bw2, 'all');
• c = [fark.Centroid];
• imshow(‘resim2.png');
• title(['Toplam fark : ',num2str(length(fark))]);
• hold on;
• x = c(1:2:end);
• y = c(2:2:end);
• plot(x,y,'yo','MarkerSize',20,'LineWidth',4);
Şekil 9. İki resim arasındaki farların bulunması
• Uygulama 2’deki iki farklı resmi kullanarak aynı matlab kodu kullanılarak sonuç
olarak 3 farklı resim çıktı alınması gerekmektedir(Figure 1, Figure 2 ve Figure 3).
• Figure 1: Standart 1. resmi ifade edecek.
• Figure 2: Farklı olan kısımları daire içine alınmış olan resmi ifade edecek.
• Figure 3: Standart 2.resmi gri ton kodlamalı şekilde gösterecek resmi ifade edecek.
Not: Deney esnasında deney föyündeki ve slayttaki tüm bilgi ve kod içeriğinden
sorumlu olduğunuzu unutmayınız…
KAYNAKLAR
• www.mathworks.com
• http://www.elektrikport.com/
• http://web.firat.edu.tr/iaydin/bmu357/Bolum_1.pdf
• http://www.yildiz.edu.tr/~bayram/sgi
• http://yzgrafik.ege.edu.tr/~tekrei/dosyalar/sunum/gi.pdf
1
Fırat Üniversitesi BMÜ-431
Bilgisayar Mühendisliği Bilgisayar Sistemleri Laboratuvarı
DENEY NO: 8
KINECT İLE İNSAN HAREKETLERİNİN ALGILANMASI
1. GİRİŞ
Eğitim ve öğretimde teknolojik araçların kullanılması, zenginleştirilmiş öğrenme ortamlarının
oluşturulması, sürecin kalite ve verimliliğinin artırılması açısından önemlidir. Özellikle
bireyselleştirilmiş öğrenme ortamlarının yapılandırılmasında pek çok avantaj sunan teknolojik
araçların özel eğitimde kullanılmasının önemi dikkat çekmektedir. Özel eğitim gereksiniminde olan
iletişim, davranış ve öğrenme özellikleri teknoloji ile zenginleştirilerek eğitiminde kullanılması,
öğrenme çıktılarının iyileştirilmesi ve yaşam kalitesinin artırılması açısından destekleyici olmaktadır.
1.1.Amaç
Kamera karşısında duran insana ait pozisyonların tespit edilerek bunlarla ilgili çıkarımlar
üretmektir. Örneğin herhangi bir rahatsızlığından dolayı egzersiz yapan bir insanın yaptığı
hareketlerin doğruluğunu tespit etmek onun tedavi süreci için önemlidir.
1.2.Deneyin Tanıtımı
Kinect’in (IR) Kızılötesi sensörü yardımıyla görüş alanındaki altı kullanıcıya kadar tanımlama
yapılabilir. Fakat bunlardan en fazla iki tanesi ayrıntılı olarak izlenebilir. Bu kullanıcıların eklemlerini
bularak onların hareketlerini gözlemlemek mümkündür.
2. Kinect Teknolojisi
Microsoft Xbox 360 ve Windows uyumlu Kinect sensörü son derece gelişmiş algılama sensör
donanımları içermektedir; derinlik kamera sensörü, RGB kamera sensörü, dörtlü mikrofon grubu ile
üç boyutlu şekilde hareketleri belirtilen aralıklarla yakalama, yüz tanıma ve ses algılama imkanı
sunmaktadır. Kinect yazılım geliştirme kitinde bir iskelet, insan vücudundaki bulundukları yerlere göre
numaralandırmış 20 adet eklemden oluşur ve bu eklemlerin pozisyonları ve uzaklıkları takip edilerek
vücut hareketlerini görüntüye işlemektedir.
Kinect kamerası kullanıcıyı 80 cm ile 400 cm (4 m) arasındayken algılayabilmektedir. En ideal
uzaklık 120 cm ile 350 cm arasındadır. Kullanıcının yüzünün olduğu ön tarafının kameraya dönük
halinde istenilen şekilde çalışmaktadır. Kamera kullanıcı 350 cm uzaklıktayken ortalama 2 metrelik bir
insan boyunu algılayabilmektedir. Kinect For Windows kamerası, Skeleton kütüphanesi yardımıyla bu
eklemlerin, eklem tipi ve pozisyon (X,Y,Z) bilgisi döndürülür.
Kinect'in üzerinde 3 adet göz, sıra mikrofonlar ve hareket sağlayıcı bir motor mekanizması
bulunmaktadır. Soldaki göz lazer projeksiyonu yaparken, sağdaki kızılötesi sensör bu ışınların gidiş -
geliş süresini hesaplayarak 320x240 çözünürlüğünde her bir noktanın mesafesini bildirmektedir.
Kinect firmware'i ise bu veriler ışığında iskelet yapısını hesaplamakta ve bunu XBOX ya da PC'ye
göndermektedir.
2.1.Uygulama için Ön Gereksinimler
Kinect SDK ile sensör ve kamera özelliklerine erişebilmek için:
- Çift çekirdekli 2.66 Ghz işlemci
2
- En az 2 GB RAM
- 32 yada 64 bit Windows 7-10 işletim sistemi ve .NET Framework 4.0’ a sahip olmanız
gerekmektedir.
2.2.Uygulama Geliştirmek için:
- Visual Studio 201x'un herhangi bir sürümüne sahip olmanız,
- Microsoft Kineck SDK'yı indirmeniz, (buradan indirebilirsiniz)
http://www.microsoft.com/en-us/search/DownloadResults.aspx?q=kinect+sdk
Not: Yazılımınızı indirdiğiniz SDK’ya uygun olarak kodlamanız gerekmektedir.
- İsteğe bağlı olarak bazı metodlar için:
OpenNi/PrimeSense kütüphaneleri için (buradan indirebilirsiniz)
http://fivedots.coe.psu.ac.th/~ad/kinect/installation.html
-Coding4Fun Kinect Toolkit'i indirmeniz için. (buradan indirebilirsiniz)
http://c4fkinect.codeplex.com/
3. Donanım Kurulumu
Kinect sensörünün bağlantı portu yeni nesil XBOX 360'lar için tasarlanmıştır. PC ile
kullanabilmek için özel adaptörünü kullanmamız gerekiyor. Adaptör kablosunun dişi ucunu Kinect'e,
USB ucunu ise PC'ye bağladığımızda, Windows aygıt sürücülerini yüklemeye başlayacak. Sürücüler
yüklendikten sonra, aygıt yöneticisinde Microsoft Kinect ve ses denetleyicileri altına veya ilgili
kütüphanelerin olduğu dizine Xbox Kinect’in cihazları resim 1’de görüldüğü gibi eklenecektir.
Resim 1: Kurulu Kinect’in aygıt yöneticisinde görünümü.
Kamera donanımının aygıt yöneticisinin görüntü aygıtları arasında yer almamasının nedeni,
Kinect kamerasının aslında fotoğraf makinesi gibi davranıp görüntüyü resimler halinde iletmesidir. Bu
sayede uygulama içerisinde görüntüye çok daha kolay ulaşabiliyoruz. Kinect'in yüksek hassaslıktaki
mikrofonunu ise Windows uygulamalarında kullanabiliyoruz.
4. Uygulama Geliştirmek
Kinect SDK ile C#, VB.NET ve C++ dilleriyle WPF ve Windows Forms uygulamaları
geliştirebilmekteyiz. Örnek bir uygulamada C# ile bir WPF uygulaması yapılacağı varsayılırsa öncelikle,
Visual Studio ile oluşturduğumuz WPF uygulamamızın referansları arasına
3
"Microsoft.Research.Kinect.dll" ve "Coding4Fun.Kinect.Wpf.dll" bileşenleri eklenmelidir. Kinect
SDK'sına ve yardımcı metodlara ulaşmak için ise using statementlar arasına:
using Microsoft.Research.Kinect.Nui;
using Coding4Fun.Kinect.Wpf;
satırlarını eklememiz gerekecektir. Bu aşamadan sonra Kinect'in özelliklerine ve yardımcı metodlarına
ulaşabiliyor olacağız.
4.1.Kamera Görüntüsü Alma
MainWindow içerisine eklenilen Image elementini kullanarak kamera görüntüsüne
ulaşılmaktadır. Öncelikle Kinect runtime'ı oluşturacağız, runtime ayarlarında yalnızca görüntü
kullanacağımızı bildireceğiz, her bir görüntü karesi aktarıldığında tetiklenecek eventi belirleyeceğiz,
görüntü akışını açıp gelen görüntüleri Image elementine aktaracağız.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;
using Microsoft.Research.Kinect.Nui;
using Coding4Fun.Kinect.Wpf;
namespace KinectSensorKameraErisimi
{
public partial class MainWindow : Window
{
public MainWindow()
{
InitializeComponent();
}
Runtime kinectNui = new Runtime();
private void Window_Loaded(object sender, RoutedEventArgs e)
{
// Yalnızca renkli görüntü aktarımı yapacak şekilde Kinect runtime'ı başlat
kinectNui.Initialize(RuntimeOptions.UseColor);
// Renkli görüntü iletiminde tetiklenecek event
kinectNui.VideoFrameReady +=
new EventHandler<ImageFrameReadyEventArgs>(kinectNui_VideoFrameReady);
// Renkli görüntü aktarımını başlat
kinectNui.VideoStream.Open(ImageStreamType.Video, // Video yayını
2, // Önbellekteki resim sayısı
ImageResolution.Resolution640x480, // Video çözünürlüğü
ImageType.Color // Yayınlanan video türü
4
);
}
void kinectNui_VideoFrameReady(object sender, ImageFrameReadyEventArgs e)
{
// Gelen görüntüyü Image elementinde göster
imgVideo.Source = e.ImageFrame.ToBitmapSource();
}
private void Window_Closed(object sender, EventArgs e)
{
// Kaynakları serbest bırak
kinectNui.Uninitialize();
}
}
}
Uygulamayı çalıştırdığımızda renkli kamera görüntüsünü Image elementi içerisinde görebiliriz.
Microsoft SDK CoordinateMapper adında kullanışlı bir yardımcı program ile kullanıma hazır
geliyor, CoordinateMapper 3B uzayda renkli bir nokta veya derinliği 2D uzayda aynı noktasına karşılık
olup olmadığını tespit etmektedir. CoordinateMapper KinectSensor ile bu bağlamda kullanılabilecek
bir fonksiyondur.
İnsan eklemlerin koordinatlarına erişen C # kodu:
foreach (Joint joint in body.Joints)
{
// 3D coordinates in meters
CameraSpacePoint cameraPoint = joint.Position;
float x = cameraPoint.X;
float y = cameraPoint.Y;
float z = cameraPoint.Z;
}
Koordinatlar CameraSpacePoint yapı içine paketlenmiş 3D noktaları temsil etmektedir. Her
CameraSpacePoint X, Y ve Z değerlerine sahiptir. Bu değerler, metre cinsinden ölçülür. Görsel
öğelerin boyutları piksel olarak ölçülür, bu yüzden bir şekilde 2D ekran piksel içine gerçek dünya 3D
değerleri dönüştürmek gerekir. Kinect SDK bu dönüşüm için ColorSpacePoint ve DepthSpacePoint
fonksiyon imkanı sunar.
İskelet bağlantı noktalarını birleştirmek için:
public void DrawPoint(ColorSpacePoint point)
{
// Create an ellipse.
Ellipse ellipse = new Ellipse
{
Width = 20,
Height = 20,
Fill = Brushes.Red
};
// Position the ellipse according to the point's coordinates.
Canvas.SetLeft(ellipse, point.X - ellipse.Width / 2);
Canvas.SetTop(ellipse, point.Y - ellipse.Height / 2);
// Add the ellipse to the canvas.
canvas.Children.Add(ellipse);
}
5
Derinlik çerçevenin üzerinde bir DepthSpacePoint çizebilirsiniz. Ayrıca iki nokta arasındaki
kemikleri (çizgiler) çizebilirsiniz. Renkli görüntünün üstüne bir koordinat haritalama da
ekleyebilirsiniz.
İskelet tahmini için elde edeceğiniz görüntü yaklaşık resimde göründüğü gibi olacaktır.
DENEYLER:
Duruş pozisyonuna ait bilgilerin elde edilmesinin ardından yapılması gereken çalışmalar:
1- Örnek bir trafik polisi hareketine ait tespitin gerçekleştirilmesi (1,-7).
2- Kamera karşısındaki kişiye ait boy uzunluğunun hesaplanması.
3- Örnek bir egzersiz hareketine ait tespitin gerçekleştirilmesi (1,-6).
4- Kamera karşısındaki kişiye ait kulaç uzunluğunun hesaplanması.
5- Örnek bir hakem hareketine ait tespitin gerçekleştirilmesi (1,-10).
Çıkarılan iskelet bilgileri üzerinden hareket tespitinin gerçekleştirme tekniği öğrencinin
insiyatifindedir. Nasıl gerçekleştirdiği konusundaki çalışmalarını deney sırasında aktarması
gerekmektedir.
Koordinatları çıkarılan örnek görüntüler aşağıdadır:
Trafiğe açık alan gösteren trafik polisi. Kenar atışı gösteren maç hakemi.
Boyun egzersizi yapan kişi.
6
Resim3:Trafik Polis İşaretleri
Resim4:Egzersiz Hareketleri
Resim5:Maç Hakemi Hareketleri
5. Kaynaklar
- http://filepi.com/i/HMUop4Y (Beginning Kinect Programming with the Microsoft Kinect SDK)
- Ayrıca yukarıda uygulama geliştirmek için kaynak olarak verilen linkler.
1 2 3 4
5
6
7
1 2 3 4 5
6 7 8 9 10
Bilgisayar Sistemleri Laboratuvarı Dersi
Son
Veri Madenciliği Dersi
Giriş
Veri Madenciliği
AR GE, 1991 yýlýn dan bu ya na müþ te ri le ri ne yö ne tim
da nýþ man lýðý hiz met le ri sun mak ta dýr. Bu gün ge liþmiþ
me to do lo ji le ri, çe þit li sek tör ler de el de et ti ði de ne yim le ri
ve güç lü da nýþ man eki bi ile AR GE Tür ki ye’nin ön de ge -
len ku ru luþlarý ara sýn da yer al mak ta dýr.
Ra kam lar, AR GE’nin ye ni iþle ri nin %60’ýnýn es ki müþ -
te ri le rin den gel di ði ni gös ter mek te dir. Bu is ta tis tik, müþ te -
ri mut lu lu ðu nun bir gös ter ge si ola rak önem ver di ði miz
bir per for mans gös ter ge si dir.
Gü cü nü, müþ te ri le ri nin ar tan per for mans la rýn dan
alan AR GE’nin müþ te ri pro fi lin de ken di sek tör le rin de
ön der fir ma lar bu lun mak ta dýr. Biz ce için de bu lu nu lan
ko num ne ka dar iyi olur sa ol sun, bu nun la ye tin me mek
ve da ha iyi ye ulaþ mak için gay ret gös ter mek, li der ol ma -
nýn çok önem li ve iç gü dü sel bir özel li ði dir.
En iyi yi ba þar mak için hiç vaz geç me di ði miz þu te mel
pren sip le ri uy gu la mak ta yýz:
• Müþ te ri le ri mi zin iþ le ri ne ar tý de ðer kat mak,
• Ya ra tý cý yak la þým lar ve uy gu la na bi lir çö züm ler üret mek,
• Üst len di ði miz her iþi en iyi þe kil de ger çek leþ tir mek
için hiç bir fe da kâr lýk tan ka çýn ma mak,
• Müþ te ri le ri mi zin giz li li ði ne da ima özen gös ter mek.
Hiz met le ri mi zi ya pý lan dý rýr ken en ön de tut tu ðu muz
un sur “uy gu la ma”dýr. Bu yak la þým ve ri len hiz met le rin sa -
de ce öne ri ve ra por lar ile ký sýt lý ol ma sýn dan çok fark lý
olup ger çek bir kat ma de ðer ya rat mak ta dýr.
AR GE’nin gö rü þü ne gö re, iþ per for man sý ný
doð ru dan et ki le yen dört te mel un sur bu lun mak ta dýr.
Bun lar iþ stra te ji si, bu stra te ji yi ger çek leþ tir mek için ge -
rek li olan iþ yap ma yön tem le ri, in san kay nak la rý ve tek -
noloji yönetimidir. Deðer yönetimi alanýn da özel bir
metodoloji ile çalýþan AR GE, çalýþ ma baþýn da müþ -
terisinin þir ketinin deðerini öl çer ve çalýþ malarýný bu
deðeri yük selt meye odak lar.
Bu çer çevede AR GE’nin sun duðu danýþ man lýk
hiz met leri dört ana baþ lýk al týn da top lan mak tadýr:
Strateji, Yönetimde Kalite, Kurum sal laþ ma, Geleceği
Şekillendirme.
ARGE danýþmanlarý, uzmanlýk konularýnda dünyadaki geliþmeleri takip etmek için senede bir ay eðitim alýrlar.
Sosyal sorumluluðunun bilincinde olan bir kurum olarak, çalýþanlarýnýn haftada bir gün gönüllü kuruluþlarda
çalýþarak deneyimlerini toplumsal sorunlarýn çözümünde kullanmalarýný teþvik eder.
ARGE, Avrupa Parlamentosu’nda kurumsal sosyal sorumluluk projeleriyle geleceði þekillendiren en iyi üç
þirket arasýnda deðerlendirilmiþtir (2002).
“Baþarýnýz için yanýnýzdayýz”
Strateji
Strateji Geliþtirme
Strateji Uygulama
(Balanced Scorecard)
Stratejik Ýþbirlikleri ve Birleþme
sonrasý Yapýlanma
Senaryo Planlama
Ülke Stratejileri
Yönetimde Kalite
Ýþ Etkinliði Deðerlendirmesi
Toplam Kalite Yönetimi
Süreç Verimliliği
Deðer Yönetimi
Yeniden Yapılanma
Kurumsallaþma
Ýnsan Kaynaklarý Yönetim
Sistemleri
Kurumsal Yönetiþim
Aile Þirketlerinde
Kurumsallaþma
Entelektüel Sermaye Yönetimi
İnsan Kaynakları
SistemDeğerlenidrmesi
Geleceği Şekillendirme
Toplumsal Katkıyı Yapılandırma
İşbirlikleri Geliştirme
Toplumsal Yönetişim
STK Etkinliği Geliştirilme
Sosyal Destek Projeleri
www.arge.com
Veri Madenciliği
Bu dört ana başlık altında verilen hizmetler şu şekildedir:
Veri Madenciliği
Veri Madenciliği
Veriden Bilgiye, Masraftan Değere
Dr. Yılmaz Argüden
Veri Madenciliği
Burak Erşahin
•
•
VERİ MADENCİLİĞİ
Veriden Bilgiye, Masraftan Değere
Dr. Yılmaz ARGÜDEN
Burak ERŞAHİN
Bu kitap kurumlarda verinin kullanımını artırarak, yönetim
kalitesinin geliştirilmesine destek olmak üzere ARGE Danışmanlık A.Ş.
tarafından hazırlanmış ve Alkim Kağıt San. ve Tic. A.Ş.’nin
destekleriyle yayınlanmıştır
Veri Madenciliği başlıklı kitap KalDer tarafından
organize edilen 17. Ulusal Kalite Kongresi katılımcılarına
ARGE Danışmanlık’ın hediyesi olarak sunulmaktadır.
ARGE Danışmanlık Yayınları No: 10
Veri Madenciliği
Veriden Bilgiye,Masra an Değere
Yazan ve Derleyen
Dr. Yılmaz ARGÜDEN
Burak ERŞAHİN
© ARGE Danışmanlık A.Ş.
Her hakkı saklıdır. Bu kitabın hiçbir kısmı yayıncısının izni
olmaksızın elektronik veya mekanik, fotokopi, kayıt ya da
herhangi bir bilgi saklama, erişim sistemi de dahil olmak üzere
herhangi bir şekilde çoğaltılamaz.
ISBN: 978-975-93641-9-9
1. Basım Kasım 2008
ARGE Danışmanlık A.Ş.
Fazılkaptanoğlu Caddesi
Seba İş Merkezi No: 3 Kat: 9
Seyrantepe, 34418, İSTANBUL
Tel: (0212) 283 59 60
Faks: (0212) 283 59 64
www.arge.com
Bu kitap 100 gr Alkim mat kuşe kağıda basılmıştır
ÖNSÖZ....................................................................................................................................................................................................................................................................................................................................................5
VERİ MADENCİLİĞİ:
Veriden Bilgiye – Masra an, Değere.................................................................................................................................................................................................7
VERİ MADENCİLİĞİ............................................................................................................................................................................................................................................................................13
Giriş – Anlaşılabilirlik..........................................................................................................................................................................................................................................15
Veri Madenciliği Nedir?...................................................................................................................................................................................................................................15
Neden Veri Madenciliği...............................................................................................................................................................................................................................16
Veri Madenciliği Ne Değildir?.........................................................................................................................................................................................................17
Veri Madenciliğine Örnek....................................................................................................................................................................................................................17
Veri Madencisi Kimdir?.............................................................................................................................................................................................................................19
Veri Madenciliği Süreci (Döngüsü)................................................................................................................................................................................20
SEKTÖREL UYGULAMA ÖRNEKLERİ.................................................................................................................................................................................27
Riski Azaltmak (Riski Önlemek).................................................................................................................................................................................29
Müşteri Kaybını Azaltmak (Churn)............................................................................................................................................................30
Doğru Kişiye Doğru Ürünü (Yaklaşımı) Sunmak............................................................................................................31
Mevcut Müşterilere Çapraz Satış / Ek Satış
(Cross-Sell / Up-Sell)......................................................................................................................................................................................................................................32
Yeni Müşteri Kazanmak........................................................................................................................................................................................................................32
Standart dışı Davranışları Belirlemek / Güvenlik
(Fraud Detection)..................................................................................................................................................................................................................................................33
Diğer Konular...................................................................................................................................................................................................................................................................34
VERİ MADENCİLİĞİNİN FONKSİYONLARI..........................................................................................................................................................35
Tahmin / Öngörü (Supervised) Fonksiyonlar..................................................................................................................37
Tanımlama (Unsupervised) Fonksiyonlar....................................................................................................................................39
VERİ MADENCİLİĞİNİN ALGORİTMALARI
(Metotları / Teknikleri)..................................................................................................................................................................................................................................................................45
Karar Ağaçları (Decision Trees)................................................................................................................................................................................47
Regresyon Analizi (Regression Analysis)....................................................................................................................................49
Lojistik Regresyon (Logistic Regression).....................................................................................................................................52
Bayes..............................................................................................................................................................................................................................................................................................52
Apriori Algoritması................................................................................................................................................................................................................................56
Kümeleme Yöntemleri............................................................................................................................................................................................................................58
SONUÇ...................................................................................................................................................................................................................................................................................................................65
OKUMA ÖNERİLERİ..................................................................................................................................................................................................................................................................69
Okuma Önerileri –Teknik............................................................................................................................................................................................................................72
3
İçindekiler

ÖNSÖZ
Bilgi güçtür. Bilgiyi üretebilen, kullanabilen bireyler, şirketler ve toplumlar daha hızlı
gelişir, gelirlerini, kârlılıklarını ve refah düzeylerini artırırlar. Bilgi çağında değer yaratmanın yolu fiziksel varlıklardan çok, bilgi kaynaklarını etkin kullanmaktan geçiyor. Bu nedenle, bilgi yönetimi için birçok yöntem ve araç geliştiriliyor.
Günümüzde gelişen bilgi teknolojileri sayesinde her geçen gün daha çok veri sayısal olarak toplanıyor, saklanıyor ve hepsinden önemlisi kullanılıyor. Veri bilgiye
dönüştürülüp, kullanılıncaya kadar değer ifade etmez. Değerli olan verilerin irdelenip, bilgiye dönüştürülmesi ve karar için kullanılabilmesidir.
Büyük miktarda verinin çeşitli yöntemler ile analiz edilmesi ve çıkan sonuçların bir
uzman gözüyle yorumlanmasıyla geçmiş verilerden gelecek tahminleri yapmaya
yarayacak bilgiler edinilmesi işlemine veri madenciliği deniyor. Ülkemizde henüz
emekleme aşamasında olan veri madenciliği konusundaki yetkinliklerimizi artırmanın, kurumlarımızı doğru kararlara yöneltmesi ve başarı şanslarını artırması
açısından önemli olduğuna inanıyoruz.
Yönetim kalitesini geliştirme misyonuyla ve yarattığı katma değer ve toplumsal
katkılarıyla örnek olma vizyonuyla çalışan ARGE Danışmanlık, her sene yeni bir
yönetim aracını ve/veya anlayışını ülkeye kazandırmaya çalışıyor.
ARGE Danışmanlık kuruluşundan bu yana yönetim bilimi konusundaki deneyimlerini gerek iyi örnekler oluşturulmasına destek olarak, gerekse ‘Balanced
Scorecard’, ‘Kurumsal Sosyal Sorumluluk’, ‘Entelektüel Sermaye’, ‘Değer Yönetimi’, ‘Değişim Yönetimi’, ‘İtibar Yönetimi’, ‘Kurumsal Yönetişim’ gibi yayınlarla
Türk yönetim dünyasıyla paylaşarak yönetim alanında birçok yeniliğin Türkiye’de
uygulanmasına da öncülük yapıyor.
Bu kapsamda her sene yeni bir kitapçığı Ulusal Kalite Kongresi’nde Türk yönetim dünyasının kullanımına sunuyoruz. Bu sene de veri madenciliği konusunu
Türk yönetim dünyasının gündemine taşıyarak, bu konudaki deneyimlerimizi “Veri
Madenciliği: Veriden, Bilgiye – Masraftan, Değere” başlıklı kitap aracılığıyla sizlerle paylaşmaktan memnuniyet duyuyoruz.
Ülkemizdeki kurumların bilgiye dayalı kararlar ile her geçen gün daha yüksek
değer yaratması dileğimizle....
ARGE Danışmanlık A.Ş.
5

VERİ MADENCİLİĞİ:
Veriden Bilgiye,
Masraftan Değere
Dr. Yılmaz ARGÜDEN

İnsanoğlu yaşam kalitesini geliştirmek için bilgi ve bilimi kullanabilmesiyle
kendisini ayırt ediyor. İnsan topluluklarında da bilgi ve bilimi daha etkin olarak
üretebilen ve kullanabilenler göreceli
olarak daha yüksek yaşam standartlarına
kavuşabiliyorlar. Bu nedenle, ülkelerin
bilgi düzeyi, bilginin mülkiyet hakları,
analiz yetkinliklerini geliştiren eğitim sistemleri, ve bilgiye dayalı karar verme
kültürüne yakınlıkları, gelişmişlik düzeyleri açısından belirleyici oluyor.
Teknolojik gelişmeler dünyada gerçekleşen bir çok işlemin elektronik olarak
kayıt altına alınmasını, bu kayıtların kolayca saklanabilmesini ve gerektiğinde
erişilebilmesini hem kolaylaştırıyor, hem
de bu işlemlerin her geçen gün daha
ucuza mal edilmesini sağlıyor. Ancak,
ilişkisel veri tabanlarında saklanan birçok
veriden kararlar için anlamlı çıkarımlar
yapabilmek bu verilerin bilinçli uzmanlarca analiz edilmesini gerektiriyor. Üstelik veri miktarı arıkça bunların analiz
edilmesi de özel araçlar ve yöntemlerin
kullanımını zorunlu hale getiriyor.
Veriyi hızlı toplayan ve bilgiye dönüştürerek hızlı kullananlar rekabetçi
avantaj elde ederler. Veri madenciliği
büyük miktarda veri içinden gelecekle ilgili tahmin yapmamızı sağlayacak ilişki
ve kuralların aranmasıdır.
Veri madenciliği, özel ve kamu sektörü kuruluşlarında birçok şekilde kullanılabilmektedir. Bunlardan bazıları
aşağıdaki gibi sıralanabilir:
• Bir süpermarket müşterilerinin satın
alım eğilimlerini irdeleyerek, promosyonlarını belli müşterilere yönlendirmesi, aynı kaynakla daha çok satış
gerçekleştirmesine yardımcı olabilir.
• Bankalar kredi kararlarında kredi isteyenlerin özelliklerini ve davranışlarını
irdeleyerek batık kredi oranını azaltabilir.
• Havayolları sürekli müşterilerinin davranış biçimlerini irdeleyerek daha
etkin fiyatlandırma ile kârlılıklarını artırabilirler.
• Bir telefon şirketi müşteri davranışlarından öğrendikleri ile yeni hizmetler
geliştirerek, müşteri bağlılığını ve kârlılığını artırabilir.
• Maliye Bakanlığı Gelir İdaresi, şirketler
için risk modelleri kurarak vergi incelemelerini daha etkin yönlendirip,
vergi kaçaklarını azaltabilir.
• Hastaların teşhis ve tedavi maliyetleri
irdelenerek hastalık riskinin ilk aşamada tespiti, kontrolü ve kaynak
planlama açısından faydalı olur.
Ancak, bu faydaları sağlayabilmek
için veri madenciliği konusuna yatırım
yapmak gerekiyor.
Büyük veri tabanlarının analiz odaklı
olarak kullanılmasının önünde çeşitli engeller var: (i) Veri tabanlarındaki gözlemlerin birçoğunda bilgilerin eksik veya
yanlış olması, (ii) Bazı verilerin kişisel değerlendirmelere dayandırılması ve bu
nedenle gözlemler arasında tutarlı karşılaştırma yapılmasının güç olması, (iii)
Veri toplama süreçlerinin bütünü resmetmeyi engelleyecek ve bilinçli olmayan
seçicilikler içermesi (selection bias), (iv)
Veri tabanı yapısının analiz odaklı olmaması, (v) Analizi mânalı hale getirecek
9
bilgi eksikliklerini tamamlamanın maliyetli (veya imkansız) olması, (vi) Yetkin
analistlerin kullanılmaması, (vii) Analiz
teknikleri konusunda bilgi sahibi olanlarla,
irdelenecek karar hakkında bilgi sahibi
olanlar arasındaki iletişimin sağlıklı modelleme yapacak düzeyde olmaması gibi...
Bu nedenle, büyük veri tabanlarından faydalanılarak bilgi üretme sürecinde dikkat edilmesi gereken unsurlar
var. Öncelikle analizlerin güvenilir verilere dayandırılmasını, yapılacak herhangi bir analizin başkaları tarafından
da tekrarlanabilir olmasını ve verinin cevaplandırabileceği sorulara odaklanılmasını sağlamak gerekiyor. Bu nedenle,
veri madenciliği yapacak analistin ilk
adımı veri tabanındaki verilerin hangi
süreç ile ve nasıl toplandığını çok iyi anlamaktır. Bazı durumlarda çok bilgi var
sanılırken, birçok gözlemde aynı bilginin
kaydedilmiş olması, aslında bazı boyutlarda veri tabanının sığ olduğunu, bu boyutlardaki analizlerin çok az veriye
dayandırılacağını gösterir. Yine verilerin
toplanma sürecindeki istemsiz seçicilikler analizde ve daha da önemlisi analiz
sonuçlarının nerelerde uygulanabilir olduğunu belirlemek açısından büyük
önem taşır.
Ayrıca, analistlerin eğitim süreçlerinde genellikle temizlenmiş, örnek
küçük veri tabanlarının kullanılması, onların büyük veri tabanlarını incelerken
bazı önemli adımları atlamalarına neden
olabilir. Bu nedenle, veri madenciliğinde
ikinci adım veri tabanının içerdiği verileri iyi anlamaktır. Bunun için her gözlemde bulunan verilerin dağılımı,
ilişkilendirilmesi planlanan boyutların
örneklemesi ve veri tabanındaki gözlem
birimi ile modellemeye temel oluşturacak gözlem birimi arasındaki farklılıkları
giderme kuralları konusunda detaylı irdeleme yapılmalıdır. Bir veri tabanının
iyi anlamak için yapılacak ilk yatırım,
analizlerin ve sonuçların kullanılabilir olmasında büyük önem taşır.
Üçüncü önemli adım ise analiz sonuçlarının kullanılması planlanan kararları ve
çevre şartlarını iyi anlamaktır. Çünkü veri
tabanının hangi soruları yanıtlaması istendiğini anlamak doğru modelleme yapabilmenin temelidir. Korelasyon, neden-sonuç
ilişkisi değildir. Doğru modelleme yapacak teorik bilgiyi edinmeksizin, sadece teknik olarak korelasyonlara dayandırılan
çıkarımlar, analistlerin güvenilirliğini zedeleyebilir veya karar vericileri yanlış kararlara yönlendirebilir.
Dördüncü adım, teorik modeli kurmak ve veri tabanı kullanılarak test edilecek hipotezleri oluşturmaktır. Kurulan
modelin, geçerliliğini test etmek, bu nedenle veri tabanının bir kısmını kullandıktan sonra model ile yapılacak
öngörülerin veri tabanındaki diğer veriler kullanılarak doğrulanması, karar vericilerin modele duydukları güveni ve
modelin gerçek hayaa kullanılma olasılığını artırır.
Özetle, veri madenciliği veriden bilgi
üreterek, ortalama kararlar yerine özgün
kararlar verilmesini destekleyen, satışları, kârlılığı, yenilikçiliği ve kaynak kullanımında etkinliği artıran önemli bir
yönetim aracıdır.
Bu nedenle, veri madenciliği konusuna yapılacak yatırımları özendirmek,
eğitim sistemimizin bu konuda yetkin10
likleri geliştirmesini sağlayacak adımları
atmak ülkemizdeki kurumların başarısını artıracaktır. Bu şekilde yönetim kalitesini artıran kurumlar aynı zamanda
toplumsal refah düzeyimizin artmasını
ve toplumsal düzeninin korunmasını
sağlarlar.
11

VERİ MADENCİLİĞİ
Burak ERŞAHİN

Giriş – Anlaşılabilirlik
Dünya ile ilgili en anlaşılmaz şey, herşeyin tamamen anlaşılabilir olmasıdır. - Albert
Einstein
Veri madenciliği dünyanın anlaşılabilirliğine önemli ölçüde destek olan bir
kavramdır. Gelişen bilgi toplama, depolama ve işleme yetkinlikleri, giderek
artan bir şekilde mevcut verilerin incelenerek anlamlı sonuçlar elde edilmesine
olanak sağlamaktadır.
Artık hangi genlerin hangi hastalığa
neden olduğunu, hangi müşterilerin kredisini geri ödeyemeyeceğini, hangi koşullarda yağmur yağacağını, hangi filmin
yüksek gişe hasılatı yapacağını veya
müşterilerin bir sonraki alışverişlerinde
hangi ürünleri alacaklarını bilebilmek
çok şaşırtcı değildir. Asıl şaşırtıcı olan bu
sonuçlara ulaşabilecek kurumların, verilerini topluyor olmalarına rağmen bu verileri anlamlı bilgilere dönüştürmüyor
olmalarıdır.
Bu çalışma veri madenciliği konusunda yazılmış mevcut literatüre bir alternatif değildir. Çalışmanın temel amacı;
konuya giriş yapmak, veriler ile neler yapılabildiğini aktarmak ve bireyleri karar
alırken veri kullanmaları konusunda teşvik etmek ve böylelikle karar kalitesini
artırmaktır.
Çalışmanın ana konusu olan üç temel
kavramı şu şekilde tanımlayabiliriz.
• Veri; sayılar, metinler, sesler ve görüntülerdir.
• Veri tabanı; sistematik erişim imkanı
olan, yönetilebilir, güncellenebilir, taşınabilir, aralarında tanımlı ilişkiler bulunabilen verilerdir.
• Bilgi: öğrenerek, deneyerek, araştırarak elde edilen, karar almaya yardımcı olan her türlü sonuçtur.
Veri Madenciliği Nedir?
Verinin bilgiye dönüştürülmesi
Veri madenciliği, büyük hacimli veri
yığınları içerisinden karar alabilmek için
potansiyel olarak faydalı olabilecek, uygulanabilir ve anlamlı bilgilerin çıkarılmasına verilen addır. Veri madenciliği
geniş anlamda veri analiz teknikleri bütünüdür ve tek başına bir çözüm değildir. Mevcut problemleri çözmek, kritik
kararları almak veya geleceğe yönelik
tahminleri yapmak için gerekli olan bilgileri elde etmeye yarayan bir araçtır. Ortaya çıkarılması hedeflenen bilgiler; üstü
kapalı, çok net olmayan, önceden bilinmeyen, daha önce keşfedilmemiş ancak
potansiyel olarak kullanışlı anlamlı ve
kritik bilgilerdir.
Veri madenciliği döngüsü, veri yığınlarını elden geçirmekle başlayarak, analiz sonucunda ortaya çıkan sonuçların
uzman gözüyle yorumlanması ile tamamlanır. Veri madenciliği çalışmalarının
15
1 The most incomprehensible thing about the world is that it is at all comprehensible
Veritabanlarında Bilgi Keşfi, Bilgi Çıkarımı, Veri Analizi, Veri Arkeolojisi, Bilgi Hasatı, İş Zekâsı, Data Mining, Information Harvesting, Knowledge Discovery
in Databases, Data Pattern Processing, Database Mining, Data Archaeology, Knowledge Mining, Data
Dredging, Knowledge Extraction, Siftware, Desen Algılama, Pattern Recognition
alt yapısının önemli bir bölümünü istatistik ve
veritabanı uygulamaları oluşturmaktadır.
Veri madenciliği, büyük boyutlu veri
ambarlarının meydana çıkmasının bir sonucudur. 1960’larda veriler elektronik ortamda toplanmaya ve geçmiş veriler
bilgisayarlar ile analiz edilmeye başlanmıştır. 1980’lerde bağıntılı (relational) veritabanları ve SQL ile verilerin dinamik
ve anlık analiz edilmesine olanak sağlanmıştır. 1990’lara gelindiğinde toplanmakta olan verinin hacmi çok büyük
boyutlara ulaşmış ve verilerin depolanması için veri ambarları kullanılmaya
başlanmıştır. Veri madenciliği toplanan
bu büyük veri kütlelerinin değerlendirilmesi için istatistik ve yapay zeka tekniklerinin kullanılması sonucunda ortaya
çıkmıştır.
Teknolojik gelişmeler, ham verilerin
yeni fırsatlar üretmek üzere yönetim ve
pazar ihtiyaçlarına yanıt verecek bilgiye
dönüştürülmesini kolaylaştırmış ve bir
anlamda kurumları veri madenciliği üzerinde çalışmaya mecbur bırakmıştır.
• Ölçüm cihazlarının çeşitlenmesi ve
otomatik veri toplama araçlarının
gelişmesi sonucunda toplanan verilerin türleri ve sayısı artmıştır.
• Veritabanları ve veritabanı teknolojisinin gelişmesi sonucunda veri depolarında çok miktarda verinin
depolanması sağlanmıştır.
• Bilgisayar ve veri işleme teknolojisinin gelişmesi sonucunda toplanan
verilerin hızlı biçimde çözümlenmesine olanak sağlanmıştır.
Veri madenciliği; veritabanı teknolojisi, makine öğrenmesi, desen tanıma,
istatistik, görselleştirme gibi birçok farklı
disiplinden yararlanmaktadır.
Neden Veri Madenciliği
Veri ile değil, bilgi ile çalışma avantajı
Her alanda, verilen kararların doğruluğu, kararı veren kişinin yeteneklerine ve
deneyimine olduğu kadar sahip olduğu
bilginin yeterliliğine de bağlıdır. Bu nedenle artık “bilgi”, mal ve hizmetin yanında üçüncü üretim faktörü olarak
değerlendirilmektedir. Bilginin yeterli olması, bilgiyi oluşturan verilerin doğru depolanması, doğru işlenmesi ve doğru
yorumlanmasına bağlıdır. Buna ek olarak
karar vericiler doğru kararları alabilmek
için mümkün olduğunca çok veriyi depolamaya çaba göstermektedirler.
Ancak verilerin toplanması, bir oyuna
giriş bileti almaktan çok farklı değildir.
Asıl zorluk devamlı çoğalmakta olan
ham veriyi, anlamlı ve kullanılabilir bir
bilgiye dönüştürebilmektir. Bilgi sistemleri birçok açık olmayan ve geleneksel
yöntemlerle anlaşılamayan bilgileri içermektedir.
Veri madenciliği, özellikle kar ve pazar
payı elde edebilmek için yoğun rekabetin
yaşandığı pazarlama alanında ön plana
çıkmaktadır. Hangi müşteri, hangi ürünü,
ne zaman satın alabilir, kimler tedarikçilerinden vazgeçmekte ve bu tür müşterileri
vazgeçirmek / geri kazanmak için neler yapılabilir, ürünün değerini yitirmesine
hangi değişkenler neden olmaktadır, vb.
16
2 Wikipedia
soruların cevapları veri yığınlarının altındadır ve cevapları bulabilmek için veri
madenciliği çözümleri gereklidir.
Veri Madenciliği ile şirketler önceden
bilinmeyen bilgileri ortaya çıkararak
karar verme süreçlerini iyileştirirler. Veri
madenciliği teknikleri kullanarak; maliyetleri azaltmak, gelirleri artırmak, verimliliği artırmak, yeni fırsatları ortaya
çıkarmak, yeni keşifler yapmak, emek
yoğun faaliyetleri otomatikleştirmek,
sahtekarlıkları belirlemek ve müşteri deneyimini geliştirmek mümkündür.
Özetle, veri madenciliği iki gereksinimden ortaya çıkmaktadır.
• Toplanan çok miktarda verinin işlenme ihtiyacı
• Artan rekabette doğru karar verebilme yetkinliğini artırmak ihtiyacı
Veri Madenciliği Ne Değildir?
İdeal durumda tüm kurumlar faaliyetleri sonucunda elde eikleri verileri değerlendirerek, kullanılabilir sonuçlar elde
etmeyi hedeflemelidirler. Ancak uygulamalara baktığımızda kurumların önemli
bir kısmının verileri toplamanın ötesine
geçmedikleri gözlenmektedir. Gelişim çizgisine bakıldığında verilerin toplanması
(ve doğru şekilde toplanması) başlangıç
noktasıdır. Elde edilen verilerden yapılacak sorgulamalar ve detaylı analizler ile
elde edilen sonuçları veri madenciliği olarak değerlendirmemek gereklidir. Bir ölçüde bunlar da veri madenciliğidir ancak
daha doğru tanımı veri düzenlemeciliği
olarak adlandırılabilir.
Veri madenciliği; veri toplamak, mevcut verilerden sorgulamalar yapmak veya
gelişmiş analiz teknikleri kullanmanın
ötesinde bir noktadır.
• Bir restoran zincirinde; hangi şubelerin ne kadar ciro yaptığı, hangi ürünlerin hangi noktalarda daha fazla
satıldığı, hangi saatlerde yoğunluk yaşandığı, gibi analizler veya
• Bir satış şirketinde; hangi müşterilerin
devamlılık gösterdikleri, hangi bölgelerde performans düşüklüğü yaşadıklarını belirlemek veri madenciliği
değildir.
• Gelir ile yaş ilişkisinin incelendiği bir
değişken, bir sonuç ve az sayıda veriden oluşan bir modeli tanımlayarak,
yaşa göre gelir tahmini yapmak da
veri madenciliği değildir. Yüz değişkenin olduğu, değişkenler arasında
sadece rakamsal değerlerin değil, sıralı (örnek: yüksek-orta-düşük) veya
sırasız (örnek: evli-bekar-dul) kategorilerin olduğu, milyon tane verinin olduğu ancak doğru algoritmalar ve
güçlü bir bilgisayar ile sonuca ulaşmanın mümkün olduğu modelleri
kurmak veri madenciliğidir. Algoritmalar yukarıdaki örnekteki lineer regresyondan daha karmaşık olmakla
birlikte, kavram aynıdır, mevcut verileri kullanarak tahmin veya tanımlama yapmak.
Veri Madenciliğine Örnek
Bir banka müşterilerine yeni bir ürün
sunacaktır. Bu ürün çağrı merkezinden yapılacak müşteri aramaları ile telefon üzerinden sunulacaktır. Çağrı merkezi ile
yapılan anlaşma gereği her bir müşteriye
ulaşmanın bedeli 3 YTL olarak tanımlan17
mıştır. Ürünün satılması halinde bankanın
elde etmeyi beklediği kar ortalama 100
YTL’dir. Bankanın müşteri portföyünde 2
milyon müşteri bulunmaktadır. Daha önceki satış kampanyalarından müşterilerin
%2,5 oranında olumlu yanıt verdikleri
gözlenmiştir.
Bu veriler doğrultusunda değerlendirme yapıldığında ürün sunma kararını
almak mümkün değildir çünkü kampanyadan 1 milyon YTL zarar edilmesi öngörülmektedir.
Bu noktada veri madenciliği teknikleri ile bir değerlendirme yapıldığında
kapmayanın yapılması kararı alınmıştır.
Müşterilerin %1’lik kısmı için bir deneme kampanyası yapılmıştır. Bu kampanyada 2.000.000 müşterinin %1’i olan
20.000 müşteriye ulaşılmış ve 500 müşteriden olumlu yanıt alınmıştır. Bu deneme kampanyasında elde edilen
veriler, istatistiksel teknikler ve müşterilerin bilgileri birlikte kullanılarak gerçek
kampanya için kullanılabilecek bazı
önemli sonuçlara ulaşılmıştır.
Bu değerlendirme sonucunda müşterilerin sadece %50’si ile temas kurarak,
ürünü kabul edeceklerin %70’ine ulaşmak veya müşterilerin sadece %40’ı ile
temas kurarak, ürünü kabul edeceklerin
%60’ına ulaşmanın mümkün olacağı sonucuna ulaşılmıştır.
Bu durumda;
18
Veri Madencisi Kimdir?
Analiz ve iş bilgisinin bir araya gelmesi
Cevap aranılan soru veya çözülecek
problem için kurulan bir modelin başarılı
olabilmesi sadece metodolojilerin derinlemesine biliniyor olmasına bağlı değildir.
Veriyi ve pazarı tanımak, kurumun iş hedeflerini biliyor olmak, modelin altyapısını oluşturan metodolojilerden çok daha
önemlidir.
Her alanda olduğu gibi veri madenciliğinde de teknoloji ile deneyimin birleşimi en doğru sonuca ulaştırmaktadır.
Deneyimin elde edilen sonuçlar üzerindeki etkisi oldukça yüksektir.
Veri madenciliği bilincinin artması ile
birlikte, bu tür çalışmalara ağırlık vermek isteyen şirketlerin büyük bölümü iki
önemli hata yapmaktadırlar.
• Çalışmaları gerçekleştirmek için teknik konulara hakim istatistik uzmanları veya teknik analistleri işe alarak,
modelleri kurgulamalarını istemek:
Bu kategorideki uzmanlar teknik konularda çok yetkin olmalarına rağmen, gerekli iş kavrayışına yeterince
sahip olmamaları nedeniyle arzu edilen sonuçlara çoğunlukla ulaşılamamaktadır.
• Sofistike veri madenciliği yazılımları
satın almak: Konu ile ilgili çok detaylı,
tüm metodolojileri içeren yazılımlar
mevcuttur ancak yazılımlardan faydalı sonuçlar alabilmek için doğru
modeli kurgulamak ve doğru girdileri
sunmak gereklidir. Bu düşünce sürecinden geçmeden yazılımdan faydalı
sonuçlar elde etmek mümkün değildir.
Her iki yaklaşımda da; hedefi oluşturma, veriyi elde etme, veriyi hazırlama, modeli uygulama, sonuçları
değerlendirme gibi önemli alanlarda
bilgi eksikliği söz konusu olabilir. Bu
alanların herhangi birinde yapılacak hata
19
çok maliyetli olabileceği gibi tamamen
yanlış sonuçlara da götürebilir.
İstatistiksel araçları çok iyi bilen en iyi
teknik analistlere sahip olmak kadar bunu
gerçek dünyanın problemlerine nasıl
uyarlayacaklarını bilmek de önemlidir. Bu
aşamada veri madenciliğinin 3 farklı boyutuna bakmakta, ilişkileri ve gereksinimleri anlamak açısından fayda vardır.
• Yanıtlanacak soru nedir? / Neye
cevap aranmaktadır?
• Cevap aranan konuyu hangi veri madenciliği fonksiyonu ile çözümlemek
gerekir?
• İlgili veri madenciliği fonksiyonu için
hangi algoritma ile model oluşturmak uygun olur?
Cevap aranılan sorunun tanımlanması
ve uygun fonksiyonun seçilmesi aşamasında faaliyeen sorumlu olan profesyonellerin daha etkin rol alması, seçilen
fonksiyona uygun algoritmanın belirlenmesi ve işletilmesi aşamasında istatistik uzmanlarının daha etkin rol alması gerekir.
Veri Madenciliği Süreci
(Döngüsü)
Veri madenciliği süreci en basit şekli
ile dört adımdan oluşmaktadır.
1. Veri Seçmek: Mevcut olan ve elde
edilebilecek verilerin oluşturduğu
veri havuzundan çalışma için kullanılacak verilerin seçilmesi
2. Veri İşlemek: Farklı kaynaklardan
alınan verilerin birleştirilmesi, hatalı
verilerin çıkarılması, vb. ile seçilmiş
verilerin kullanılabilir hale getirilmesi
3. Veri Eğilimlerini / Desenlerini
Belirlemek: İşlenmiş verilerin veri
madenciliği fonksiyonları ve algoritmaları ile değerlendirilerek verilerden anlamlı eğilimlerin, desenlerin
(pattern) çıkarılması
4. Bilgiye Ulaşmak: Verilerden çıkarılan anlamlı eğilimler ve desenlerin
yorumlanarak bilgi elde edilmesi
Daha detaylı süreç tanımı ise veri madenciliğinin uluslararası düzeyde standardı olarak kabul edilmiş, CRISP-DM
(CRoss Industry Process for Data Mining)
ile yapılmaktadır. Veri madenciliği projelerinin hızlı, daha verimli ve daha az maliyetli gerçekleştirilmesi için geliştirilmiş
olan bu süreç altı adımdan oluşmaktadır.
1. İşi ve İş Ortamını Anlama
(Business Understanding):
İlk adım veri madenciliği çalışmasının hangi amaç için yapılacağının
net olarak tanımlanmasıdır. Amaç;
cevap aranılan sorunun üzerine
odaklanmalı, net biçimde ifade edilmeli ve sonuç değerlendirme kriterleri tanımlanmalıdır. Çalışma
sonunda doğru cevaplanmış birçok
yanlış soru elde edilmek istenmiyorsa, çalışmanın cevap aranılan
soru ile uyumlu olması güvence altına alınmalıdır.
a. İş Hedeflerini Algılamak: Çalışmanın temel amacının belirlenmesi ve
bu amacın mümkün olduğunca
ikincil amaçlardan ayrıştırılarak net
olarak tanımlanması aşamasıdır.
Çalışma sonuçlarının değerlendirme kriterlerinin belirlenmesi de
20
bu aşamada yapılması gereken
diğer bir konudur.
b. Durumu Değerlendirmek: Veri madenciliğinin temel amacı verim artırmaktır. Bu amaç elde edilecek
sonuçlar kadar sürecin kendisi için
de geçerlidir. Çalışma sonucunda
elde edilecek faydayı değerlendirmek (yanlış kararların maliyetleri
ve doğru kararların getirilerine ilişkin öngörüler) önemli bir gerekliliktir. Bu aşamada çalışma için
gerekli kaynaklar, tahmini maliyet,
mevcut kısıtlar, olası riskler, vb. değerlendirilerek elde edilecek faydanın boyutu ile karşılaştırılır.
2. Veriyi Anlama (Data Understanding):
İkinci adım ilk verilerin toplanması,
mevcut verilerin uygunluğunun değerlendirilmesi, modeli oluşturmak
için gerekli farklı veri ihtiyaçlarının
tespit edilmesi, sahip olunan kayıt sayısının yeterliliği gibi veri kalite ve
yeterliliğine yönelik düşünce sürecinden geçilmesi aşamasıdır. Hedef
çalışmada kullanılacak verilere aşinalık kazanmaktır. Veriyi anlamak ile
işi anlamak iç içe geçmiş alt süreçlerdir. İşi anladıkça farklı verilere bakmak
veya verilerin gösterdiklerini anlamak, verilere baktıkça iş ile ilgili farklı
bakış açıları kazanmak mümkündür.
Bu döngü kendi içinde devam ettikçe
çalışmada kullanılacak verilerin netlik
kazanır.
a. Başlangıç Verilerini Toplamak: Proje
kaynaklarında tanımlanmış olan
başlangıç verilerinin toplanması
aşamasıdır.
b. Veriyi Tanımlamak: Toplanan verinin
tanımlanması ve ihtiyaçları karşılama yeterliliğinin değerlendirilmesi aşamasıdır.
c. Veriyi Keşfetmek: Başlangıç aşamasında toplanan veriler ile başlangıç
hipotezlerinin oluşturulması, limitli
bir şekilde veriden çıkarımlar yapılması aşamasıdır. Bu aşamada sonuca yönelik bilgilerin elde
edilmesinden daha çok çalışmanın
gerçekleştirilebilmesi için veri anlamında eksikliklerin tespit edilmesi amaçlanır.
d. Verinin Kalitesini Belirlemek: Veri
tam mı, doğru mu, hatalar içeriyor
mu, hatalar içeriyorsa ne tür hatalar içeriyor, veride eksik bölümler
var mı şeklindeki sorular ile verinin
kalitesinin tespit edilmesi aşamasıdır.
3. Veri Hazırlama (Data Preparation):
Bu aşama başlangıç verilerinin, çalışmalara temel oluşturacak final verilere dönüştürülmesi aşamasıdır. Bu
çalışmanın adımlarının belirgin bir sırası veya tekrar sayısı yoktur. Modelin
kurulması aşamasında ortaya çıkacak
sorunlar, bu aşamaya sık sık geri dönülmesine ve verilerin yeniden düzenlenmesine neden olabilmektedir.
Bu aşama karar vericinin veri keşfi sürecinin toplamı içerisindeki enerji ve
zamanının % 50’sinden fazlasını harcamasına neden olmaktadır.
21
3 www.crisp-dm.org
a. Veri Setini Tanımlamak: Modelin kurulacağı, tanımlanan soru için gerekli olduğu düşünülen veri setinin
(veriler ve bu verilerin toplanacağı
veri kaynakları) belirlenmesi aşamasıdır. Bazı durumlarda kurum
içinde büyük boyutlarda veri toplanıyor olmasına karşın, toplanmakta
olan veriler tanımlanan soru için yeterli olmayıp, başka veri gruplarından eklemeler yapmak gerekebilir.
Müşterilerinin yaptığı her işlemi
kaydeden, hesaplarının düzeyini,
kredi başvuru detaylarını tamamen
bilen bir bankanın veri madenciliği
çalışmaları için tüm verilere sahip olduğu düşünülebilir. Ancak yapılacak
bir pazarlama kampanyasında müşterilerin bireysel ilgi alanları gibi
demografik göstergelere göre değerlendirme yapılmak isteniyorsa
bu verileri bankanın veri tabanlarındaki operasyonel verilerden sağlamak mümkün değildir. Çalışmalar
öncesinde bu veriler doğrudan
müşteriler ile temas kurularak ya da
bir veri sağlayıcısından temin edilerek tamamlanmalıdır.
b. Veriyi Seçmek: Yapılacak analizde
kullanılacak verilerin belirlenmesi
aşamasıdır. Değerlendirme sırasında verinin hedefler ile ilişkisine,
kalitesine, teknik limitlere dikkat
etmek gerekir. Verilerin değişken
sayısı kadar kullanılan kayıt sayısı
da önemlidir. Gereğinden az veri,
çalışmayı eksik bırakabileceği gibi,
gereğinden fazla veri, veri kirliliğine ve sürecin uzamasına neden
olabilecektir.
c. Veriyi Temizlemek: Gürültülü ve tutarsız verileri çıkararak verinin kalitesini artırma aşamasıdır. Yanlış
girişden veya istisnalardan kaynaklanan verilerin, değerlendirmeden
çıkarılması tercih edilir. Bazı durumlarda çok büyük veri tabanı ile
çalışmak yerine örnekleme yapılması uygun olabilir (seçilen örneklerin tüm popülasyonu temsil
düzeyi önemlidir.) Verileri temizlemek sadece çıkarmak gibi düşünülmemelidir, bazı durumlarda eksik
verilerin tamamlamak için modellemeler yapmak da söz konusudur.
d. Veriyi Kurmak: Verileri tanımlayan
mevcut değişkenlerde modifikasyonlar yaparak model için daha kullanılır değişken setleri oluşturma
aşamasıdır. Örneğin müşterilere yapılan satışların aylık olarak kaydedildiği bir yapıda, müşterilerin
ortalama sipariş verme sıklığını tanımlamak, mevcut değişkenlerden
yeni bir değişken tanımlamaktır.
Herhangi bir ayda alım yapmamış
müşterilerin listede yer almaması
analizlerde yanlış sonuçlar doğurabileceğinden alım yapmayan müşteriler için sıfır miktarlı kayıtlar
eklemek yine bu aşamada sık yapılan uygulamalardan biridir.
e. Veri Birleştirmek: Veri madenciliğinde
kullanılacak verilerin farklı kaynaklardan toplanması, doğal olarak veri
uyumsuzluklarına neden olmaktadır. Bu uyumsuzlukların başlıcaları
farklı zamanlara ait olmaları, güncelleme hataları, veri formatlarının
22
farklı olması, kodlama farklılıkları
(örneğin bir veri tabanında cinsiyet
özelliğinin e/k, diğer bir veri tabanında 0/1 olarak kodlanması), farklı
ölçü birimleri ve varsayım farklılıklarıdır. Bu adımda farklı kaynaklardan
toplanan verilerin uyumsuzluklar
mümkün olduğu ölçüde giderilerek,
tek bir veri tabanında toplanması
amaçlanır. Ancak burada çok dikkatli ve titiz davranmak gereklidir.
Dikkatin en çok gerektiği aşamalardandır. Bu aşamada yapılacak bir
hata, ileriki aşamalarda daha büyük
sorunlar yaratacaktır. Doğru sonuç
alınacak veri madenciliği çalışmaları
ancak doğru verilerin üzerine kurulabileceği için, toplanan verilerin ne
ölçüde uyumlu oldukları bu adımda
incelenerek değerlendirilmelidir.
f. Veri Formatlamak: Veri seti oluşturulduktan sonra kullanılacak modele
göre anlam değişikliği yapmayacak
format düzenlemelerinin yapılması
aşamasıdır.
4.Modelleme (Modeling): Benzer veri
madenciliği problemleri için birden çok
çözüm tekniği olabilmektedir. Bazı teknikler verilerde spesifik ihtiyaçlar duyarlar. Bu nedenle veri hazırlama ve
model kurma aşamaları, en iyi olduğu
düşünülen modele varılıncaya kadar
yinelenen bir süreçtir. (Veri Madenciliği
Fonksiyonları / Algoritmaları bölümünde daha detaylı incelenmiştir.)
a. Model Tekniğini Seçmek: Kullanılacak veri madenciliği fonksiyonun
ve algoritmasının belirlenmesi aşamasıdır. (Veri Madenciliği Fonksiyonları / Algoritmaları bölümünde
daha detaylı incelenmiştir.) Genel
olarak verilerin oluşturulma aşamasından itibaren bu konuda bir öngörünün oluşmuş olması gerekir.
b. Model Test Tasarımı Yapmak: Modeli
işletip sonuçları elde etmeye başlamadan önce, modelin kalitesini ve
geçerliliğini test etmek gereklidir. Örneğin öngörü fonksiyonlarından sınıflandırma fonksiyonunda hata
oranlarını kalite göstergesi olarak
kullanılır. Veriler hazırlandıktan
sonra, ilk aşamada verinin bir kısmı
modelin öğrenilmesi, diğer kısmı ise
modelin geçerliliğinin test edilmesi
için ayrılır. Modelin öğrenilmesi, öğrenim kümesi kullanılarak gerçekleştirildikten sonra, test kümesi ile
modelin doğruluk derecesi belirlenir.
Modelde yanlış olarak sınıflanan
olay sayısının, tüm olay sayısına
bölünmesi ile hata oranı, doğru
olarak sınıflanan olay sayısının tüm
olay sayısına bölünmesi ile ise doğruluk oranı hesaplanır.
Sınırlı miktarda veriye sahip olunması durumunda, kullanılabilecek
bir yöntem, çapraz geçerlilik testidir. Bu yöntemde veri kümesi rasgele iki eşit parçaya ayrılır. İlk
aşamada bir parça üzerinde model
eğitimi ve diğer parça üzerinde
test işlemi; ikinci aşamada ise ikinci
parça üzerinde model öğrenimi ve
birinci parça üzerinde test işlemi
yapılarak elde edilen hata oranlarının ortalaması kullanılır.
Model kuruluşu çalışmalarının sonucuna bağlı olarak, aynı teknikle farklı
parametrelerin kullanıldığı veya
23
başka algoritma ve araçların denendiği değişik modeller kurulabilir.
Model kuruluş çalışmalarına başlamadan önce, hangi tekniğin en
uygun olduğuna karar verebilmek
güçtür. Bu nedenle farklı modeller
kurarak, doğruluk derecelerine göre
en uygun modeli bulmak üzere denemeler yapılmasında yarar bulunmaktadır.
Önemli bir diğer değerlendirme kriteri modelin anlaşılabilirliğidir. Bazı
uygulamalarda doğruluk oranlarındaki küçük artışlar çok önemli olsa
da, bir çok kuruluş uygulamasında
ilgili kararın niçin verildiğinin yorumlanabilmesi çok daha büyük
önem taşıyabilir.
Kaldıraç oranı ve grafiği, bir modelin sağladığı faydanın değerlendirilmesinde kullanılan önemli bir
yardımcıdır. Örneğin kredi kartını
muhtemelen iade edecek müşterilerin belirlenmesi amacını taşıyan
bir uygulamada, kullanılan modelin belirlediği 100 kişinin 35’i gerçekten bir süre sonra kredi kartını
iade ediyorsa ve tesadüfi olarak seçilen 100 müşterinin aynı zaman
diliminde sadece 5’i kredi kartını
iade ediyorsa kaldıraç oranı 7 olarak hesaplanmaktadır.
Ancak kurulan modelin doğruluk
derecesi ne denli yüksek olursa
olsun, gerçek dünyayı tam anlamı
ile modellediğini garanti edebilmek mümkün değildir.
c. Modeli Kurmak: Model için kullanılacak algoritmanın/yöntemin/tekniğin hazırlanan veri üzerinde
çalıştırılması aşamasıdır. Kurulan ve
geçerliliği kabul edilen model doğrudan bir uygulama olabileceği
gibi, bir başka uygulamanın alt parçası olarak da kullanılabilir. Kurulan
modeller risk analizi, kredi değerlendirme, dolandırıcılık tespiti gibi
işletme uygulamalarında doğrudan
kullanılabileceği gibi, promosyon
planlaması simülasyonuna entegre
edilebilirler.
d. Modeli Değerlendirmek: Başarı kriterleri, daha önceki tecrübeler ve
test sonuçlarına göre modelin değerlendirilmesi aşamasıdır. Tüm
projenin değerlendirilmesinden
çok modelin teknik değerlendirilmesi amaçlanır.
5. Değerlendirme (Evaluation):
Bu aşamaya gelindiğinde kurulmuş
bir model vardır. Bu aşama, modelin nihai olarak sunulmasından önce
modeli yoğun olarak değerlendirilmesi ve iş hedefleri ile uyumlu olup
olmadığının kontrol edilmesini
amaçlar. Kapsanmamış ( açıkta kalmış ) konu olup olmadığı değerlendirilmelidir.
a. Sonuçları Değerlendirmek: Ön değerlendirme aşamaları modelin
geçerliliği ve uygunluğu konusunda değerlendirme sunarken,
bu aşamada modelin iş hedeflerini
ne ölçüde karşıladığı değerlendirilir. Eğer zaman ve bütçe varsa gerçek veriler ile modelin test
edilmesi tercih edilir. Modelleme
sırasında ortaya çıkan ancak ana
hedefler ile ilişkisi olmayan diğer
ek faydaların da bu aşamada tanımlanması uygun olur.
24
b. Süreci Değerlendirmek: Kalite güvence aşamasıdır. Modelin iş hedeflerini karşılamaya yeterli olduğu
kararını aldıktan sonra, modelin
doğru kurulup kurulmadığı, sadece
eldeki verilerden mi yararlanıldığı,
gelecekte kullanılabilecek farklı verilerin neler olabileceği gibi konularda değerlendirmeler yapılmalıdır.
c. Gelecek Adımları Planlamak: Projenin
geldiği noktanın yeterli olup olmadığı, ek çalışma gerekliliğinin değerlendirilmesi aşamasıdır. Atılacak
başka adımlar nelerdir, bunu gerçekleştirebilecek bütçemiz var mı,
eğer devam etmek mantıklı ise nereden devam etmeliyiz gibi konularda değerlendirmeler yapılmalıdır.
6. Yayma (Deployment): Modelin tamamlanmış olması projenin nihai
sonucu değildir. Modelin amacı veriler hakkında bilinenleri artırmak
dahi olsa, elde edilen veri kullanılacak biçimde organize edilmeli ve
sunulmalıdır. Genellikle gerçek verilerden örneklerin sunulması şeklinde olur.
a. Yayma Planını Oluşturmak: Sonuçları değerlendirilerek, yayma stratejisinin oluşturulması aşamasıdır.
b. Takip ve Bakımı Planlamak: Zaman
içerisinde bütün sistemlerin özelliklerinde ve dolayısıyla ürettikleri
verilerde ortaya çıkan değişiklikler,
kurulan modellerin sürekli olarak izlenmesini ve gerekiyorsa yeniden
düzenlenmesini gerektirecektir.
Uzun süre yanlış veri kullanarak çalışmanın önüne geçmek için bakım
çok önemlidir.
c. Final Raporu Hazırlamak:Yapılan çalışmanın başkaları tarafından da tekrarlanabilirliğini sağlamak ve
sonuçlarını karar vericilere aktarabilmek üzere hazırlanan rapordur.
Çalışmanın üçüncü taraflarca denetlenebilmesini ve güvenilirliğini
sağlamak açısından önem taşır.
d. Projeyi Değerlendirmek: Yapılan
çalışmaya dayandırılan kararların
ve sonuçların belli bir zaman sonrasında beklentilerle karşılaştırıması ve gerektiğine çalışmanın
yenilenmesi aşamalarını içerir.
25

Sektörel Uygulama
Örnekleri

CNN’nin yayın akışının her dakikasının aldığı ratingden, IMDB web sayfasının kaç ziyaretçi aldığına, İstanbul’a eylül
aylarında düşen yağmur miktarından,
Markee en çok satılan süt markasına,
Av Köpekleri Takım Yıldızı’nın (Canes
Venatici) parlaklık düzeylerindeki değişimden, sedan otomobil satın alanların
yaşlarına, pandaların doğurganlık oranından, Everest’e tırmanan dağcı sayısına kadar çevremizde yaşananların çok
önemli bir kısmı sürekli olarak kaydedilmektedir.
Sayılardan oluşan tüm bu kayıtlar
ancak doğru şekilde bakıldığında bir
anlam ifade etmektedirler. Bu nedenle
veri madenciliği en geniş anlamı ile yaşadığımız ve kaydeiğimiz olaylara
anlam katmaktır.
Veri madenciliğinin uygulama alanlarını bilimsel ve iş dünyası olarak ikiye
ayırmak mümkündür. Bilimsel çalışmalarda veri madenciliği kullanımının ardında yatan sebepler; gelişmiş veri
toplama yöntemleri (otomatik istasyonlar, uydu ve uzaktan algılama sistemleri,
teleskop taramaları, gen çözümlemeleri,
vb.) ile işlenmek üzere ham olarak çok
büyük boyutlarda veri toplanması, geleneksel tekniklerin ham verileri işlemede
yetersiz kalması ve hipotezler oluşturma,
sınıflandırma, karar alma gibi bilimsel
çalışma adımlarında bilim insanlarına
destek olmasıdır.
İş dünyasında veri madenciliği uygulamalarının kullanılmasının temel nedeni; müşteriyi tanıyarak (müşteri gibi
düşünerek) müşteri memnuniyeti sağlamak ve bu şekilde rekabet ortamında
hızlı ve doğru kararları alabilmektir.
İş dünyasında her alanda veri madenciliği uygulamalarını kullanmak mümkündür ancak sundukları ürün ve
servislerle bilgiye dayalı yönetime en
fazla ihtiyaç duyan sektörler ve alanlar;
Finans (Bankacılık, Sigortacılık), Telekomünikasyon, Pazarlama ve Perakendedir.
İş dünyasında veri madenciliği çalışmalarının büyük bölümü üç temel ihtiyacı karşılamak için kullanılır. Bu
ihtiyaçlar; “Kaynakları Daha Verimli
Kullanmak”, “Potansiyeli Artırmak” ve
“Güvenliği Sağlamaktır”.
Riski Azaltmak (Riski Önlemek)
Ürün veya hizmet sunumu sonrasında kayıp yaşama potansiyeli yüksek
olan sektörlere özgü çalışmalardır. En
29
çok bankacılık ve sigortacılık sektörlerinde
riskleri değerlendirmek için kullanılır.
Bankalar müşterilerine kredi verdiklerinde bir finansal risk öngörürler, kurgulanan risk modelleri ile kredi alanların
kredilerini geri ödeyememe ihtimallerini
tahmin ederler. Krediye karşılık araba
veya evin ipotek edildiği durumlarda risk
daha düşük olmakla birlikte, kredi kartı
bankalar açısından riski en yüksek kredi
tipidir.
Sahtekarlık riski de bankalar için
önemli bir konudur. Kredi kartı kaybolduğunda bankalar kaybedilme sırasında
oluşan zararın bir kısmını üstlenmektedirler. Bu dönemde oluşan zararları azaltmak
için sahtekarlığı tespit edici sistemler kurgulanmaktadır. Müşterilerin tipik harcama biçimlerini önceden tanımlayıp,
harcama eğilimlerinde oluşan ani değişiklikleri tespit etmek ve bu doğrultuda
satınalma işlemlerini onaylamayı durdurmak kullanılan yöntemlerden biridir.
Sigorta endüstrisinde risk müşterinin
sigortalaığı üründe zararın oluşması ve
müşterinin zararının karşılanmasını talep
etmesidir. Tüm sigortacılık ürünlerinde fiyatlandırma için riskin doğru belirlenmesi
gereklidir. Fiyatlar üzerinde düzenleyici
kurulların etkisi nedeniyle, fiyatlandırma
kârlılık açısından çok önem taşımaktadır.
Bankacılık ve sigortacılık gibi tahsilatını daha sonra yapmak üzere ürün ve
hizmet sunan bir çok sektör risk taşımaktadır. Telekomünikasyon şirketleri,
enerji şirketleri, perakendeciler, vb. ürünün veya hizmetin ödemesini yapmayacak olan müşteri riskini taşıyan benzer
sektörlerdir.
• Yüksek riskli müşteriler ile çalışmamak: Firma için finansal kayıp oluşturabilecek müşterileri veya müşteri
adaylarını belirleyerek bunlar ile çalışılmamasını sağlamak.
• Kredi taleplerini değerlendirmek:
Mevcut müşterileri verilerinden
kredi risk davranış modelleri oluşturarak, yeni başvurularda riskin en
aza indirilmesini sağlamak.
• Kredi geri ödemelerini kontrol
altında tutmak (farklı risk politikaları oluşturmak): Kredi kartı ödemelerini aksatan, gecikmeli olarak yapan
veya hiç yapmayanların özelliklerinden yola çıkarak bundan sonra aynı
duruma düşebilecek muhtemel kredi
sahiplerini saptamak. Kötü ödeme
performansı gösteren müşterilerin
ortak özelliklerini belirleyerek, benzer
özelliklere sahip tüm müşteriler için
politikalar geliştirmek.
Müşteri Kaybını Azaltmak (Churn)
Müşterilerin, şirketin ürünlerini almaktan vazgeçerek rakip şirketin ürünlerini tercih etmeleri birçok endüstride
giderek büyüyen bir sorundur. Müşterilerin bir firmadan diğer firmaya geçmesinin en önemli sebebi çoğunlukla daha
iyi bir teklif almış olmalarıdır. Örneğin
bankalar düşük faiz oranları ile rakiplerinin kredi kartı müşterilerinin kendi
kredi kartlarını kullanmalarını sağlamaktadırlar. Kredi kartı kullanımı yaygınlaştıkça yeni kredi kartı müşterileri
pazarı oldukça küçülmüştür. Bu da kredi
kartı sunan bankaları yeni müşteri bula30
bilmek için rakiplerinin müşterilerini
elde etmek zorunda bırakmaktadır. Bankalar müşterileri çekebilmek için kısa bir
dönem için daha düşük kredi oranları
sunmakta, oranlar normale döndüğünde
müşterilerin bankada kalacaklarını düşünmektedirler.
Telekomünikasyon sektöründe en
önemli sorun müşteri kaybıdır. Şirketler
müşterilerinin rakiplerine geçmesini engellemek için çeşitli pazarlama taktikleri
uygulamakta, ürünleri sürekli yeni sunular ile çeşitlendirmektedirler.
• Mevcut müşteriyi elde tutmak:
Kuruluşlar hangi müşterilerini kaybedebileceklerini önceden belirleyebildikleri durumda, bu müşterilerini
elde tutma amaçlı stratejiler geliştirebilirler. Kendi müşterisiyken rakibine
giden müşterilerle ilgili analizler yaparak rakiplerini tercih eden müşterilerinin özelliklerini elde etmek
mümkündür. Bundan yola çıkarak
gelecek dönemlerde kaybetme olasılığı olan müşterilerin kimler olabileceği konusunda tahminlerde
bulunarak onlara özgü ürünler ve
servisler geliştirebilirler. Müşteriyi
elde tutmak için yapılacak maliyet
her zaman için müşteriyi geri kazanmak için yapılacak maliyetten düşük
olacaktır.
• Kaybedilen müşterileri yeniden
kazanmak: Eski müşterileri kazanmak için kurulmuş modellerdir.
Müşterilerden ömür boyu elde edilecek getiri belirlenerek bu müşterilere sunulacakların maliyeti ile
karşılaştırılır.
Doğru Kişiye Doğru Ürünü
(Yaklaşımı) Sunmak
Mevcut ve potansiyel müşteriler hakkında detaylı bilgiye sahip olmak rekabetçi kalmak için önemli bir gerekliliktir.
Farklı müşteri grupları için en uygun
ürünleri bulmak, hangi tip müşterilerin
ne tür ürün aldıklarını belirlemek, müşteri tabanını gruplara ayırmak, bu grupların karlılıklarını belirlemek ve buna
göre farklı seviyelerde hizmet sunmak
mümkün olabilir. Ürün veya hizmee
hangi özelliklerin ne derecede müşteri
memnuniyetini etkilediği, hangi özelliklerinden dolayı müşterin bunları tercih
eiği ortaya çıkarılabilir.
Ürün veya hizmet sunumuna kimin
yanıt vereceğini tahmin etmek maliyet
düşürmek açısından önemli yöntemlerden biridir. Bir ürün veya hizmet ile ilgili
bir kampanya programı oluşturmak için
hedef kitlenin seçiminden başlayarak
bunun hedef kitleye hangi kanallardan
sunulacağı kararına kadar olan süreçte
veri madenciliği kullanılabilir. Aynı grubun geçmiş davranışlarına dayandırılabileceği gibi, mantıksal bir alternatif
popülasyonun davranışlarına da dayandırılabilir.
• Kampanya şartlarını düzenlemek: Düzenlenecek çeşitli kampanyalarda mevcut müşteri kitlesinin
seçmek ve bu müşterilerin davranış
özelliklerine yönelik yaklaşımlar geliştirmek. Bu şekilde pazarlama
veya perakende kampanyalarına
cevap alma oranını artırmak, müşteri ilişkileri yönetimi maliyetlerinin
azaltmak hedeflenir.
31
• Özel kampanyalar düzenlemek:
Potansiyel müşteriler arasından en
karlı olabilecekleri belirleyerek onlara özel kampanyalar uygulamak.
En masraflı müşterileri daha masrafsız müşteriler haline dönüştürmek. Örneğin en çok bankacılık
işlemi yapanlar ortaya çıkarılıp
bunlar şube bankacılığı yerine internet bankacılığına yönlendirmek.
• Müşterilere özgü satış
politikaları oluşturmak: Aynı karakteristikleri (gelir düzeyi, ilgi alanları, harcama alışkanlıkları, vb.)
paylaşan “model” müşteri gruplarını bulmak ve satınalma profillerine göre satış şartlarını ve fiyatları
belirlemek.
• Yeni ürün geliştirmek: Farklı müşteri gruplarının ihtiyaç duydukları
özellikleri belirtip, ihtiyaç duymadıkları özellikleri üründen çıkararak müşterilerin beklentilerini karşılayacak
şekilde farklı ürünler geliştirmek
Mevcut Müşterilere Çapraz Satış /
Ek Satış (Cross-Sell / Up-Sell)
Kârlılığı artırmak için mevcut müşterilere satış yapmak, yeni müşteriler
bulup onlara satış yapmaktan daha avantajlı bir yöntemdir. Bu nedenle; çapraz
satış modelleri ile müşterilerin bir şirkeen aldıkları ürünler dışında aynı şirkeen ek ürün alma ihtimallerini, ek satış
ile müşterilerin aynı ürünü tekrar veya
daha çok alma olasılıklarını tahmin eden
modeller oluşturulabilir.
• Çapraz satış: Kredi kartı harcamalarına göre müşteri gruplarının
belirlenmesi, farklı finansal göstergeler arasında gizli korelasyonların bulunması, hangi müşteri
profilinin neyi, ne zaman ve neden
tercih ettiğini anlayabilen modeller ile ürün satışları arasındaki bağlantı ve ilişkileri bulmak ve bu
bağlantılara dayalı tahminler geliştirerek ek ürünler sunmak. Çapraz
satış ile birim müşteriye yapılan
satış miktarının artırılması, karsız
müşteriler karlı hale getirilmesi
sağlanabilir. Perakende alanında
pazar sepeti analizi ile birlikte satılan ürünlerin bulunması ve buna
göre stratejilerin geliştirilmesi en
yaygın uygulamalardandır.
• Ek satış: En iyi müşterileri veya
müşteri gruplarını bulmak, bulunan bu müşteri gruplarının ihtiyaçları belirleyerek kişiselleştirilmiş
ürün ve hizmetler geliştirmek, bu
şekilde müşterilerin vazgeçemeyeceği ürün sunularını oluşturmak. Örneğin, yeniden sigorta
poliçesi talep edecek müşterilerin tahmin edilmesi
Yeni Müşteri Kazanmak
Firmaların temel amaçlarından biri sürekli olarak yeni müşteriler kazanmaktır.
Ancak tüm müşteriler eşit ölçüde kârlı değildir. Firmalar hedef kitlelerini ilk aşamada gelir, yaş, vb. gibi bazı temel
ölçütlere göre seçerler ancak seçilen tüm
potansiyeller kazanılsalar bile firmaya faydalı olmayabilirler. Firma ile uzun süre
32
çalışmayabilir, tüm ihtiyaçlarını firmadan almayabilir, sürekli olarak farklı teklifleri değerlendirerek başka firmalara
geçebilir, alım sıklıkları düşük olabilir
veya sadece düşük karlılığı olan ürünleri
satın alıyor olabilirler. Tüm bu sebeplerle
uzun vadede müşterilerden elde edilmek istenen sonuçlara ulaşılamayabilir.
Müşterileri elde etmek için cazip teklifler
sunmak yüksek müşteri edinme maliyeti
yaraığından, doğru potansiyele sahip
müşteriye odaklanmak, müşteriden
ömür boyu elde edilecek değeri belirlemek önemlidir.
Doğru müşteriyi elde etmek için kritik yöntemlerden biri veri madenciliğidir.
3. taraflardan elde edilen başlangıç verilerinden segmentasyon ve sınıflandırmalar ile çeşitli müşteri segmentleri
oluşturulabilir. Bu segmentlerden hangilerinin söz konusu ürün veya hizmeti alabileceği tespit edilir. Bu bilgiyi elde etmek
için mevcut ve geçmişte alım yapmış
müşterilerin alım bilgileri ve özelliklerinin yer aldığı bilgileri kullanılabilir. Alım
yapma potansiyeli olan müşteriler belirlendikten sonra, hangi müşterilerin karlı
olabileceği belirlenmelidir. Bu aşama da
geçmiş verilere gereksinim duyar. Sınıflandırma yöntemleri ile karlı müşteriler
belirlenerek ulaşılmaya çalışılır.
• Müşterilerden ömür boyu elde
edilecek getirileri belirlemek
(Lifetime Value): Müşterilerin firma
ile ilişkileri boyunca yaratacakları
katma değerleri tahmin etmek ve bu
katma değer kategorilerine göre
seçim yapmak, yaklaşım biçimleri belirlemek.
• Kampanya şartlarını düzenlemek:
Düzenlenecek çeşitli kampanyalarda
hedef müşteri kitlesinin seçmek ve
bu müşterilerin davranış özelliklerine
yönelik yaklaşımlar geliştirmek. Bu
şekilde potansiyel müşterilere yapılan pazarlama veya perakende kampanyalarına cevap alma oranını
artırmak, yeni müşteri edinme maliyetlerini azaltmak hedeflenir.
Standart dışı Davranışları
Belirlemek /Güvenlik
(Fraud Detection)
Para ile ilişkili tüm alanlarda sahtekarlık (fraud) riski vardır. Sağlık, finans
sektörü ve vergilendirme en çok sahtekarlık denemesine rastlanan alanlardır.
Genellikle geçmiş verilere göre sahtekarlık desenleri örnekleri çıkarılabilir ve bu
örneklere benzer davranışlar tespit edilerek sahtekarlık denemelerinin önüne
geçilebilir. Araştırılması gereken her olay
maliyet yükü getirdiğinden veya verilen
hizmeti aksaığından, sahtekarlık ihtimallerini belirlerken araştırılması gereken olay sayısını minimumda tutmak
esastır. (İstatistik uygulamalarındaki 1.
tür ve 2. tür hata tipleri bu konuda
önemlidir.)
Kara para aklama, kayıp ve kaçakları
engelleme, sigorta dolandırıcılıklarının
tespiti, kredi kartı dolandırıcılıklarının
tespiti, kaçak enerji kullananların profillerini tespit ederek olası kaçak enerji kullanıcılarını tahmin etmek, telefon
görüşmelerinin (aranan yer, arama süresi, aranan zaman, vb.) modellenmesi ve
33
beklenen değerlerden sapmanın olduğu
konuşmaların tespiti, sağlık sigortası uygulamalarında gereksiz veya birbiriyle ilgisiz sağlık testlerinin tespiti, vergi ile
ilgili yolsuzlukları ve izlerini belirlemek,
ağ saldırının tespit edilmesi vb. şeklinde
farklı konularda veri madenciliği uygulamaları kullanılabilir.
Diğer Konular
Yukarıda belirtilen başlıklar veri madenciliği çalışmalarının genel olarak
çözüm üreiği konulardır. Ancak tüm
sektörlerde, verinin olduğu her yerde,
mutlaka bir veri madenciliği çalışması ihtiyacı oluşabilmektedir.
• Hastanelerde hastanın hastanede
kalma süresinin azaltılması
• Hastanelerde hasta sonuçlarının
iyileştirilmesi
• Hisse senetlerinde zaman serileri
analizleri ile gelecek değerlerin belirlenmesi
• Devletin kurumlara vereceği destek
programlarında verilecek desteğin
doğru miktarda ve doğru hedefleri olan
kuruluşlara verilmesinin sağlanması
• Emniyet birimlerinin hangi profildeki insanların ne tür suçlara eğilimi
olduklarını belirleyerek, suç engelleme politikalarının oluşturulması
• E-ticaret / e-devlet uygulamalarında web sayfa tasarımını en iyi
kullanılabilir hale getirilmesi
• Karayollarının belirli yollardaki kaza
oranlarını düşürülmesini sağlaması
• Üniversitelere eğitimi tamamlayacak ve başarılı olabilecek öğrencilerin alınması
• Telekom şirketlerinde ağ performansının yönetimi
• Arşivde belirli bir dokümana benzer dokümanların bulunması
• …
“Arşivimde (veya internet üzerinde)
bu dokümana benzer hangi dokümanlar
var?” gibi soruların yanıtlarını bulacak
şekilde “Doküman Madenciliği” (Text
Mining) konusu da veri madenciliğinin
bir alt kolu olarak gelişmektedir. Bu çalışmalarda amaç dokümanlar arasında
ayrıca elle bir ayrım gerekmeden benzerlik hesaplayabilmektir. Bu genelde
otomatik olarak çıkarılan anahtar sözcüklerin tekrar sayısı ile yapılır. Metin
Madenciliğinin; haber, email, yazılı dökümanlar, arşiv ve internet üzerinde uygulamaları vardır.
34
Veri Madenciliğinin
Fonksiyonları

Tahmin / Öngörü
(Supervised) Fonksiyonlar
Geçmiş verilerden yararlanarak, gelecek ile ilgili bir sonucu tahmin etmek için
kullanılan fonksiyonlardır. Yeni bir nesnenin niteliklerini inceleme ve bu nesneyi önceden tanımlanmış bir sınıfa
atamaktır. Modellemelerinde olası sonucu öngörmeye yarayan faktörler ve
sonuç yer alır. Model kurulurken geçmiş
deneyimlerde, faktörlerin aldığı değerlere
göre elde edilen sonuçlar girdi olarak kullanılır. Beklenen sonuç; “Katılır-Katılmaz”
şeklinde kategorik değer veya rakamsal
değerdir.
Tahmin edilen sonuçların kalitesi (ne
kadar iyi tahmin edildiği) tahmin edilen
sonuç kadar önemlidir. Çoğunlukla tahmin edilen sonuç ile birlikte, bu sonucun
kalitesine yönelik; güvenlik aralığı, olasılığı, vb. değerleri belirlenir.
Sınıflandırma (Classification)
“Genç kadınlar küçük araba satın alır, yaşlı,
zengin erkekler büyük, lüks araba satın alır.”
En temel veri madenciliği fonksiyonlarından biri olarak kategorik sonuçları
tahmin etmek için kullanılır. Modeli kurabilmek için, sonuçları önceden bilinen
durumlar ve bu durumlarda ilgili faktörlerin aldığı değerler gereklidir. Bu değerler “eğitim verisi” olarak adlandırılır.
Elde edilmesi beklenen sonuç “müşteri
%80 ihtimal ile bu kampanyaya olumlu
yanıt verecek” şeklinde belirli bir olasılık
ile birlikte sunulur. Sonuçlar “Hizmeti
Bırakır-Hizmeti Bırakmaz” şeklinde iki
alternatifli olabileceği gibi “Kesin Tercih
Eder-Tercih Eder-Yanıt Vermez-Tercih
Etmez-Kesinlikle Tercih Etmez” şeklinde
çoklu alternatifli de olabilir. Bir deneme
kümesi modelin doğruluğunu belirlemek için kullanılır. Genellikle verilen veri
kümesi öğrenme ve deneme kümesi olarak ikiye ayrılır. Öğrenme kümesi modeli
oluşturulmasında, deneme kümesi modelin doğrulanmasında kullanılır. Örneğin bir otomobil satıcısı şirket geçmiş
müşteri hareketlerinin analizi ile yukarıdaki gibi iki kural bulursa genç kadınların okuduğu bir dergiye reklam verirken
küçük modelinin reklamını verir.
• Uygulama Alanları: Potansiyel müşteriler için düzenlenen kampanyalara
dönüşler, mevcut müşterilerin belirli
bir hizmeti almaktan vazgeçme olasılıkları, kredi başvurularının risk seviyeleri, çeşitli belirtilere göre hastalık
ihtimalleri, vb.
• Örnek Model: Satışlarını artırmak
için kampanya düzenlemek isteyen
bir otomobil firması, kampanyasına
katılma ihtimali olan potansiyel alıcıları belirlemek için daha önceden
satış yapmış olduğu müşterilerinin verilerini (sonuçlarını) kullanarak, hangi
özelliklere sahip adayların kampanyaya katılabileceğini belirli bir olasılık
aralığında tahmin edebilir. Bu şekilde;
ihtiyacı kadar veri satın alarak (eğer
adayların verisini dışarıdan alıyorsa)
ve sadece alma potansiyeli yüksek
olan adaylara ulaşmaya çalışarak tasarruf sağlamaktadır.
Aşağıdaki örnekte adayın gelir düzeyi, mesleği, yaşı, çocuk sayısı, kullandığı mevcut aracın modeli, sınıfı,
37
yaşı, gibi faktörler göz önüne alınarak bir model tasarlanmıştır.
• Yöntemler / Algoritmalar: Yapay
Sinir Ağları (Neural Networks), Bayes
Sınıflandırması (Bayesian Classification), En Yakın Komşu (Nearest Neighbour), Karar Destek Makineleri
(Support Vector Machines), Zaman
Serisi Analizi (Time Series Analysis),
Karar Ağaçları (Decision Trees), Lojistik Regresyon (Logistic Regression)
Regresyon / Eğri Uydurma
(Regression)
“Ev sahibi olan, evli, aynı iş yerinde beş
yıldan fazladır çalışan, geçmiş kredilerinde
geç ödemesi bir ayı geçmemiş bir erkeğin
kredi skoru 825’dir.”
Süreklilik gösteren değerleri tahmin
etmek için kullanılan fonksiyonlardır. Regresyon ile amaç girdiler ile çıktıyı ilişkilendirecek modeli oluşturup, en iyi tahmine
ulaşmaktır. Sonuç “bağımlı değişken”, girdiler “bağımsız değişken” olarak adlandırılır. Sonucun alacağı değer genellikle bir
güvenlik aralığı içinde belirtilir. Girdiler,
çözülecek probleme göre bir veya birden
fazla olabilir. Örneğin; bir inşaat firması
konut satışlarının, faaliyet gösterdiği bölgede elde edilen toplam gelir ile ilişkili olduğunu düşünüyorsa, sadece bölgesel
gelire dayalı bir model oluşturarak, bölgesel gelirdeki değişime göre satacağı ev sayısını tahmin etme yoluna gidebilir. Ancak
gerçek hayaa çözülecek problemlerin
hemen hepsinde doğru tahmine ulaşmak
için birden fazla girdiden faydalanmak gereklidir. Bu noktada önemli olan konu girdilerin sonucun doğru tahmin edilmesine
yaptıkları katkıdır. Bazı durumlarda sonuca katkısı limitli olan girdileri modelden
çıkarmak, daha etkin bir model oluşturmak için önemli bir gerekliliktir.
• Uygulama Alanları: Finansal tahminler, zaman serisi tahminleri, biomedikal ve ilaç reaksiyonları, konut
fiyatı değerlendirmeleri, müşterinin
yaşam çevrimi boyunca yarattığı
değer, atmosferdeki CO2 oranı, vb.
• Örnek Model: Bir dergiye ilk kez
reklam vermeye başlayacak olan bir
şirket daha önce reklam vermiş olduğu dergilerin sayfa maliyetlerini
38
kullanarak, çalışılmaya başlanılacak
olan derginin vermiş olduğu fiyatın
uygunluk seviyesini belirli bir güven
aralığı içinde değerlendirebilir. Yada
daha sonra yapacağı kampanyalarda
çalışmakta olduğu dergilerin verecekleri fiyatların ne kadar makul olduğunu önceden öngörebilir.
Aşağıdaki örnekte derginin okuyucu sayısı, bayan okuyucuların
payı, okuyucuların ortalama yıllık
kazancı, gibi faktörler göz önüne
alınarak bir model tasarlanmıştır.
• Yöntemler / Algoritmalar: Yapay
Sinir Ağları (Neural Networks), Karar
Destek Makineleri (Support Vector
Machines), Karar Ağaçları (Decision
Trees), Lineer Regresyon (Linear
Regression)
Tanımlama (Unsupervised)
Fonksiyonlar
Fonksiyonların amacı belirli bir hedefi
tahmin etmek değildir. Amaç veri setinde
yer alan veriler arasındaki ilişkileri, bağlantıları ve davranışları bulmaktır. Var olan
verileri yorumlayarak davranış biçimleri
ile ilgili tespitler yapmayı ve bu davranış
biçimini gösteren alt veri setlerinin özelliklerini tanımlamayı hedefler. Tanımı bilmek; tekrarlanan bir faaliyee veya tanımı
bilinen yeni bir verinin yapıya katılmasında ne şekilde hareket edileceği konusunda karar almaya destek olur.
Kümeleme/Gruplama/
Demetleme/ Öbekleme
(Clustering)
Müşterilerin büyük bir kısmı düzenli
olarak pazartesi akşamları kredi kartıyla
alışveriş yaparlar.
Veriyi birbirlerine benzeyen elemanlardan oluşan sınıflara (kümelere) ayırarak,
heterojen bir veri grubundan, homojen alt
veri grupları elde edilmesi işlemidir.
Kümeleme fonksiyonu genellikle bölümleme sorunlarını çözmekte kullanılır.
Kümelemenin temel hedefleri arasında;
geniş veri yığınları için tanımlayıcı veriler
belirleyerek, işlenecek veri hacmini daraltmak, veri yığınlarındaki doğal kümeleri ortaya çıkarak aynı kümede olması
gereken verileri belirlemek, belirlenmiş
kümelerin dışında kalan istisna durumları
39
tanımlamak sayılabilir. Başlangıç aşamasında verilerin hangi kümelere ayrılacağı
veya kümelemenin hangi değişken özelliklerine göre yapılacağı bilinmemekte,
konunun uzmanı olan bir kişi tarafından
kümelerin neler olacağı tahmin edilmektedir.
Kümeleme algoritmaları; küme
içinde benzerliğin maksimize (küme içi
uzaklıkların minimize edilmesi) edilmesi, kümeler arası benzerliğin minimize (kümeler arası uzaklıkların
maksimize edilmesi) edilmesi kavramına dayanır. Sonuçta elde edilen farklı
kümelere ait elemanlar arasında benzerlik azdır.
Kümeleme fonksiyonu ile sınıflandırma fonksiyonu arasındaki en önemli
fark, kümelemenin önceden tanımlanmış girdilere dayanmıyor olmasıdır. Sınıflandırma fonksiyonunda tanımlı
girdiler ve bunların geçmişte aldıkları
değerler temel modeli oluştururken, kümeleme fonksiyonunda önceden tanımlanmış girdiler ve örnekler yoktur.
Veriler kendi içlerindeki benzerliklere
göre gruplanırlar. Benzerliği tanımlayacak boyutlar ve özellikler modeli kuran
tarafından öngörülür.
Kümeleme fonksiyonu bazı durumlar
başka bir veri madenciliği fonksiyonun
öncesinde kullanılabilir. Hangi promosyon kampanyasına müşteriler en iyi tepkiyi verirler diye değerlendirmek yerine
öncelikli olarak müşterilerin belirli kümelere yarılması bunun ardından her
küme için en iyi promosyon kampanyasının ne olacağı belirlenebilir.
Müşterileri kümelemek için genellikle
karlılık ve pazar potansiyeli boyutları
kullanılır. Perakende sektöründe müşterilerin; söz konusu firmadaki alım alışkanlıkları ve tüm mağazalardaki alım
alışkanlıklarına göre kümelenmeleri ve
en yüksek potansiyelli kümeye odaklanılması sıkça rastlanan bir uygulamadır.
• Uygulama Alanları: Benzer hücreleri
tanımlamak, benzer davranışlar gösteren perakende müşterilerini tanımlamak, gen ve protein analizleri, ürün
gruplaması, hastalık belirtileri, metin
madenciliği
• Örnek Model: İki boyutlu bir örnekte
kümeleme fonksiyonunu algılamak
oldukça kolaydır. Yaş ve gelir düzeyleri belirtilmiş 40 kişiden oluşan bir
grubu, grafik yardımı ile kümelerine
ayırmak mümkündür. Yaş ve gelir düzeyi değerlerinin histograma yerleştirilmesi ve en yoğun durumların
merkez olarak belirlenmesi en basit
anlamda bir kümeleme işlemidir. Bu
örnekte veri madenciliği yöntemleri
kullanılmadan kümeler oluşturulmuştur. Ancak onlarca değişken olduğunda verileri kolayca kümelemek
mümkün değildir, bu aşamada kümeleme fonksiyonuna özgü algoritmaları kullanmak gereklidir.
• Yöntemler / Algoritmalar: Bölme
yöntemleri (Partitioning methods), Hiyerarşik yöntemler (Hierarchical methods), Yoğunluk tabanlı yöntemler
(Density-based methods), Grid tabanlı
yöntemler (Grid-based methods),
Model tabanlı yöntemler (Modelbased methods)
40
Birliktelik Analizi / Bağıntı /
Eşleme / İlişki Kuralları
(Association Rules)
“Çocuk bezi alan müşterilerin 30%’u süt
de alır.”
Büyük veri kümeleri içinde farklı veriler arasındaki birliktelik ilişkilerini
bulma işlemidir. Birliktelik analizi, belirli
bir veri kümesinde yüksek sıklıkta birlikte görülen özellik değerlerine ait ilişkisel kuralların keşfidir. Sonuçta elde edilen
birliktelik kuralları (A  B) şeklinde sunulur. şirketlerin karar alma işlemlerini
daha verimli hale getirmektedir.
En klasik örneği sepet analizidir.
(basket analysis) Bu analizde müşterilerin beraber satın aldığı ürünlerin analizi
yapılır. Amaç ürünler arasındaki pozitif
veya negatif korelasyonları bularak
müşterilerin satınalma alışkanlıklarını
ortaya çıkarmaktır. Çocuk bezi alan
müşterilerin mama da satın alacağını
veya deterjan satın alanların yumuşatıcı
da alacağını tahmin edebiliriz ancak
manuel olmayan bir analiz bütün olasılıkları göz önüne alır ve kolay düşünülemeyecek, “mama” ve “yumuşatıcı”
gibi bağıntıları da bulur. Bu verilere
sahip olan marketler, birlikte satılan
ürünleri yakın raflara koyarak, katalogda birlikte satılan ürünlerin birlikte
görülmesini sağlayarak veya müşteriler
için cazip ürün paketleri oluşturarak satışları artırabilirler.
• Uygulama Alanları: Birlikte hareket
eden verilerin bulunması ile verimlik
sağlanacak her alanda kullanılabilir.
Süpermarkette birlikte satılan ürünler, otomobilde sunulacak ekstra
özellikler, depolarda birbirine yakın
konumlandırılması gereken ürünler,
alışveriş merkezinde olması gereken
mağazalar, vb.
• Örnek Model: Bir A ürününü satın
alan müşteriler aynı zamanda B ürününü da satın alıyorlarsa, bu durum
A  B [destek = %2, güven = %60]
şeklinde ifade edilir. Buradaki destek
ve güven değerleri, birliktelik kuralının ilginçlik ölçüleridir. “Destek” tanımlanan kuralın sıklığını ve “güven”
tanımlanan kuralın kabul edilebilirliğini gösterir. %2 oranındaki bir destek değeri, analiz edilen tüm
alışverişlerden %2'sinde A ile B
ürünlerinin birlikte satıldığını belirtir. %60 oranındaki güven değeri ise
A ürününü satın alan müşterilerinin
%60'ının aynı alışverişte B ürününü
de satın aldığını ortaya koyar . Kullanıcı tarafından minimum destek eşik
değeri ve minimum güven değeri
belirlenir ve bu değerleri aşan birliktelik kuralları dikkate alınır.
Büyük veri tabanlarında birliktelik
kuralları bulunurken, iki aşamalı bir
süreç işletilir. İlk aşamada sık tekrarlanan öğeler bulunur: Bu öğelerin her biri en az, önceden
belirlenen minimum destek sayısı
kadar sık tekrarlanırlar. İkinci aşamada sık tekrarlanan öğeler arasından güçlü birliktelik kuralları
oluşturulur:
• Yöntemler / Algoritmalar: Apriori
41
Sıralı Dizi Analizi (Sequence
Analysis / Sequential Paerns):
“X şirketinin hisse fiyatları ile Y şirketinin hisse fiyatları benzer hareket ediyor.”
Gözlem sonuçlarının zaman ve mekan
özelliklerine göre sıralanmış olarak gösteren sayı dizileridir. Sayısal sıralı verilerdeki trendleri ve döngüleri anlamak
için kullanılır. Bu fonksiyonda ilişkili kayıtlar incelenir ve zaman içinde sıkça rastlanan trendler ve benzer trendler
bulunur. Bu trendler daha sonra veri içindeki ilişkileri tanımlamak için kullanılır.
Bir beyaz eşya perakendecisinin veritabanından buzdolabı alımını takip eden
beyaz eşya alımının bulaşık makinesi olduğunun belirlenmesi, doğal afetler veritabanından 6 büyüklüğünde bir deprem
olduktan 3 gün sonra Klimanjaro dağının
püskürmesi, banka veritabanından ilk üç
taksitinden iki veya daha fazlasını geç
ödemiş olan müşterilerin %60 olasılıkla
kanuni takibe gidiyor olduklarının belirlenmesi gibi örnekleri vardır. Kredi kartı
örneğinde belirlenen davranış skoru (behavioral score), başvuru skorundan farklı
olarak kredi almış ve taksitleri ödeyen bir
kişinin sonraki taksitlerini ödeme/geciktirme davranışını notlamayı amaçlar. Seriler özelliklerine göre “zaman serileri”,
“mekan serileri”, “bölünme serileri” ve
“bileşik seriler” olmak üzere dört başlık
altında incelenebilirler.
• Zaman Serisi Analizi / Benzer
Zaman Sıraları/ Zaman İçinde Sıralı Örüntüler (Similar Time Sequences / Time Series): Gözlem
sonuçlarının zamana göre sıralanmış şeklidir. Borsada yer alan hisselerin davranışları sık rastlanan bir
örneğidir. Günlere göre hisse değeri, yıllara göre faiz oranları, aylara
göre üretim fire oranı, vb. gibi örnekleri vardır. Tek bir seri dışında,
birden fazla hareket serisi arasında
da bağıntı kurmak mümkündür.
Bunlar örneğin iki malın zaman
içindeki satış miktarları olabilir. Örneğin dondurma satışları ile kola
satışları arasında pozitif, dondurma
satışları ile salep satışları arasında
negatif bir bağıntı beklenebilir.
Zaman serisinde yer alan verilerin
davranışları trend ve döngüler
(cycle) ile tanımlanır. “Trend” serideki verilerin ortalama değerinde
yaşanan değişimi tanımlamak için
kullanılır. “Döngü” veride tekrar eden
herhangi bir davranışı tanımlamak
için kullanılır. Sezonsal veya dönemsel olabilir. Sezonsal olanlar tahmin
edilebilir zamanlarda gerçekleşir,
(her pazartesi, her yılbaşı, vb.) dönemsel olanlar “n” zaman aralıkları
ile kendini tekrarlar.
Zaman serisi analizlerinde veri serisindeki davranışları belirlemek kadar
gelecek değerleri tahmin etme çalışmaları da gerçekleştirilir. Hisse değerlerini, ekonomik değerleri, ürün
talebini hava durumunu tahmin
etmek, vb.)
42
• Mekan Serisi: Gözlem sonuçlarının
mekana göre sıralanmış şeklidir. Bölgelere göre satış rakamları, ülkelere
göre yaşam süresi, vb.
• Bölünme Serisi (Frekans): Gözlem
sonuçlarının belirlenen kriterlere göre
sıralanmış şeklidir.
• Bileşik Seri: Gözlem sonuçlarının iki
ya da daha fazla özelliğe göre bir
arada gösterilmiş şeklidir.
43

Veri Madenciliğinin
Algoritmaları
(Metotları/Teknikleri)

Veri madenciliği, sahip olunan verilerden yola çıkarak daha önce keşfedilmemiş bilgileri ortaya çıkarma ve
bunları karar alma sürecinde kullanma
yöntemidir. Veri madenciliği, verilerin
içerisindeki desenlerin, ilişkilerin, değişimlerin, düzensizliklerin, kuralların ve
istatistiksel olarak önemli olan yapıların
analiz ve yazılım tekniklerinin kullanılarak ortaya çıkarılmasıdır. Bu açıdan
bakıldığında veri madenciliği istatistiksel bir yöntemler serisi olarak görülebilir. Benzer şekilde veri madenciliğiyle
ilgili yazılım ürünleri ve uygulamalara
bakıldığında da veri madenciliğinin esasen istatistiğin kullanıldığı bir teknik olduğu görülmektedir.
Ancak önemli olan kolaylıkla mantıksal kurallara ya da görsel sunumlara
çevrilebilecek nitel modellerin çıkarılmasıdır. Bu bağlamda, veri madenciliği
sadece istatistik değildir, insan merkezli
bir uygulamadır.
Veri madenciliği literatürü incelendiğinde istatistik ve algoritmalar ağırlıklı sayısız makale ve kitabın olduğu
görülmektedir. Bu çalışmada bu yöntemlere alternatif sunmak, yeni yöntemler geliştirmek veya anlatılan konuları
tekrarlamak gibi bir hedef ile yola çıkmadık. Asıl olarak ortaya koymak istediğimiz kritik konunun teknikleri en
detayına kadar bilmekten çok hangi soruların hangi yaklaşımlar ile çözülebileceği konusunda fikir vermek ve yönetim
kalitesinin artırılması için veri kullanımını teşvik etmektir.
Bununla birlikte veri madenciliği fonksiyonlarının kullandığı bazı kritik teknikler ve tanımlamaları şu şekildedir;
• Karar Ağaçları
• Regresyon
• Lojistik Regresyon
• Bayes
• Apriori
• Kümeleme Teknikleri
• Yapay Sinir Ağları
Karar Ağaçları (Decision Trees)
Karar ağaçları, kurgulanmasının, yorumlanmasının ve veri tabanları ile entegrasyonun kolaylığı nedeniyle en
yaygın kullanılan öngörü yöntemlerinden / sınıflandırma tekniklerinden biridir. Güvenilirliklerinin iyi olması da bir
başka tercih edilme nedenidir. Karar
ağaçlarının hedefi bağımlı değişkendeki
farklılıkları maksimize edecek şekilde
veriyi sıralı bir biçimde parçalarına
(farklı gruplara) ayırmaktır. Sınıflandırma ağacı olarak da adlandırılabilir.
İstatistiksel yöntemlerde veya yapay
sinir ağlarında veriden bir fonksiyon öğrenildikten sonra bu fonksiyonun insanlar tarafından anlaşılabilecek bir kural
olarak yorumlanması zordur. Karar
ağaçları ise ağaç oluşturulduktan sonra,
kökten yaprağa doğru inilerek kurallar
yazılabilir. Bu kurallar uygulama konusunda uzman bir karar vericiye gösterilerek sonucun anlamlı olup olmadığı
denetlenebilir. Sonradan başka bir teknik
kullanılacak bile olsa karar ağacı ile önce
bir kısa çalışma yapmak, önemli değişkenler ve yaklaşık kurallar konusunda
karar vericiye bilgi verir.
47
Yapısı ve Kuruluşu
Karar ağacı, adında belirtildiği şekilde ağaç görünümünde bir tekniktir.
Karar düğümleri, dallar ve yapraklardan oluşur.
• Karar düğümü: Veriye uygulanacak
test tanımlanır. Her düğüm bir özellikteki testi gösterir. Test sonucunda
ağacın dalları oluşur. Dalları oluştururken veri kaybı yaşanmaması için
verilerin tümünü kapsayacak sayıda
farklı dal oluşturulmalıdır.
• Dal: testin sonucunu gösterir. Elde
edilen her dal ile tanımlanacak sınıfın belirlenmesi amaçlanır. Ancak
dalın sonucunda sınıflandırma tamamlanamıyorsa tekrar bir karar
düğümü oluşur. Karar düğümünden
elde edilen dalların sonucunda sınıflandırmanın tamamlanıp tamamlanmadığı tekrar kontrol edilerek
devam edilir.
• Yaprak: Dalın sonucunda bir sınıflandırma elde edilebiliyorsa yaprak
elde edilmiş olur. Yaprak, verileri
kullanarak elde edilmek istenen sınıflandırmanın sınıflarından birini
tanımlar.
Başlangıçta bütün öğrenme örnekleri
kök düğümdedir, örnekler seçilmiş özelliklere tekrarlamalı olarak göre bölündükten sonra ağacı temizlemek için (Tree
pruning) gürültü ve istisna kararları içeren dallar belirlenir ve kaldırılır. Karar
ağacı tekniğini kullanarak verinin sınıflanması üç aşamadan oluşur.
• Öğrenme: Önceden sonuçları bilinen verilerden (eğitim verisi) model
oluşturulur.
• Sınıflama: Yeni bir veri seti (test verisi) modele uygulanır, bu şekilde
karar ağacının doğruluğu belirlenir.
Test verisine uygulanan bir modelin
doğruluğu, yaptığı doğru sınıflamanın test verisindeki tüm sınıflara oranıdır. Her test örneğinde bilinen
sınıf, model tarafından tahmin edilen sınıf ile karsılaştırılır.
• Uygulama: Eğer doğruluk kabul
edilebilir oranda ise, karar ağacı
yeni verilerin sınıflanması amacıyla
kullanılır.
Uygulama Alanları
Risk grupları kategorileri oluşturmak, gelecekte olabilecek olaylar için
tahmin kuralları oluşturmak, kategorilerin birleştirilmesi, yeni bilinmeyen bir
örneğin sınıflandırılması gibi durumlarda karar ağaçları kullanılır. Örneğin
kredi sınıfını tahmin edecek bir model
için aşağıdaki şekilde bir sınıflandırma
kuralı oluşturulabilir:
EĞER “yaş” = "41...50" VE “gelir” = yüksek BU DURUMDA “kredi durumu” = mükemmel.
48
Dü üm
Dü üm
Dü üm
Dal
Dal
Dal
Dal
Yaprak
Yaprak
Bu kural gereğince yaşı "41...50" kategorisinde olan (yaşı 41 ile 50 arasında
olan) ve gelir düzeyi yüksek bir kişinin
kredi durumunun mükemmel olduğu
görülür. Oluşturulan bu modelin doğruluğu, bir test verisi aracılığı ile onaylandıktan sonra model, sınıfı belli olmayan
yeni bir veriye uygulanabilir ve sınıflama
kuralı gereği yeni verinin sınıfı "mükemmel" olarak belirlenebilir.
“Yanıt verme” veya “teklifi kabul
etme” gibi beklenen davranış biçimlerini
gösterecek sınıfları tanımlamak için (pazarın hareket biçimini anlamak için)
uygun ve basit bir yöntemdir. Regresyona göre avantajı lineer olmayan ilişkileri de ortaya çıkarabilmesidir. Bu çalışma
ile elde edilen veriler daha farklı modellerde de kullanılabilir. Yandaki örnekte
en üst düğümün tüm kampanyanın genel
sonucunu gösterdiği bir kredi kartı kampanyası kurgulanmıştır. Kredi kartı satışı için 200.000 kişiye ulaşılmıştır. Sonuç
olarak %4,6’sı olan 9.200 kişiden geri
dönüş alınmıştır. İlk aşamada cinsiyete
göre bir ayrım yapılmıştır. Buradan erkeklerin daha yüksek geri dönüş yaptıkları görülmüştür. Eğer model bu
aşamada tamamlansaydı erkekler daha
iyi bir hedef kitledir sonucu elde edilecekti ancak cinsiyet ayrımı çok geniş bir
ayrım olduğundan her cinsiyet grubunun içindeki alt grupları da bulunmuştur. İkinci aşamada iki grup kendi
içlerinde farklı şekillerde alt gruplara ayrılmışlardır. Erkekler için gelir düzeyi,
bayanlar için yaş ikinci seviyedeki ayrım
olarak düşünülmüş ve sonuç olarak en
yüksek yanıt verme ihtimali olan hedef
kitleler belirlenmiştir. Bundan sonra yapılacak bir kredi kartı kampanyasında
101.000 YTL ve üzerinde geliri olan
erkek ve 31-40 yaşları arasındaki bayanlara ulaşılması durumunda daha az maliyet ile daha yüksek oranlarda geri
dönüşün elde edildiği bir kampanya gerçekleştirilmiş olacaktır.
Regresyon Analizi
(Regression Analysis)
Bir ya da daha çok değişkenin başka
değişkenler cinsinden tahmin edilmesini
sağlayacak ilişkiler bulmak ve bunları
tanımlamaktır. Regresyon analizinin temelinde gözlenen bir olayın değerlendirilirken, hangi olaylardan etkilendiğini
belirlemek yatmaktadır. Bu olaylar bir
veya birden çok olacağı gibi etki düzeyleri farklı seviyelerde de olabilir.
49
200.000
Dönü : % 4,6
Erkek: 86.700
Dönü : % 5,8
Bayan: 113.300
Dönü : % 3,68
Gelir: 101+ K YTL
34.680
Dönü : % 6,63
Gelir: 61-100 K YTL
30.345
Dönü : % 3,95
Gelir: 30-60 K YTL
21.675
Dönü : % 7,05
Ya : 20-30
45.320
Dönü : % 2,65
Ya : 31-40
16.995
Dönü : % 11,77
Ya : 41-50
22.660
Dönü : % 1,32
Ya : 51+
28.325
Dönü : % 2,37
Yapısı ve Kuruluşu
Regresyonda, verilerin matematiksel
gösterimle, bir fonksiyon olarak tanımlanması gerekmektedir. Regresyon analizi yapılırken kurulan matematiksel
modelde yer alan değişkenler bir bağımlı
değişken ve bir veya birden çok bağımsız
değişkenden oluşmaktadır. Değişkenler
sayılabilir veya ölçülebilir niteliktedir.
Örneğin bir hissenin fiyatını ile ona dolaylı veya direkt etkili olan faiz oranları,
enflasyon, vb. gibi bir veya birden çok değişken ile ilişkilendirmek mümkündür.
Sadece faiz oranlarının etkisi ile ilgileniyorsak, tek değişkenli bir matematiksel
model, faiz oranları ile birlikte enflasyon
oranı ile de ilgileniyorsak, iki değişkenli
bir matematiksel model kurulmalıdır.
Tek değişkenli modeller basit doğrusal
regresyon (doğrusal ilişkiyi temsil eden
bir doğrunun denklemi formüle edilir),
birden fazla bağımsız değişkenli modeller çoklu regresyon modeli konusunu
oluşturmaktadır.
• Tek Değişkenli Regresyon - Lineer Regresyon: Basit lineer regresyon iki sürekli değişken (tahmin
edilmeye çalışılan bağımlı değişken
ve bağımsız değişken) arasındaki
ilişkiyi tanımlamayı amaçlayan bir
tekniktir. Teknik verileri kullanarak
bir doğru denklemi oluşturmayı
hedefler. Bu doğru oluşturulurken
tüm veri noktalarından tahmin edilen eğriye olan uzaklığın karelerinin
minimize edilmesi ile doğrunun
optimize edilmesi sağlanır. Doğru
elde edildikten sonra iki değişken
arasındaki ilişkinin gücü R-kare
(R-Square) değeri ile tanımlanır. Rkare verinin değişiminin ne ölçüde
oluşturulan model (çizilen doğru)
ile açıklanabildiğini gösterir.
• Tek Değişkenli Regresyon - Lineer
Olmayan Regresyon: Bazı durumlarda bağımlı ve bağımsız değişkenler
arasındaki ilişki doğrusal olmayabilir.
Bu gibi durumlarda daha iyi bir uyum
için bağımsız değişkeni modifiye
etmek gerekebilir.
• Çoklu Regresyon: Pazarlama, risk
yönetimi, müşteri ilişkileri yönetimi
konularında model oluşturulurken
birden fazla değişkenin bağımlı değişken üzerinde etki ediyor olması
çok doğal ve genellikle rastlanan bir
durumdur. Bazı durumlarda değişkenler yüzler ile ifade edilecek seviyelere çıkabilir.
Uygulama Alanları
İki değişken arasındaki ilişkiyi bulmak,
ilişki varsa bu ilişkinin gücünü belirlemek,
değişkenler arasındaki ilişkinin türünü belirlemek, ileriye dönük değerleri tahmin
etmek gibi konularda kullanılır. Regresyon analizi, araştırma, matematik, finans,
ekonomi, tıp gibi bilim alanlarında yoğun
olarak kullanılmaktadır. “Ev sahibi olan,
evli, aynı iş yerinde beş yıldan fazladır çalışan, geçmiş kredilerinde geç ödemesi bir
ayı geçmemiş bir erkeğin kredi skoru
825’dir.” sonucu bir regresyon ilişkisidir.
Aşağıdaki örneklerde reklam harcamaları ile satış rakamları arasındaki ilişkiler
farklı regresyon yöntemlerine göre belirlenmiş ve R-kare değerleri bulunmuştur. (y:
satış değeri, x:reklam değeri, z: enflasyon)
50
İlk örnekte satış değerlerindeki değişimi reklam harcamaları cinsinden tanımlamak için tek değişkenli lineer
regresyon uygulanmıştır. R-karenin aldığı 0,7 değeri, çizilen doğrunun verileri
yüksek bir düzeyde açıkladığını göstermektedir.
İkinci örnekte satış değerlerindeki değişimi reklam harcamaları cinsinden tanımlamak için tek değişkenli lineer
olmayan regresyon uygulanmıştır.
Üçüncü örnekte bir bağımsız değişken
daha değerlendirmeye katılmıştır ve satışlar iki boyutlu olarak tanımlanmıştır.
51
De eri
120 1.500
160 1.750
200 2.970
210 1.680
225 3.500
230 2.000
290 4.530
315 2.940
375 3.620
390 4.400
440 3.850
475 4.470
490 5.490
550 4.400
De eri
100 1.800
140 2.670
150 3.510
170 1.680
185 4.400
200 3.000
240 3.530
260 5.140
280 3.720
350 5.200
380 3.840
395 4.470
465 4.590
490 5.400
De eri
120 3,4% 1.500
160 3,3% 1.755
205 3,6% 2.970
210 3,5% 1.680
225 3,4% 3.500
230 3,3% 2.000
290 3,2% 4.530
315 3,3% 2.940
375 3,3% 3.620
390 3,4% 4.400
440 3,2% 3.840
475 3,1% 4.470
490 3,2% 5.490
550 3,2% 4.400
y = 7,7912x + 876,66
R2
= 0,6995
0
1.000
2.000
3.000
4.000
5.000
6.000
0 100 200 300 400 500 600
y = 146,16x0,5813
R2
= 0,589
0
1.000
2.000
3.000
4.000
5.000
6.000
0 100 200 300 400 500 600
y = 415,6 + 7,9x + 12781z
R2
= 0,70
Lojistik Regresyon
(Logistic Regression)
Lojistik regresyon lineer regresyona
çok benzer olmakla birlikte, lojistik regresyonda bağımlı değişkenin kesikli veya
kategorik olması (sürekli olmaması) en
önemli farklılıktır. Bu fark özellikle bir
teklife yanıt veya bir seçim yapmak gibi
kesikli aksiyonları belirlemeye yönelik sınıflandırma modellerinde önem kazanmaktadır. (Sınıflandırma analizlerinde
doğrusal regresyonun kullanılması mümkün olmamaktadır.) Lojistik regresyon,
çok değişkenli normal dağılım varsayımına ihtiyaç göstermediğinden bu tür uygulamalarda avantaj sağlamaktadır.
Lojistik regresyon ile bağımsız değişkenleri kullanarak ikili çıktısı olan bağımlı değişkenin istenilen durumunun
gerçekleşme olasılığını hesaplanır. Regresyon yapabilmek için bağımlı değişken
sürekli değere dönüştürülür. Bu değer
beklenen olayın olma olasılığıdır.
İşlem şu şekilde yapılır. Her gelir değeri için gelire göre verilen yanıtların ortalamalarından bir olasılık hesaplanır. (p:
eldeki verilere göre her gelir düzeyinde
teklifin kabul edilme sıklığı), daha sonra
her gelir düzeyinde teklifin kabul edilme
olasılığı hesaplanır. (p/(1-p) ile). Son aşamada olasılıkların logaritmik değerleri
log(p/(1–p)) ile hesaplanır.
Yandaki grafikte gelir ile müşterilere
yapılan bir teklife verilen cevaplar arasındaki ilişki kurulmuştur. Yüksek gelir
sahiplerinin olumlu yanıt verme ihtimallerinin yüksek olduğu net olarak görülmektedir. Yanıt alma denklemi aşağıdaki
şekilde oluşmuştur.
Log (p/(1-p)) = 4,9 + 0,0911 x Gelir
Bayes
İstatistiksel bir sınıflandırıcıdır. Eldeki verilerin belirlenmiş olan sınıflara
ait olma olasılıklarını öngörür. İstatistikteki Bayes teoremine dayanır. Bu teorem;
belirsizlik taşıyan herhangi bir durumun
modelinin oluşturularak, bu durumla ilgili evrensel doğrular ve gerçekçi gözlemler doğrultusunda belli sonuçlar elde
edilmesine olanak sağlar. Belirsizlik taşıyan durumlarda karar verme konusunda
çok kullanışlıdır. En önemli zafiyeti değişkenler arası ilişkinin modellenmiyor
olması ve değişkenlerin birbirinden tamamen bağımsız olduğu varsayımıdır.
Yapısı ve Kuruluşu
Bayes yöntemi koşullu olasılık durumları ile ilgilidir. Her hangi bir koşullu
olasılık durumu P(X=x | Y=y) = R şeklinde tanımlanır. Bu ifade; “Eğer Y = y
doğru ise, X = x olma olasılığı R’dir” anlamına gelmektedir. X ve Y ‘nin alabileceği değerlerin her kombinasyonu için
koşullu olasılıkları belirleyen tabloya koşullu olasılık dağılımı adı verilir ve
P(X|Y) ile ifade edilir.
Bayes Kuralı şu şekilde tanımlanır.
P(XIY) = P(YIX) x P(X) / P(Y)
52
Bu ifade; Y’nin gerçekleşmesi halinde
X’in gerçekleşme ihtimalinin ne olduğunu belirtmektedir. Bu değeri bulabilmek için “X’in gerçekleştiği durumlarda
Y’nin gerçekleşme ihtimali” ile X’in gerçekleşme ihtimalini çarpmak ve bunu
Y’nin gerçekleşme ihtimaline bölmek gereklidir.
Örneğin; bir cep telefonu operatörü
müşterileri arasında yaptığı araştırma ile
cep telefonu kullanımı arka arkaya 3 ay
sürekli düşüş gösteren müşterilerinin
%20’sinin haını kapatarak başka operatöre geçtiğini tespit etmiştir. Ayrıca araştırmalardan her 100 müşterinin 6’sının
(çeşitli nedenlerle) haını kapaığı ve her
100 müşterinin 14’inde arka arkaya 3 ay
sürekli düşüş yaşandığı tespit edilmiştir.
Bu bilgiler doğrultusunda haını kapatan bir müşterinin, kullanımında son 3
ayda sürekli azalma olan bir müşteri
olma ihtimali nedir?
P(Düşüş I Kapatmış) = P(Kapatmış I Düşüş) x
P(Düşüş) / P(Kapatmış)
P(Düşüş I Kapatmış) = (0,2 x 0,14) / 0,06 = % 47
Bu değer haını kapatan müşterilerin
yaklaşık yarısının kullanımında son 3
ayda sürekli azalış olan müşterilerden
geldiğini göstermektedir. Bu oldukça
yüksek bir orandır. Şirket bu müşterilerin kimler olduğunu kullanım trendlerinden önceden tahmin edebilmektedir.
Eğer bu tür müşteriler yeni alternatifler
sunularak ayrılmaktan vazgeçirebilirlerse, toplam kaybedilen müşterinin yarısı elde tutulacaktır.
Örneğin; üç farklı kurye şirketinin
faaliyet gösterdiği bir şehirde, gece yaşanan bir trafik kazasının tek görgü tanığı
mavi bir kurye aracının kazayı gerçekleştirdiğini söylemektedir.
Şehirde faaliyet gösteren üç kurye şirketinin kırmızı, mavi ve sarı olmak üzere
farklı renklerde araçları vardır. Kazanın
olduğu gece Kırmızı kuryenin 7, mavi
kuryenin 4 ve sarı kuryenin 9 aracı hizmet vermektedir. Gece karanlığında
rengi doğru olarak görme olasılığı
%70’dir. Bu durumda görgü tanığının ifadesi ne ölçüde doğrudur.
Burada belirlenmek istenen P(Mavi I
İddia-Mavi), yani iddianın mavi olduğu
durumda aracın gerçekten mavi olması
ihtimalidir.
P(Mavi I İddia-Mavi) = P(İddia-Mavi I Mavi) x
P(Mavi) / P(İddia-Mavi)
P(İddia-Mavi I Mavi): Görgü tanığının
araç mavi ise iddiasının mavi olması
olasılığı %70’dir. Bu olasılık doğru
görme olasılığıdır.
P(Mavi): Gece toplam çalışan araç sayısına göre aracın mavi olma ihtimali 4/20 = %20’dir.
P(İddia-Mavi): Görgü tanığının mavi
iddiasında bulunması iki şekilde
olur. Gerçekten mavidir ve doğru
görmüştür = 0,2 x 0,7 = 0,14, Mavi
değildir ve yanlış görmüştür = 0,8 x
0,3 = 0,24, ikisinin toplamında
P(İddia-Mavi) = 0,24+0,14 = 0,38
olur.
P(Mavi I İddia-Mavi) = 0,7 x 0,2 / 0,38 = %37’dir.
Aracın mavi olma ihtimali %37’dir. Bu
değerlendirmeye göre görgü tanığının
ifadesine rağmen kazayı diğer iki şirketten birinin yapmış olması ihtimali daha
yüksektir.
53
Uygulama Alanları
Belirsiz durumlarda tahmin yapmak,
sınıflandırma yapmak için kullanılır.
Aşağıda ABD’de 2008’in ilk üç ayında
vizyona giren filmlerin bazı özellikleri
ve sonuçta elde edilen hasılatları özetlenmiştir.
60 milyon USD üzerinde hasılat yapılan filmlerin başarılı olarak kabul edildiği
varsayılırsa, yukarıdaki tablodaki verilerden yola çıkarak yeni vizyona girecek
Küçük bir şirket tarafından yapılan,
drama tarzında, erkek starı olan ancak
kadın starı olmayan, 20-30 mio bütçeli, bir
filmin hasılatının 60 mio USD’yi aşma ihtimali var mıdır?
54
     	

 
  
   
                	  
          
      
 	         ¬ 
     
!"    # "                $ 
 	%
& 
"     '     
'   ( 
	) 	
) * +* 
,  	     
 )- 
   
         - .)     /   /
0 1 	   
  
 
        - .)!  "*  
 *  2 00
   * 
 "     
    
  
 
        !   %  
	 0  30
  1  ,  
 
  
   
                * +	   % - . 2  2 
/ +  (   


 
  
   
             
 
4 5      2 
2  / $      
  
 
        - .         //
3    +  	  %    6
#	 $             &      	 
  	       / 
   * !, 
 7 
"  +*  	 
"     
  - 
   
          
		
% 3  /
  	    &  
	  # "           +    5 
  0  / 
  -   8  9 
# "              	  
    /  / 
' : 		 * # 	  	 ;# 
 % +%    $ 
           & " /   
0 ! , <,  ¬  * !     $             6  ,  
	      2
  +*    
   
   	8      $             9  
  
  +*    
 /   /
  &=!=    (     $               " 	 '   0
/ !7	%   

$ 
          $   7         '
2 4  5  # "             
 	        0'
3   "   :  > 4  " 
1	  
	   
  
 
        <	 
(        0 
    *    
   
 
   
$             9*     
 
   0 
  #   * !,    	   
  
 
         7 4 	"% '  '2
       	  $                  
	    
   '   
 '  *      :      
  - 
   
         
 " 	 0  0 
 0 - 
    ! 
 %  
  
 
        + 5( 
  
 	    '2
   !  
?&    
  
 
        $   + =    '0
   $  
	 
  %> # %5 $             <	 
(        ' 
 /  * @%  
               
 	        '
 2 6 # 
  
+     
               " 	     /
 3  * 6 *  
  %	 9 
   $             

+ '   /
'  <	   " 5  # "           + *	 ; &    '   3
' # 
# %  
  
 
        
 
  + 
 %     
'   * & 
      *  $ 	8  $ 
 	% * 
	    
 )- 
   
         
 
 )
     '
'' 
  
 
	
47 
	
 
  
 
        &    
A 	   
'0 &	  ,  
  
 
        !     
        
      	

 
 
 
 
 
     
 
 
              
  
 
 
Öğrenilmek istenen durum X= (Drama
– Küçük Yapımcı – Erkek Star – 20-30 mio
USD bütçe) şeklinde ifade edilebilir.
• P(60+ I X) = P(X I 60+) x P (60+) /
P(X) ile
• P(60- I X) = P(X I 60-) x P (60-) /
P(X) karşılaştırılacağından iki
denklemde de yer alan P(X) değerleri kaldırılabilir.
Soru P(X I 60+) x P (60+) ile P(X I 60-) x P (60-) değerlerinin karşılaştırılması şekline getirilir.
P(X I 60+) x P (60+) = P(Drama I 60+) x P(Küçük Şirket I 60+) x P(Erkek Star Var I 60+) x P(Kadın Star Yok
I 60+) x P(Bütçe 20-40 I 60+) x P (60+)
P(X I 60+) x P (60+) = 3/15 x 6/15 x 5/15 x 12/15 x
4/15 x 15/34 = 0,003
P(X I 60-) x P (60-) = P(Drama I 60-) x P(Küçük Şirket I
60-) x P(Erkek Star Var I 60-) x P(Kadın Star Yok I 60-) x
P(Bütçe 20-40 I 60-) x P (60-)
P(X I 60-) x P (60-) = 5/19 x 14/19 x 6/19 x 17/19 x
15/19 x 19/34 = 0,024
Değerlendirme sonucunda söz konusu filmin 60 mio USD üzerinde hasılat
yapamayacağı görülmektedir.
55
Bu hesaplama için öncelikle olasılık değerleri belirlenmelidir. P(60+) = 15/34 P(60-) = 19/34’dür.
Diğer detaylı olasılıklar aşağıdaki tabloda hesaplanmıştır.
4 Warner Bros, Walt Disney Pictures, Fox 2000, Fox Searchlight, 20th Century Fox,, Paramount Vantage, Columbia, Dreamworks, Lionsgate, Universal yapımcı şirketleri büyük şirket, diğerleri küçük şirket kabul edilmiştir.
Apriori Algoritması
Sık tekrarlanan öğeleri bulmak için
kullanılan en temel yöntemdir.
Yapısı ve Kuruluşu
Apriori algoritmasında sık geçen öğe
kümelerini bulmak için birçok kez veritabanını taramak gerekir. İlk taramada
bir elemanlı minimum destek eşik değerini sağlayan sık geçen veriler bulunur.
İzleyen taramalarda bir önceki taramada
bulunan sık geçen veriler aday veriler adı
verilen yeni potansiyel sık geçen verileri
üretmek için kullanılır. Aday verilerin
destek değerleri tarama sırasında hesaplanır ve aday kümelerinden minimum
destek eşik değerin sağlayan veriler o geçişte üretilen sık geçen veriler olur. Sık
geçen veriler bir sonraki geçiş için aday
veriler olurlar. Bu süreç yeni bir sık geçen
veri bulunmayana kadar devam eder.
Uygulama Alanları
Geleneksel kullanım alanı marketlerde
ürünler arası ilişkileri tanımlamaktır. Benzer şekilde hızlı tüketim mamulleri üreticisi
firmalarda depo sistemlerinin optimizasyonunda da kullanılabilir. Genel olarak birlikte sevk edilen ürünlerin yakın raflara
yerleştirilmesi depo içindeki hareketi ve taşıma miktarını azaltıcı sonuçlar sağlayacaktır. Yöntem restoranlarda servis hızının
artırılması için de çözümler sağlayabilir.
Müşterilerin sipariş etme ihtimali olan
ürünleri önceden tahmin ederek hazırlamak veya ilişkili ürünlerden mönüler oluşturmak gibi çözümler üretilebilir.
Aşağıdaki tabloda 15 alışveriş fişinden
oluşan küçük bir market veri tabanı tanımlanmıştır. Buradaki alımlardan yola
çıkarak hangi ürünlerin birlikte alındıkları belirlenecektir.
56
İlk aşamada her ürünün kaç kez alındığının belirlenmelidir. Destek değeri
olarak da adlandırılan bu değerler kümesi C1, minimum alışveriş destek sayısının 2 olduğu varsayımı doğrultusunda
tek başlarına sık tekrarlanan ürünler L1
kümesinde görülmektedir. C1 kümesindeki tüm ürünlerin destek sayısı, minimum destek eşik değeri olan 2'den fazla
olduğu için C1 tüm ürünler sık tekrarlanan ürün olarak değerlendirilir ve L1 kümesine aktarılır.
Sonraki aşamada hangi ürünlerin ikili
olarak sık tekrarlandığını belirlemek için
L1 kümesindeki ürünlerin ikili kombinasyonları bulunarak C2 kümesi oluşturulur.
C2 kümesindeki ürünlerden minimum
destek eşik değerini asan ürünler L2 kümesine aktarılır.
Hangi ürünlerin üçlü olarak sık tekrarlandığını belirlemek için L2 kümesindeki ürünlerin üçlü kombinasyonları
bulunarak C3 kümesi oluşturulur. C3 =
MEP – MES – MED – MPS – MPD – MSD
– EPS – EPD – ESD – PSD olması beklenir
ancak Apriori algoritmasına göre, sık
tekrarlanan öğelerin alt kümeleri de sık
tekrarlanan öğe olması gerekmektedir.
Bu nedenle Et-Sabun ikilisi sık tekrarlanan olmadığından bu alt kümeye sahip
MES – EPS – ESD elenmiş olur. Geriye
kalanların destek değerleri belirlenir.
Hangi ürünlerin dörtlü olarak sık tekrarlandığını belirlemek için L3 kümesindeki ürünlerin dörtlü tek kombinasyonu
olan M-E-P-D incelenir. Ancak bu kümenin destek değeri sık tekrarlanan limitinin altında olduğundan Apriori yöntemi
tüm sık tekrarlanan öğeleri bularak tamamlanmış olur.
Sık tekrarlanan öğeler bulduktan
sonra, veritabanından birliktelik kuralları çıkartılır.
57
Minimum güven eşiği değerinin %60
olarak belirlendiği bir durumda; 1., 2,, 7.
ve 8. kurallar eşik değerini aştıkları için
dikkate alınırlar.
Kümeleme Yöntemleri
Bölünmeli yöntemler: Veriyi bölerek,
her grubu belirlenmiş bir kritere göre değerlendirir. En yaygın olarak kullanılan
iki algoritma vardır.
• K-ortalaması (K-means): Başlangıç
olarak verinin kaç kümeye ayrılacağını belirlemek gereklidir. Küme sayısı
“k” değeri olarak adlandırılır. k-means
algoritmasının 4 aşaması vardır:
o Veri kümesinin rastsal olarak k altkümeye ayrılması (her küme bir
altküme),
o Her kümenin ortalaması olan merkez noktanın (kümedeki nesnelerin
niteliklerinin ortalaması) hesaplanması
o Nesnelerin küme merkezine olan
uzaklıklarının değerlendirilmesi ve
dahil olduğu kümenin merkezinden başka bir küme merkezine
daha yakın olan nesnelerin yakın
oldukları kümeye dahil edilmesi
o Yeni nesnelerle artan veya dışarıya
nesne vererek azalan kümelerin
ortalaması olan merkez noktaları
yeniden hesaplanır ve nesnelerin
kümelenmesinde değişiklik olmayana kadar aynı şekilde devam
edilir.
58
K-means yöntemi kurgulaması kolay
ve karmaşıklığı az olan bir tekniktir. Ancak
zayıf olduğu bazı önemli noktalar vardır.
Sonuçları ilk başta merkez noktaların seçimine bağımlıdır. Merkez noktaların seçimine göre farklı sonuçlar ortaya çıkabilir.
Bununla birlikte veri grupları farklı boyutlarda ise, veri gruplarının şekli küresel
değilse ve veri içinde ortalamayı önemli
ölçüde etkileyecek büyük bileşenler varsa
çok iyi sonuçlar alınamayabilir.
Uygulama
Bir şirkee yapılan performans değerlendirmesi uygulamasında çalışanların
yetkinlikleri ve iş hedeflerini gerçekleştirme düzeyleri değerlendirilmiştir. İnsan
Kaynakları bölümü çalışanların performans değerlendirme sonuçları doğrultusunda gelişim ve ödüllendirme paketleri
oluşturmaktadır. Bu paketler hangi farklı
gruplar için oluşturulmalıdır sorusunun
yanıtı aranmaktadır.
Üç farklı grup olacağı öngörülmüş ve
başlangıç olarak yanda görülen gruplama
yapılmıştır. Bu gruplamaya göre kümelerin merkezleri belirlenecektir.
Sadece tek bir çalışanın değerleri kendi
kümesi dışında başka bir kümeye yakındır. Bu çalışanın da uygun kümeye yerleştirilmesi sonucunda üç grup ve
merkezleri şu şekilde oluşmuştur.
59
• K-medoids: K-means yönteminde;
sadece kümenin ortalamasının tanımlanabildiği durumlarda kullanılma ve değeri çok büyük bir
nesnenin kümede olması durumunda (kümenin ortalaması ve
merkez noktası büyük ölçüde değişebileceğinden) kümenin hassasiyetinin bozulabilmesi gibi iki önemli
zafiyet vardır. Bu sorunu gidermek
için kümedeki nesnelerin ortalamasını almak yerine, kümede ortaya en
yakın noktada konumlanmış olan
nesne (medoid) kullanılabilmekte ve
bu işlem k-medoids yöntemi ile tanımlanmaktadır. k-medoids yöntemi şu aşamalardan oluşur;
o Veri kümesi merkezi bir medoid
olan k adet kümeye ayrılır.
o Veri kümesindeki nesneler, kendilerine en yakın olan medoide göre
k adet kümeye yerleşirler.
o Bu bölünmelerin ardından kümenin ortasına en yakın olan nesneyi
bulmak için medoid, medoid olmayan her nesne ile yer değiştirir.
Bu işlem en verimli medoid bulunana kadar devam eder.
Hiyerarşik yöntemler: Veri kümelerini önceden belirlenmiş bir kritere göre,
kümeler ağacı seklinde gruplara ayırma
esasına dayanır . Hiyerarşik kümeleme
yöntemleri, hiyerarşik ayrışmanın yönüne göre ikiye ayrılır.
• Agglomerative (HAC / AGNES (AGlomerative NESting),) hiyerarşik kümelemede, hiyerarşik ayrışma
aşağıdan yukarıya doğru olur .İlk
olarak her nesne kendi kümesini
oluşturur ve ardından bu atomik kümelerin içinde aralarında en az
uzaklık olanlar birleşerek, tüm nesneler bir kümede toplanıncaya dek
daha büyük kümeler oluştururlar.
• Divise (DIANA (Dlvise ANAlysis) hiyerarşik kümelemede, hiyerarşik ayrışma yukarıdan aşağıya doğru olur.
İlk olarak tüm nesneler bir kümededir ve her nesne tek başına bir küme
oluşturana dek, kümeler daha küçük
parçalara bölünürler.
Uygulama
19 çalışanın yukarıdaki örnekteki
biçimde iki boyua değerlendirildiği bir
performans çalışması gerçekleştirilmiştir.
Bu çalışma sonuçları aşağıdan yukarıya
hiyerarşik yöntemle gruplandırılmak
istenmektedir.
60
Sonuca grafiksel olarak bakıldığın
farklı seviyelerde elde edilen kümeler
aşağıdaki gibidir.
Bu çalışma sırasında yapılan iterasyonlarda kümelerin merkez noktalarından hareket edilmiştir. Bu nedenle bazı
durumlarda kümeler arası mesafe bir önceki iterasyondan daha kısa olmuştur.
İterasyonlar gereksinime göre dört
farklı şekilde yapılabilir.
• Kümelerin minimum noktalarının bağlanması
• Kümelerin maksimum noktalarının bağlanması
• Kümelerin elemanlarının ortalama değerlerinin bağlanması
• Kümelerin merkez noktalarının
bağlanması
61
Çalışanlar aralarındaki minimum uzaklıklara göre aşağıdaki tabloda belirtilen adımlar ile gruplanabilirler.
Yukarıdaki grafikle elde edilen sonuçlar dendrogram şekli ile de ifade edilebilir.
Yoğunluk tabanlı yöntemler: Nesnelerin yoğunluğuna göre kümeleri oluşturur.
Kümelerin içinde yer alan ortalamaları
bozan çok büyük veya çok küçük değerlerden etkilenmeyen yöntemlerdir. Kümeleme iterasyonun sona ermesi önceden
belirlenmiş bir yoğunluk parametresi ile
olur. En bilinen yöntemleri; Dbscan ve Optics yöntemleridir.
• Dbscan: Bu yöntemde iki kriter tanımlanır ve bunun doğrultusunda kümeleme işlemi yapılır. Birinci kriter etki
yarıçapı, ikinci kriter minimum eleman
sayısıdır. Amaç minimum eleman sayısına ulaşmak ve bunu minimum etki
yarıçapı ile gerçekleştirmektir. Etki yarı
çapı iterasyonlar ile artırılarak minimum eleman sayısını kapsayıncaya
kadar devam edilir. Minimum eleman
sayısına ulaşıldığında nokta kümenin
çekirdeği olur ve bu işleme diğer noktalar ile devam edilir.
Model tabanlı yöntemler: Her kümeyi
oluşturan verilerin bir matematiksel modele uyduğu varsayılır.
Yapay Sinir Ağları
(Artificial Neural Networks)
İnsan beyninin işleme mantığını temel
alarak, nöronların matematiksel olarak
modellenmesidir. Bu yöntem, kurulan modeli kontrol etmekte ve öğrenme faaliyeti
ile modeli geliştirmektedir. Süreç davranış
biçimlerini anlamak ve hatayı en aza indirmek üzerine kuruludur. Bilgiyi almak
ve daha sonra her uygulamadan bir ders
çıkarmak gibi düşünülebilir. İstatistiksel
yöntemler gibi veri hakkında parametrik
bir model öngörmez.
Doğru sınıflandırma sağlayan, doğru
sonuçlar veren bir yöntem olmakla birlikte
en önemli zafiyetleri öğrenme süresinin
uzun olması ve çıkan sonucun ifade edilmesinin / tanımlanmasının güç olmasıdır.
Yapısı ve Kuruluşu
Yapı nöronlar arasındaki bağlantılar
ve bağlantıların ağırlıkları (öğrenme mekanizması ile geliştirilen) üzerine kurulur.
Modelin karmaşıklığı bu bağlantı yapısına bağlıdır. Nöronların bir araya geldiği
alanlara katman denir. (Giriş katmanı,
çıkış katmanı ve bu iki katman arasında
yer alan gizli katman). Model kurulduktan sonra eğitim verileri sürekli olarak
modele girilir ve elde edilen sonuçlar gerçek sonuçlar ile karşılaştırılarak modelde
iyileştirmeler (ağırlıklarda değişiklikler)
yapılır. Minimum kabul edilebilir hata seviyesine ulaşıldığında model tamamlanmış olur.
Uygulama Alanları
Yapay sinir ağları; halka arzlar, hisse
senedi piyasaları tahmini, kredi değerlendirmesi, belirtilere göre hastalık tahmini,
vb. alanlarında kullanılmaktadır.
62
Örneğin dört girdiden oluşan bir sistemde, aşağıdaki tablodan görülmektedir
ki, en az 3 girdinin 1 olması halinde çıktı
1 olmaktadır.
Çıktının fonksiyonu şu şekilde tanımlanabilir.
Çıktı = 1 eğer (0,3xG1 + 0,3xG2 + 0,3xG3 + 0,3xG4
– 0,8) > 0
Çıktı = 0 eğer (0,3xG1 + 0,3xG2 + 0,3xG3 + 0,3xG4
– 0,8) < 0
Yukarıdaki örnekte sınırlı sayıda veri
olduğundan tüm veriler gözle hesaplanacak kadar basit ağırlık değerleri kullanılarak doğru biçimde sınıflandırılmıştır. Çok
sayıda veriden olan sistemlerde Verilerin
tümünü doğru sınıflandırmak için “ağırlıkları belirleme işlemi” (eğitme işlemi) şu
adımlar ile gerçekleştirilir.
• Başlangıç ağırlık değerleri vermek,
• Bu başlangıç değerlerine göre tüm
verilerin sonucuna bakmak,
• Oluşan hayatı belirlemek
• Hataların karelerini minimum edecek şekilde ağırlıkları değiştirmek.
63

Sonuç

SONUÇ
Veri Madenciliği istatistik biliminin teknolojiyle bütünleşmesi sonucu oluşmuş
bir yöntemler serisidir. Bilgi teknolojilerinin gelişmesi ve konu ile ilgili yeni programların üretilmesi çalışmaları kolaylaştırmaktadır. Ancak veri madenciliği sadece program kullanmak değildir.
Veri madenciliği için iş deneyimine, sorunları tanımlama becerisine ve temel
istatistik bilgisine ihtiyaç vardır. Veri madenciliği veriden bilgi üreterek ortalama
kararlar yerine veriye dayalı özgün kararlar verilmesini destekleyen, satışları, kârlılığı, yenilikçiliği ve kaynak kullanımında etkinliği artıran önemli bir yönetim aracıdır. Veriye dayalı kararların kalitesi ve güvenilirliği artar; bu veriye dayalı
kararlarla çalışan kurumların kaynak kullanım etkinliği ve değer yaratma potansiyeli de gelişir.
Teoride, teori ile pratik arasında fark yoktur ama pratikte vardır. - Jan L. A. van
de Snepscheut
67

Okuma Önerileri

Akyouş Selim, Veri Madenciliği Yöntemlerine Genel Bakış
(Sunum)
Alpaydın Ethem, Zeki Veri Madenciliği (Sunum)
Argüden, R. Yılmaz (1982). Management of Large Data Sets:
A Case Study with California Oil Wells. The RAND Corporation, P-6802
Argüden, R. Yılmaz (1988). Principles for Dealing with Large
Programs and Large Data Files in Policy Studies. The RAND
Corporation, P-7409
Ayres, Ian, (2008). Super Crunchers, Bantam Books
Bishop, C., (1996). Neural Networks for Pattern Recognition,
Oxford Univ Press
Berry Michael J., Linoff, Gordon S., (2000). Mastering data
mining. New York: Wiley
Berry Michael J., Linoff, Gordon S., (2004). Data Mining Techniques For Marketing Sales And Customer Support, New
York: Wiley
Bilgin, Turgay T., Maltepe Üniversitesi Bilgisayar Mühendisliği (BIL 416) (Ders Notları)
Crisp-DM 1.0 (2000), SPSS
Edelstein, H., A. (1999). Introduction to data mining and
knowledge discovery (3rd ed). Potomac, MD: Two Crows
Corp
Fayyad, U. M., Piatetsky-Shapiro, G., Smyth, P., & Uthurusamy, R. (1996). Advances in knowledge discovery & data
mining. Cambridge, MA: MIT Pres
Han Jiawei, Kamber Micheline (2006), Data Mining Concepts
and Techniques, Morgan Kaufmann
Hastie, T., Tibshirani, R., & Friedman, J. H. (2001). The elements of statistical learning : Data mining, inference, and
prediction. New York: Springer.
Mitchell, T. (1997). Machine Learning, McGraw-Hill
Horning Mark F., Marcade Erik, Venkayala Sunil (2007). Java
Data Mining: Strategy, Standard and Practice, Morgan Kaufmann
Levitt, Steven D., Dubner, Stephen J., (2005) Freakonomics,
Harper Collins
Linoff, Gordon S., Survival Data Mining (Sunum)
Olson David L., Delen Dursun (2008). Advanced Data Mining
Techniques, Springer
Pregibon, D. (1997). Data Mining: Statistical Computing and
Graphics 7-8.
Relles, Dan (1986). Allocating Research Resources: TheRole
of a Data Management Core Unit. The RAND Corporation, N2383-NICHD
Rencher, A.C., (1995). Methods of Multivariate Analysis,
Wiley
Rud, Olivia Par, (2001). Data Mining Cookbook - Modeling
Data for Marketing, Risk, and Customer Relationship Management, New York: Wiley
Thearling_K._An_Introduction_to_Data_Mining (Sunum)
Toros Hüseyin, Veri Madenciliğine Giriş (Sunum)
Van Tessel, Dennie (1978). Programming Style, Design, Efficiency, Debugging, and Testing. Prentice-Hall, Inc., Englewood Cliffs
Widner G., Fürnkranz J., Clustering (Sunum)
Weiss, S. M., & Indurkhya, N. (1997). Predictive data mining:
A practical guide. New York: Morgan-Kaufman
Westphal, C., Blaxton, T. (1998). Data mining solutions. New
York: Wiley.
Witten, I. H., & Frank, E. (2000). Data mining. New York:
Morgan-Kaufmann
Ye, Nong (2003) Handbook of Data Mining, Lawrence Erlbaum Associates Publishers
71
Okuma Önerileri –Teknik
Chakrabarti, Soumen (2003). Mining The Web - Discovering
Knowledge From Hypertext Data, Morgan Kaufmann
Pal, Nikhil R., Jain Lakhmi (2004). Advanced Techniques in
Knowledge Discovery and Data Mining, Springer
Hand, David, Mannila, Heikki and Smyth, Padhraic (2001).
Principles of Data Mining, MIT Pres
Chen, Hsinchun, Fuller, Sherrilynne S ., Friedman, Carol,
Hersh, William (2005). Medical Informatics: Knowledge Management and Data Mining in Biomedicine, Springer
Witten, Ian H., Frank Eibe, (2005). Data Mining: Practical
Machine Leraning Tools and Techniques, Elsevier
Wang, John (2006). Encyclopedia of Data Warehousing and
Mining, Idea Group
Sumathi, S., Sivanandam, S. (2006). Introduction to Data
Mining and its Applications, Springer
Felici, Giovanni, Vercellis, Carlo (2008). Mathematical Methods for Knowledge Discovery and Data Mining, Information Science
Evangelos, Triantaphyllou, Giovanni, Felici (2006). Data Mining and Knowledge Discovery Approaches Based on Rule
Induction Techniques (Massive Computing), Springer
Larose, D.T., (2007). Data Mining Methods and Models, Wiley
Cook, Diane J., Holder, Lawrence B., (2007). Mining raph
Data, Wiley
72
1
1
VERİ MADENCİLİĞİ
Genel Bilgiler
Yrd. Doç. Dr. Şule Gündüz Öğüdücü
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 2
İletişim Bilgileri
 e-posta: sgunduz@itu.edu.tr
 Görüşme saati: e-posta ile randevu alınız.
 web sayfası:
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195
 kaynaklar
 duyurular
 sınav sonuçları
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 3
Konular
 Veri madenciliğine giriş
 Veri hazırlama ve temizleme
 Sınıflandırma teknikleri
 Demetleme teknikleri
 İlişkilendirme Kuralları
 Sıralı diziler
 Metin – Doküman Madenciliği
 Sosyal Ağlar
 Veri madenciliği uygulamaları
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 4
Notlandırma
 Ara sınav:%20
 Ödev:%20
 Proje ve sunum (%20)
 3-4 kişilik sunum grupları
 Bir kişi sunum yapacak
 Diğerleri sunum hakkında yorumlar ve sorular:
kendi sunum notlarını %30 etkileyecek
 Yılsonu sınavı:%40
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 5
Ders Kitabı
Data Mining: Concepts and Techniques
Jiawei Han and Micheline Kamber
Morgan Kaufmann Publishers (2006).
ISBN 1-55860-489-8.
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 6
Kaynaklar
 Ders için hazırlanan yansılarda yararlanılan
kaynaklar:
 Data Mining: Concepts and Techniques. Jiawei
Han and Micheline Kamber (2000).
 Data Mining: Introductory and Advanced Topics.
Margaret Dunham (2002).
 Introduction to Data Mining. Pang-Ning Tan,
Michael Steinbach, Vipin Kumar (2005).
1
1
VERİ MADENCİLİĞİ
Giriş
Yrd. Doç. Dr. Şule Gündüz Öğüdücü
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 2
Konular
 Veri madenciliği ve bilgi keşfinin tanımı
 Veri madenciliğinin uygulama alanları
 Veri kaynakları
 Veri madenciliği modellerinin gruplanması
 Veri ambarları
 Veri madenciliğinde sorunlar
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 3
Problem Tanımı
 teknolojinin gelişimiyle bilgisayar ortamında
ve veritabanlarında tutulan veri miktarının
artması (terabyte -> petabyte)
 verinin kolayca toplanabilmesi
 bu veriyi nasıl kullanacağımızı bilmiyoruz
 saklanan veriden bilgi elde etmek için bu veriyi
yorumlamamız gerekiyor
 kullanıcıların beklentilerinin artması
 basit veritabanı sorgulama yöntemlerinin yeterli olmaması
 Veri madenciliği yöntemleri fazla miktardaki veri içinden yararlı bilgiyi bulmak için kullanılır.
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 4
Veri Madenciliği: Tarihçe
 Data Fishing-Data Dredging: 1960-
 istatistikçiler
 Data Mining: 1990-
 veritabanı kullanıcıları, ticari
 Knowledge Discovery in Databases (KDD): 1989-
 yapay zeka, makine öğrenmesi toplulukları
 Data Archaeology, Information Harvesting,
Information Discovery, Knowledge Extraction,...
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 5
Bilgi Keşfi
 Büyük veri kaynaklarından yararlı ve ilginç bilgiyi
bulmak
 Bulunan bilgi
 gizli
 önemli
 önceden bilinmeyen
 yararlı
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 6
Veri Madenciliği Nedir?
 Teoride veri madenciliği bilgi keşfi işleminin
aşamalarından biridir.
 Pratikte veri madenciliği ve bilgi keşfi eş anlamlı
olarak kullanılır.
 Veri madenciliği teknikleri veriyi belli bir modele
uydurur.
 veri içindeki örüntüleri bulur
 örüntü: veri içindeki herhangi bir yapı
 Sorgulama ya da basit istatistik yöntemler veri
madenciliği değildir.
2
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 7
Bilgi Keşfi
Veri Temizleme
Veri Birleştirme Veri Tabanları
Veri Ambarı
Kullanım amaçlı Veri
Seçme
Veri Madenciliği
 Veri madenciliği: Model Değerlendirme
Bilgi keşfinin
temel taşı
Veri Dosyaları http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 8
Bilgi Keşfinin Aşamaları
 Uygulama alanını inceleme
 Konuyla ilgili bilgi ve uygulama amaçları
 Amaca uygun veri kümesi oluşturma
 Veri ayıklama ve önişleme
 Veri azaltma ve veri dönüşümü
 incelemede gerekli boyutları (özellikleri) seçme, boyutlar arası ilişkiyi belirleme, boyut azaltma,
 Veri madenciliği tekniği seçme
 Sınıflandırma, eğri uydurma, bağıntı kuralları, demetleme
 Veri madenciliği algoritmasını seçme
 Model değerlendirme ve bilgi sunumu
 Bulunan bilginin yorumlanması
işlemin %70’lik
bölümünü oluşturur
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 9
Bilgi Keşfi Örnek: web kayıtları
 web sitesinin yapısını inceleme
 verileri seçme: tarih aralığını belirleme
 veri ayıklama, önişleme: gereksiz kayıtları silme
 veri azaltma, veri dönüşümü: kullanıcı oturumları
belirleme
 veri madenciliği tekniği seçme: demetleme
 veri madenciliği algoritması seçme: k-ortalama, EM,
DBSCAN...
 Model değerlendirme/yorumlama: değişik kullanıcı
grupları için sıkça izlenen yolu bulma
 Uygulama alanları: öneri modelleri, kişiselleştirme, ön
belleğe alma
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 10
Bilgi Keşfi: Farklı Alanların Bileşimi
İstatistik
Makine Öğrenmesi
Veritabanı
Görüntüleme
Veri Madenciliği ve
Bilgi Keşfi
Diğer
Araştırma
Alanları
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 11
Veri Madenciliğine Farklı Bakış Açıları
 Veri madenciliği uygulanacak veri
 veri dosyaları, ilişkisel veritabanları, veri ambarları, nesneye dayalı
veritabanları, www, konumsal veriler, zamansal veriler
 Veri madenciliği işlevleri
 demetleme, sınıflandırma, ilişkilendirme kuralları, eğri uydurma,
kestirim, aykırılıkların belirlenmesi..
 veri içindeki örüntülerin bulunması /aykırılıkların bulunması
 Kullanılan teknikler
 kullanıcıyla etkileşim seviyesi
 veri analizi için kullanılan yöntemler (makine öğrenmesi, istatistik,
görüntüleme...)
 Uygulama alanı
 telekomunikasyon, finans, sahtekarlık belirlenmesi, biyolojik veri
madenciliği, web madenciliği
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 12
İstatistik & Makine Öğrenmesi &
Veri Madenciliği
 İstatistik
 daha çok teoriye dayalı yaklaşımlar
 bir varsayımın doğruluğunu araştırır
 Makine Öğrenmesi
 daha çok sezgisel yaklaşımlar
 öğrenme işleminin başarımını artırmaya çalışır
 Veri madenciliği ve bilgi keşfi
 teori ve sezgisel yaklaşımları birleştirir
 bilgi keşfinin tüm aşamalarını gerçekler: veri temizleme,
öğrenme, sonucu sunma, yorumlama,...
 Aradaki ayrım net değil
3
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 13
Veri Madenciliğinin Amacı
 Yapmak istemediğimiz: Büyük
miktardaki veri içinde arama
yapmak (Veritabanı yönetim
sistemleri bu işi yapıyor)
 Amaç: Aradığımız veri mevcutsa
sonuçlarını anlamak
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 14
Veritabanı & Veri Madenciliği İşlemleri
 Sorgulama
 Tanımlı
 SQL
 Sorgulama
 Tam tanımlı değil
 yaygın sorgulama
dili yok
 Veri
 Canlı veri
 Veri
 Üzerinde işlem
yapılmayan veri
 Çıkış
 Belirli
 verinin bir alt kümesi
 Çıkış
 Belirli değil
 verinin bir alt kümesi
değil
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 15
Sorgulama Örnekleri
 Veritabanı uygulaması:
 Soyadı Gündüz olan kredi kartı sahiplerini bul.
 Bir ayda 2000 YTL’den fazla harcama yapan kredi kartı sahiplerini bul.
 Önce bilgisayar daha sonra yazıcı satın alan tüm
müşterileri bul.
 Veri madenciliği uygulaması
 Riski az olan tüm kredi kartı başvurularını bul
(sınıflandırma)
 Harcama alışkanlığı benzer olan kredi kartı sahiplerini
bul (demetleme)
 DVD birlikte sıkça satın alınan ürünü bul (ilişkilendirme
kuralları)
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 16
Konular
 Veri madenciliği ve bilgi keşfinin tanımı
 Veri madenciliğinin uygulama alanları
 Veri kaynakları
 Veri madenciliği modellerinin gruplanması
 Veri ambarları
 Veri madenciliğinde sorunlar
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 17
Veri Madenciliğinin Uygulama Alanları
 Veritabanı analizi ve karar verme desteği
 Pazar araştırması
 Hedef Pazar, müşteriler arası benzerliklerin saptanması, sepet
analizi, çapraz pazar incelemesi
 Risk analizi
 Kalite kontrolu, rekabet analizi, öngörü
 Sahtekarlıkların saptanması
 Diğer Uygulamalar
 Belgeler arası benzerlik (haber kümeleri, e-posta)
 Sorgulama sonuçları
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 18
Uygulamalar
 Hangi promosyonu ne zaman uygulamalıyım?
 Hangi müşteri aldığı krediyi geri ödemeyebilir?
 Bir müşteriye ne kadar kredi verilebilir?
 Sahtekarlık olabilecek davranışlar hangileridir?
 Hangi müşteriler yakın zamanda kaybedilebilir?
 Hangi müşterilere promosyon yapmalıyım?
 Hangi yatırım araçlarına yatırım yapmalıyım?
4
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 19
Pazar Araştırması (1)
 Veri madenciliği uygulamaları için veri kaynağı
 Kredi kartı hareketleri, üyelik kartları, ucuzluk kuponları,
pazar anketleri
 Hedef pazarlar bulma
 Benzer özellikler gösteren müşterilerin bulunması:
benzer gelir grupları, ilgi alanları, harcama alışkanlıkları
 Müşterilerin davranışlarında zaman içindeki değişiklik
 Tek kişilik banka hesabının ortak hesaba çevrilmesi:
evlilik
 Çapraz pazar incelemesi:
 Ürün satışları arasındaki ilişkiyi bulma
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 20
Pazar Araştırması (2)
 Müşteri profili
 Hangi özellikteki müşterilerin hangi ürünleri
aldıkları (demetleme veya sınıflandırma)
 Müşterilerin ihtiyaçlarını belirleme
 Farklı müşterilerin o anki ilgisine yönelik ürünü
bulma
 Yeni müşterileri hangi faktörlerin etkilediğini
bulma
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 21
Sahtekarlık İncelemesi
 Sigorta, bankacılık,
telekomünikasyon alanlarında
 Geçmiş veri kullanılarak sahtekarlık
yapanlar için bir model oluşturma
ve benzer davranış gösterenleri
belirleme
 Örnek:
 Araba sigortası
 Sağlık Sigortası
 Kredi kartı başvurusu
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 22
Risk Analizi
 Finans planlaması ve bilanço değerlendirmesi
 nakit para akışı incelemesi ve kestirimi
 talep incelemesi
 zaman serileri incelemesi
 Kaynak planlaması
 kaynakların incelenmesi ve uygun olarak dağıtılması
 Rekabet
 rakipleri ve pazar eğilimlerini takip etme
 müşterileri sınıflara ayırma ve fiyat politikası belirleme
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 23
Konular
 Veri madenciliği ve bilgi keşfinin tanımı
 Veri madenciliğinin uygulama alanları
 Veri kaynakları
 Veri madenciliği modellerinin gruplanması
 Veri ambarları
 Veri madenciliğinde sorunlar
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 24
Veri Kaynakları
 Veri dosyaları
 Veritabanı kaynaklı veri kümeleri
 ilişkisel veritabanları, veri ambarları
 Gelişmiş veri kümeleri
 duraksız veri (data stream),
algılayıcı verileri (sensor data)
 zaman serileri, sıralı diziler
(biyolojik veriler)
 çizgeler, sosyal ağ (social
networks) verileri
 konumsal veriler (spatial data)
 çoğul ortam veritabanları
(multimedia databases)
 nesneye dayalı veritabanları
 www
5
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 25
Konular
 Veri madenciliği ve bilgi keşfinin tanımı
 Veri madenciliğinin uygulama alanları
 Veri kaynakları
 Veri madenciliği modellerinin gruplanması
 Veri ambarları
 Veri madenciliğinde sorunlar
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 26
Veri Madenciliği Algoritmaları
 amaç: veriyi belli bir modele uydurmak
 tanımlayıcı
 En iyi müşterilerim kimler?
 Hangi ürünler birlikte satılıyor?
 Hangi müşteri gruplarının alışveriş alışkanlıkları benzer?
 kestirime dayalı
 Kredi başvuralarını risk gruplarına ayırma
 Şirketle çalışmayı bırakacak müşterileri öngörme
 Borsa tahmini
 seçim: veriye uyan en iyi modeli seçmek için kullanılan
kriter
 arama: veri üzerinde arama yapmak için kullanılan
teknik
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 27
Veri Madenciliği Modelleri
veri madenciliği
kestirime dayalı tanımlayıcı
sınıflandırma eğri
uydurma
zaman
serileri
demetleme özetleme
ilişkilendirme
kuralları
sıralı
dizi
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 28
Veri Madenciliği İşlevleri
 Sınıflandırma (Classification): Veriyi önceden
belirlenmiş sınıflardan birine dahil eder.
 Gözetimli öğrenme
 Örüntü tanıma
 Kestirim
 Eğri uydurma (Regression): Veriyi gerçel değerli bir
fonksiyona dönüştürür.
 Zaman serileri inceleme (Time Series Analysis): Zaman
içinde değişen verinin değerini öngörür.
 Aykırılıkları Belirleme (Outlier Analysis): Verinin
geneline uymayan nesneleri belirleme
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 29
Veri Madenciliği İşlevleri
 Demetleme (Clustering): Benzer verileri aynı grupta
toplama
 Gözetimsiz öğrenme
 Özetleme (Summarization): Veriyi altgruplara ayırır.
Her altgrubu temsil edecek özellikler bulur.
 Genelleştirme (Generalization)
 Nitelendirme (Characterization)
 İlişkilendirme kuralları (Association Rules)
 Veriler arasındaki ilişkiyi belirler
 Sıralı dizileri bulma (Sequence Discovery): Veri içinde
sıralı örüntüler bulmak için kullanılır.
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 30
Örnek: Sınıflandırma
Tid Geri
Ödeme
Medeni
Durum
Gelir Dolan
dırıcı
1 Evet Bekar 125K -1
2 Hayır Evli 100K -1
3 Hayır Bekar 70K -1
4 Evet Evli 120K -1
5 Hayır Boşanmış 95K 1
6 Hayır Evli 60K -1
7 Evet Boşanmış 220K -1
8 Hayır Bekar 85K 1
9 Hayır Evli 75K -1
10 Hayır Bekar 90K 1 10
kategorik
kategorik
sürekli
sınıf
Geri
Ödeme
Medeni
Durum
Gelir Dolan
dırıcı
Hayır Bekar 75K ?
Evet Evli 50K ?
Hayır Evli 150K ?
Evet Boşanmış 90K ?
Hayır Bekar 40K ?
Hayır Evli 80K ? 10
Deneme
Kümesi
Öğrenme
Kümesi Model
Sınıflandırıcı
6
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 31
Örnek: Demetleme
 Doküman Demetleme:
 Amaç:
 Döküman içinde geçen terimlere göre aynı konudaki
dokümanları gruplama
 Yaklaşım:
 Her doküman içinde sık geçen terimleri bul. Bu terimlerden ve ağırlıklarından yararlanarak bir benzerlik
ölçütü geliştir. Bu ölçüte göre demetleme yap
 Kullanımı:
 Yeni bir dokümanın hangi dokümanlarla benzer olduğu
 terimlere göre arama yapıldığında bu terimleri içeren dokümanları bulma
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 32
Örnek: İlişkilendirme Kuralları
 Veri kümesindeki nesneler arasındaki ilişkiyi
bulma
 bir nesnenin (nesnelerin) varlığı ile diğer bir
nesnenin (nesnelerin) de varlığını tahmin
edebilecek kurallar
TID Nesneler
1 Ekmek, Kola, Süt
2 Bira, Ekmek
3 Bira, Kola, Çocuk bezi, Süt
4 Bira, Ekmek, Çocuk bezi, Süt
5 Kola, Çocuk bezi, Süt
Bulunan Kurallar:
{Süt} --> {Kola}
{Çocuk bezi, Süt} --> {Bira}
Bulunan Kurallar:
{Süt} --> {Kola}
{Çocuk bezi, Süt} --> {Bira}
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 33
Bulunan Örüntüler Önemli mi?
 Binlerce örüntü: Bir kısmı önemli
 Veri madenciliği ile bulunan sonuç kümesi üzerinde tekrar veri madenciliği uygulanacak kadar büyük
 Bulunan örüntünün önemli olması için:
 insanlar tarafından kolayca anlaşılabilir
 sınama verisi veya yeni veriler üzerinde belli oranda
geçerli
 yararlı ve kullanılabilir
 yeni
 nesnel / öznel metrikler
 nesnel: örüntünün yapısına bağlı
 öznel: kullanıcının yaklaşımına bağlı
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 34
Bütün Önemli Örüntülerin
Bulunması
 Bütünlük: Önemli bütün örüntülerin bulunması
 Önemli bütün örüntüler bulunabilir mi?
 Eniyileme: Sadece önemli örüntüleri bulma
 Sadece önemli örüntüler bulunabilir mi?
 Bütün örüntüler bulunduktan sonra önemsiz olanların
ayıklanması
 Sadece önemli örüntülerin bulunması
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 35
En İyi 10 Veri Madenciliği Algoritması
Belirlenen 18 Aday
 Classification
 #1. C4.5 Quinlan, J. R. 1993. C4.5: Programs for Machine Learning. Morgan
Kaufmann Publishers Inc.
 #2. CART L. Breiman, J. Friedman, R. Olshen, and C. Stone. Classification and
Regression Trees. Wadsworth, Belmont, CA, 1984.
 #3. K Nearest Neighbours (kNN) Hastie, T. and Tibshirani, R. 1996. Discriminant
Adaptive Nearest Neighbor Classification. IEEE Trans. Pattern Anal. Mach. Intell.
(TPAMI). 18, 6 (Jun. 1996), 607-616.
 #4. Naive Bayes Hand, D.J., Yu, K., 2001. Idiot's Bayes: Not So Stupid After All?
Internat. Statist. Rev. 69, 385-398.
 Statistical Learning
 #5. SVM Vapnik, V. N. 1995. The Nature of Statistical Learning Theory. Springer- Verlag New York, Inc.
 #6. EM McLachlan, G. and Peel, D. (2000). Finite Mixture Models. J. Wiley, New
York.
 Association Analysis
 #7. Apriori: Rakesh Agrawal and Ramakrishnan Srikant. Fast Algorithms for Mining
Association Rules. In VLDB '94.
 #8. FP-Tree: Han, J., Pei, J., and Yin, Y. 2000. Mining frequent patterns without
candidate generation. In SIGMOD '00.
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 36
En İyi 10 Veri Madenciliği Algoritması
Belirlenen 18 Aday
 Link Mining
 #9. PageRank: Brin, S. and Page, L. 1998. The anatomy of a large-scale
hypertextual Web search engine. In WWW-7, 1998.
 #10. HITS: Kleinberg, J. M. 1998. Authoritative sources in a hyperlinked
environment. SODA, 1998.
 Clustering
 #11. K-Means: MacQueen, J. B., Some methods for classification and
analysis of multivariate observations, in Proc. 5th Berkeley Symp.
Mathematical Statistics and Probability, 1967.
 #12. BIRCH: Zhang, T., Ramakrishnan, R., and Livny, M. 1996. BIRCH: an
efficient data clustering method for very large databases. In SIGMOD '96.
 Bagging and Boosting
 #13. AdaBoost: Freund, Y. and Schapire, R. E. 1997. A decision-theoretic
generalization of on-line learning and an application to boosting. J.
Comput. Syst. Sci. 55, 1 (Aug. 1997), 119-139.
7
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 37
En İyi 10 Veri Madenciliği Algoritması
Belirlenen 18 Aday
 Sequential Patterns
 #14. GSP: Srikant, R. and Agrawal, R. 1996. Mining Sequential Patterns:
Generalizations and Performance Improvements. In Proceedings of the 5th
International Conference on Extending Database Technology, 1996.
 #15. PrefixSpan: J. Pei, J. Han, B. Mortazavi-Asl, H. Pinto, Q. Chen, U. Dayal and MC. Hsu. PrefixSpan: Mining Sequential Patterns Efficiently by Prefix-Projected Pattern
Growth. In ICDE '01.
 Integrated Mining
 #16. CBA: Liu, B., Hsu, W. and Ma, Y. M. Integrating classification and association
rule mining. KDD-98.
 Rough Sets
 #17. Finding reduct: Zdzislaw Pawlak, Rough Sets: Theoretical Aspects of Reasoning
about Data, Kluwer Academic Publishers, Norwell, MA, 1992
 Graph Mining
 #18. gSpan: Yan, X. and Han, J. 2002. gSpan: Graph-Based Substructure Pattern
Mining. In ICDM '02.
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 38
Seçilen En İyi 10 Veri Madenciliği Algoritması
ICDM’06
 #1: C4.5 (61 votes)
 #2: K-Means (60 votes)
 #3: SVM (58 votes)
 #4: Apriori (52 votes)
 #5: EM (48 votes)
 #6: PageRank (46 votes)
 #7: AdaBoost (45 votes)
 #7: kNN (45 votes)
 #7: Naive Bayes (45 votes)
 #10: CART (34 votes)
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 39
Bu Konudaki Başlıca Konferanslar ve Dergiler
 KDD konferansları
 ACM SIGKDD Int. Conf. on
Knowledge Discovery in
Databases and Data Mining
(KDD)
 SIAM Data Mining Conf.
(SDM)
 (IEEE) Int. Conf. on Data
Mining (ICDM)
 Conf. on Principles and
practices of Knowledge
Discovery and Data Mining
(PKDD)
 Pacific-Asia Conf. on
Knowledge Discovery and
Data Mining (PAKDD)
 Konuyla ilgili diğer konferanslar
 ACM SIGMOD
 VLDB
 (IEEE) ICDE
 WWW, SIGIR
 ICML, CVPR, NIPS
 Dergiler
 Data Mining and Knowledge
Discovery (DAMI or DMKD)
 IEEE Trans. On Knowledge
and Data Eng. (TKDE)
 KDD Explorations
 ACM Trans. on KDD
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 40
Konular
 Veri madenciliği ve bilgi keşfinin tanımı
 Veri madenciliğinin uygulama alanları
 Veri kaynakları
 Veri madenciliği modellerinin gruplanması
 Veri ambarları
 Veri madenciliğinde sorunlar
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 41
İlgili Konular: Veri Ambarları
 Çok fazla miktarda üzerinde işlem yapılan veri var
 Çoğunlukla farklı veritabanlarında ve farklı ortamlarda
 Veri farklı formatlarda ve yerlerde (heterojen ve
dağıtık)
 Karar destek birimleri veriye sanal olarak tek bir
yerden ulaşabilmeli
 Ulaşım hızlı olmalı
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 42
Veri Ambarı
 Amaca yönelik
 Birleştirilmiş
 Zaman değişkenli
 Değişken değil
8
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 43
Veri Ambarları: Amaca Yönelik
 Müşteri, ürün, satış gibi belli konular için
düzenlenebilir
 Verinin incelenmesi ve modellenmesi için
oluşturulur
 Konuyla ilgili karar vermek için gerekli olmayan
veriyi kullanmayarak konuya basit, özet bakış
sağlar
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 44
Veri ambarları: Birleştirilmiş
 Veri kaynaklarının birleştirilmesiyle oluşturulur
 Canlı veri tabanları, dosyalar
 Veri temizleme ve birleştirme teknikleri kullanılır
 Değişik veri kaynakları arasındaki tutarlılık
sağlanır
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 45
Veri Ambarları: Zaman Değişkenli
 Zaman değişkeni canlı veri tabanlarına göre
daha uzundur
 Canlı veri tabanları: Güncel veriler bulunur (en
çok geçmiş 1 yıl)
 Veri ambarları: Geçmiş hakkında bilgi verir
(geçmiş 5-10 yıl)
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 46
Veri Ambarları: Değişken Değil
 Canlı veritabanlarından alınmış verinin fiziksel
olarak başka bir ortamda saklanması
 Canlı veritabanlarındaki değişimin veri
ambarlarını etkilememesi
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 47
Veri Ambarı Mimarisi
İstemci İstemci
Veri Ambarı
Kaynak Kaynak Kaynak
Sorgulama &
İnceleme
Birleştirme
Metadata
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 48
Veri Kaynakları
 İki yaklaşım:
 sorgulamalı
 veri ambarı
Kaynak Kaynak
?
9
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 49
Veri Ambarı & Birleşmiş Veritabanları
 Veritabanlarının birleştirilmesi:
 Farklı veritabanları arasında bir arabulucu katman
 Sorgulamalı
 Bir sorgulamayı her veritabanı için alt sorgulamalara ayır
 Sonucu birleştir
 Veri ambarı:
 Veri daha sonra kullanılmak üzere birleştirilip veri ambarında
saklanıyor
Veri Ambarı
Sorgulama
Sonuç
Birleştirme
Veri Ambarı
Birleştirilmiş veritabanları
Sorgu
Alt Sorgulamalar
Sonuç
Kaynaklar
Arabulucu
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 50
Veri Madenciliği & OLAP
 OLAP (On-Line Analytical Processing)
 Veri ambarlarının işlevi
 Veriyi inceleme ve karar verme
 OLTP (On-Line Transaction Processing) saatler sürebilen işlemler
 OLAP avantajları
 Daha geniş kapsamlı sonuçlar
 Daha kısa süreli işlem
 OLAP dezavantajları
 Kullanıcı neyi nasıl soracağını bilmesi gerekiyor
 Genelde veriden istatistiksel inceleme yapmak için kullanılır.
OLAP NE sorusuna cevap verir, veri madenciliği NEDEN
sorusuna cevap verir.
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 51
Konular
 Veri madenciliği ve bilgi keşfinin tanımı
 Veri madenciliğinin uygulama alanları
 Veri kaynakları
 Veri madenciliği modellerinin gruplanması
 Veri ambarları
 Veri madenciliğinde sorunlar
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 52
Veri Madenciliğinde Sorunlar (1)
 Güvenlik ve sosyal haklar
 Kullanıcı Arabirimi
 Veri madenciliği yöntemi
 Başarım ve ölçeklenebilirlik
 Veri kaynağı
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 53
Veri Madenciliğinde Sorunlar (2)
 Gizlilik ve sosyal haklar
 Kişilere ait verilerin toplanarak, kişilerden
habersiz ve izinsiz olarak kullanılması
 Veri madenciliği yöntemleri ile bulunan
sonuçların izinsiz olarak açıklanması
(/paylaşılması)
 Gizlilik ve veri madenciliği politikalarının
düzenlenmesi
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 54
Veri Madenciliğinde Sorunlar (3)
 Kullanıcı Arabirimi
 Görüntüleme
 Sonucun anlaşılabilir ve yorumlanabilir hale
getirilmesi
 Bilginin sunulması
 Etkileşim
 Veri madenciliği ile elde edilen bilginin kullanılması
 Veri madenciliği yöntemine müdahele etmek
 Veri madenciliği yönteminin sonucuna müdahele
etmek
10
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 55
Veri Madenciliğinde Sorunlar (4)
 Veri madenciliği yöntemi
 Farklı tipte veriler üzerinde çalışabilme
 Farklı seviyelerde kullanıcı ile etkileşim halinde olabilme
 Uygulama ortamı bilgisini kullanabilme
 Veri madenciliği ile elde edilen sonucu anlaşılır şekilde
sunabilme
 Gürültülü ve eksik veri ile çalışabilme (ve iyi sonuç
verebilme)
 Değişen veya eklenen verileri kolayca kullanabilme
 Örüntü değerlendirme: önemli örüntüleri bulma
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 56
Veri Madenciliğinde Sorunlar (5)
 Başarım ve ölçeklenebilirlik
 Kullanabilirlik ve ölçeklenebilirlik
 Zaman karmaşıklığı ve yer karmaşıklığı kabul edilebilir
 Örnekleme yapabilme
 Paralel ve dağıtık yöntemler
 Artımlı veri madenciliği
 Parçala ve çöz
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 57
Uyarı
 Veri madenciliği yöntemleri bilinçsiz olarak
kullanılmamalı
 Veri madenciliği yöntemleri geçmiş olaylara
bakarak örüntüler bulur: Gelecekteki olaylar
geçmiştekilerle aynı değildir
 İlişkiler her zaman nedenleri açıklamaz
 David Heckerman’ın verdiği örnek (1997)
 hamburger, hot-dog, barbecue sauce
1
1
VERİ MADENCİLİĞİ
Veri Önişleme
Yrd. Doç. Dr. Şule Gündüz Öğüdücü
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 2
Konular
 Veri
 Veri Önişleme
 Veriyi Tanıma
 Veri temizleme
 Veri birleştirme
 Veri dönüşümü
 Veri azaltma
 Benzerlik ve farklılık
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 3
Veri Nedir?
 nesneler ve nesnelerin
niteliklerinden oluşan küme
 kayıt (record), varlık (entity), örnek (sample,
instance) nesne için
kullanılabilir.
 Nitelik (attribute) bir
nesnenin (object) bir
özelliğidir
 bir insanın yaşı, ortamın sıcaklığı..
 boyut (dimension), özellik
(feature, characteristic)
olarak da kullanılır
 Nitelikler ve bu niteliklere
ait değerler bir nesneyi oluşturur.
Tid Geri
Ödeme
Medeni
Durum
Gelir Dolan
dırıcı
1 Evet Bekar 125K -1
2 Hayır Evli 100K -1
3 Hayır Bekar 70K -1
4 Evet Evli 120K -1
5 Hayır Boşanmış 95K 1
6 Hayır Evli 60K -1
7 Evet Boşanmış 220K -1
8 Hayır Bekar 85K 1
9 Hayır Evli 75K -1
10 Hayır Bekar 90K 1 10
nitelikler
nesneler
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 4
Değer Kümeleri
 Nitelik için saptanmış sayılar veya semboller
 Nitelik & Değer Kümeleri
 aynı nitelik farklı değer kümelerinden değer
alabilir
 ağırlık: kg, lb
 farklı nitelikler aynı değer kümesinden değer
alabilirler
 ID, yaş: her ikisi de sayısal
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 5
Nitelik Türleri
 Belli aralıkta yeralan değişkenler (interval)
 sıcaklık, tarih
 İkili değişkenler (binary)
 cinsiyet
 Ayrık ve sıralı değişkenler (nominal, ordinal,
ratio scaled)
 göz rengi, posta kodu
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 6
Konular
 Veri
 Veri Önişleme
 Veriyi Tanıma
 Veri temizleme
 Veri birleştirme
 Veri dönüşümü
 Veri azaltma
 Benzerlik ve farklılık
2
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 7
Problem
 Gerçek uygulamalarda toplanan veri kirli
 eksik: bazı nitelik değerleri bazı nesneler için girilmemiş,
veri madenciliği uygulaması için gerekli bir nitelik
kaydedilmemiş
 meslek = “ ”
 gürültülü: hatalar var
 maaş= “-10”
 tutarsız: nitelik değerleri veya nitelik isimleri uyumsuz
 yaş= “35”, d.tarihi: “03/10/2004”
 önceki oylama değerleri: “1,2,3”, yeni oylama değerleri: “A,B,C”
 bir kaynakta nitelik değeri ‘ad’, diğerinde ‘isim’
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 8
Verinin Gürültülü Olma Nedenleri
 Eksik veri kayıtlarının nedenleri
 Veri toplandığı sırada bir nitelik değerinin elde edilememesi,
bilinmemesi
 Veri toplandığı sırada bazı niteliklerin gerekliliğinin görülememesi
 İnsan, yazılım ya da donanım problemleri
 Gürültülü (hatalı) veri kayıtlarının nedenleri
 Hatalı veri toplama gereçleri
 İnsan, yazılım ya da donanım problemleri
 Veri iletimi sırasında problemler
 Tutarsız veri kayıtlarının nedenleri
 Verinin farklı veri kaynaklarında tutulması
 İşlevsel bağımlılık kurallarına uyulmaması
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 9
Sonuç
 Veri güvenilmez
 Veri madenciliği sonuçlarına güvenilebilir mi?
 Kullanılabilir veri madenciliği sonuçları kaliteli veri ile elde edilebilir
 Veri kaliteli ise veri
madenciliği
uygulamaları ile
yararlı bilgi bulma
şansı daha fazla.
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 10
Veri Önişleme
 Veri temizleme
 Eksik nitelik değerlerini tamamlama, hatalı veriyi
düzeltme, aykırılıkları saptama ve temizleme,
tutarsızlıkları giderme
 Veri birleştirme
 Farklı veri kaynağındaki verileri birleştirme
 Veri dönüşümü
 Normalizasyon ve biriktirme
 Veri azaltma
 Aynı veri madenciliği sonuçları elde edilecek şekilde
veri miktarını azaltma
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 11
Veri Önişleme
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 12
Konular
 Veri
 Veri Önişleme
 Veriyi Tanıma
 Veri temizleme
 Veri birleştirme
 Veri dönüşümü
 Veri azaltma
 Benzerlik ve farklılık
3
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 13
Veriyi Tanımlayıcı Özellikler
 Amaç: Veriyi daha iyi anlamak
 Merkezi eğilim (central tendency), varyasyon,
yayılma, dağılım
 Verinin dağılım özellikleri
 Ortanca, en büyük, en küçük, sıklık derecesi,
aykırılık, varyans
 Sayısal nitelikler -> sıralanabilir değerler
 verinin dağılımı
 kutu grafiği çizimi ve sıklık derecesi incelemesi
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 14
Merkezi Eğilimi Ölçme
 Ortalama:
 ağırlıklı ortalama
 kırpılmış ortalama: Uç değerleri kullanmadan
hesaplama
 Ortanca (median): Verinin tümü kullanılarak hesaplanır
 veri sayısı tek ise ortadaki değer, çift sayı ise ortadaki iki
değerin ortalaması
 Mod
 Veri içinde en sıklıkla görülen değer
 Unimodal, bimodal, trimodal
 deneysel formül:
∑=
=
n
i
i x n x 1
1
∑
∑
=
= = n
i
i
n
i
i i
w
w x
x
1
1
c f
n f median L
median
l
)
/ 2 ( ) ( 1 = + − ∑
mean− mode = 3×(mean− median)
N
∑x μ =
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 15
Simetrik – Asimetrik
Dağılım
 Simetrik ve asimetrik
verinin ortalama, ortanca
ve mod değerleri
Mean
Median
Mode
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 16
Verinin Dağılımını Ölçme
 Çeyrek, aykırılıklar, kutu grafiği çizimi
 Çeyrek (quartile) : nitelik değerleri küçükten büyüğe doğru
sıralanır.
 Q1: ilk %25, Q3: ilk %75
 Dörtlü aralık (Inter-quartile Range): IQR= Q3-Q1
 Five Number Summary: min, Q1, median, Q3, max
 Kutu Grafiği Çizimi:
 Q1 ve Q3 aralığında bir kutu
 kutu içinde ortanca noktayı gösteren bir çizgi
 kutudan min ve max değerlere birer uzantı
 Aykırılıklar: 1,5xIQR değerinden küçük/büyük olan değerler
 Varyans ve standart sapma
∑ ∑ ∑ = = =
− − − = − =
n
i
n
i
i i
n
i
i x n x n x x n s 1 1
2 2
1
2 2 ( ) ] 1 [
1
1 ( ) 1
1 ∑ ∑ = =
= − = −
n
i
i
n
i
i x N x N 1
2 2
1
2 2 1 ( ) 1 σ μ μ
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 17
Quantile Plot
 Verinin bütününü bir nitelik değerine göre görüntüleme
 Veri bir nitelik değerine göre küçükten büyüğe doğru
sıralanır
 xi değeri için % 100 fi miktardaki veri xi değerinden
küçük ya da eşittir
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 18
Scatter Plot
 İki sayısal nitelik değeri arasındaki ilişkiyi
görmek
4
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 19
Konular
 Veri
 Veri Önişleme
 Veriyi Tanıma
 Veri temizleme
 Veri birleştirme
 Veri dönüşümü
 Veri azaltma
 Benzerlik ve farklılık
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 20
Veri Temizleme
 Gerçek uygulamalarda veri eksik, gürültülü veya
tutarsız olabilir.
 Veri temizleme işlemleri
 Eksik nitelik değerlerini tamamlama
 Aykırılıkların bulunması ve gürültülü verinin
düzeltilmesi
 Tutarsızlıkların giderilmesi
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 21
Eksik Veri
 Veri için bazı niteliklerin değerleri her zaman
bilinemeyebilir.
 Eksik veri
 diğer veri kayıtlarıyla tutarsızlığı nedeniyle
silinmesi
 Bazı nitelik değerleri hatalı olması dolayısıyla
silinmesi
 yanlış anlama sonucu kaydedilmeme
 veri girişi sırasında bazı nitelikleri önemsiz
görme
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 22
Eksik Veriler nasıl Tamamlanır?
 Eksik nitelik değerleri olan veri kayıtlarını kullanma
 Eksik nitelik değerlerini elle doldur
 Eksik nitelik değerleri için global bir değişken kullan
(Null, bilinmiyor,...)
 Eksik nitelik değerlerini o niteliğin ortalama değeri ile
doldur
 Aynı sınıfa ait kayıtların nitelik değerlerinin ortalaması
ile doldur
 Olasılığı en fazla olan nitelik değeriyle doldur
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 23
Gürültülü Veri
 Ölçülen bir değerdeki hata
 Yanlış nitelik değerleri
 hatalı veri toplama gereçleri
 veri girişi problemleri
 veri iletimi problemleri
 teknolojik kısıtlar
 nitelik isimlerinde tutarsızlık
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 24
Gürültülü Veri nasıl Düzeltilir?
 Gürültüyü yok etme
 Bölmeleme
 veri sıralanır, eşit genişlik veya eşit derinlik ile
bölünür
 Demetleme
 aykırılıkları belirler
 Eğri uydurma
 veriyi bir fonksiyona uydurarak gürültüyü düzeltir
 http://control.cs.berkeley.edu/abc/
5
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 25
Bölmeleme
 Veri sıralanır: 4, 8, 15, 21, 21, 24, 25, 28, 34
 Eşit genişlik: Bölme sayısı belirlenir. Eşit aralıklarla bölünür
 Eşit derinlik: Her bölmede eşit sayıda örnek kalacak şekilde
bölünür.
 her bölme ortalamayla ya da bölmenin en alt ve üst sınırlarıyla temsil
edilir
Bölme genişliği:3
1. Bölme: 4, 8, 15
2. Bölme: 21, 21, 24
3. Bölme: 25, 28, 34
Ortalamayla düzeltme:
1. Bölme: 9, 9, 9
2. Bölme: 22, 22, 22
3. Bölme: 29, 29, 29
Alt-üst sınırla düzeltme:
1. Bölme: 4, 4, 15
2. Bölme: 21, 21, 24
3. Bölme: 25, 25, 34
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 26
Demetleme
 Benzer veriler aynı demette olacak şekilde
gruplanır
 Bu demetlerin dışında kalan veriler aykırılık
olarak belirlenir ve silinir
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 27
Eğri Uydurma
 Veri bir fonksiyona
uydurulur. Doğrusal
eğri uydurmada, bir
değişkenin değeri diğer
bir değişken
kullanılarak bulunabilir.
x
y = x + 1
X1
Y1
Y1’
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 28
Konular
 Veri
 Veri Önişleme
 Veriyi Tanıma
 Veri temizleme
 Veri birleştirme
 Veri dönüşümü
 Veri azaltma
 Benzerlik ve farklılık
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 29
Veri Birleştirme
 Farklı kaynaklardan verilerin tutarlı olarak
birleştirilmesi
 Şema birleştirilmesi
 Aynı varlıkların saptanması:
A.cust_id=B.cust_num
 meta veri kullanılır
 Nitelik değerlerinin tutarsızlığının saptanması
 Aynı nitelik için farklı kaynaklarda farklı değerler
olması
 Farklı metrikler kullanılması
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 30
Gereksiz Veri
 Farklı veri kaynaklarından veriler birleştirilince gereksiz
(fazla) veri oluşabilir
 aynı nitelik farklı kaynaklarda farklı isimle
 bir niteliğin değeri başka bir nitelik kullanılarak
hesaplanabilir
 korelasyon hesaplaması: sayısal nitelikler
 =0: nitelikler bağımsız, >0: pozitif korelasyon, <0: negatif
korelasyon
 korelasyon hesaplaması: ayrık nitelikler (chi-square test)
A B
A B n
A A B B r ( 1)σ σ
( )( ) , −
− − = ∑ n
A A = ∑
1
( )
2
−
− = ∑ n
A A σ A
∑ − = Expected
Observed Expected 2
2 ( ) χ
6
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 31
Konular
 Veri
 Veri Önişleme
 Veriyi Tanıma
 Veri temizleme
 Veri birleştirme
 Veri dönüşümü
 Veri azaltma
 Benzerlik ve farklılık
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 32
Veri Dönüşümü
 Veri, veri madenciliği uygulamaları için uygun olmayabilir
 Seçilen algoritmaya uygun olmayabilir
 Veri belirleyici değil
 Çözüm
 Veri düzeltme
 Bölmeleme
 Demetleme
 Eğri Uydurma
 Biriktirme
 Genelleme
 Normalizasyon
 Nitelik oluşturma
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 33
Bölmeleme ve Demetleme Yöntemleri
ile Veri Düzeltme
Veri Eşit genişlik
Eşit derinlik demetleme: K-ortalama
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 34
Normalizasyon
 min-max normalizasyon
 z-score normalizasyon
 ondalık normalizasyon
A A A
A A
A
new max new min new min max min
v min v' ( _ − _ ) + _ −
− =
A
A
stand dev
v mean v _ ' − =
j
v v 10 '= j: Max(| |)<1 olacak v' şekildeki en küçük tam sayı
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 35
Nitelik Oluşturma
 Yeni nitelikler yarat
 orjinal niteliklerden daha önemli bilgi içersin
 alan=boy x en
 veri madenciliği algoritmalarının başarımı daha
iyi olsun
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 36
Konular
 Veri
 Veri Önişleme
 Veriyi Tanıma
 Veri temizleme
 Veri birleştirme
 Veri dönüşümü
 Veri azaltma
 Benzerlik ve farklılık
7
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 37
Veri Azaltma
 Veri miktarı çok fazla olduğu zaman veri madenciliği algoritmalarının
çalışması ve sonuç üretmesi çok uzun sürebilir
 veriyi azaltma başarımı artırır
 sonucun (nerdeyse) hiç değişmemesi gerekir
 Veri azaltma
 nitelik birleştirme
 nitelik azaltma
 veri sıkıştırma
 veri ayrıştırma ve kavram oluşturma
 veri küçültme
 eğri uydurma
 demetleme
 histogram
 örnekleme
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 38
Nitelik Birleştirme
 Sorgulama için gerekli olan boyutlar
kullanılıyor.
Tarih
Ürün
Ülke
sum
sum
TV
VCR
PC
1Qtr 2Qtr3Qtr4Qtr
U.S.A
Canada
Mexico
sum
Tarih
Ürün
Ülke
sum
TV
VCR
PC
1999 20002001 2002
U.S.A
Canada
Mexico
sum
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 39
Nitelik Seçme - Nitelik Azaltma
 Nitelik Seçme
 Nitelikler kümesinin bir alt kümesi seçilerek veri
madenciliği işlemi yapılır
 Nitelik azaltma
 d boyutlu veri kümesi k<d olacak şekilde k
boyuta taşınır
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 40
Nitelik Seçme
 Nitelik seçme
 Veri madenciliği uygulaması için gerekli olan niteliklerin seçilmesi
 Nitelikler altkümesi kullanılarak elde edilen sınıfların dağılımları gerçek dağılıma eşit ya da çok yakın olmalı
 Veri madenciliği işlemi yer ve zaman karmaşıklığını azaltma
 Sistemin başarımını artırma
 Sezgisel yöntemler kullanılarak nitelikler seçilebilir.
 istatistiksel anlamlılık testi (statistical significance)
 bilgi kazancı (information gain)
 karar ağaçları
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 41
Örnek
Başlangıç nitelikler kümesi:
{A1, A2, A3, A4, A5, A6}
Seçilen nitelik kümesi: {A1, A4, A6}
A4 ?
A1? A6?
Class 1 Class 2 Class 1 Class 2
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 42
Nitelik Azaltma
 Çok boyutlu veriyi daha küçük boyutlu uzaya taşıma
 d nitelikten oluşan n adet veri D={x1, x2, ...,xn} k
boyutlu uzaya taşınır:
 Veri kümesinde yer alan bütün nitelikler kullanılır
 Niteliklerin doğrusal kombinasyonu
 Niteliklerin ayırıcılığına artırma
(k d) k
i
d xi ∈R → y ∈R <<
8
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 43
Veri Sıkıştırma
 Verinin boyutunu azaltır
 daha az saklama ortamı
 veriye ulaşmak daha çabuk
 Kayıplı ve kayıpsız veri sıkıştırma
 bazı yöntemler bazı veri tiplerine uygun
 her veri tipi için kullanılan yöntemler de var
 Eğer veri madenciliği yöntemi sıkıştırılmış veri
üzerinde doğrudan çalışabiliyorsa elverişli
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 44
Veri Ayrıştırma
 Bazı veri madenciliği algoritmaları sadece ayrık
veriler ile çalışır
 Sürekli bir nitelik değerini bölerek her aralığı
etiketler
 Verinin değeri, bulunduğu aralığın etiketi ile
değişir
 Veri boyutu küçülür
 Kavram oluşturmak için kullanılır
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 45
Kavram Oluşturma
 Sayısal veriler
 çok geniş aralıkta olabilir
 değerleri çok sık değişebilir
 Sayısal veriler için kavram oluşturma
 bölmeleme
 histogram
 demetleme
 entropi
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 46
Veri Küçültme
 Veriyi farklı şekillerde gösterme
 parametrik
 eğri uydurma
 parametrik olmayan
 histogram
 demetleme
 örnekleme
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 47
Histogram ile Veri Küçültme
 Verinin dağılımı
 Veriyi bölerek her bölüm için veri
değerini gösterir (toplam,
ortalama)
 eşit genişlik (equi-width):
bölmelerin genişliği eşit
 eşit yükseklik (equi-height): her
bölmedeki veri sayısı eşit
 v-optimal: en az varyansı olan
histogram Σ(countb*valueb)
 MaxDiff: bölme genişliğini
kullanıcı belirler
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 48
Demetleme ile Veri Küçültme
 Veri demetlere ayrılır
 Veri demetleri temsil eden örnekler (demet merkezleri)
ve aykırılıklar ile temsil edilir
 Etkisi verinin dağılımına bağlı
 Hiyerarşik demetleme yöntemleri kullanılabilir.
9
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 49
Örnekleme ile Veri Küçültme
 Büyük veri kümesini daha küçük bir alt küme ile
temsil etme
 Alt küme nasıl seçiliyor?
 yerine koymadan örnekleme (SRSWOR)
 yerine koyarak örnekleme (SRSWR)
 demet örnekleme (yerine koymadan veya
koyarak)
 katman örnekleme (katman: nitelik değerine
göre grup)
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 50
Örnek
T1
T2
T3
T4
T5
T6
T7
T8
T5
T2
T8
T6
T4
T7
T4
T1
SRSWOR
SRSWR
 Örnekleme
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 51
Örnek
 Demetleme
T1
:
:
T100
T101
T201
T901 ...
T201
:
:
T300
T701
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 52
Örnek
 Katman Örnekleme
T1 genç
T2 genç
T3 genç
T4 genç
T5 orta yaşlı
T6 orta yaşlı
T7 orta yaşlı
T8 orta yaşlı
T9 orta yaşlı
T10 orta yaşlı
T11 orta yaşlı
T12 orta yaşlı
T13 yaşlı
T14 yaşlı
T1 genç
T4 genç
T6 orta yaşlı
T7 orta yaşlı
T9 orta yaşlı
T11 orta yaşlı
T13 yaşlı
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 53
Konular
 Veri
 Veri Önişleme
 Veriyi Tanıma
 Veri temizleme
 Veri birleştirme
 Veri dönüşümü
 Veri azaltma
 Benzerlik ve farklılık
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 54
Benzerlik ve Farklılık
 Benzerlik
 iki nesnenin benzerliğini ölçen sayısal değer
 nesneler birbirine daha benzer ise daha büyük
 genelde 0-1 aralığında değer alır
 Farklılık
 iki nesnenin birbirinden ne kadar farklı olduğunu
gösteren sayısal değer
 nesneler birbirine daha benzer ise daha küçük
 en küçük farklılık genelde 0
 üst sınır değişebilir
10
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 55
Öklid Uzaklığı
 Veri kümesi
 Uzaklık matrisi
 Öklid uzaklığı (Euclidean Distance) nesneler arası farklılığı bulmak için
kullanılır.
 p adet niteliği (boyutu) olan i ve j nesneleri arasındaki uzaklık
2 2
2 2
2
1 1 ( , ) ... i j i j ip jp d i j = x − x + x − x + + x − x
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎦
⎤
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎣
⎡
np ... x nf ... x n1 x
... ... ... ... ...
ip ... x if ... x i1 x
... ... ... ... ...
1p ... x 1f ... x 11 x
⎥
⎥
⎥
⎥
⎥
⎥
⎦
⎤
⎢
⎢
⎢
⎢
⎢
⎢
⎣
⎡
( ,1) ( ,2) ... 0
: : :
) (3,2)
d n d n ...
d(3,1 d 0
d(2,1) 0
0
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 56
Örnek: Öklid Uzaklığı
0
1
2
3
0123456
p1
p2
p3 p4
nesne x y
p1 0 2
p2 2 0
p3 3 1
p4 5 1
Uzaklık Matrisi
p1 p2 p3 p4
p1 0 2.828 3.162 5.099
p2 2.828 0 1.414 3.162
p3 3.162 1.414 0 2
p4 5.099 3.162 2 0
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 57
Minkowski Uzaklığı
 Öklid uzaklığının genelleştirilmiş hali
 q=1 Manhattan uzaklığı
q q
p p
q q
j x i
x j x i
x j x i d(i, j) (| x | | | ... | | ) 1 1 2 2
= − + − + + − q: positif tam sayı
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 58
Uzaklık Özellikleri
 q=1⇒ Manhattan Uzaklığı
 q=2 ⇒ Öklid Uzaklığı
 Uzaklık ölçütünün sağlaması gereken özellikler:
1. d(i,j)≥0
2. d(i,i)=0
3. d(i,j)=d(j,i)
4. d(i,j)≤d(i,h)+d(h,j)
 Uzaklıklar ağırlıklı olarak da hesaplanabilir:
2 2
2 2 2
2
1 1 1 ( , ) ... i j i j p ip jp d i j = w x − x + w x − x + + w x − x
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 59
Benzerlik Özellikleri
 İki nesne arası benzerlik özellikleri
1. sim(i,j)>=0
2. sim(i,j)=sim(j,i)
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 60
İkili Değişkenler Arası Benzerlik
 İkili bir değişkenin 0 veya 1 olarak iki değeri olabilir.
 Bir olasılık tablosu oluşturulur:
 Yalın uyum katsayısı (simple matching coefficient): ikili değişkenin simetrik olduğu durumlarda
 Jaccard katsayısı (İkili değişkenin asimetrik olduğu durumlar):
00 01 10 11
11 00 ( , ) M M M M
M M simi j + + +
+ =
01 10 11
11 ( , ) M M M
M d i j + + =
M00: i nesnesinin 0, j nesnesinin 0 olduğu
niteliklerin sayısı
M10: i nesnesinin 1, j nesnesinin 0 olduğu
niteliklerin sayısı
M01: i nesnesinin 0, j nesnesinin 1 olduğu
niteliklerin sayısı
M11: i nesnesinin 1, j nesnesinin 1 olduğu
niteliklerin sayısı
M10 M11
M00 M01
1
0
0 1
Nesne j
Nesne i
11
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 61
Örnek
p = 1 0 0 0 0 0 0 0 0 0
q = 0 0 0 0 0 0 1 0 0 1
M01 = 2
M10 = 1
M00 = 7
M11 = 0
Yalın Uyum Katsayısı:
(M11 + M00)/(M01 + M10 + M11 + M00) = (0+7) / (2+1+0+7) = 0.7
Jaccard Katsayısı:
(M11) / (M01 + M10 + M11) = 0 / (2 + 1 + 0) = 0
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 62
Kosinüs Benzerliği
 d1 ve d2 iki doküman. Kosinüs benzerliği
cos(d1,d2)=d1zd2 / ||d1|| ||d2||
di
zdj
: iki dokümanın vektör çarpımı
||di
||: di dokümanının uzunluğu
 Örnek
d1 = 3 2 0 5 0 0 0 2 0 0
d2 = 1 0 0 0 0 0 0 1 0 2
d1 • d2
= 3*1 + 2*0 + 0*0 + 5*0 + 0*0 + 0*0 + 0*0 + 2*1 + 0*0 + 0*2 = 5
||d1
|| = (3*3+2*2+0*0+5*5+0*0+0*0+0*0+2*2+0*0+0*0)0.5 = (42) 0.5 = 6.481
||d2
|| = (1*1+0*0+0*0+0*0+0*0+0*0+0*0+1*1+0*0+2*2) 0.5 = (6) 0.5 = 2.245
cos( d1
, d2 ) = .3150
1
1
VERİ MADENCİLİĞİ
Temel Sınıflandırma Yöntemleri
Yrd. Doç. Dr. Şule Gündüz Öğüdücü
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 2
Konular
 Sınıflandırma işlemi
 Sınıflandırma tanımı
 Sınıflandırma uygulamaları
 Sınıflandırma yöntemleri
 Karar ağaçları
 Yapay sinir ağları
 Bayes sınıflandırıcılar
 Bayes ağları
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 3
Sınıflandırma
 Sınıflandırma (classification) problemi:
 nesnelerden oluşan veri kümesi (öğrenme kümesi):
D={t1,t2,…,tn}
 her nesne niteliklerden oluşuyor, niteliklerden biri sınıf
bilgisi
 Sınıf niteliğini belirlemek için diğer nitelikleri kullanarak
bir model bulma
 Öğrenme kümesinde yer almayan nesneleri (sınama
kümesi) mümkün olan en iyi şekilde doğru sınıflara
atamak
 sınıflandırma=ayrık değişkenler için öngörüde
(prediction) bulunma
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 4
Sınıflandırma
 Amaç: Bir niteliğin değerini diğer nitelikleri kullanarak belirlemek
 verinin dağılımına göre bir model bulunur
 bulunan model, başarımı belirlendikten sonra niteliğin gelecekteki
ya da bilinmeyen değerini tahmin etmek için kullanılır
 model başarımı: doğru sınıflandırılmış sınama kümesi örneklerinin oranı
 Veri madenciliği uygulamasında:
 ayrık nitelik değerlerini tahmin etmek: sınıflandırma
 sürekli nitelik değerlerini tahmin etmek: öngörü
¾ Sınıflandırma: hangi topun
hangi sepete
koyulabileceği
¾ Öngörü: Topun ağırlığı
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 5
Gözetimli & Gözetimsiz Sınıflandırma
 Gözetimli (Supervised) sınıflandırma = sınıflandırma
 Sınıfların sayısı ve hangi nesnenin hangi sınıfta olduğu biliniyor.
 Gözetimsiz (Unsupervised) sınıflandırma = demetleme (clustering)
 Hangi nesnenin hangi sınıfta olduğu bilinmiyor. Genelde sınıf sayısı
bilinmiyor.
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 6
Konular
 Sınıflandırma işlemi
 Sınıflandırma tanımı
 Sınıflandırma uygulamaları
 Sınıflandırma yöntemleri
 Karar ağaçları
 Yapay sinir ağları
 Bayes sınıflandırıcılar
 Bayes ağları
2
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 7
Sınıflandırma Uygulamaları
 Kredi başvurusu değerlendirme
 Kredi kartı harcamasının sahtekarlık olup
olmadığına karar verme
 Hastalık teşhisi
 Ses tanıma
 Karakter tanıma
 Gazete haberlerini konularına göre ayırma
 Kullanıcı davranışları belirleme
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 8
Sınıflandırma için Veri Hazırlama
 Veri dönüşümü:
 Sürekli nitelik değeri ayrık hale getirilir
 Normalizasyon ([-1,...,1], [0,...,1])
 Veri temizleme:
 gürültüyü azaltma
 gereksiz nitelikleri silme
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 9
Sınıflandırma İşlemi
 Sınıflandırma işlemi üç aşamadan oluşur:
1. Model oluşturma
2. Model değerlendirme
3. Modeli kullanma
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 10
Sınıflandırma İşlemi: Model
Oluşturma
1. Model Oluşturma:
 Her nesnenin sınıf etiketi olarak tanımlanan
niteliğinin belirlediği bir sınıfta olduğu varsayılır
 Model oluşturmak için kullanılan nesnelerin
oluşturduğu veri kümesi öğrenme kümesi
olarak tanımlanır
 Model farklı biçimlerde ifade edilebilir
 IF – THEN – ELSE kuralları ile
 Karar ağaçları ile
 Matematiksel formüller ile
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 11
Sınıflandırma İşlemi: Model
Değerlendirme
2. Model Değerlendirme:
 Modelin başarımı (doğruluğu) sınama kümesi
örnekleri kullanılarak belirlenir
 Sınıf etiketi bilinen bir sınama kümesi örneği
model kullanılarak belirlenen sınıf etiketiyle
karşılaştırılır
 Modelin doğruluğu, doğru sınıflandırılmış
sınama kümesi örneklerinin toplam sınama
kümesi örneklerine oranı olarak belirlenir
 Sınama kümesi model öğrenirken kullanılmaz
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 12
Sınıflandırma İşlemi: Modeli
Kullanma
3. Modeli kullanma:
 Model daha önce görülmemiş örnekleri
sınıflandırmak için kullanılır
 Örneklerin sınıf etiketlerini tahmin etme
 Bir niteliğin değerini tahmin etme
3
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 13
Örnek
Model
Tid Nit1 Nit2 Nit3 Sınıf
1 1 Büyük 125K 0
2 0 Orta 100K 0
3 0 Küçük 70K 0
4 1 Orta 120K 0
5 0 Büyük 95K 1
6 0 Orta 60K 0
7 1 Büyük 220K 0
8 0 Küçük 85K 1
9 0 Orta 75K 0
10 0 Küçük 90K 1 10
Tid Nit1 Nit2 Nit3 Sınıf
11 0 Küçük 55K ?
12 1 Orta 80K ?
13 1 Büyük 110K ?
14 0 Küçük 95K ?
15 0 Büyük 67K ? 10
Sınama
Kümesi
Öğrenme
Algoritması
Öğrenme
Kümesi Uygulama
Öğrenme
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 14
Sınıflandırıcı Başarımını Değerlendirme
 Doğru sınıflandırma başarısı
 Hız
 modeli oluşturmak için gerekli süre
 sınıflandırma yapmak için gerekli süre
 Kararlı olması
 veri kümesinde gürülltülü ve eksik nitelik değerleri olduğu
durumlarda da iyi sonuç vermesi
 Ölçeklenebilirlik
 büyük miktarda veri kümesi ile çalışabilmesi
 Anlaşılabilir olması
 kullanıcı tarafından yorumlanabilir olması
 Kuralların yapısı
 birbiriyle örtüşmeyen kurallar
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 15
Konular
 Sınıflandırma işlemi
 Sınıflandırma tanımı
 Sınıflandırma uygulamaları
 Sınıflandırma yöntemleri
 Karar ağaçları
 Yapay sinir ağları
 Bayes sınıflandırıcılar
 Bayes ağları
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 16
Sınıflandırma Yöntemleri
 Karar ağaçları (decision trees)
 Yapay sinir ağları (artificial neural networks)
 Bayes sınıflandırıcılar (Bayes classifier)
 İlişki tabanlı sınıflandırıcılar (association-based
classifier)
 k-en yakın komşu yöntemi (k- nearest neighbor
method)
 Destek vektör makineleri (support vector machines)
 Genetik algoritmalar (genetic algorithms)
 ...
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 17
Konular
 Sınıflandırma işlemi
 Sınıflandırma tanımı
 Sınıflandırma uygulamaları
 Sınıflandırma yöntemleri
 Karar ağaçları
 Yapay sinir ağları
 Bayes sınıflandırıcılar
 Bayes ağları
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 18
Karar Ağaçları
 Akış diyagramı şeklinde ağaç yapısı
 Ara düğümler bir nitelik sınaması
 Dallar sınama sonucu
 Yapraklar sınıflar
Nit ?
Cl
Nit ?
Nit ? Nit ? Nit ?
Cl Cl Cl Cl Cl Cl
Cl
4
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 19
Örnek: Karar Ağacı
Day Outlook Temperature Humidity Wind Play ball
D1 Sunny Hot High Weak No
D2 Sunny Hot High Strong No
D3 Overcast Hot High Weak Yes
D4 Rain Mild High Weak Yes
D5 Rain Cool Normal Weak Yes
D6 Rain Cool Normal Strong No
D7 Overcast Cool Normal Strong Yes
D8 Sunny Mild High Weak No
D9 Sunny Cool Normal Weak Yes
D10 Rain Mild Normal Weak Yes
D11 Sunny Mild Normal Strong Yes
D12 Overcast Mild High Strong Yes
D13 Overcast Hot Normal Weak Yes
D14 Rain Mild High Strong No
 J. Ross Quinlan’ın
geliştirdiği ID3
modeline
uyarlanmış:
 hava tenis
oynamaya uygun
mu?
Hava durumu Verisi
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 20
Örnek: Karar Ağacı
Outlook?
overcast
humidity? wind?
high normal strong weak
sunny rain
no yes no yes
yes
Rain Hot Normal Weak ?
kök düğümden başlanır Outlook Temperature Humidity Wind Play ball
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 21
Örnek: Karar Ağacı
Outlook?
overcast
humidity? wind?
high normal strong weak
sunny rain
no yes no yes
yes
Rain Hot Normal Weak ?
Outlook Temperature Humidity Wind Play ball
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 22
Örnek: Karar Ağacı
Outlook?
overcast
humidity? wind?
high normal strong weak
sunny rain
no yes no yes
yes
Rain Hot Normal Weak ?
Outlook Temperature Humidity Wind Play ball
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 23
Örnek: Karar Ağacı
Outlook?
overcast
humidity? wind?
high normal strong weak
sunny rain
no yes no yes
yes
Rain Hot Normal Weak ?
Outlook Temperature Humidity Wind Play ball
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 24
Örnek: Karar Ağacı
Outlook?
overcast
humidity? wind?
high normal strong weak
sunny rain
no yes no yes
yes
Rain Hot Normal Weak ?
Outlook Temperature Humidity Wind Play ball
5
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 25
Örnek: Karar Ağacı
Outlook?
overcast
humidity? wind?
high normal strong weak
sunny rain
no yes no yes
yes
Rain Hot Normal Weak ?
Outlook Temperature Humidity Wind Play ball
Sınıf=Yes
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 26
Karar Ağacı Yöntemleri
 Karar ağacı oluşturma yöntemleri genel olarak
iki aşamadan oluşur:
1. ağaç oluşturma
 en başta bütün öğrenme kümesi örnekleri kökte
 seçilen niteliklere bağlı olarak örnek yinelemeli
olarak bölünüyor
2. ağaç budama
 öğrenme kümesindeki gürültülü verilerden oluşan
ve sınama kümesinde hataya neden olan dalları
silme (sınıflandırma başarımını artırır)
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 27
Karar Ağacı Oluşturma
 Yinelemeli işlem
 ağaç bütün verinin oluşturduğu tek bir düğümle
başlıyor
 eğer örnekleri hepsi aynı sınıfa aitse düğüm
yaprak olarak sonlanıyor ve sınıf etiketini alıyor
 eğer değilse örnekleri sınıflara en iyi bölecek
olan nitelik seçiliyor
 işlem sona eriyor
 örneklerin hepsi (çoğunluğu) aynı sınıfa ait
 örnekleri bölecek nitelik kalmamış
 kalan niteliklerin değerini taşıyan örnek yok
Cl
Nit?
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 28
Örnekleri En İyi Bölen Nitelik Hangisi?
 Bölmeden önce:
 10 örnek C0 sınıfında
 10 örnek C1 sınıfında
Hangisi daha iyi?
Own
Car?
C0: 6
C1: 4
C0: 4
C1: 6
C0: 1
C1: 3
C0: 8
C1: 0
C0: 1
C1: 7
Car
Type?
C0: 1
C1: 0
C0: 1
C1: 0
C0: 0
C1: 1
Student
ID?
...
Yes No Family
Sports
Luxury c1
c10
c20
C0: 0
C1: 1 ...
c11
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 29
En iyi Bölme Nasıl Belirlenir?
 “Greedy” yaklaşım
 çoğunlukla aynı sınıfa ait örneklerin bulunduğu
düğümler tercih edilir
 Düğümün kalitesini ölçmek için bir yöntem
kalitesi düşük kalitesi yüksek
C0: 5
C1: 5
C0: 9
C1: 1
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 30
En İyi Bölen Nitelik Nasıl Belirlenir?
 İyilik Fonksiyonu (Goodness Function)
 Farklı algoritmalar farklı iyilik fonksiyonları
kullanabilir:
 bilgi kazancı (information gain): ID3, C4.5
 bütün niteliklerin ayrık değerler aldığı varsayılıyor
 sürekli değişkenlere uygulamak için değişiklik
yapılabilir
 gini index (IBM IntelligentMiner)
 her nitelik ikiye bölünüyor
 her nitelik için olası bütün ikiyi bölünmeler sınanıyor
6
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 31
Bilgi Kazancı
sepetteki toplar farklı renklerde belirsizlik fazla
topların hepsi aynı renkte ise daha belirsizlik yok
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 32
Bilgi / Entropi
 p1, p2,.., ps toplamları 1 olan olasılıklar. Entropi
(Entropy)
 Entropi rastgeleliği, belirsizliği ve beklenmeyen
durumun ortaya çıkma olasılığını gösterir
 Sınıflandırmada
 olayın olması beklenen bir durum
 entropi=0
∑=
= −
s
i
H p p ps pi pi
1
1 2 ( , ,..., ) log( )
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 33
Entropi
 örnekler aynı sınıfa aitse entropi=0
 örnekler sınıflar arasında eşit dağılmışsa entropi=1
 örnekler sınıflar arasında rastgele dağılmışsa 0<entropi<1
log (p) H(p,1-p)
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 34
Örnek
 S veri kümesinde 14 örnek: C0 sınıfına ait 9, C1
sınıfına ait 5 örnek.
 Entropi
 H(p1,p2)= - (9/14) Log2 (9/14) - (5/14) Log2 (5/14)
= 0.940
∑=
= −
s
i
H p p ps pi pi
1
1 2 ( , ,..., ) log( )
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 35
Bilgi Kazancı (ID3 / C4.5)
 Bilgi kuramı kavramlarını kullanarak karar ağacı
oluşturulur. Sınıflandırma sonucu için en az sayıda
karşılaştırma yapmayı hedefler.
 Ağaç bir niteliğe göre dallandığında entropi ne kadar
düşer?
 A niteliğinin S veri kümesindeki bilgi kazancı
Values(A), A niteliğinin alabileceği değerler, Sv , A=v
olduğu durumda S’nin altkümesi.
( ) | |
| | ( , ) ( ) ( ) Values A v v Entropy S S
Sv Gain S A Entropy S ∑ ∈ = −
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 36
Örnek
 Bilgi kazancına göre nitelik seçme
toplam örnek sayısı s=14, iki sınıfa ayrılmış
s1=9(yes), s2=5(no)
Entropy(S) = - (9/14) Log2 (9/14) - (5/14) Log2 (5/14) = 0.940
wind için: weak=8, strong=6
weak: no=2, yes=6
strong: no=3, yes=3
Entropy(Sweak) = - (6/8)*log2(6/8) - (2/8)*log2(2/8) = 0.811
Entropy(Sstrong) = - (3/6)*log2(3/6) - (3/6)*log2(3/6) = 1.00
Entropywind(S) = (8/14)*0.811 + (6/14)*1.00
Gain(wind)=0.940 - (8/14)*0.811 - (6/14)*1.00
Day Outlook Temperature Humidity Wind Play ball
D1 Sunny Hot High Weak No
D2 Sunny Hot High Strong No
D3 Overcast Hot High Weak Yes
D4 Rain Mild High Weak Yes
D5 Rain Cool Normal Weak Yes
D6 Rain Cool Normal Strong No
D7 Overcast Cool Normal Strong Yes
D8 Sunny Mild High Weak No
D9 Sunny Cool Normal Weak Yes
D10 Rain Mild Normal Weak Yes
D11 Sunny Mild Normal Strong Yes
D12 Overcast Mild High Strong Yes
D13 Overcast Hot Normal Weak Yes
D14 Rain Mild High Strong No
Gain(Outlook) = 0.246
Gain(Humidity) = 0.151
Gain(wind)=0.048
Gain(Temperature) = 0.029
∑
∑
=
∈
= −
= −
s
i
s i i
Values A v v
H p p p p p
Entropy S S
Sv Gain S A Entropy S
1
1 2
( )
( , ,..., ) log( )
( ) | |
| | ( , ) ( )
7
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 37
Örnek
Outlook?
overcast
? ?
sunny rain
yes
{D1,D2,...,D14}
{D1,D2,D8,D9,D11}
[2+,3-
]
{D3,D7,D12,D13}
[4+,0-
]
{D4,D5,D6,D10,D14}
[3+,2-
]
Ssunny= {D1,D2,D8,D9,D11}, Entropy(Ssunny)=0.970
humidity için: high=3, normal=2
high: no=3, yes=0
normal: no=0, yes=2
Entropy(Shigh) = 0
Entropy(Snormal) = 0
Gain(Ssunny,Humidity)=0.970-(3/5)0.0- (3/5)0.0=0.970
Day Outlook Temperature Humidity Wind Play ball
D1 Sunny Hot High Weak No
D2 Sunny Hot High Strong No
D3 Overcast Hot High Weak Yes
D4 Rain Mild High Weak Yes
D5 Rain Cool Normal Weak Yes
D6 Rain Cool Normal Strong No
D7 Overcast Cool Normal Strong Yes
D8 Sunny Mild High Weak No
D9 Sunny Cool Normal Weak Yes
D10 Rain Mild Normal Weak Yes
D11 Sunny Mild Normal Strong Yes
D12 Overcast Mild High Strong Yes
D13 Overcast Hot Normal Weak Yes
D14 Rain Mild High Strong No http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 38
Gini Index (IBM InteligentMiner)
 Veri kümesi S içinde n sınıf varsa ve pj Cj sınıfının
olasılığı ise
 Eğer veri kümesi S1 ve S2 altkümelere bölünüyorsa ve
her altkümede sırasıyla N1 ve N2 örnek varsa:
 Gini Index değeri en küçük olan nitelik seçilir.
∑
=
= − n
j
p j gini S
1
2 ( ) 1
( ) ( ) ( )2 2 1 1 gini S N
N gini S N
N gini S split = +
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 39
Örnek
C1 0
C2 6
C1 2
C2 4
C1 1
C2 5
P(C1) = 0/6 = 0 P(C2) = 6/6 = 1
Gini = 1 – P(C1)2 – P(C2)2 = 1 – 0 – 1 = 0
= −∑j
GINI S pj
2 ( ) 1 [ ]
P(C1) = 1/6 P(C2) = 5/6
Gini = 1 – (1/6)2 – (5/6)2 = 0.278
P(C1) = 2/6 P(C2) = 4/6
Gini = 1 – (2/6)2 – (4/6)2 = 0.444
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 40
Sürekli Nitelikleri Bölme
 Bölmeleme:
 Statik: En başta bölmelenir
 Bölmeler eşit genişlik, eşit derinlik veya demetleme yöntemi ile
bulunur.
 Dinamik:
 Sürekli nitelik A sıralanır. Birbirini izleyen ancak sınıf etiketi farklı
olan nitelik değerleri bulunur. En fazla kazanç sağlayan bölme
seçilir.
Play tennis No No Yes Yes Yes No
Temperature 40 48 60 72 80 90
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 41
Ağaç Oluşturmada Temel Yaklaşımlar
 Bölme kriteri:
 ağacın bir düğümünde karşılaştırma yapılacak niteliğin
seçilmesi
 farklı algoritmalar farklı iyilik fonksiyonları kullanabilir:
bilgi kazancı, gini index,...
 Dallanma kriteri:
 bir örneğin hangi dala ait olduğunu belirleme
 ikiye dallanma (gini index), çoklu dallanma (bilgi kazancı)
 Durma kararı:
 dallanma işleminin devam edip etmeyeceğine karar verme
 Etiketleme kuralı:
 yaprak düğüm en çok örneği olan sınıfla etiketleniyor
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 42
Ağaç Oluşturma:
 Parçala ve çöz (divide and conquer)
 kökten yapraklara
 düğümü dallara ayır
 ‘Greedy’ algoritma
 her adımda en iyi çözümü bul: her düğümde dallanmak için
en iyi niteliği bul
 her dal için algoritmayı uygula
8
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 43
Örnek Algoritma: ID3
 Bütün nitelikler ayrık
 Bir düğüm oluştur N:
 Eğer örneklerin hepsi C sınıfına ait ise, N düğümü C etiketli yaprak
 Eğer karşılaştırma yapılacak nitelik yoksa N düğümü en çok örneği
olan sınıf
 En büyük bilgi kazancı olan niteliği bölmek için seç
 N’yi seçilen nitelik ile etiketle
 niteliğin her Ai değeri için bir dal oluştur
 Si
, örneklerin hepsinin Ai değeri aldığı dal
 Si boş bir yaprak oluşturup en çok örneği olan sınıfla etiketle
 Si boş değil algoritmayı Si düğümü üzerinde yinele
 Yaprak düğümlere kadar
Ayrıntılı bilgiler: http://dms.irb.hr/tutorial/tut_dtrees.php
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 44
Örnek Algoritma: C4.5
 Kökten yapraklara doğru ağaç oluşturma
 Bilgi kazancı yöntemini kullanıyor
 Bütün veri kümesini bellekte tutuyor
 Büyük veri kümeleri için uygun değil
http://www.rulequest.com/Personal/c4.5r8.tar.gz
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 45
Karar Ağacı Kullanarak Sınıflandırma
 Doğrudan
 sınıflandırmak istenilen örneğin nitelikleri ağaç boyunca
sınanır
 ulaşılan yaprağın etiketi sınıf bilgisini verir
 Dolaylı
 karar ağacı sınıflandırma kurallarına dönüştürülür
 kökten yaprakların herbirine giden yollar için ayrı bir
kural oluşturulur.
 IF-THEN şeklinde kuralları insanlar daha kolay anlıyor
 Örnek: IF Outlook=“sunny” AND humidity=“normal” THEN play
tennis
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 46
Karar Ağacı Kullanarak Sınıflandırma
 Avantajları:
 Karar ağacı oluşturmak zahmetsiz
 Küçük ağaçları yorumlamak kolay
 Anlaşılabilir kurallar oluşturulabilir
 Sürekli ve ayrık nitelik değerleri için kullanılabilir
 Dezavantajları:
 Sürekli nitelik değerlerini tahmin etmekte çok başarılı değil
 Sınıf sayısı fazla ve öğrenme kümesi örnekleri sayısı az olduğunda
model oluşturma çok başarılı değil
 Zaman ve yer karmaşıklığı öğrenme kümesi örnekleri sayısına (q),
nitelik sayısına (h) ve oluşan ağacın yapısına bağlı.
 Ağaç oluşturma karmaşıklığı fazla, ağaç budama karmaşıklığı fazla
 ağaç oluşturmak için zaman karmaşıklığı: O(h q logq)
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 47
Karar Ağaçlarında Aşırı Öğrenme
 Öğrenme kümesindeki
örneklerin azlığı veya
gürültülü olması
 Aşırı öğrenmeyi
engelleyen iki
yaklaşım
 işlemi erken sona
erdirme
 işlemi sona erdirmek
için eşik değeri
belirlemek gerekiyor
 karar ağacı
oluştuktan sonra
ağacı küçültme
Overfitting
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 48
Aşırı Öğrenme:Gürültülü Örnekler
Gürültülü örnekler nedeniyle sınıfları ayıran düzlemin bozulması
9
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 49
Aşırı Öğrenme: Yetersiz Öğrenme Kümesi
 Öğrenme kümesindeki örnek sayısının yetersiz
olması nedeniyle sınama kümesindeki
örneklerin yanlış sınıflandırılması
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 50
Aşırı Öğrenme
 Gereğinden fazla karmaşık karar ağaçları aşırı
öğrenmeye neden oluyor.
 Karar ağacının yeni örnekler üzerindeki
başarımını tahmin etmek için öğrenme kümesi
örnekleri yeterli olmuyor.
 Hatayı tahmin etmek için farklı yöntemler
gerekli.
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 51
Genel Hatayı Tahmin Etme
 Yerine koyma (Resubstitution) Hatası: öğrenme kümesi kullanılarak
hesaplanan hata (Σ e(t))
 Genel (Generalization) hata: sınama kümesi kullanılarak hesaplanan
hata (Σ e’(t))
 Genel hatayı tahmin etme yöntemleri:
 İyimser yaklaşım: e’(t) = e(t)
 Kötümser yaklaşım:
 Her yaprak düğüm için: e’(t) = (e(t)+0.5)
 Toplam hata: e’(T) = e(T) + N × 0.5 (N: yaprak düğüm sayısı)
 30 yaprak düğümü olan bir karar ağacı, 1000 öğrenme kümesi
örneğinden 10 örneği yanlış sınıflandırırsa
 Yerine koyma hatası: 10/1000 = %1
 Genel hata: (10 + 30×0.5)/1000 = % 2.5
 Ağaç budama: Genel hatayı tahmin etmek için geçerleme kümesi
kullanılır
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 52
Occam’s Razor
 Genel hatası aynı olan iki modelden
karmaşıklığı daha az olan seçilmeli
 Karmaşık modellerin veri içindeki gürültüyü
öğrenme ihtimalleri daha fazla
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 53
Karar Ağacı Boyutunu Belirleme
 Veri kümesi öğrenme ve sınama kümesi olarak
ayrılır
 Çapraz geçerleme kullanılır.
 Veri kümesinin tümü ağacı oluşturmak için
kullanılır
 istatistiksel bir test ile (chi-square) düğüm
eklemenin ya da ağacı küçültmenin katkısı
sınanır
 MDL (Minimum Description Length) yöntemi
kullanılır: kodlama en aza indirildiğinde ağacın
büyümesi durdurulur
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 54
Karar Ağacı: Erken Durdurma
 Karar ağacını tam oluşturmadan işlemi bitirme
 İşlemi sona erdirme için ek kurallar
 Örneklerin sayısı kullanıcı tarafından belirlenen bir
eşik değerinden daha az ise
 Örneklerin sınıf dağılımı niteliklerden bağımsız ise
(chi-square testi ile belirlenebilir)
 Ağaca yeni bir düğüm ekleyince iyilik fonksiyonu
yeterince artmıyorsa
10
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 55
Konular
 Sınıflandırma işlemi
 Sınıflandırma tanımı
 Sınıflandırma uygulamaları
 Sınıflandırma yöntemleri
 Karar ağaçları
 Yapay sinir ağları
 Bayes sınıflandırıcılar
 Bayes ağları
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 56
Yapay Sinir Ağları ile Sınıflandırma
 İnsan beynindeki sinir hücrelerinin işlevini
modelleyen bir yapı
 Birbiri ile bağlantılı katmanlardan oluşur.
 katmanlar hücrelerden oluşur
 Katmanlar arasında iletim
 İleti katmanlar arasındaki bağın ağırlığına ve
her hücrenin değerine bağlı olarak değişebilir
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 57
Örnek:
 En az iki giriş 1 ise çıkış 1, diğer durumlarda çıkış 0
X1 X2 X3 Y
1000
1011
1101
1111
0010
0100
0111
0000
X1
X2
X3
Y
Kara kutu
Çıkış
Giriş
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 58
Örnek
I(z)=
(0.3 0.3 0.3 0.4 0) Y = I X1 + X 2 + X 3 − >
1 eğer z>0
0 diğer
X1 X2 X3 Y
1000
1011
1101
1111
0010
0100
0111
0000
Σ
X1
X2
X3
Y
Kara kutu
0.3
0.3
0.3 t=0.4
Çıkış
nöronu
Giriş
nöronları
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 59
Yapay Sinir Ağları
 Birbiri ile bağlantılı
nöronlar ve ağırlıklar
 Çıkış nöronu kendisine
gelen girişleri ağırlıklı
olarak topluyor
 Çıkış nöronu bir eşik
değeri ile karşılaştırılıyor
Y I( w X t) i
= ∑ i i −
Y sign( w X t) i
= ∑ i i −
Σ
X1
X2
X3
Y
Kara kutu
w1
t
Çıkış
nöronu
Giriş
nöronları
w2
w3
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 60
Çok Katmanlı
 Yapay sinir ağını
öğrenme: ağırlıkları
öğrenme
Giriş
Katmanı
Gizli
Katman
Çıkış
Katmanı
x1 x2 x3 x4 x5
y
Aktivasyon
fonksiyonu
g(Si )
Si Oi
I
1
I
2
I
3
wi1
wi2
wi3
Oi
Giriş Nöron i Çıkış
eşik değeri, t
11
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 61
Yapay Sinir Ağı ile Öğrenme
 Yapay sinir ağı oluşturma
 giriş verisini modelleme
 gizli katman sayısını, gizli katmanlardaki nöron
sayısını belirleme
 Yapay sinir ağını eğitme
 Sinir ağını küçültme
 Sonucu yorumlama
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 62
Yapay Sinir Ağını Oluşturma
 Giriş nöron sayısı
 Öğrenme kümesindeki verilerin nitelik sayısı
 Gizli nöron sayısı
 öğrenme sırasında ayarlanır
 Çıkış nöron sayısı
 sınıf sayısı
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 63
Yapay Sinir Ağını Eğitme
 Amaç: Veri kümesindeki örneklerin hepsini doğru
sınıflandıracak ağırlıkları belirlemek
 ağırlıklara rasgele değerler ata
 öğrenme kümesindeki giriş değerlerini teker teker sinir
ağına uygula
 çıkışı hesapla
 hata değerini hesapla
 ağırlıkları hata fonksiyonunu enküçültecek şekilde düzelt
[ ]2
= ∑ − ( , ) i
i wi Xi E Y f
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 64
Yapay Sinir Ağını Küçültme
 Tam bağlı ağın anlaşılması çok güç
 n giriş nöron, h gizli nöron, m çıkış nöronu
h(m+n) ağırlık
 Küçültme: ağırlıklardan bazıları sınıflandırma
sonucunu etkilemeyecek şekilde silinir
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 65
Yapay Sinir Ağları
 Avantajları
 doğru sınıflandırma oranı genelde yüksek
 kararlı – öğrenme kümesinde hata olduğu
durumda da çalışıyor
 çıkış ayrık, sürekli ya da ayrık veya sürekli
değişkenlerden oluşan bir vektör olabilir
 Dezavantajları
 öğrenme süresi uzun
 öğrenilen fonksiyonun anlaşılması zor
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 66
Konular
 Sınıflandırma işlemi
 Sınıflandırma tanımı
 Sınıflandırma uygulamaları
 Sınıflandırma yöntemleri
 Karar ağaçları
 Yapay sinir ağları
 Bayes sınıflandırıcılar
 Bayes ağları
12
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 67
Bayes (İstatistiksel) Modelleme
 Bayes teoremini kullanan istatistiksel
sınıflandırıcı
 Örneklerin hangi sınıfa hangi olasılıkla ait
oldukları
 Naïve Bayes sınıflandırıcı
 niteliklerin hepsi aynı derecede önemli
 nitelikler birbirinden bağımsız
 bir niteliğin değeri başka bir nitelik değeri hakkında
bilgi içermiyor
 sınıflandırma ve öğrenme problemleri
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 68
Bayes Teoremi
 X sınıflandırılacak örnek. Hipotez h, X örneğinin C
sınıfına ait olduğu
 h hipotezinin sonrasal olasılığı (posteriori probability )
 MAP (maximum posteriori) hipotez
 Çok sayıda olasılığı önceden kestirmek gerekiyor
( )
( | ) ( ) ( | ) P X
P X h P h P h X =
argmax ( | ) argmaxP(D|h)P(h).
h H P h D MAP h H h ∈ = ∈ ≡
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 69
Örnek
 +
 P(H)=P( ) P(X)=P( + )
 P(X|H)= P( ise + )
H
X C
( )
( | ) ( ) ( | ) P X
P X h P h P h X =
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 70
Naïve Bayes Sınıflandırıcı
 X=(x1
,x2
,...xn) örneğinin C sınıfında olma olasılığı
(P(C|X)) nedir?
 değerini enbüyütme
P(X|Ci
)P(Ci
) değerini enbüyütme
 P(Ci
)=|Si
| / |S|, Si
: Ci sınıfına ait örneklerin sayısı
 , P(xk|Ci
)=sik / si
 Hesaplama maliyetini azaltıyor, sadece sınıf dağılımları
hesaplanıyor
 Naïve: nitelikler bağımsız
( )
( | ) ( )
P X
P X Ci P Ci
∏=
=
n
k
i k Ci P X C P x 1
( | ) ( | )
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 71
Hava Durumu Verisi için Olasılıklar
5/14
5
No
9/14
9
Yes
Play
3/5
2/5
3
2
No
3/9
6/9
3
6
Yes
True
False
True
False
Windy
1/5
4/5
1
4
Yes No Yes No Yes No
6/9
3/9
6
3
Normal
High
Normal
High
Humidity
1/5
2/5
2/5
1
2
2
3/9
4/9
2/9
3
4
2
Rainy 3/9 2/5 Cool
Mild
Hot
Cool
Mild
Hot
Temperature
Overcast 4/9 0/5
Sunny 2/9 3/5
Rainy 3 2
Overcast 4 0
Sunny 2 3
Outlook
Rainy Mild High True No
Overcast Hot Normal False Yes
Overcast Mild High True Yes
Sunny Mild Normal True Yes
Rainy Mild Normal False Yes
Sunny Cool Normal False Yes
Sunny Mild High False No
Overcast Cool Normal True Yes
Rainy Cool Normal True No
Rainy Cool Normal False Yes
Rainy Mild High False Yes
Overcast Hot High False Yes
Sunny Hot High True No
Sunny Hot High False No
Outlook Temp Humidity Windy Play
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 72
Hava Durumu Verisi için Olasılıklar
5/14
5
No
9/14
9
Yes
Play
3/5
2/5
3
2
No
3/9
6/9
3
6
Yes
True
False
True
False
Windy
1/5
4/5
1
4
Yes No Yes No Yes No
6/9
3/9
6
3
Normal
High
Normal
High
Humidity
1/5
2/5
2/5
1
2
2
3/9
4/9
2/9
3
4
2
Rainy 3/9 2/5 Cool
Mild
Hot
Cool
Mild
Hot
Temperature
Overcast 4/9 0/5
Sunny 2/9 3/5
Rainy 3 2
Overcast 4 0
Sunny 2 3
Outlook
 Yeni veri Sunny Cool High True ?
Outlook Temp. Humidity Windy Play
İki Sınıf için olasılık:
P(“yes”|X) = 2/9 × 3/9 × 3/9 × 3/9 × 9/14 = 0.0053
P(“no”|X) = 3/5 × 1/5 × 4/5 × 3/5 × 5/14 = 0.0206
Normalize edilmiş olasılıklar:
P(“yes”) = 0.0053 / (0.0053 + 0.0206) = 0.205
P(“no”) = 0.0206 / (0.0053 + 0.0206) = 0.795
( | ) ( | ) ( ) ( | ) ( ) 1
i
n
k
P Ci X = P X Ci × P Ci =∏P xk Ci × P C =
13
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 73
Sürekli Veriler için Olasılık
 Verinin normal dağılımdan
geldiği varsayılıyor.
 Her sınıf-nitelik çifti için bir
olasılık hesaplanıyor.
 Gelir için sınıf=-1
 ortalama=110
 varyans=2975
Tid Geri
Ödeme
Medeni
Durum
Gelir Dolan
dırıcı
1 Evet Bekar 125K -1
2 Hayır Evli 100K -1
3 Hayır Bekar 70K -1
4 Evet Evli 120K -1
5 Hayır Boşanmış 95K 1
6 Hayır Evli 60K -1
7 Evet Boşanmış 220K -1
8 Hayır Bekar 85K 1
9 Hayır Evli 75K -1
10 Hayır Bekar 90K 1 10
2
2
2
( )
2 2
1 ( | ) ij
Ai ij
ij
i j P A c e σ
μ
πσ
− −
=
0.0072
2 (54.54)
1 ( 120 | 1) 2(2975)
(120 110)
2
= − = =
− −
P Gelir e π
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 74
Örnek
X=(Geri Ödeme=“Hayır”,Medeni Durum=“Evli”,Gelir=120k)
P(Geri Ödeme=“Evet”|-1)=3/7
P(Geri Ödeme=“Hayır”|-1)=4/7
P(Geri Ödeme=“Evet”|1)=0
P(Geri Ödeme=“Hayır”|1)=1
P(Medeni Durum=“Evli”|-1)=4/7
P(Medeni Durum=“Bekar”|-1)=2/7
P(Medeni Durum=“Boşanmış”|-1)=1/7
P(Medeni Durum=“Evli”|1)=0
P(Medeni Durum=“Bekar”|1)=2/3
P(Medeni Durum=“Boşanmış”|1)=1/3
Gelir:
Sınıf=-1
ortalama=110
varyans=2975
Sınıf=1
ortalama=90
varyans=25
Tid Geri
Ödeme
Medeni
Durum
Gelir Dolan
dırıcı
1 Evet Bekar 125K -1
2 Hayır Evli 100K -1
3 Hayır Bekar 70K -1
4 Evet Evli 120K -1
5 Hayır Boşanmış 95K 1
6 Hayır Evli 60K -1
7 Evet Boşanmış 220K -1
8 Hayır Bekar 85K 1
9 Hayır Evli 75K -1
10 Hayır Bekar 90K 1 10
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 75
Örnek
 P(X|Sınıf=-1) =
P(Geri Ödeme=“Hayır”|Sınıf=-1)
× P(Medeni Durum=“Evli”|Sınıf=-1)
× P(Gelir=120K| Sınıf=-1)
= 4/7 × 4/7 × 0.0072 = 0.0024
 P(X|Sınıf=1) =
P(Geri Ödeme=“Hayır”|Sınıf=1)
× P(Medeni Durum=“Evli”| Sınıf=1)
× P(Gelir=120K| Sınıf=1)
= 1 × 0 × 1.2 × 10-9 = 0
P(X|-1)P(-1) > P(X|1)P(1)
P(-1|X) > P(1|X)
=> Sınıf = -1
X=(Geri Ödeme=“Hayır”,Medeni Durum=“Evli”,Gelir=120k)
P(Geri Ödeme=“Evet”|-1)=3/7
P(Geri Ödeme=“Hayır”|-1)=4/7
P(Geri Ödeme=“Evet”|1)=0
P(Geri Ödeme=“Hayır”|1)=1
P(Medeni Durum=“Evli”|-1)=4/7
P(Medeni Durum=“Bekar”|-1)=2/7
P(Medeni Durum=“Boşanmış”|-1)=1/7
P(Medeni Durum=“Evli”|1)=0
P(Medeni Durum=“Bekar”|1)=2/3
P(Medeni Durum=“Boşanmış”|1)=1/3
Gelir:
Sınıf=-1
ortalama=110
varyans=2975
Sınıf=1
ortalama=90
varyans=25
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 76
Olasılığın Sıfır Olması
 Her sınıfta bir niteliğin her değeri olmazsa
 koşullu olasılıklardan biri 0
 o sınıfa ait olma olasılığı 0
 Olasılıklar
N k
N Laplace : P A C
N
N Original : P A C
c
ic
i
c
ic
i
+
+ =
=
1 ( | )
( | )
k: nitelik sayısı
Toplamları 1 olmak zorunda
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 77
Bayes Sınıflandırıcılar
 Avantajları:
 gerçeklemesi kolay
 çoğu durumda iyi sonuçlar
 Dezavantajları
 varsayım: sınıf bilgisi verildiğinde nitelikler bağımsız
 gerçek hayatta değişkenler birbirine bağımlı
 değişkenler arası ilişki modellenemiyor
 Çözüm:
 Bayes ağları
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 78
Konular
 Sınıflandırma işlemi
 Sınıflandırma tanımı
 Sınıflandırma uygulamaları
 Sınıflandırma yöntemleri
 Karar ağaçları
 Yapay sinir ağları
 Bayes sınıflandırıcılar
 Bayes ağları
14
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 79
Bayes Ağları
 Niteliklerin altkümesinin birbiri ile bağımsız olduğunu
varsayıyor
 Yönlü çevrimsiz çizge (directed acyclic graph) ve
koşullu olasılık tablolarından oluşur
 Her değişken A için bir tablo var
 niteliğin ebeveynlerine olan koşullu olasılıkları
 düğümler: rasgele değişkenler
 ayrıtlar: olasılıklı bağlılık
 X ve Y , Z değişkeninin ebeveyni
 Y, P değişkeninin ebeveyni
 Z ve P arasında bağ yok
X Y
Z
P
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 80
Örnek
Family
History
LungCancer
PositiveXRay
Smoker
Emphysema
Dyspnea
LC
~LC
(FH, S) (FH, ~S)(~FH, S) (~FH, ~S)
0.8
0.2
0.5
0.5
0.7
0.3
0.1
0.9
Bayes Ağları
LungCancer için koşullu olasılık tablosu
P(LC=“yes”|FH=“yes”, S=“yes”)=0.8
P(LC=“no”| FH=“no”, S=“no”)=0.9
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195 81
Bayes Ağlarının Eğitilmesi
 Ağ yapısı ve tüm değişkenler biliniyorsa koşullu
olasılıklar hesaplanır
 Ağ yapısı belli ancak bazı değişkenler eksik ise
yinelemeli öğrenme uygulanır
 gradient descent algoritması
 D. Heckerman. A Tutorial on Learning with Bayesian
Networks. In Learning in Graphical Models, M. Jordan,
ed.. MIT Press, Cambridge, MA, 1999. Also appears
as Technical Report MSR-TR-95-06, Microsoft
Research, March, 1995.
1
1
VERİ MADENCİLİĞİ
Farklı Sınıflandırma Yöntemleri
Yrd. Doç. Dr. Şule Gündüz Öğüdücü
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 2
Konular
 Sınıflandırma yöntemleri
 Örnek tabanlı yöntemler
 k-En Yakın Komşu Yöntemi
 Genetik Algoritmalar
 Destek Vektör Makineleri
 Bulanık Küme Sınıflandırıcılar
 Öngörü
 Eğri Uydurma
 Model Değerlendirme
 Öğrenme, sınama, geçerleme kümelerini oluşturma
 Sınıflandırıcıları birleştirme
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 3
Örnek Tabanlı Yöntemler
 Örnek tabanlı sınıflandırma:
 Öğrenme kümesi saklanır
 Sınıflandırılacak yeni bir örnek geldiğinde
öğrenme kümesi sınıf etiketini öngörmek için
kullanılır (tembel (lazy) yöntemler)
 Yöntemler
 k-en yakın komşu yöntemi
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 4
Örnek Tabanlı Yöntemler
Nit1 ……... NitN Sınıf
A
B
B
C
A
C
B
Öğrenme Kümesi
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 5
En Yakın Komşu Yöntemi
 Temel yaklaşım: Sınıflandırılmak istenen örneğe en yakın örnekleri
bul.
Örnek: ördek gibi yürüyor, ördek gibi bağırıyor
=> büyük olasılıkla ördek
Öğrenme
Örnekleri
Sınama
Örneği
Uzaklık
hesapla
en yakın k adet
örnek seç
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 6
En Yakın Komşu Sınıflandırıcı
 Bütün örnekler n-boyutlu uzayda
bir noktaya karşı düşürülür
 Nesneler arasındaki uzaklık
(Öklid uzaklığı)
 Öğrenilen fonksiyon ayrık değerli
veya gerçel değerli olabilir
 Ayrık değerli fonksiyonlarda kkomşu algoritması Xq örneğine
en yakın k öğrenme örneğinde
en çok görülen sınıf değerini
verir
 Sürekli değerli fonksiyonlarda en
yakın k öğrenme örneğinin
ortalaması alınır
2
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 7
K-En Yakın Komşu Yöntemi
 Xq örneği 1-en yakın
komşuya göre pozitif
olarak, 5-en yakın
komşuya göre negatif
olarak sınıflandırılır
.
_
+
_ xq
+
_ _
+
_
_
+
.
. .
. .
 Voronoi diyagramları:
Her öğrenme örneğini
çevreleyen dışbükey
çokgenlerden oluşan
karar yüzeyi
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 8
K-En Yakın Komşu Yöntemi
 Uzaklık-ağırlıklı k-en yakın komşu algoritması
 Öğrenme kümesindeki örneklere (xi
), sınıflandırılmak
istenen örneğe (xq) olan uzaklıklarına göre ağırlıklar
verilmesi
 yakın örneklerin ağırlığı daha fazla
 k-en yakın komşunun ortalaması alındığı için gürültülü
veriden az etkileniyor
 İlgisiz nitelikler uzaklığı etkileyebilir
 bu nitelikler uzaklık hesaplarken kullanılmayabilir
w d xq x
i
≡ 1 2 ( ,)
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 9
Konular
 Sınıflandırma yöntemleri
 Örnek tabanlı yöntemler
 k-En Yakın Komşu Yöntemi
 Genetik Algoritmalar
 Destek Vektör Makineleri
 Bulanık Küme Sınıflandırıcılar
 Öngörü
 Eğri Uydurma
 Model Değerlendirme
 Öğrenme, sınama, geçerleme kümelerini oluşturma
 Sınıflandırıcıları birleştirme
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 10
Genetik Algoritmalar
 Optimizasyon amaçlı
 Bir başlangıç çözümü öneriyor, tekrarlanan her ara
adımda daha iyi çözüm üretmeye çalışıyor.
 Doğal evrime ve en iyi olanın yaşamını sürdürmesine
dayanıyor
 Çözümü birey olarak sunuyor.
 Birey: I=I1,I2,…,In – Ij kullanılan alfabenin bir karakteri
 gen: Ij
 Toplum: Bireylerden oluşan küme
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 11
Genetik Algoritmalar
 Genetik Algoritmalar (GA) 5 parçadan oluşuyor:
 Bireylerden oluşan bir başlangıç kümesi, P
 Çaprazlama (Crossover): Bir anne babadan yeni
bireyler üretmek için yapılan işlem
 Mutasyon: Bir bireyi rastgele değiştirme
 Uygunluk (fitness): En iyi bireyleri belirleme
 Çaprazlama ve mutasyon tekniklerini uygulayan
ve uygunluk fonksiyonuna göre toplum içindeki
en iyi bireyleri seçen algoritma
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 12
Çaprazlama Örnekleri
111 111
000 000
Parents Children
111 000
000 111
a) Single Crossover
111 111
Parents Children
111 000
000
a) Single Crossover
111 111
000 000
Parents
a) Multiple Crossover
000
Children
111 000
00 000 111
11
00
11
3
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 13
Genetik Algoritma
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 14
GA – Avantajlar, Dezavantajlar
 Avantaj
 Paralel çalışabilir
 NP karmaşık problem çözümlerine uygun
 Dezavantaj
 Son kullanıcının modeli anlaması güç
 Problemi GA ile çözmeye uygun hale getirmek
zor
 Uygunluk fonksiyonunu belirlemek zor
 Çaprazlama ve mutasyon tekniklerini belirlemek
zor
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 15
Konular
 Sınıflandırma yöntemleri
 Örnek tabanlı yöntemler
 k-En Yakın Komşu Yöntemi
 Genetik Algoritmalar
 Destek Vektör Makineleri
 Bulanık Küme Sınıflandırıcılar
 Öngörü
 Eğri Uydurma
 Model Değerlendirme
 Öğrenme, sınama, geçerleme kümelerini oluşturma
 Sınıflandırıcıları birleştirme
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 16
Destek Vektör Makineleri
 Hem doğrusal olarak ayırt edilebilen hem de
edilemeyen veri kümesini sınıflandırabilir
 Doğrusal olmayan bir eşlem ile n boyutlu veri kümesi
m > n olacak şekilde m boyutlu yeni bir veri kümesine
dönüştürülür
 Yüksek boyutta doğrusal sınıflandırma işlemi yapılır
 Uygun bir dönüşüm ile her zaman veri bir hiper düzlem
ile iki sınıfa ayrılabilir
 Hiper düzleme en yakın öğrenme verileri destek
vektörleri olarak adlandırılır
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 17
Destek Vektör Makineleri
 Destek Vektör Makineleri (Support Vector Machines
SVM): Veriyi ayıracak doğrusal bir sınır
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 18
Destek Vektör Makineleri
 Bir çözüm
B1
4
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 19
Destek Vektör Makineleri
 Başka bir çözüm
B2
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 20
Destek Vektör Makineleri
 Diğer çözümler
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 21
Destek Vektör Makineleri
 Hangisi daha iyi? B1 mi, B2 mi?
 Daha iyi nasıl tanımlanır?
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 22
Destek Vektör Makineleri
 Farklı sınıftan örnekler arasındaki uzaklığı enbüyüten hiper
düzlemi bul => B1, B2’den daha iyi
B1
B2
b11
b12
b21
b22
margin
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 23
Destek Vektör Makineleri
(w·x1)+b=yi
=+1
(w·x2)+b=yi
=-1
=>w·(x1-x2)=2
=> w · (x1-x2)= 2
||w|| ||w||
w• x + b = −1 r r
w• x + b = +1 r r
w• x + b = 0 r r
yi
=+1
yi
=-1
x2
x1
.
w
(w·x) + b ≥ +1, yi
=+1
(w·x) + b ≤ -1, yi
=-1
=>yi
(w·x + b) ≥ +1
H H2
H1
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 24
Destek Vektör Makineleri
 enbüyük olması isteniyor
 yi
(w·x + b) ≥ +1 olacak şekilde enküçük olmalı
 kısıtlı eniyileme (constraint optimization) problem
 Problem
2
||w||2
||w||2
2
∑ [ ] =
= − ⋅ + −
N
i
Lp w i yi i b 1
2
( ) 1
2
1 α w x
α1…αN bulunması
Σαi - ½ΣΣαi
αj
yi
yj
xi
Txj en büyük olacak
kısıtlar:
(1) Σαi
yi = 0
(2) αi ≥ 0, ∀αi
5
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 25
Eniyileme Problemi Çözümü
 Çözüm
 Sınıflandırma fonksiyonu
 f(x) = 1 ise x pozitif olarak, diğer durumlarda
negatif olarak sınıflandırılıyor.
w =Σαi
yi
xi b= yk- wTxk ∀ xk , αk≠ 0
f(x) = Σαi
yi
xi
Tx + b
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 26
Destek Vektör Makineleri
 Öğrenme kümesi doğrusal olarak ayrılamıyor
 ξi değişkenleri ekleniyor
ξi
ξi
(w·x) + b ≥ +1- ξi
, yi
=+1
(w·x) + b ≤ -1- ξi
, yi
=-1
=>yi
(w·x + b) ≥ +1- ξi
ξi ≥ 0, ∀i
 Problem:
α1…αN bulunması
Σαi - ½ΣΣαi
αj
yi
yj
xi
Txj en büyük olacak
kısıtlar:
(1) Σαi
yi = 0
(2) 0 ≤ αi ≤ C, ∀αi
k N
i
Lp w C i ⎟
⎠
⎞ ⎜
⎝
⎛ = − ∑=1
2
2
1 ξ
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 27
Eniyileme Problemi Çözümü
 Çözüm
 Sınıflandırma fonksiyonu
w =Σαi
yi
xi
b= yk(1- ξk) – wTxk, k = argmax αk
f(x) = Σαi
yi
xi
Tx + b
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 28
DVM Uygulamaları
 Boser, Guyon ve Vapnik tarafından 1992 yılında
önerildi. 1990’ların sonlarına doğru yaygın
olarak kullanılmaya başlandı
 DVM için en yaygın eniyileme algoritmaları SMO
[Platt ’99] ve SVMlight [Joachims’ 99]
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 29
Konular
 Sınıflandırma yöntemleri
 Örnek tabanlı yöntemler
 k-En Yakın Komşu Yöntemi
 Genetik Algoritmalar
 Destek Vektör Makineleri
 Bulanık Küme Sınıflandırıcılar
 Öngörü
 Eğri Uydurma
 Model Değerlendirme
 Öğrenme, sınama, geçerleme kümelerini oluşturma
 Sınıflandırıcıları birleştirme
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 30
Bulanık Küme
Sınıflandırıcılar
 Bulanık mantık 0.0 ve 1.0 arasında gerçel
değerler kullanarak üyelik dereceleri hesaplar
 Nitelik değerleri bulanık değerlere
dönüştürülür
 Kurallar kümesi oluşturulur
 Yeni bir örneği sınıflandırmak için birden fazla
kural kullanılır
 Her kuraldan gelen sonuç toplanır
6
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 31
Konular
 Sınıflandırma yöntemleri
 Örnek tabanlı yöntemler
 k-En Yakın Komşu Yöntemi
 Genetik Algoritmalar
 Destek Vektör Makineleri
 Bulanık Küme Sınıflandırıcılar
 Öngörü
 Eğri Uydurma
 Model Değerlendirme
 Öğrenme, sınama, geçerleme kümelerini oluşturma
 Sınıflandırıcıları birleştirme
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 32
Öngörü
 Sınıflandırma problemleriyle aynı yaklaşım
 model oluştur
 bilinmeyen değeri hesaplamak için modeli kullan
 eğri uydurma
 doğrusal
 doğrusal olmayan
 Sınıflandırma ayrık değerli
 Öngörü sürekli değerli
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 33
Eğri Uydurma
 Doğrusal eğri uydurma:
 en basit eğri uydurma yöntemi
 veri doğrusal bir eğri ile modellenir.
 veri kümesindeki niteliklerin doğrusal fonksiyonu
 öğrenme kümesindeki yi sınıfından bir xi örneği için çıkış
 karesel hatayı enküçültecek ağırlıkları bulma
k k y = w + w a + w a +...+ w a 0 1 1 2 2
∑=
= + + + + =
k
j
i i i k ik j ij y w x w x w x w x w x 0
0 0 1 1 2 2 ...
2
1 0
∑ ∑ = = ⎟
⎟
⎠
⎞
⎜
⎜
⎝
⎛ −
n
i
k
j
i j ij y w x
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 34
Konular
 Sınıflandırma yöntemleri
 Model Değerlendirme
 Hata oranı
 Anma
 Kesinlik
 F-ölçütü
 ROC eğrileri
 Öğrenme, sınama, geçerleme kümelerini oluşturma
 Sınıflandırıcıları birleştirme
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 35
Sınıflandırma Modelini Değerlendirme
 Model başarımını değerlendirme ölçütleri
nelerdir?
 Hata oranı
 Anma
 Kesinlik
 F-ölçütü
 Farklı modellerin başarımı nasıl karşılaştırılır?
 ROC
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 36
Sınıflandırma Hatası
 Sınıflandırma yöntemlerinin hatalarını ölçme
 başarı: örnek doğru sınıfa atandı
 hata: örnek yanlış sınıfa atandı
 hata oranı: hata sayısının toplam örnek sayısına
bölünmesi
 Hata oranı sınama kümesi kullanılarak
hesaplanır
7
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 37
Model Başarımını Değerlendirme
 Model başarımını değerlendirme ölçütleri
 modelin ne kadar doğru sınıflandırma yaptığını ölçer
 hız, ölçeklenebilirlik gibi özellikleri değerlendirmez
 Karışıklık matrisi:
Sınıf =-1 c d
Sınıf =1 a b
Sınıf=1 Sınıf=-1
DOĞRU
SINIF
ÖNGÖRÜLEN SINIF
a: TP (true positive)
b: FN (false negative)
c: FP (false positive)
d: TN (true negative)
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 38
Model Başarımını Değerlendirme: Doğruluk
 Modelin başarımı:
d
(TN)
c
(FP)
-1
b
(FN)
a
(TP)
+1
+1 -1
DOĞRU
SINIF
ÖNGÖRÜLEN SINIF
TP TN FP FN
FN FP
a b c d
b c Hata Orani
TP TN FP FN
TP TN
a b c d
a d Dogruluk
+ + +
+ = + + +
+ =
+ + +
+ = + + +
+ =
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 39
Örnek
 Hangi sınıflandırıcı daha iyi?
 B ve C, A’dan daha iyi bir sınıflandırıcı
 B, C’den daha iyi bir sınıflandırıcı mı?
FP=25 TN=25
TP=25 FN=25
Sınıflandırıcı A
FP=25 TN=25
TP=50 FN=0
Sınıflandırıcı B
FP=0 TN=50
TP=25 FN=25
Sınıflandırıcı C
Doğruluk=%50 Doğruluk=%75 Doğruluk=%75
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 40
Model Başarımını Değerlendirme: Kesinlik
d
(TN)
c
(FP)
-1
b
(FN)
a
(TP)
+1
+1 -1
DOĞRU
SINIF
ÖNGÖRÜLEN SINIF
Kesinlik =
Doğru sınıflandırılmış pozitif örnek sayısı
Pozitif sınıflandırılmış örneklerin sayısı
= TP
TP + FP
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 41
Model Başarımını Değerlendirme: Anma
d
(TN)
c
(FP)
-1
b
(FN)
a
(TP)
+1
+1 -1
DOĞRU
SINIF
ÖNGÖRÜLEN SINIF
Anma =
Doğru sınıflandırılmış pozitif örnek sayısı
Pozitif örneklerin sayısı
= TP
TP + FN
Doğru pozitif oranı
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 42
Anma / Kesinlik
 A modeli B modelinden daha iyi anma ve
kesinlik değerine sahipse A modeli daha iyi bir
sınıflandırıcıdır.
 Kesinlik ve anma arasında ters orantı var.
kesinlik
anma
8
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 43
Sınıflandırıcıları Karşılaştırma
 Doğruluk en basit ölçüt
 Kesinlik ve anma daha iyi ölçme sağlıyor
 Model A’nın kesinliği model B’den daha iyi ancak
model B’nin anma değeri model A’dan daha iyi
olabilir.
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 44
Model Başarımını Değerlendirme: F-ölçütü
 F-ölçütü: Anma ve kesinliğin harmonik
ortalamasını alır.
F-ölçütü =
2 * kesinlik * anma
kesinlik + anma
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 45
ROC (Receiver Operating Characteristic)
 İşaret işlemede bir sezicinin, gürültülü bir kanalda
doğru algılama oranının yanlış alarm oranına karşı
çizdirilen grafiği (algılayıcı işletim eğrisi)
 Farklı sınıflandırıcıları karşılaştırmak için ROC eğrileri
 Doğru pozitif (TPR - y ekseni) oranının yanlış pozitif
(FPR – x ekseni) oranına karşı çizdirilen grafiği
 TPR = TP / (TP + FN)
 FPR = FP / (TN + FP)
 ROC üzerindeki her nokta bir sınıflandırıcının
oluşturduğu bir modele karşı düşer
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 46
ROC Eğrisi
 iki sınıftan oluşan tek boyutlu bir veri kümesi (positive – negative)
 x > t için her örnek pozitif olarak sınıflandırılıyor
t eşik değeri için:
TPR=0.5, FNR=0.5, FPR=0.12, FNR=0.88
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 47
ROC Eğrisi
(FPR,TPR)
 (0,0): Bütün örneklerin
negatif sınıflandırılması
 (1,1): Bütün örneklerin
pozitif sınıflandırılması
 (0,1): ideal durum
 Çapraz çizgi:
 Rastlantısal tahmin
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 48
ROC Eğrilerinin Kullanılması
 Farklı modelleri
karşılaştırmak için
 M1 veya M2 birbirlerine
üstünlük sağlamıyor
 küçük FPR değerleri için
M1 daha iyi
 büyük FPR değerleri için
M2 daha iyi
 ROC eğrisi altında kalan
alan
 ideal = 1
 Rastlantısal tahmin=0.5
9
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 49
ROC Eğrisinin Çizilmesi
 Her örnek için P(+|A)
olasılığı hesaplanır
 P(+|A) değeri azalarak
sıralanır
 Her farklı P(+|A) değeri
için bir eşik değeri
uygulanır
 Her eşik değeri için TP,
FP, TN, FN hesaplanır
10 0.25 +
9 0.43 -
8 0.53 +
7 0.76 -
6 0.85 +
5 0.85 -
4 0.85 -
3 0.87 -
2 0.93 +
1 0.95 +
Örnek P(+|A) Sınıf
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 50
ROC Eğrisinin Çizilmesi Class + - + - - - + - + +
0.25 0.43 0.53 0.76 0.85 0.85 0.85 0.87 0.93 0.95 1.00
TP 5 4 4 3 3 3 3 2 2 1 0
FP 5 5 4 4 3 2 1 1 0 0 0
TN 0 0 1 1 2 3 4 4 5 5 5
FN 0 1 1 2 2 2 2 3 3 4 5
TPR 1 0.8 0.8 0.6 0.6 0.6 0.6 0.4 0.4 0.2 0
FPR 1 1 0.8 0.8 0.6 0.4 0.2 0.2 0 0 0
ROC Eğrisi:
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 51
Model Parametrelerini Belirleme
 Sınama kümesi sınıflandırıcı oluşturmak için kullanılmaz
 Bazı sınıflandırıcılar modeli iki aşamada oluşturur
 modeli oluştur
 parametreleri ayarla
 Sınama kümesi parametreleri ayarlamak için
kullanılmaz
 Uygun yöntem üç veri kümesi kullanma: öğrenme,
geçerleme, sınama
 geçerleme kümesi parametre ayarlamaları için kullanılır
 model oluşturulduktan sonra öğrenme ve geçerleme
kümesi son modeli oluşturmak için kullanılabilir
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 52
Sınıflandırma: Öğrenme, Geçerleme, Sınama
Veri
Sınıflandırma
Y N
Sınıflar
Öğrenme kümesi
Geçerleme Kümesi
+
+
-
-
+
Model Oluşturma
Değerlendirme
+
-
+
-
S Son model ınama Kümesi
+
-
+
-
hata oranı
Model
Oluşturma
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 53
Model Başarımını Tahmin Etme
 Örnek: Doğruluğu %25 olan bir modelin gerçek
başarımı ne kadardır?
 Sınama kümesinin büyüklüğüne bağlı
 Sınıflandırma (hileli) yazı tura atmaya benziyor
 tura doğru sınıflandırma (başarı), yazı yanlış
sınıflandırma (başarısızlık)
 İstatistikte birbirinden bağımsız olayların başarı ya da
başarısızlıkla sonuçlanmaları Bernoulli dağılımı ile
modellenir.
 Gerçek başarı oranını belirlemek için istatistikte güven
aralıkları tanımlanmıştır.
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 54
Güven Aralığı
 p belli bir güvenle belli bir aralıkta bulunmaktadır.
 Örnek: N=1000 olayda S=750 başarı sağlanmış.
 Tahmin edilen başarı oranı: 75%
 Gerçek başarıya ne kadar yakın
 %80 güven ile p∈[73,2 - 76,7]
 Örnek: N=100 olayda S=75 başarı sağlanmış.
 Tahmin edilen başarı oranı: 75%
 Gerçek başarıya ne kadar yakın
 %80 güven ile p∈[69,1 - 80,1]
10
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 55
Ortalama Değer ve Varyans
 Başarı oranı p olan bir Bernoulli dağılımının ortalama
değeri ve varyansı: p, p (1–p)
 N kere tekrarlanan bir deneyin beklenen başarı oranı
f=S/N
 Büyük N değerleri için, f normal dağılım
 f için ortalama değer ve varyans: p, p (1–p)/N
 Ortalama değeri 0 ve varyansı 1 olan X rastlantı
değişkeninin %c güven aralığı :
Pr[–z ≤ X ≤ z]=c
 Simetrik bir dağılım için:
Pr[–z ≤ X ≤ z]=1 – 2*Pr [X ≥ z]
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 56
Güven Sınırları
 Ortalama değeri 0 ve varyansı 1 olan bir normal
dağılımın güven sınırları
 Pr[–1,65 ≤ X ≤ 1,65]=90%
 f’in ortalama değerinin 0, varyansının 1 olacak şekilde
dönüştürülmesi gerekir.
40% 0.25
20% 0.84
10% 1.28
5% 1.65
2.33
2.58
3.09
z
1%
0.5%
0.1%
Pr[X ≥ z]
–1 0 1 1.65
–1 0 1 1.65
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 57
Dönüşüm
 f’in ortalama değerinin 0, varyansının 1 olacak şekilde
dönüştürülmesi için
 Güven aralığı
 p’nin değeri
p p N
f p
(1− )/
−
z c p p N
f p z =⎥
⎦
⎤ ⎢
⎣
⎡ ≤ −
− − ≤
(1 )/
Pr
⎟
⎠
⎞ ⎜
⎝
⎛ + ⎟
⎟
⎠
⎞
⎜
⎜
⎝
⎛ = + ± − + N
z
N
z
N
f
N
f z N
z p f
2
2
2 2 2
1
2 4
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 58
Örnek
 f = 75%, N = 1000, c = 80% (z = 1.28):
p ∈ [0,732 – 0,767]
 f = 75%, N = 100, c = 80% (z = 1.28):
p ∈ [0,691 – 0,801]
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 59
Konular
 Sınıflandırma yöntemleri
 Model Değerlendirme
 Öğrenme, sınama, geçerleme kümelerini
oluşturma
 holdout
 k-kat çapraz geçerleme
 Bootstrap
 Sınıflandırıcıları birleştirme
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 60
Verinin Dengesiz Dağılımı
 Küçük veya dengesiz veri kümeleri için örnekler
tanımlayıcı olmayabilir
 Veri içinde bazı sınıflardan çok az örnek olabilir
 tıbbi veriler: %90 sağlıklı, %10 hastalık
 elektronik ticaret: %99 alışveriş yapmamış, %1 alışveriş
yapmış
 güvenlik: %99 sahtekarlık yapmamış, %1 sahtekarlık
yapmış
 Örnek: Sınıf1: 9990 örnek, Sınıf2: 10 örnek
 bütün örnekleri sınıf1’e atayan bir sınıflandırıcının hata
oranı: 9990 / 10000= %99,9
 hata oranı yanıltıcı bir ölçüt olabilir
11
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 61
Dengeli Dağılım Nasıl Sağlanır?
 Veri kümesinde iki sınıf varsa
 iki sınıfın eşit dağıldığı bir veri kümesi oluştur
 Az örneği olan sınıftan istenen sayıda rasgele
örnekler seç
 Çok örneği olan sınıftan aynı sayıda örnekleri
ekle
 Veri kümesinde iki sınıftan fazla sınıf varsa
 Öğrenme ve sınama kümesini farklı sınıflardan
aynı sayıda örnek olacak şekilde oluştur
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 62
Örnek
¾ holdout
¾ repeated holdout
¾ k-fold cross validation
¾ bootstrapping
Model
Tid Nit1 Nit2 Nit3 Sınıf
1 1 Büyük 125K 0
2 0 Orta 100K 0
3 0 Küçük 70K 0
4 1 Orta 120K 0
5 0 Büyük 95K 1
6 0 Orta 60K 0
7 1 Büyük 220K 0
8 0 Küçük 85K 1
9 0 Orta 75K 0
10 0 Küçük 90K 1 10
Tid Nit1 Nit2 Nit3 Sınıf
11 0 Küçük 55K ?
12 1 Orta 80K ?
13 1 Büyük 110K ?
14 0 Küçük 95K ?
15 0 Büyük 67K ? 10
Sınama
Kümesi
Öğrenme
Algoritması
Öğrenme
Kümesi Uygulama
Öğrenme
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 63
Büyük Veri Kümelerinde Değerlendirme
 Veri dağılımı dengeli ise: Veri kümesindeki
örnek sayısı ve her sınıfa ait örnek sayısı fazla
ise basit bir değerlendirme yeterli
 holdout yöntemi: Belli sayıda örnek sınama için
ayrılır, geriye kalan örnekler öğrenme için
kullanılır
 genelde veri kümesinin 2/3’ü öğrenme, 1/3’i sınama
kümesi olarak ayrılır
 öğrenme kümesi kullanılarak model oluşturulur
ve sınama kümesi kullanılarak model
değerlendirilir
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 64
Tekrarlı Holdout Yöntemini
 Veri kümesini farklı altkümelere bölerek holdout
yöntemini tekrarlama
 Her eğitme işleminde veri kümesinin belli bir
bölümü öğrenme kümesi olarak rasgele ayrılır
 Modelin hata oranı, işlemler sonunda elde edilen
modellerin hata oranlarının ortalaması
 Problem: Farklı eğitme işlemlerindeki sınama
kümeleri örtüşebilir
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 65
k-Kat Çapraz Geçerleme
 Veri kümesi eşit boyutta k adet farklı gruba ayrılır.
 Bir grup sınama, diğerleri öğrenme için ayrılır.
 Her grup bir kere sınama kümesi olacak şekilde
deneyler k kere tekrarlanır.
Sınama
Kümesi
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 66
Biri Hariç Çapraz Geçerleme
 k-kat çapraz geçerlemenin özel hali
 k sayısı veri kümesindeki örnek sayısına (N) eşit
 Model N-1 örnek üzerinde eğitilir, dışarıda bırakılan 1
örnek üzerinde sınanır
 Bu işlem her örnek 1 kez sınama için kullanılacak
şekilde tekrarlanır
 model N kez eğitilir
 Model başarımı denemelerin başarımının ortalaması
 Verinin en etkin şekilde kullanımı
12
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 67
Bootstrap Yöntemi
 Veri kümesinden yerine koyma yöntemi ile örnekler
seçilerek öğrenme kümesi oluşturulur
 N örnekten oluşan veri kümesinden yerine koyarak N
örnek seçilir
 Bu küme öğrenme kümesi olarak kullanılır
 Öğrenme kümesinde yer almayan örnekler sınama kümesi olarak kullanılır
Örnek 1
Örnek 2
Örnek 3
Örnek 4
Örnek 5
Örnek 1
Örnek 1
Örnek 3
Örnek 3
Örnek 5
Örnek 2
Örnek 4
Veri Öğrenme Kümesi(1)
Sınama Kümesi(1)
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 68
0.632 bootstrap
 N örnekten oluşan bir veri kümesinde bir örneğin
seçilmeme olasılığı:
 Sınama kümesinde yer alma olasılığı:
 Öğrenme kümesi veri kümesindeki örneklerin
%63,2’sinden oluşuyor
N
1 1−
0.368 1 1 1 ⎟ ≈ = ⎠
⎞ ⎜
⎝
⎛ − − e N
N
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 69
Bootstrap Yönteminde Model Hatasını
Belirleme
 Model başarımını sadece sınama kümesi kullanarak
belirleme kötümser bir yaklaşım
 model örneklerin sadece ~%63’lük bölümüyle eğitiliyor
 Model başarımı hem öğrenme kümesindeki hem de
sınama kümesindeki başarım ile değerlendirilir
hata = 0,632 hata(sınama) + 0,368 hata(öğrenme)
 İşlem birkaç kez tekrarlanarak hatanın ortalaması
alınır.
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 70
Konular
 Sınıflandırma yöntemleri
 Model Değerlendirme
 Öğrenme, sınama, geçerleme kümelerini
oluşturma
 Sınıflandırıcıları birleştirme
 Bagging
 Boosting
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 71
Model Başarımını Artırma
 Bir grup sınıflandırıcı kullanma
 Bagging
 Boosting
Veri
Sınıflandırıcı(1)
Sınıflandırıcı(2)
Sınıflandırıcı(3)
Sınıflandırıcı(k)
:
Model
Yeni
Veri
Öğrenme K.(1)
Öğrenme K.(2)
Öğrenme K.(3)
Öğrenme K.(k)
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 72
Bagging
 N örnekten oluşan bir veri kümesinde bootstrap
yöntemi ile T örnek seç
 Bu işlemi k öğrenme kümesi oluşturmak üzere tekrarla
 Aynı sınıflandırma algoritmasını k öğrenme kümesi
üzerinde kullanarak k adet sınıflandırıcı oluştur
 Yeni bir örneği sınıflandırmak için her sınıflandırıcının
sonucunu öğren
 Yeni örnek en çok hangi sınıfa atanmışsa o sınıfın
etiketiyle etiketlendir.
13
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 73
Boosting
 Öğrenme kümesindeki her örneğin bir ağırlığı
var
 Her öğrenme işleminden sonra, her sınıflandırıcı
için yapılan sınıflandırma hatasına bağlı olarak
örneklerin ağırlığı güncelleniyor
 Yeni bir örneği sınıflandırmak için her
sınıflandırıcının doğruluğuna bağlı olarak
ağırlıklı ortalaması alınıyor.
1
1
VERİ MADENCİLİĞİ
Demetleme Yöntemleri
Yrd. Doç. Dr. Şule Gündüz Öğüdücü
http://www.ninova.itu.edu.tr/EgitimDeta
y.aspx?eId=195/
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 2
Konular
 Demetleme işlemleri
 Demetleme tanımı
 Demetleme uygulamaları
 Demetleme Yöntemleri
 Bölünmeli Yöntemler
 Hiyerarşik Yöntemler
 Yoğunluk Tabanlı Yöntemler
 Model Tabanlı Yöntemler
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 3
Demetleme
 Nesneleri demetlere (gruplara) ayırma
 Demet: birbirine benzeyen nesnelerden oluşan grup
 Aynı demetteki nesneler birbirine daha çok benzer
 Farklı demetlerdeki nesneler birbirine daha az benzer
Farklı demetlerdeki
nesneler arasındaki
uzaklığı en büyütme Aynı demet içindeki
nesneler arasındaki
uzaklığı en küçültme
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 4
Demetleme
 Gözetimsiz öğrenme:
Hangi nesnenin hangi
sınıfa ait olduğu ve sınıf
sayısı belli değil
 Uygulamaları:
 verinin dağılımını anlama
 başka veri madenciliği
uygulamaları için ön
hazırlık
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 5
Demetleme Uygulamaları
 Örüntü tanıma
 Görüntü işleme
 Ekonomi
 Aykırılıkları belirleme
 WWW
 Doküman demetleme
 Kullanıcı davranışlarını demetleme
 Kullanıcıları demetleme
 Diğer veri madenciliği algoritmaları için bir önişleme
adımı
 Veri azaltma – demet içindeki nesnelerin temsil edilmesi
için demet merkezlerinin kullanılması
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 6
Veri Madenciliğinde Demetleme
 Ölçeklenebilirlik
 Farklı tipteki niteliklerden oluşan nesneleri demetleme
 Farklı şekillerdeki demetleri oluşturabilme
 En az sayıda giriş parametresi gereksinimi
 Hatalı veriler ve aykırılıklardan en az etkilenme
 Model oluşturma sırasında örneklerin sırasından
etkilenmeme
 Çok boyutlu veriler üzerinde çalışma
 Kullanıcıların kısıtlarını göz önünde bulundurma
 Sonucun yorumlanabilir ve anlaşılabilir olması
2
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 7
İyi Demetleme
 İyi demetleme yöntemiyle elde edilen demetlerin özellikleri
 aynı demet içindeki nesneler arası benzerlik fazla
 farklı demetlerde bulunan nesneler arası benzerlik az
 Oluşan demetlerin kalitesi seçilen benzerlik ölçütüne ve bu ölçütün
gerçeklenmesine bağlı
 Uzaklık / Benzerlik nesnelerin nitelik tipine göre değişir
 Nesneler arası benzerlik: s(i,j)
 Nesneler arası uzaklık: d(i,j) = 1 – s(i,j)
 İyi bir demetleme yöntemi veri içinde gizlenmiş örüntüleri bulabilmeli
 Veriyi gruplama için uygun demetleme kriteri bulunmalı
 demetleme = aynı demetteki nesneler arası benzerliği en büyüten,
farklı demetlerdeki nesneler arası benzerliği en küçülten fonksiyon
 Demetleme sonucunun kalitesi seçilen demetlerin şekline ve temsil
edilme yöntemine bağlı
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 8
Farklı Demetler
Demet sayısı
2 demet 4 demet
6 demet
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 9
Temel Demetleme Yaklaşımları
 Bölünmeli yöntemler: Veriyi bölerek, her grubu
belirlenmiş bir kritere göre değerlendirir
 Hiyerarşik yöntemler: Veri kümelerini (ya da
nesneleri) önceden belirlenmiş bir kritere göre
hiyerarşik olarak ayırır
 Yoğunluk tabanlı yöntemler: Nesnelerin
yoğunluğuna göre demetleri oluşturur
 Model tabanlı yöntemler: Her demetin bir
modele uyduğu varsayılır. Amaç bu modellere
uyan verileri gruplamak
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 10
Konular
 Demetleme işlemleri
 Demetleme tanımı
 Demetleme uygulamaları
 Demetleme Yöntemleri
 Bölünmeli Yöntemler
 K-means demetleme yöntemi
 K-medoids demetleme yöntemi
 Hiyerarşik Yöntemler
 Yoğunluk Tabanlı Yöntemler
 Model Tabanlı Yöntemler
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 11
Bölünmeli Yöntemler
 Amaç: n nesneden oluşan bir veri kümesini (D) k (k≤n)
demete ayırmak
 her demette en az bir nesne bulunmalı
 her nesne sadece bir demette bulunmalı
 Yöntem: Demetleme kriterini en büyütücek şekilde D
veri kümesi k gruba ayırma
 Global çözüm: Mümkün olan tüm gruplamaları yaparak
en iyisini seçme (NP karmaşık)
 Sezgisel çözüm: k-means ve k-medoids
 k-means (MacQueen’67): Her demet kendi merkezi ile temsil
edilir
 k-medoids veya PAM (Partition around medoids) (Kaufman &
Rousseeuw’87): Her demet, demette bulunan bir nesne ile
temsil edilir
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 12
Bölünmeli Demetleme
Veri kümesi Bölünmeli demetleme
3
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 13
K-means Demetleme
 Bilinen bir k değeri için k-means demetleme
algoritmasının 4 aşaması vardır:
1. Veri kümesi k altkümeye ayrılır (her demet bir altküme)
2. Her demetin ortalaması hesaplanır: merkez nokta
(demetteki nesnelerin niteliklerinin ortalaması)
3. Her nesne en yakın merkez noktanın olduğu demete
dahil edilir
4. Nesnelerin demetlenmesinde değişiklik olmayana kadar
adım 2’ye geri dönülür.
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 14
K-means Demetleme Yöntemi
 Örnek
0
1
2
3
4
5
6
7
8
9
10
0 1 2 3 4 5 6 7 8 9 10
0
1
2
3
4
5
6
7
8
9
10
0 1 2 3 4 5 6 7 8 9 10
0
1
2
3
4
5
6
7
8
9
10
0 1 2 3 4 5 6 7 8 9 10
0
1
2
3
4
5
6
7
8
9
10
0 1 2 3 4 5 6 7 8 9 10
0
1
2
3
4
5
6
7
8
9
10
0 1 2 3 4 5 6 7 8 9 10
k=2
k noktayı demetlerin
merkezi olarak
rasgele seç
Her
nesneyi
en
yakın
merkezi
olan
demete
dahil et
demet
merkezlerini
yeniden
hesapla
demet
merkezlerini
yeniden
hesapla
yeniden demetle yeniden demetle
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 15
k-means Demetleme Yöntemi
 Demet sayısının belirlenmesi gerekir
 Başlangıçta demet merkezleri rasgele belirlenir
 Her uygulamada farklı demetler oluşabilir
 Uzaklık ve benzerlik Öklid uzaklığı, kosinüs benzerliği gibi
yöntemlerle ölçülebilir
 Az sayıda tekrarda demetler oluşur
 Yakınsama koşulu çoğunlukla az sayıda nesnenin demet
değiştirmesi şekline dönüştürülür
 Karmaşıklığı:
 Yer karmaşıklığı - O((n+k) d)
 Zaman karmaşıklığı - O(ktnd)
k: demet sayısı, t: tekrar sayısı, n: nesne sayısı, d: nitelik sayısı
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 16
K-Means: İki Farklı Demetleme
-2 -1.5 -1 -0.5 0 0.5 1 1.5 2
0
0.5
1
1.5
2
2.5
3
x
y
-2 -1.5 -1 -0.5 0 0.5 1 1.5 2
0
0.5
1
1.5
2
2.5
3
x
y
Lokal optimum
-2 -1.5 -1 -0.5 0 0.5 1 1.5 2
0
0.5
1
1.5
2
2.5
3
x
y
Optimal
Demetleme
Veri Kümesi
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 17
K-Means Demetleme Yöntemini
Değerlendirme
 Yaygın olarak kullanılan yöntem hataların karelerinin toplamı
(Sum of Squared Error SSE)
 Nesnelerin bulundukları demetin merkez noktalarına olan
uzaklıklarının karelerinin toplamı
x: Ci demetinde bulunan bir nesne, mi : Ci demetinin merkez noktası
 Hataların karelerinin toplamını azaltmak için k demet sayısı
artırılabilir
 Küçük k ile iyi bir demetleme, büyük k ile kötü bir demetlemeden
daha az SSE değerine sahip olabilir.
 Başlangıç için farklı merkez noktaları seçerek farklı
demetlemeler oluşturulur
 En az SSE değerini sahip olan demetleme seçilir
∑ ∑= ∈
=
K
i C x
i
i
SSE dist m x 1
2
( , )
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 18
Merkez Noktaların Seçimi
-2 -1.5 -1 -0.5 0 0.5 1 1.5 2
0
0.5
1
1.5
2
2.5
3
x
y
Iteration 1
-2 -1.5 -1 -0.5 0 0.5 1 1.5 2
0
0.5
1
1.5
2
2.5
3
x
y
Iteration 2
-2 -1.5 -1 -0.5 0 0.5 1 1.5 2
0
0.5
1
1.5
2
2.5
3
x
y
Iteration 3
-2 -1.5 -1 -0.5 0 0.5 1 1.5 2
0
0.5
1
1.5
2
2.5
3
x
y
Iteration 4
-2 -1.5 -1 -0.5 0 0.5 1 1.5 2
0
0.5
1
1.5
2
2.5
3
x
y
Iteration 5
-2 -1.5 -1 -0.5 0 0.5 1 1.5 2
0
0.5
1
1.5
2
2.5
3
x
y
Iteration 6
4
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 19
Merkez Noktaların Seçimi
-2 -1.5 -1 -0.5 0 0.5 1 1.5 2
0
0.5
1
1.5
2
2.5
3
x
y
Iteration 1
-2 -1.5 -1 -0.5 0 0.5 1 1.5 2
0
0.5
1
1.5
2
2.5
3
x
y
Iteration 2
-2 -1.5 -1 -0.5 0 0.5 1 1.5 2
0
0.5
1
1.5
2
2.5
3
x
y
Iteration 3
-2 -1.5 -1 -0.5 0 0.5 1 1.5 2
0
0.5
1
1.5
2
2.5
3
x
y
Iteration 4
-2 -1.5 -1 -0.5 0 0.5 1 1.5 2
0
0.5
1
1.5
2
2.5
3
x
y
Iteration 5
-2 -1.5 -1 -0.5 0 0.5 1 1.5 2
0
0.5
1
1.5
2
2.5
3
x
y
Iteration 6
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 20
Merkez Noktaların Seçimi
-2 -1.5 -1 -0.5 0 0.5 1 1.5 2
0
0.5
1
1.5
2
2.5
3
x
y
Iteration 1
-2 -1.5 -1 -0.5 0 0.5 1 1.5 2
0
0.5
1
1.5
2
2.5
3
x
y
Iteration 2
-2 -1.5 -1 -0.5 0 0.5 1 1.5 2
0
0.5
1
1.5
2
2.5
3
x
y
Iteration 3
-2 -1.5 -1 -0.5 0 0.5 1 1.5 2
0
0.5
1
1.5
2
2.5
3
x
y
Iteration 4
-2 -1.5 -1 -0.5 0 0.5 1 1.5 2
0
0.5
1
1.5
2
2.5
3
x
y
Iteration 5
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 21
Merkez Noktaların Seçimi
-2 -1.5 -1 -0.5 0 0.5 1 1.5 2
0
0.5
1
1.5
2
2.5
3
x
y
Iteration 1
-2 -1.5 -1 -0.5 0 0.5 1 1.5 2
0
0.5
1
1.5
2
2.5
3
x
y
Iteration 2
-2 -1.5 -1 -0.5 0 0.5 1 1.5 2
0
0.5
1
1.5
2
2.5
3
x
y
Iteration 3
-2 -1.5 -1 -0.5 0 0.5 1 1.5 2
0
0.5
1
1.5
2
2.5
3
x
y
Iteration 4
-2 -1.5 -1 -0.5 0 0.5 1 1.5 2
0
0.5
1
1.5
2
2.5
3
x
y
Iteration 5
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 22
K-Means Demetleme Çeşitleri
 K-Means demetlemeye başlamadan önce yapılanlar
 Veri kümesini örnekleyerek hiyerarşik demetleme yap.
Oluşan k demetin ortalamasını başlangıç için merkez
nokta seç
 Başlangıçta k’dan fazla merkez nokta seç. Daha sonra
bunlar arasından k tane seç.
 K-Means demetleme işlemi sonrasında yapılanlar
 Küçük demetleri en yakın başka demetlere dahil et
 En büyük toplam karesel hataya sahip olan demeti böl
 Merkez noktaları birbirine en yakın demetleri birleştir
 Toplam karesel hatada en az artışa neden olacak iki
demeti birleştir
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 23
K-Means Demetleme Algoritmasının
Özellikleri
 Gerçeklemesi kolay
 Karmaşıklığı diğer demetleme yöntemlerine
göre az
 K-Means algoritması bazı durumlarda iyi sonuç
vermeyebilir
 Veri grupları farklı boyutlarda ise
 Veri gruplarının yoğunlukları farklı ise
 Veri gruplarının şekli küresel değilse
 Veri içinde aykırılıklar varsa
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 24
Konular
 Demetleme işlemleri
 Demetleme tanımı
 Demetleme uygulamaları
 Demetleme Yöntemleri
 Bölünmeli Yöntemler
 K-means demetleme yöntemi
 K-medoids demetleme yöntemi
 Hiyerarşik Yöntemler
 Yoğunluk Tabanlı Yöntemler
 Model Tabanlı Yöntemler
5
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 25
K-Medoids Demetleme Yöntemi
 Her demeti temsil etmek için demet içinde orta
nokta olan nesne seçilir.
 1, 3, 5, 7, 9 ortalama:
 1, 3, 5, 7, 1009 ortalama
 1, 3, 5, 7, 1009 orta nokta
0
1
2
3
4
5
6
7
8
9
10
0 1 2 3 4 5 6 7 8 9 10
0
1
2
3
4
5
6
7
8
9
10
0 1 2 3 4 5 6 7 8 9 10
5
205
5
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 26
K-Medoids Demetleme Yöntemi
 PAM (Partitioning Araound Medoids 1987)
1. Başlangıçta k adet nesne demetleri temsil etmek üzere rasgele seçilir xik
2. Kalan nesneler en yakın merkez nesnenin bulunduğu demete dahil edilir
3. Merkez nesne olmayan rasgele bir nesne seçilir xrk
4. xrk merkez nesne olursa toplam karesel hatanın ne kadar değiştiği bulunur
5. TCik<0 ise Ork merkez nesne olarak atanır.
6. Demetlerde değişiklik oluşmayana kadar 3. adıma geri gidilir.
 Küçük veri kümeleri için iyi sonuç verebilir, ancak büyük veri
kümeleri için uygun değil
 CLARA (Kaufmann & Rousseeuw, 1990)
 CLARANS (Ng & Han, 1994)
∑ ∑ = =
= − − − k k n
j
n
j
ik ik jk rk jk TC x x x x 1 1
2 2 ( ) ( ) nk
: k demeti içindeki nesne sayısı
xjk: k demeti içindeki j. nesne
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 27
Konular
 Demetleme işlemleri
 Demetleme tanımı
 Demetleme uygulamaları
 Demetleme Yöntemleri
 Bölünmeli Yöntemler
 Hiyerarşik Yöntemler
 Yoğunluk Tabanlı Yöntemler
 Model Tabanlı Yöntemler
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 28
Hiyerarşik Demetleme
 Demet sayısının belirlenmesine gerek yok
 Sonlanma kriteri belirlenmesi gerekiyor
agglomerative:
Aşağıdan yukarıya
(AGNES)
divisive:
yukarıdan aşağıya
(DIANA)
Adım 0 Adım 1 Adım 2 Adım 3 Adım 4
b
d
c
e
a a b
d e
c d e
a b c d e
Adım 4 Adım 3 Adım 2 Adım 1
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 29
Hiyerarşik Yöntemler
 AGNES (AGglomerative NESting):
 Kaufmann ve Rousseeuw tarafından 1990 yılında önerilmiştir.
 Birinci adımda her nesne bir demet oluşturur.
 Aralarında en az uzaklık bulunan demetler her adımda
birleştirilir.
 Bütün nesneler tek bir demet içinde kalana kadar ya da istenen
sayıda demet elde edene kadar birleştirme işlemi devam eder.
0
1
2
3
4
5
6
7
8
9
10
0 1 2 3 4 5 6 7 8 9 10
0
1
2
3
4
5
6
7
8
9
10
0 1 2 3 4 5 6 7 8 9 10
0
1
2
3
4
5
6
7
8
9
10
0 1 2 3 4 5 6 7 8 9 10
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 30
Hiyerarşik Yöntemler
0
1
2
3
4
5
6
7
8
9
10
0 1 2 3 4 5 6 7 8 9 10 0
1
2
3
4
5
6
7
8
9
10
0 1 2 3 4 5 6 7 8 9 10
0
1
2
3
4
5
6
7
8
9
10
0 1 2 3 4 5 6 7 8 9 10
 DIANA (DIvisive ANAlysis):
 Kaufmann ve Rousseeuw tarafından 1990 yılında önerilmiştir.
 AGNES’in yaptığı işlemlerin tersini yapar.
 En sonunda her nesne bir demet oluşturur.
 Her nesne ayrı bir demet oluşturana ya da istenilen demet sayısı
elde edene kadar ayrılma işlemi devam eder.
6
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 31
Hiyerarşik Demetleme
 Dendogram: Demetler hiyerarşik olarak ağaç yapısı şeklinde
görüntülenebilir
 Ara düğümler çocuk düğümlerdeki demetlerin birleşmesiyle elde
edilir
 Kök: bütün nesnelerden oluşan tek demet
 Yapraklar: bir nesneden oluşan demetler
 Dendogram istenen seviyede kesilerek demetler elde edilir
1 3 2 5 4 6 0
0.05
0.1
0.15
0.2
1
2
3
4
5
6
1
2 3 4
5
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 32
Aşağıdan Yukarıya Demetleme
 Algoritma
1. Uzaklık matrisini hesapla
2. Her nesne bir demet
3. Tekrarla
4. En yakın iki demeti birleştir
5. Uzaklık matrisini yeniden hesapla
6. Sonlanma: Tek bir demet kalana kadar
 Uzaklık matrisini hesaplarken farklı yöntemler
farklı demetleme sonuçlarına neden olurlar
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 33
p1
p3
p5
p4
p2
p1 p2 p3 p4 p5 . . .
.
.
.
 MIN (Tek Bağ)
 MAX (Tam Bağ)
 Ortalama
 Merkezler arası uzaklık
Benzerlik
Uzaklık Matrisi
Demetler Arası Uzaklık
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 34
p1
p3
p5
p4
p2
p1 p2 p3 p4 p5 . . .
.
.
. Uzaklık Matrisi
 MIN (Tek Bağ)
 MAX (Tam Bağ)
 Ortalama
 Merkezler arası uzaklık
Demetler Arası Uzaklık
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 35
p1
p3
p5
p4
p2
p1 p2 p3 p4 p5 . . .
.
.
. Uzaklık Matrisi
 MIN (Tek Bağ)
 MAX (Tam Bağ)
 Ortalama
 Merkezler arası uzaklık
Demetler Arası Uzaklık
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 36
p1
p3
p5
p4
p2
p1 p2 p3 p4 p5 . . .
.
.
. Uzaklık Matrisi
 MIN (Tek Bağ)
 MAX (Tam Bağ)
 Ortalama
 Merkezler arası uzaklık
Demetler Arası Uzaklık
7
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 37
p1
p3
p5
p4
p2
p1 p2 p3 p4 p5 . . .
.
.
. Uzaklık Matrisi
× ×
 MIN (Tek Bağ)
 MAX (Tam Bağ)
 Ortalama
 Merkezler arası uzaklık
Demetler Arası Uzaklık
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 38
Farklı Uzaklık Yöntemlerinin Etkisi
Ortalama
MIN MAX
1
2
3
4
5
6
1
2
5
3 4
1
2
3
4
5
6
1
2 5
3
1 4
2
3
4
5
6
1
2
3
4
5
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 39
Hiyerarşik Demetleme Yöntemlerinin
Özellikleri
 Demetleme kriteri yok
 Demet sayılarının belirlenmesine gerek yok
 Aykırılıklardan ve hatalı verilerden etkilenir
 Farklı boyuttaki demetleri oluşturmak problemli
olabilir
 Yer karmaşıklığı – O(n2 )
 Zaman karmaşıklığı – O(n2logn)
n : nesne sayısı
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 40
Konular
 Demetleme işlemleri
 Demetleme tanımı
 Demetleme uygulamaları
 Demetleme Yöntemleri
 Bölünmeli Yöntemler
 Hiyerarşik Yöntemler
 Yoğunluk Tabanlı Yöntemler
 Model Tabanlı Yöntemler
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 41
Yoğunluk Tabanlı Yöntemler
 Demetleme nesnelerin yoğunluğuna göre yapılır.
 Başlıca özellikleri:
 Rasgele şekillerde demetler üretilebilir.
 Aykırı nesnelerden etkilenmez.
 Algoritmanın son bulması için yoğunluk parametresinin
verilmesi gerekir.
 Başlıca yoğunluk tabanlı yöntemler:
 DBSCAN: Ester, et al. (KDD’96)
 OPTICS: Ankerst, et al (SIGMOD’99).
 DENCLUE: Hinneburg & D. Keim (KDD’98)
 CLIQUE: Agrawal, et al. (SIGMOD’98)
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 42
DBSCAN
 İki parametre:
 Eps: En büyük komşuluk yarıçapı
 MinPts: Eps yarıçaplı komşuluk bölgesinde bulunan en
az nesne sayısı
 Neps(p): {q∈D | d(p,q)≤Eps}
 Doğrudan erişilebilir nesne: Eps ve MinPts koşulları
altında bir q nesnesinin doğrudan erişilebilir bir p
nesnesi şu şartları sağlar:
 p∈Neps(q)
 q nesnesinin çekirdek nesne koşulunu sağlaması
Neps(q)≥MinPts p
q
MinPts = 5
Eps = 1 cm
8
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 43
DBSCAN
 Erişilebilir nesne:
 Eps ve MinPts koşulları altında q
nesnesinin erişilebilir bir p nesnesi
olması için:
 p1
,p2
,...,p n nesne zinciri olması,
 p1=q, pn=p,
 pi nesnesinin doğrudan erişilebilir
nesnesi:pi+1
 Yoğunluk bağlantılı Nesne:
 Eps ve MinPts koşulları altında q
nesnesinin yoğunluk bağlantılı
nesnesi p şu koşulları sağlar:
 p ve q nesneleri Eps ve MinPts
koşulları altında bir o nesnesinin
erişilebilir nesnesidir.
p
q
p1
p q
o
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 44
Yoğunluk Tabanlı Yöntemler: DBSCAN
 Veri tabanındaki her nesnenin Eps yarıçaplı komşuluk
bölgesi araştırılır.
 Bu bölgede MinPts’den daha fazla nesne bulunan p
nesnesi çekirdek nesne olacak şekilde demetler
oluşturulur.
 Çekirdek nesnelerin doğrudan erişilebilir nesneleri
bulunur.
 Yoğunluk bağlantılı demetler birleştirilir.
 Hiçbir yeni nesne bir demete eklenmezse işlem sona
erer.
 Yer karmaşıklığı – O(n)
 Zaman karmaşıklığı – O(nlogn)
n: nesne sayısı
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 45
Konular
 Demetleme işlemleri
 Demetleme tanımı
 Demetleme uygulamaları
 Demetleme Yöntemleri
 Bölünmeli Yöntemler
 Hiyerarşik Yöntemler
 Yoğunluk Tabanlı Yöntemler
 Model Tabanlı Yöntemler
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 46
Model Tabanlı Demetleme Yöntemleri
 Veri kümesi için öngörülen matematiksel model
en uygun hale getiriliyor.
 Verinin genel olarak belli olasılık dağılımlarının
karışımından geldiği kabul edilir.
 Model tabanlı demetleme yöntemi
 Modelin yapısının belirlenmesi
 Modelin parametrelerinin belirlenmesi
 Örnek EM (Expectation Maximization)
Algoritması
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 47
Model Tabanlı Demetleme Yöntemleri
 İstatistiksel yaklaşım:
 K nesneden oluşan bir veri kümesi D={x1
,x2
,...,xK}
 her xi (i∈[1,...K]) nesnesi Θ parametre kümesiyle tanımlanan bir olasılık
dağılımından oluşturulur.
 Olasılık dağılımının, cj
∈C={c 1
, c 2
, ...,cG} şeklinde G adet bileşeni vardır.
 Her Θg
, g∈[1, ...,G] parametre kümesi g bileşeninin olasılık dağılımını
belirleyen, Θ kümesinin ayrışık bir alt kümesidir.
 Herhangi bir xi nesnesi öncelikle, p(c g
|Θ) = τg
, (ΣG τg
=1 olacak şekilde)
bileşen katsayısına (ya da bileşenin seçilme olasılığına) göre bir bileşene
atanır.
 Bu bileşen p(xi
|c g
; Θg
) olasılık dağılımına göre xi değişkenini oluşturur.
 Böylece bir xi nesnesinin bu model için olasılığı bütün bileşenlerin
olasılıklarının toplamıyla ifade edilebilir:
( | ) ( | ; )
( | ) ( | ) ( | ; )
1
1
i g g
G
g
i g
i g g
G
g
i g
p x p c
p x p c p c
Θ x Θ
Θ Θ x Θ
∑
∑
=
=
=
=
τ
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 48
Model Tabanlı Demetleme Problemi
 Model parametrelerinin belirlenmesi
 Maximum Likelihood (ML) yaklaşımı
 Maximum Aposteriori (MAP) yaklaşımı
 Uygulamada her ikisinin logaritması
∏∑= =
Θ Θ = Θ
K
i
G
g
ML G G g i g g D p x c 1 1
1 1 l ( ,..., ;τ ,...,τ | ) τ ( | , )
∏∑= =
Θ Θ Θ Θ =
K
i
G
g
g i g g
MAP G G p D
p x c p D 1 1
1 1 ( )
( | , ) ( ) ( ,..., ; ,..., | ) τ l τ τ
( )
∑ ∑( )
∑ ∑
= =
= =
Θ Θ = Θ + Θ
Θ Θ = Θ
K
i
G
g
G G g i g g
K
i
G
g
G G g i g g
L D p x c p
L D p x c
1 1
1 1
1 1
1 1
( ,..., ; ,..., | ) ln ( | , ) ln ( )
( ,..., ; ,..., | ) ln ( | , )
τ τ τ
τ τ τ
9
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 49
EM Algoritması
 Veri kümesi: D={x1,x2,...,xK}
 Gizli değişkenler H={z1,z2,...,zK} (her nesnenin hangi demete
dahil olduğu bilgisi)
 Verinin eksik olduğu durumda, tam verinin beklenen değeri
hesaplanır:
 EM Algoritmasının adımları:
 Θ’ için başlangıç değerleri atama
 (E) Expectation: Q(Θ| Θ’) hesaplanması
 (M) Maximization: argmax Q(Θ| Θ’)
( | )[ln ( | ) ln ]
( , ') [ ( , | ) | , ')
1 1
∑∑= =
= +
Θ Θ = Θ Θ
K
i
i g g
G
g
g i
c
p c x p x c
Q E L D H D
τ
1
1
VERİ MADENCİLİĞİ
Farklı Demetleme Yöntemleri
Yrd. Doç. Dr. Şule Gündüz Öğüdücü
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 2
Çizge Tabanlı Demetleme
 Veri kümesi çizge şeklinde temsil edilebilir
 Aile ilişkileri
 Sosyal ağlar (eğitim, suçlular arası ilişki...)
 Telefon çağrıları
 Bilgisayar ağları
 ...
 www
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 3
Çizge
 Veri kümesi D={x1
,x2
,...,xK}
 Veri kümesi ağırlıklı, yönsüz, bağlı bir çizge ile temsil edilir: G(V,E)
E={wij
} xi ve xj düğümleri arasındaki ağırlık
0.1
0.2
0.8
0.7
0.6
0.8
0.8
0.8
1
2
3
4
5
6
V={xi
} veri kümesindeki nesnelerden oluşan düğümler kümesi
G yönsüz çizge => wij
= wji
xi düğümünün derecesi ∑=
=
K
j
di wij
1
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 4
Çizge Demetleme için Veri Kümesi
 Veri kümesi D={x1,x2,...,xK} => G(V,E)
 ε-komşu çizge: Veri kümesindeki nesneler arasında
uzaklık hesaplanır. Aralarındaki uzaklık belirlenen ε
değerinden küçük olanlar arasında ayrıt oluşturulur.
 k-en yakın komşu çizge: Veri kümesindeki
nesnelerin k en yakın komşuları arasında ayrıtlar
oluşturulur.
 Tam bağlı çizge: Bütün nesneler arasında benzerlik
hesaplanır ve bu benzerlik ile ağırlıklandırılmış
ayrıtlar oluşturulur. 2
2 ( , ) exp 2
xi xj s xi xj σ
⎛ ⎞ − = ⎜− ⎟ ⎜ ⎟ ⎝ ⎠
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 5
Çizge Tabanlı Demetleme
 S={V,N,W,P}
 V : veri kümesindeki nesnelerden oluşan düğümler kümesi
 N ⊆ V×V
 W: N kümesinin elemanları için simetrik benzerlik matrisi
 P: Demetleme kriteri
 Çizge Bölme: P demetleme kriterini enbüyütecek şekilde V
kümesini k demete bölmek (C={C1,...,Ck
}).
 Her demet bir altçizge Gi
(Vi
,Ei
)
 Problem: Çizge tabanlı demetleme yöntemleri için P demetleme
kriteri nedir?
U
k
i
Vi V =1
=
{ , } i jk j k Vi E = w ∈ E ∧ x x ∈
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 6
Çizge Tabanlı Demetleme Problemi
 Demetlemenin sağlaması gereken koşullar:
1. Aynı demetlerdeki nesnelerin birbirine daha çok benzemesi
2. Farklı demetlerdeki nesnelerin birbirine daha az benzemesi
2. Farklı gruplar arasındaki ağırlıkları enküçültme
0.1
0.2
1. Aynı grup içindeki ağırlıkları enbüyütme
0.8
0.7
0.6
0.8
0.8
0.8
1
2
3
4
5
6
 Aynı koşullar çizge tabanlı demetlemeye uygulanırsa
2
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 7
Çizge Tabanlı Demetleme için Tanımlar
 Tanımlar:
 uzaklık d, benzerlik s
 d=1-s
 Ci ve Cj demetleri arasındaki uzaklık: d(Ci
,Cj
)
 tek bağ, tam bağ ya da ortalama
 Ci demedinin çapı: diam(Ci
)
 Ci demedinde bulunan en uzak iki nesne arasındaki
uzaklık
 Ci demedinden bulunan tüm nesneler arasındaki
uzaklıkların ortalaması
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 8
Çizge Kesmesi
 Çizge Kesmesi: Demetleri (altçizgeleri) birbirine
bağlayan ayrıtların ağırlıklarının toplamı
∑∈ ∈
=
1 2 ,
1 2 ( , ) x G x G
ij
i j
cut G G w
0.1
0.2
0.8
0.7
0.6
0.8
0.8
1
2
3
4
5
6
0.8
G1 G2
cut(G1,G2) = 0.3
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 9
Çizge Kesmesi Kriteri
 Kriter: En küçük kesme (Minimum-cut)
 Demetler arasındaki ağırlıkları en küçültüyor
 min cut (G1
,G2
)
Optimal kesme
Enküçük kesme
 Problem:
 Sadece demetler arası ağırlıkları enküçültüyor
 Demet içi ağırlıkları göz önüne almıyor
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 10
Çizge Tabanlı Demetleme Kriteri
 Min-Max cut: Demet içindeki ağırlıkların enbüyük,
demetler arasındaki ağırlıkların enküçük olması
 Ratio-Cut:
 Demetler daha dengeli
 Problemin optimal çözümü NP karmaşık
 sezgisel yöntemler
∑= ∑∈
k
m
v v Gm
ij
m m
i j
w
cut G G G minimize 1
,
( , \ )
∑=
k
m m
m m
G
cut G G G minimize 1 | |
( , \ )
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 11
Çizge Tabanlı Demetleme için Seyrekleştirme
Veri Benzerlik Matrisi
D1
D2
D3
Benzerlik
Hesaplama
Seyrekleştirme Demetleme
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 12
İzgesel Demetleme
 Yaklaşım:
 Çizge düğümlerin ikili benzerliklerinden oluşan W simetrik matrisi ile
temsil edilir
 Lineer cebir yöntemleri kullanılır
 W matrisinin en büyük k özdeğeri bulunur
 Bir matrisin özdeğerleri
ve özvektörleri, yapısı
hakkında bilgi verir ⎥
⎥
⎥
⎦
⎤
⎢
⎢
⎢
⎣
⎡
=
⎥
⎥
⎥
⎦
⎤
⎢
⎢
⎢
⎣
⎡
⎥
⎥
⎥
⎦
⎤
⎢
⎢
⎢
⎣
⎡
n nn n n
n
x
x
λ
x
x
a a
a a
M M
K
M M
K 1 1
1
11 1
 İzgesel Çizge Kuramı
 Bir matrisin izgesi incelenir.
 İzge (Spectrum ): Çizgenin öz değerlerinin
büyüklüklerine göre sıralanmış özvektörü
{ , ,..., } Λ = λ1 λ2 λn
3
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 13
Matris Yapısı
 Benzerlik matrisi (W)
 n×n matris (n: düğüm sayısı)
 W=[wij]: xi ve xj düğümleri arasındaki ayrıtın
ağırlığı
0.1
0.2
0.8
0.7
0.6
0.8
0.8
1
2
3
4
5
6
0.8
x6 0 0 0 0.7 0.8 0
x5 0.1 0 0 0.8 0 0.8
x4 0 0 0.2 0 0.8 0.7
x3 0.6 0.8 0 0.2 0 0
x2 0.8 0 0.8 0 0 0
x1 0 0.8 0.6 0 0.1 0
x1 x2 x3 x4 x5 x6
 Özellikleri:
 Simetrik matris
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 14
Matris Yapısı
 Derece matrisi (D)
 n×n diagonal matris
 xi düğümünden diğer düğümlere olan
ayrıtların ağırlıklarının toplamı
= ∑j
wij D (i, i)
x6 0 0 0 0 0 1.5
x5 0 0 0 0 1.7 0
x4 0 0 0 1.7 0 0
x3 0 0 1.6 0 0 0
x2 0 1.6 0 0 0 0
x1 1.5 0 0 0 0 0
x1 x2 x3 x4 x5 x6
0.1
0.2
0.8
0.7
0.6
0.8
0.8
1
2
3
4
5
6
0.8
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 15
Matris Yapısı
 Laplacian matrisi (L)
 n×n simetrik matris
0.1
0.2
0.8
0.7
0.6
0.8
0.8
1
2
3
4
5
6
0.8
L = D - W
x6 0 0 0 -0.7 -0.8 1.5
x5 -0.1 0 0 -0.8 1.7 -0.8
x4 0 0 -0.2 1.7 -0.8 -0.7
x3 -0.6 -0.8 1.6 -0.2 0 0
x2 -0.8 1.6 -0.8 0 0 0
x1 1.5 -0.8 -0.6 0 -0.1 0
x1 x2 x3 x4 x5 x6
 Özellikleri:
 Özdeğerler pozitif gerçel sayılar
 Özvektörler gerçel ve dikey
 Özdeğerler ve özvektörler çizge yapısı hakkında bilgi
veriyor. http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 16
Optimal Enküçük Kesme Bulma
(Hall’70, Fiedler’73)
 İki altçizgeye (G1
,G2
) bölünen çizge bir vektörle temsil
edilir.
⎩
⎨
⎧
− ∈
+ ∈ =
i 2
i 1
i if x G
if x G
p 1
1
2
,
( ) ( ) i j
i j V
f p = ∑wij p − p ∈
 Bölmenin kesmesini enküçültmek için f(p)
fonksiyonunu enküçültecek p vektörü bulunur:
p L p T =
Laplacian
 Rayleigh Kuramına göre: matrisi
 f(p)’nin enküçük değeri L matrisinin ikinci enküçük
özdeğeri ile elde edilir.
 p için optimal çözüm Fiedler vektörü olarak bilinen λ2
vektörüdür.
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 17
İzgesel Çizge Demetleme
 A. Pothen, H.D. Simon and K. Paul Liou. Partitioning Sparse Matrices with Eigenvectors of Graphs, SIAM J.
Mat. Theory and Appl., Vol. 11, No. 3, pp. 430 - 452,
1990.
 Önişleme
 veri kümesinin matris olarak temsil edilmesi
 Laplacian matrisinin bulunması
 Ayrıştırma
 Matrisin özvektörlerinin ve özdeğerlerinin bulunması
 Veri kümesindeki her nesnenin bir veya daha çok özvektörü kullanılarak daha küçük bir boyuta taşınması
 Gruplama
 Yeni boyutlardan yararlanarak nesnelerin iki veya daha fazla
demede ayrılması
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 18
Spectral Bi-partitioning Algoritması
x6
x5
x4
x3
x2
x1
0 0 0 -0.7 -0.8 1.5
-0.1 0 0 -0.8 1.7 -0.8
0 0 -0.2 1.7 -0.8 -0.7
-0.6 -0.8 1.6 -0.2 0 0
-0.8 1.6 -0.8 0 0 0
1.5 -0.8 -0.6 0 -0.1 0
1. Önişleme
 Çizgenin L Laplacian
matrisini oluşturma
Demetler nasıl
belirlenir?
0.7 0.7 0.9 -0.2 0.4 0.4
0.4 0.4 -0.2 -0.3 -0.3 -0.2
0.4 0.4 0.4 -0.5 -0.5 -0.6
0.4 -0.4 -0.6 0.1 0.1 0.6
0.4 -0.4 0.0 0.3 0.3 0.3
0.4 -0.4 -0.6 -0.3 -0.3 -0.9
2.6
2.5
2.3
2.1
0.2
0.0
Λ = X =
2. Ayrıştırma
 L matrisinin
özvektörlerinin X
ve özdeğerlerinin Λ
bulunması
x 0.4 6
x 0.4 5
x 0.4 4
x -0.4 3
x -0.4 2
x -0.4 1
 Düğümlerin λ2
özvektörü ile temsil
edilmesi
4
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 19
Spectral Bi-partitioning Algoritması
 Gruplama
 Tek boyutlu vektörde bulunan elemanlar sıralanır
 Vektör ikiye bölünür
 Bölme noktası nasıl belirlenir?
 Ortalamadan ya da orta noktadan bölünür
x 0.4 6
x 0.4 5
x 0.4 4
x -0.4 3
x -0.4 2
x -0.4 1 Orta noktadan
Demet G1: Eksi noktalar
Demet G2: Artı noktalar
x -0.4 3
x -0.4 2
x -0.4 1
x 0.4 6
x 0.4 5
x 0.4 4
G1 G2
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 20
K-Yönlü İzgesel Demetleme
 Biz çizge k adet altçizgeye bölünmek isteniyor.
 İki yaklaşım
 Yinelemeli ikiye demetleme (L. Hagen, A.B. Kahng, New
spectral methods for ratio cut partitioning and
clustering, IEEE Trans. Comput. Aided Des. 11,1992)
 Yinelemeli olarak ikiye demetleme algoritmasını hiyerarşıik
olarak uygulanması
 Daha fazla sayıda özvektörü kullanarak demetleme (J.
Shi and J. Malik. Normalized cuts and image
segmentation. IEEE Trans. on Pattern Analysis and
Machine Intelligence, 22(8):888-905, 2000.=
 Özvektörleri kullanarak veriyi daha az boyutlu bir uzaya taşır
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 21
K-Yönlü İzgesel Demetleme
 Çizgeler arasındaki optimal kesmeyi yaklaşık olarak
bulabilir (Shi & Malik, 2002).
 Veri içindeki grupları belirgin hale getirir (M. Brand and
K. Huang. A unifying theorem for spectral embedding
and clustering, Proceedings of the Ninth International
Workshop on Artificial Intelligence and Statistics,
January 2003.)
 Benzer nesneler arasındaki ilişki kuvvetleniyor, daha az
benzer nesneler arasındaki ilişki zayıflıyor.
 Uzayı daha iyi ayırıyor
 Veriyi k adet vektör kullanarak daha az boyutlu uzaya
taşır.
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 22
K-Özvektör Demetleme
 k özvektör kullanarak demetleme yapılıyor (A. Ng,
M. Jordan, and Y. Weiss. On spectral clustering:
Analysis and an algorithm, In Advances in Neural
Information Processing Systems 14: Proceedings
of the 2001.)
1. Önişleme: ölçeklendirilmiş ağırlık matrisi oluşturulur
2. Ayrıştırma: W' matrisinin özvektörleri bulunur. Veri
kümesi en büyük k özdeğer ile temsil edilir
3. Demetleme: k-means algoritması kullanılarak n×k
boyutundaki veri k demede ayrılır.
1/ 2 1/ 2 ' − − W = D WD
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 23
-2
-1.5
-1
-0.5
0
0.5
1
1.5
2
-2 -1.5 -1 -0.5 0 0.5 1 1.5 2
Veri kümesi iki spiral şeklinde
gruptan oluşuyor
⇒ k-means algoritmasının
performansı bu durumda çok
düşük
-0.8
-0.6
-0.4
-0.2
0
0.2
0.4
0.6
0.8
En büyük iki ö -0.709 -0.7085 -0.708 -0.7075 -0.707 -0.7065 -0.706 zdeğer
kullanılarak veri k-means
algoritması kullanılarak
demetlenebiliyor
Örnek
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 24
Çizge Tabanlı Demetleme Yöntemi
(Kannan’00)
 En küçük kesme bulunarak
demetlenirse altçizgeler
arasındaki nesneler dengeli
dağılmayabilir.
 Demetlerin kalitesi önemli
(Ravi Kannan and Santosh
Vempala and Adrian Vetta,
On Clusterings: Good, Bad,
and Spectral, Proceedings of
the 41st Annual Symposium
on the Foundation of
Computer Science, 2000.)
5
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 25
Çizge Tabanlı Demetleme Yöntemi
(Kannan’00)
 Bir kesme için genişlik
 Bir kesme için iletkenlik
c(S) şu şekilde tanımlanmıştır
min{| |,| |} ( ) ,
S S
w
S x S x S ij ∑ i∈ j∈
ψ =
min{ ( ), ( )} ( ) ,
c S c S
w
S x S x S ij ∑ i∈ j∈
φ =
= = ∑x V ∈ ∈ S∑x ij i j
c(S) c(S,V) w
 Bir demetin genişliği (iletkenliği) demet içindeki kesmelerin genişliklerinin
(iletkenliklerinin) en küçüğü
 Demetlemenin genişliği (iletkenliği) demetlerin genişliklerinin
(iletkenliklerinin) en küçüğü
 Genişliğin (iletkenliğin) büyük olması iyi bir demetleme olduğunu
gösteriyor
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 26
Çizge Tabanlı Demetleme Yöntemi
(Kannan’00)
 Çizgeyi demetlemek için iki kriter beraber
kullanılıyor:
 Her demedin iletkenliği (genişliği) en az α
değerinde olmalı
 Demetler arası ayrıtların ağırlıklarının toplamının
bütün ayrıtların ağırlıklarının toplamına oranı ε
değerinden büyük olmamalı
 Problemin çözümü NP-karmaşık olduğu için
yaklaşık bir çözüm öneriliyor.
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 27
Evrimsel Algoritma Tabanlı Çizge
Demetleme
 Çizge demetleme problemi NP-karmaşık bir problem
olduğundan doğa esinli algoritmalar kullanılarak
problem çözülebilir (Ş.Uyar and Ş.Oguducu, A New
Graph-Based Evolutionary Approach to Sequence
Clustering, The Fourth International Conference on
Machine Learning and Applications, 2005)
 Amaç:
 Aynı demetteki nesneler arasındaki ayrıtların
ağırlıklarının toplamının, demetler arasındaki ayrıtların
ağırlıklarının toplamına oranını enbüyütmek
 Demet sayısını adaptif olarak belirlemek.
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 28
Evrimsel Algoritma Tabanlı Çizge
Demetleme
 İki objektif fonksiyonu:
 Min-max cut
 Silhoutte index
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 29
Demetleme Değerlendirme
 Hangi demetleme algoritması kullanılmalı?
 Farklı bir demetleme uygulanmalı mı?
 Farklı demetleme yöntemleri kullanılarak sonuç
nasıl iyileştirilir?
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 30
Demetleme Değerlendirme
 Farklı demetleme teknikleri
 En iyi demetleme algoritmasını seçmek zor
 Verinin istatistiksel özelliğine, önişleme tekniklerine,
nitelik sayısına bağlı olarak algoritmaların avantajları
ve dezavantajları var
 Aynı veri kümesi üzerinde farklı algoritmalar farklı
demetleme sonuçları üretebilir. Hangi demetlemenin
daha iyi olduğuna karar vermek gerekiyor
 uygulama alanını iyi incelemek gerekiyor
 demetleme sonucunu iyi anlamak gerekiyor
6
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 31
Bir Veri Kümesi için Farklı Demetlemeler
0 0.2 0.4 0.6 0.8 1 0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
x
y
Veri
Kümesi
0 0.2 0.4 0.6 0.8 1 0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
x
y
K-means
0 0.2 0.4 0.6 0.8 1 0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
x
y
DBSCAN
0 0.2 0.4 0.6 0.8 1 0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
x
y
Max
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 32
Demetleme Değerlendirme
 Gözetimli öğrenme için kullanılan yöntemler:
 Doğruluk, kesinlik, anma
 Demetleme yöntemlerinde değerlendirilmesi
gerekenler:
 Veri içinde gerçekte demetler var mı?
 Doğru demet sayısı bulunabiliyor mu?
 Hatalı veriler için örüntü bulunmaması
 Farklı demetleme algoritmalarını karşılaştırma
 Farklı demetlemeleri karşılaştırma
 Ek bir bilgi olmadan
 Sınıf etiketleri bilindiği durumda
 Oluşturulan demetler gerçeğe ne kadar yakın?
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 33
Veri Kümesi Demetlemeye Uygun mu?
 Veri kümesi içinde gruplar olmayabilir.
 Nesneler rasgele dağılmış
 Her demetleme algoritması veri kümesi üzerinde demetleme
yapar
 Hopkins istatistiği: Veri kümesi içinde demetler bulunup bulunmadığını test etmek için kullanılır
 Veri uzayında rasgele dağılmış p nokta üretilir {R}
 Veri kümesinden örnekleme ile p nokta seçilir {S}
 Her iki küme içindeki noktalar için veri kümesinden en yakın nesneler seçilir.
 ui yapay olarak üretilmiş noktalara olan uzaklık, wi veri kümesinden seçilmiş olan noktalara olan uzaklık
 Hopkins istatistiği
∑ ∑
∑
= =
=
+
= p
i
p
i
i i
p
i
i
u w
w
H
1 1
1
Rastgele üretilmiş noktalar ve veri kümesi
içindeki noktalar aynı en yakın komşu
uzaklığına sahipse H değeri yaklaşık 0.5 olur
Veri demetlemeye uygun değil.
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 34
Demetleme Değerlendirme Ölçütleri
 Üç yaklaşım:
 Harici Gösterge: Veri kümesi için öngörülen bir yapıya dayanarak
değerlendirme
 Dahili Gösterge: Ek bir bilgi kullanmadan veri kümesinden elde
edilen bilgiye dayanarak değerlendirme
 Göreceli Değerlendirme: Aynı algoritmanın farklı parametrelerini
kullanarak elde edilen demetleme sonuçlarını değerlendirme
 İki kriter:
 Sıkılık: Her demette bulunan nesneler birbirine mümkün olduğunca
yakın olmalı
 Uzaklık: Demetler birbirinden mümkün olduğunca uzak olmalı
 Tek bağ
 Tam bağ
 Demet merkezleri arasındaki uzaklık
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 35
Harici Değerlendirme
 Demetleme algoritması kullanılarak elde edilen
demetleme C={C1
,...,Ck
}
 Veri içinden bulunan gruplar P={P1
,...,Pm}
 Demetleme sonucundan elde edilen dağılım
 SS: Eğer iki nesne C için aynı demette ve P için aynı
grupta ise (a)
 SD: Eğer iki nesne C için aynı demette ancak P için farklı
gruplarda ise (b)
 DS: Eğer iki nesne C için farklı demette ancak P için aynı
grupta ise (c)
 DS: Eğer iki nesne C için farklı demette ancak P için aynı
grupta ise (d)
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 36
Harici Değerlendirme Ölçütleri
 Rand Statistics:
 Jaccard katsayısı:
 Folkes ve Mallows göstergesi:
a b c d
a d R + + +
+ =
a b c
a J + + =
a c
a
a b
a FM + ⋅ + =
7
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 37
Harici Değerlendirme Ölçütleri
 Entropi: Her demette sınıfların nasıl dağıldığı
 Saflık: Bir demette ne kadar tek sınıftan örnek
bulunduğu
∑
∑
=
=
=
= −
k
i
i
i
m
j
i ij ij
e n
n e
e p p
1
1
2 log m: sınıf sayısı
k: demet sayısı
pij= nij/ni
ni
: i demedindeki nesne sayısı
nij: i demedinde j sınıfından nesne sayısı
n: toplam nesne sayısı
∑=
=
=
k
i
i
i
ij j i
p n
n purity
p p
1
max
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 38
Dahili Değerlendirme Ölçütleri
 Sadece veri kümesi özellikleri kullanılarak yapılan
değerlendirme
 Hataların karelerinin toplamı (SSE)
 İki farklı demetlemeyi ya da iki demeti karşılaştırmak
için iyi bir yöntem
 Demet sayısını tahmin etmek için de kullanılabilir.
2 5 10 15 20 25 30 0
1
2
3
4
5
6
7
8
9
10
K
SSE
5 10 15
-6
-4
-2
0
2
4
6
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 39
Dahili Değerlendirme Ölçütleri
 Silhouette Göstergesi:
 xi nesnesi Cj demedinde
 Ortalama uzaklığa göre xi nesnesine en yakın demet Ch
 xi nesnesi için silhouette göstergesi
 -1 ≤ s(vi
) ≤ 1
 1’e yakın olursa xi doğru demette
 Demetleme için silhouette göstergesi:
max( ( , ), ( , ))
( , ) ( , ) ( )
i h i j
i h i j
i d x C d x C
d x C d x C s x − =
k
S
GS
Vj
s x
S
k
j
j
Vj
i
i
j
∑
∑
=
=
=
=
1
| |
1
| |
( )
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 40
Göreceli Değerlendirme
 Palg seçilen demetleme algoritmasının parametreleri
 Ci(i=1,...,nc):Palg’deki parametrelerin farklı değerleri ile elde edilen
demetlemeler
 Amaç: Farklı parametrelerle elde edilen demetlemeler arasında veriye
en çok uyanı seçme
 İki durum:
 Demet sayısı nc Palg’deki parametereler arasında değil:
 Palg’deki parametrelerin değerleri geniş bir aralıkta değiştirilerek demetleme algoritması çalıştırılır. nc << N (nesne sayısı) sabit kaldığı en geniş aralık seçilir. Parametre değerleri olarak bu aralığın orta noktası seçilir. Bu yöntemle demet sayısı da belirlenmiş olur.
 Demet sayısı nc Palg’deki parametereler arasında:
 En iyi demetleme, demetleme göstergesi q kullanarak seçilir.
 ncmin ve ncmax arasında değişen farklı demet sayıları için algoritma çalıştırılır.
 nc’nin her farklı değeri için algoritma diğer parametreleri değiştirerek r defa çalıştırılır.
 Her nc için q’nun en büyük değeri seçilir ve nc’nin fonksiyonu olarak çizilir. Bu çizim kullanılarak nc değeri belirlenir.
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 41
Göreceli Değerlendirme Ölçütleri
 Birbiri ile örtüşmeyen demetler için tanımlanmış
göstergeler:
 Hubert istatistiği:
 Dunn göstergesi:
∑ ∑
−
= + =
Γ = ⋅
1
1 1
(1/ ) ( , ) ( , )
N
i
N
j i
M P i j Q i j
N= veri kümesindeki nesne sayısı
M=N(N-1)/2
P: benzerlik matrisi
Q: (i,j) elemanı, xi ve xj nesnelerinin
bulundukları demetler arasındaki
uzaklık değeri olan matris
⎪⎭
⎪
⎬
⎫
⎪⎩
⎪
⎨
⎧ =
= = = + max ( )
( , ) min min
1,..., 1,..., 1,..., k nc k
i j
i nc j i nc diam c
d c c Dnc d(ci
,cj
)=min d(x,y)
diam(C)=max d(x,y)
x∈ci,y∈cj
x,y∈C
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 42
Hiyerarşik Demetleme için Gösterge
 Hiyerarşik demetleme için 4 gösterge
 Demetlerin standard sapmalarının karakökü
(RMSSTD)
 Semi-partial R-squared (SPR)
 R-Squared (RS)
 İki demet arası uzaklık (CD)
8
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 43
Örtüşen Demetleri Değerlendirme
 Örtüşen demetleme için U=[uij
] matrisi: xi nesnesinin cj
demedine dahil olma olasılığı
 Bölme katsayısı:
 [1/nc,1] arasında değişir.
∑∑= =
=
N
i
nc
j
uij N
PC 1 1
1 2
1
1
VERİ MADENCİLİĞİ
Sosyal Ağlar
Yrd. Doç. Dr. Şule Gündüz Öğüdücü
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 2
Sosyal Ağ
 Sosyal ağ kişiler arasındaki ilişkilerin
oluşturduğu bir yapıdır
 Sosyal ağ incelemesi: ağ yapısının, kişiler ya da
gruplar (topluluklar) arasındaki ilişkilerin ve
bilgi akışının incelenmesi
L.C. Freeman, Visualizing Social Networks. Journal of Social Structure, 2000.
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 3
Sosyal İlişkiler: Çizge
 Düğümler: Kişiler
 Ayrıtlar: sosyal
ilişkiler
 aile, arkadadaş, iş
 Çizge G(V,E)
 V: düğümler
kümesi
 E: Ayrıtlar kümesi
 Benzerlik Matrisi
S. Milgram (1967)
Yakınlığın Altı Derecesi: Six Degrees of Separation
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 4
Sosyal Ağların Özellikleri
 Farklı (doğal) ağlar
 sosyal, biyolojik, teknik, içerik..
 Ortak özellikleri
 Çok büyük, dinamik: düğümler, ayrıtlar
eklenebilir/silinebilir
 düğümler hangi düğümlerle ilişkide olacaklarına kendileri
karar veriyorlar
 düğümler arası etkileşim ayrıtlarla sınırlı
 uzaklık/benzerlik için soyut bilgi: coğrafi, içerik, ilişkiler
 Sosyal ağ kuramı: link analizi
 Farklı ağların genel özellikleri nelerdir?
 Bu özellikler nasıl belirlenir, nasıl ölçülür?
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 5
Sosyal Ağların Özellikleri
 Uzunluk (dG(s,t)): Iki düğüm (s,t) arasındaki en büyük,
en küçük, ortalama uzaklık
 Iki düğüm arasında bulunan yoldaki ayrıt sayısı
 Iki düğüm arasında bulunan yoldaki ayrıtların
ağırlıklarının toplamı
 Derece: yönlü ise düğüme gelen (in-link) / düğümden
çıkan (out-link) bağlantıların sayısı
 Merkez: Ağdaki diğer düğümlerin bağlı olduğu bir ya
da bir kaç düğüm
 Yoğunluk: Ağdaki bağlantı sayısının olası bütün
bağlantı sayısına oranı
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 6
Tanımlar
 σst= σts s ve t (s,t ∈ V) düğümleri arasındaki en kısa yol sayısı -> σss=1
 σst(v): v ∈ V düğümünün üzerinde bulunduğu s ve t düğümleri arasındaki
en kısa yol sayısı
∑∈
=
t V
G
c d v t C v ( , )
1 ( )
max ( , )
1 ( ) d v t C v
t V G
G
∈
=
∑≠ ≠ ∈
=
s v t V
st Cs(v) σ (v)
∑≠ ≠ ∈
=
s v t V st
st
B
v C v σ
σ ( ) ( )
closeness centrality (Sabidussi, 1966)
graph centrality (Hage and Harary, 1995)
stress centrality (Shimbel, 1953)
betweenness centrality
(Freeman, 1977; Anthonisse, 1971)
Ulrik Brandes, A Faster Algorithm for Betweenness Centrality, Journal of Mathematical Sociology 25(2):163-177, (2001).
2
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 7
Tanımlar
 Hizip (Clique):
 seçilebilecek her düğüm çifti arasında
bir bağ olan alt çizge
 tam bağlı alt çizge
 Daha zayıflatılmış
 N-Hizip (N-Clique): Bir düğümün içinde bulunduğu alt çizgedeki
diğer tüm düğümlere olan uzaklığı en çok N olabilir
 N-Klan (N-Clan): N-Hizipteki düğüm çiftleri arasındaki yollar
üstündeki düğümler de N-Hizip üyesi
 K-Plexes: Bir düğümün n düğümden oluşan bir N-Hizip içindeki en
az n-k düğüm ile doğrudan bağlı olması
 Kesitleme noktası (Cut Points): Bağlı olan bir G çizgesinden, v
düğümü ve bu düğüme bağlı olan bütün ayrıtlar çıkarıldığında
oluşan G-v çizgesi bağlı değil ise v kesitleme noktasıdır.
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 8
Sosyal Ağların Yeteneği
Diğer iki düğüm arasında
ilişkiye sağlamak/kesmek
İki düğüm arasında yer
alan düğüm Ara düğüm
Diğer düğümlerle doğrudan
etkileşim
Diğer düğümlere olan
yolun uzunluğu Yakınlık
Bir düğümün bağlantı sayısı daha fazla seçenek Derece
(Degree)
Özellik Tanım Etki
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 9
Problemler
 Bağlı parçalar:
 kaç parça, büyüklükleri ne, ne kadar bağlılar
 Ağ çapı:
 en uzak – ortalama
 Bağlı olmayan düğümler / parçalar
 Küçük dünya özelliği
 Demetleme
 Gruplaşan ilişkiler/düğümler
 Örtüşen gruplar
 Grup içi ve gruplar arası ilişkilerin oranı
 Grup içi ve gruplar arası ilişkilerin rolü
 Ağın yapısı
 düğümlerin derecesi
 ki
: i düğümünün derecesi, Ni
: i düğümünün komşular kümesi
 ilişkilerin ağırlığının dağılımı
 ağ içinde önemli rolü olan düğümler: iki grubu birbirine bağlayan
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 10
Web’de Sosyal Ağlar
 Facebook
 Myspace
 LinkedIn
 Classmates
 Orkut
 Bebo
Medya paylaşım siteleri:
 YouTube
 Flickr
11
Boyd, D. M., & Ellison, N. B. (2007). Social network sites: Definition, history, and scholarship.
Journal of Computer-Mediated Communication, 13(1), article 11.
http://jcmc.indiana.edu/vol13/issue1/boyd.ellison.html
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 12
Sosyal Ağlar için Modeller
 Rassal çizgeler (Random Graphs: Erdös-Rényi
models)
 Watts-Strogatz modelleri
 Scale-free Networks
3
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 13
Rassal Ağlar
 Erdös-Rényi (ER) Model: 1959 yılında
Paul Erdös ve Alfred Rényi
 düğüm sayısı N, iki düğüm arasında
ayrıt olasılığı p, G(N,p)
 p = 1/2N, p = 1/N, p = 2/N, p=10/N,
p = log(N)/N...
 N(N-1)/2 adet hileli yazı tura atma
 Derece dağılımı
 N çok büyük olduğunda Poisson dağılımı
 G(N,p) ile bir çizge oulştur, rastgele bir u düğümü
 Pr[deg(u) = k] ?
 Poisson dağılımı ortalama λ= p(N-1) ~ pN
 Demetleme katsayısı (clustering coefficient ) küçük
! ( ; ) k
e f k
k λ λ λ
−
=
{ }
∑=
=
∈ ∈ − =
N
i
i
j k i jk
i i
jk
C C
v v N e E k k
e Ci
1
: , , ( 1)
2
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 14
Erdös-Rényi Model (1960)
Pál Erdös
(1913-1996)
Connect with
probability p
p=1/6
N=10
〈k〉~1.5 Poisson distribution
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 15
Watts-Strogatz modelleri: Caveman and
Solaria
 Erdos-Renyi
 Ortak komşuları olması iki düğüm arasında ayrıt olma olasılığını artırmıyor
 her ayrıt daha öncekilerden bağımsız olarak oluşuyor
 Gerçekte oluşan ağ yapısına uygun değil
 iki kişinin tanışma olasılığı ortak arkadaşları varsa daha fazladır
 Web de iki sayfa biribirine bağlı ise büyük olasılıkla aynı konudadırlar
 Watts Caveman:
 ayrıtların genel olarak yoğunluğu az
 iki düğümün ortak komşuları varsa aralarında ayrıt olma olasılığı büyük
 Watts Solaria
 ayrıtların genel olarak yoğunluğu az, bir düğümün komşuları arasında ayrıt olma olasılığı farklı değil
 Erdos-Renyi çizgesine benzer
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 16
α-model
 α-model için parametreler
 N düğüm sayısı
 k: ortalama derece
 p: iki düğüm arasında ayrıt olma olasılığı
 α: yakın ilişkilerin olasılığını artırmak için parametre
 u,v düğüm çifti için
 m(u,v): ortak komşu sayısı
 R(u,v): iki düğümün arasında ayrıt olma eğilimi (propensity)
 m(u,v) >= k, R(u,v) = 1
 m(u,v) = 0, R(u,v) = p
 diğer durumlarda R(u,v) = p + (m(u,v)/k)^α (1-p)
 α→∞ için Erdös-Renyi çizgelerine benziyor
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 17
Watts-Strogatz Model
 Bir daire etrafında eşit dağılmış N düğüm
 Her düğümün en yakın k komşusu arasında k ayrıt (yakın ilişki)
 p olasılığı ile bir düğüme az sayıda rastgele ayrıt ekle (uzak ilişki)
 farklı p değerleri için farklı çizgeler
Collective dynamics of 'small-world' networks
Duncan J. Watts & Steven H. Strogatz
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 18
Small Worlds - Occam’s Razor
 küçük α değerleri için demetleme katsayısı
büyük
 Erdos-Renyi Æ çapı küçük
 α-model Æ büyük demetleme katsayısı
 Occam’s Razor
 farklı özellikler için basit tek bir model
 Watt’s small world:
 çapı küçük
 demetleme katsayısı büyük
4
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 19
Örnek
 üç gerçek ağ üzerinde inceleme
 Oyuncular
 batı bölgesindeki güç santralleri
 C.elegans sinir sistemi
C.elegans 282 14 2.65 0.28
Power-grid 4,941 2.67 18.7 0.08
Actors 225,226 61 3.65 0.79
n k d c
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 20
Small World
 Serbest Ölçekli Ağlar (Scale free): Örnek web
 düğümler web sayfaları
 ayrıtlar bağlantılar
web örümcekleri/web robotlar
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 21
Serbest Ölçekli Ağlar
 Düğüm sayısı N sabit değil
 Ağ sürekli yeni düğümlerin eklenmesi/silinmesi ile
değişiyor
 web: yeni sayfalar/siteler ekleniyor/siliniyor
 yayınlar: yeni yayınlar ekleniyor
 Eklenen düğümlerle oluşan ayrıtlar üniform değil
 çok sayıda sayfanın/sitenin bağlantı verdiği
sayfaya/siteye bağlantı verme olasılığı yüksek
 çok sayıda yayının referans gösterdiği yayının referans
gösterilme olasılığı yüksek
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 22
Serbest Ölçekli Ağlar
 Pareto veya power law
dağılımı
 çapı küçük (~log(N))
 demetleme katsayısı çok
büyük değil
 yakın komşuları ile ayrıt olma
olasılığı yüksek değil
 “hub” olan düğümlerle ayrıt
oluşturma olasılığı yüksek
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 23
Topluluk Belirleme
 S. Fortunato and C. Castellano, Community Structure
in Graphs, ArXiv e-prints
 Bir çizge içinde ortak özellikleri/görevleri olan
düğümler topluluğu
 aynı konudaki web sayfaları
 benzer işleve sahip proteinler
 aynı konuda çalışan insan grupları
 aynı ilgi alanına sahip insan grupları
 Topluluk içindeki topolojik konumlarına göre düğümler
sınıflandırılabilir
 topluluğun merkezinde yer alan düğüm
 topluluğun sınırında yer alan düğüm
24
Metabolik Protein
Sosyal Ekonomik
5
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 25
Topluluk Tanımı
 Dar tanım
 Geniş tanım
 Düğüm benzerliği
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 26
Dar Tanım
 Sadece alt çizgedeki ilişkilere göre toplulukları
belirliyor
Örnek: Hizip, n-klan, k-plexes
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 27
Geniş Tanım
 Topluluk çizginin yapısal bir birimi
 Altçizgeler hem kendi içindeki ilişkiler hem de
çizgenin geri kalanıyla olan ilişkileri ile
belirleniyor
 Null model: içinde topluluk bulunmayan çizge
 Erdös-Renyi
 Newman-Girvan: düğümlerin orjinal çizge ile
aynı dereceye sahip olduğu rassal çizge
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 28
Düğüm benzerliği
 Düğümler birbirine “benzer” ise aynı toplulukta
 dar
 geniş
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 29
Çizge Parçalama
 Graph Partitioning: Çizgeyi bir düğüm bir
grupta kalacak şekilde gruplara (altçizgelere)
bölme
 Problem:
 Örtüşen topluluklar
 Hiyerarşik yapı
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 30
Örtüşen Topluluklar
 Gerçek dünyada bir nesne birden fazla gruba
üye olabilir
G. Palla, I. Derényi, I. Farkas, T. Vicsek,
Uncovering the overlapping community structure of
complex networks in nature and society
Nature 435, 814, 2005
http://www.cfinder.org/
6
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 31
Hiyerarşik Yapı
 Altçizgeler tekrar
parçalanabilir
A. Clauset, C. Moore, M.E.J. Newman,
Hierarchical structure and prediction of missing links
Nature 453, 98, 2008
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 32
Çizge Parçalama
 Hangisi daya iyi
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 33
İki Farklı Sonuç
 Üstünlüklerini karşılaştırmak için bir kriter Q
 Q(P1) > Q(P2) veya Q(P1) < Q(P2) ?
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 34
Birimsellik
 Modularity:
Bitişiklik Matrisi: ⎩
⎨
⎧ ∈ = 0 diger
(u,v) E
Auv
1
∑
∑
∈
∈
=
=
v V
u uv
u v V
uv
k A
A m , 2
∑
∑
∑
= −
=
=
= ∩ = ∅ ≠ =
∈
∈ ∈
∈
i
ii i
v c
i v
u c v c
ij uv
i c C i j
Q G C e a
a k m
e A m
C c c c c i j c V
i
i j
i
( , ) ( )
/ 2
/ 2
{ , ,...}, ( )
2
,
1 2 U
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 35
Girvan-Newman Algoritması
 M. Girvan & M.E.J Newman, Community
structure in social and biological networks,
PNAS 99, 7821-7826 (2002)
 Toplulukları birbirine bağlayan ayrıtları belirle
 Betweenness
 bu ayrıtları silme
 birbirinden ayrık demetler
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 36
Girvan-Newman Algoritması
1. Bütün ayrıtların “betweenness” değerleri
hesaplanır
2. En büyük “betweenness” değerine sahip ayrıt
silinir
3. Kalan ayrıtların “betweenness” değerleri
hesaplanır
4. 2. adıma geri dönülür
7
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 37
Geliştirilmiş Girvan-Newman Algoritması
 M.E.J. Newman & M. Girvan, Finding and
evaluating community structure in networks,
Phys. Rev. E 69, 026113 (2004)
1. Her düğüm bir demet
2. Q değerini en büyütecek iki düğümü birleştir
3. Bütün düğümler tek demet olana kadar işleme
devam et
4. En fazla Q değerine sahip demetlemeyi seç
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 38
Problemler
 Örtüşen topluluklar
 Yönlü çizgeler
 Ağırlıklı çizgeler
 Karmaşıklık
1
1
VERİ MADENCİLİĞİ
İlişkilendirme Kuralları
Yrd. Doç. Dr. Şule Gündüz Öğüdücü
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 2
İlişkilendirme Kuralları Madenciliği
 İlişkilendirme kuralı madenciliği
 Veri kümesi içindeki yaygın örüntülerin, nesneleri
oluşturan nitelikler arasındaki ilişkilerin bulunması
 İlişkilendirme kurallarını kullanma: veri içindeki
kuralları belirleme
 Hangi ürünler çoğunlukla birlikte satılıyor?
 Kişisel bilgisayar satın alan bir kişinin bir sonraki satın
alacağı ürün ne olabilir?
 Yeni bir ilaca duyarlı olan DNA tipleri hangileridir?
 Web dökümaları otomatik olarak sınıflandırılabilir mi?
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 3
İlişkilendirme Kuralları Bulma
 Bir niteliğin (veya nitelikler kümesinin) varlığını harekette
bulunan başka niteliklerin varlıklarına dayanarak
öngörme
{a,b,c,...}
{x,y,..}
{ , , }
hareketlerde
sıkça birlikte yer
alan nitelikleri
bulur
 Kural şekli: “Gövde Baş [destek, güven] “
satın alma(x, “ekmek”) satın alma (x, “süt”) [%0.6, %65]
öğrenci(x, “BLG”), kayıt(x, “VTYS”) not(x, “A”) [%1, %75]
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 4
İlişkilendirme Kuralları Bulma
 Bütün niteliklerden oluşan küme I={i1, i2,...,id}
 I={ekmek, süt, bira, kola, yumurta, bez}
 Hareket Tj
⊆I, Tj={ij1, ij2,...,ijk}
 T1={ekmek, süt}
 Hareketlerden oluşan veri kümesi D={T1
,T2
,...,TN}
Market Alışveriş verisi
Hareket Öğeler
T1 Ekmek, Süt
T2 Ekmek, Bez, Bira, Yumurta
T3 Süt, Bez, Bira, Kola
T4 Ekmek, Süt, Bez, Bira
T5 Ekmek, Süt, Bez, Kola
Bulunan İlişkilendirme Kuralları
{Bez} → {Bira},
{Süt, Ekmek} → {Yumurta, Kola},
{Bira, Ekmek} → {Süt}
Yaygın nitelikler:
Bez, bira
Süt, ekmek, yumurta, kola
Bira, ekmek, süt
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 5
Yaygın Nitelikler
 nitelikler kümesi (Itemset)
 Bir veya daha çok nitelikten oluşan küme
 k-nitelikler kümesi (k-itemset): k nitelikten oluşan
küme
 3-nitelikler kümesi: {Bez, Bira, Ekmek}
 Destek sayısı σ (Support count)
 Bir nitelikler kümesinin veri kümesinde görülme sıklığı
 σ({Süt, Ekmek, Bez}) = 2
 Destek s (Support)
 Bir nitelikler kümesinin içinde bulunduğu hareketlerin
toplam hareketlere oranı
 s({Süt, Ekmek, Bez}) = 2 /5 http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 6
İlişkilendirme Kuralları
 Veri kümesi D={T1,T2,...,TN}
 en az, en küçük destek ve güven
değerine sahip X Y şeklinde
kuralların bulunması
 X ⊂I, Y⊂I, X∩Y=∅
 Kuralları değerlendirme ölçütleri
 destek (support) s: X∪Y nitelikler kümesinin bulunduğu hareket sayısının toplam hareket sayısına oranı
 güven (confidence) c: X∪Y nitelikler kümesinin bulunduğu hareket sayısının X nitelikler kümesi bulunan hareket
sayısına oranı
TID Öğeler
T1 Ekmek, Süt
T2 Ekmek, Bez, Bira, Yumurta
T3 Süt, Bez, Bira, Kola
T4 Ekmek, Süt, Bez, Bira
T5 Ekmek, Süt, Bez, Kola
Örnek:
{Süt, Bez} ⇒ {Bira}
0,67 3
2
( , )
( , , )
0,4 5
2
| |
( , , )
= = =
= = =
sut bez
sut bira bez confidence
T
sut bira bez support
σ
σ
σ
N
X Y support(X Y) ∪ → = #
X
X Y confidence X Y #
#( ) ( ) ∪ → =
2
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 7
İlişkilendirme Kuralları Oluşturma
 İlişkilendirme kuralları madenciliğinde temel amaç: D hareket
kümesinden kurallar oluşturmak
 kuralların destek değeri, belirlenen en küçük destek (minsup)
değerinden büyük ya da eşit olmalı
 kuralların güven değeri, belirlenen en küçük güven (minconf)
değerinden büyük ya da eşit olmalı
 Brute-force yaklaşım
 Olası bütün kuralları listele
 Her kural için destek ve güven değeri hesapla
 minsup ve minconf eşik değerlerinden küçük destek ve güven
değerlerine sahip kuralları sil
 hesaplama maliyeti yüksek
3 2 1 1 = − + d d + R
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 8
İlişkilendirme Kuralları Özellikleri
 Aynı nitelikler kümesinin ikili bölünmesine (binary partition) ait
kurallar
 {Süt, Bez, Bira}
 Aynı nitelikler kümesinden oluşan kuralların destek değerleri
aynı, güven değerleri farklı
 Kurallar için destek ve güven şartları ayrı değerlendirilebilir
TID Öğeler
1 Ekmek, Süt
2 Ekmek, Bez, Bira, Yumurta
3 Süt, Bez, Bira, Kola
4 Ekmek, Süt, Bez, Bira
5 Ekmek, Süt, Bez, Kola
Örnek Kurallar:
{Süt, Bez} → {Bira} (s=0.4, c=0.67)
{Süt, Bira} → {Bez} (s=0.4, c=1.0)
{Bez, Bira} → {Süt} (s=0.4, c=0.67)
{Bira} → {Süt, Bez} (s=0.4, c=0.67)
{Bez} → {Süt, Bira} (s=0.4, c=0.5)
{Süt} → {Bez, Bira} (s=0.4, c=0.5)
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 9
İlişkilendirme Kuralları Oluşturma
 İki adımda gerçeklenir
1. Yaygın nitelikleri belirleme:
 destek değeri minsup değerinden büyük ya da eşit olan
nitelikler kümelerini bulma
2. Kural Oluşturma:
 Destek değeri minconf değerinden büyük ya da eşit olan ve
yaygın niteliklerin ikili bölünmeleri olan kurallar oluşturma
 Güçlü kurallar
Yaygın nitelikleri belirleme
abc
1
İlişkilendirme Kuralları Oluşturma
ab c, b ac
2
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 10
Yaygın nitelik Adayları Oluşturma
 Yaygın nitelikleri bulmak
maliyetli
 d nitelik için 2d -1 yaygın
nitelik oluşabilir
 2d -1 yaygın nitelik adayı
null
AB AC AD AE BC BD BE CD CE DE
A B C D E
ABC ABD ABE ACD ACE ADE BCD BCE BDE CDE
ABCD ABCE ABDE ACDE BCDE
ABCDE
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 11
Yaygın Nitelik Oluşturma
 Brute-Force Yaklaşım
 Her yaygın nitelik adayı için veri kümesini taranarak hareketlerde
yaygın nitelik adayı bulunup bulunmadığı kontrol edilir
 yaygın nitelik adayları için destek değeri bulunur
 Destek değeri minsup değerine eşit yada büyük olanlar yaygın
nitelikler
 karmaşıklığı: O(NMw), M=2d - 1⇒ hesaplaması maliyetli
TID Öğeler
1 Ekmek, Süt
2 Ekmek, Bez, Bira, Yumurta
3 Süt, Bez, Bira, Kola
4 Ekmek, Süt, Bez, Bira
5 Ekmek, Süt, Bez, Kola
Yaygın nitelik
adayları
M
N
w
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 12
Yaygın nitelik Oluşturma Yöntemleri
 Yaygın nitelik aday sayısını (M) azaltma
 Örnek: Apriori algoritması
 Hareket sayısını (N) azaltma
 Veri kümesi tarama sayısını (MN) azaltma
3
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 13
Apriori Algoritması
 Apriori yöntemi
 Rakesh Agrawal, Ramakrishnan Srikant, Fast Algorithms for Mining
Association Rules, Proc. 20th Int. Conf. Very Large Data Bases,
VLDB’94
 Heikki Mannila, Hannu Toivonen, Inkeri Verkamo, Efficient
Algorithms for Discovering Association Rules . AAAI Workshop on
Knowledge Discovery in Databases (KDD-94).
 Temel yaklaşım:
 Bir nitelikler kümesinin destek değeri altkümesinin destek
değerinden büyük olamaz
 anti-monotone özellik
∀X,Y : (X ⊆ Y ) ⇒ s(X ) ≥ s(Y )
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 14
Apriori Algoritması
 Bir yaygın nitelikler kümesinin herhangi bir altkümesi de yaygın
nitelikler kümesidir
 {Süt, Bez, Bira} kümesi yaygın nitelikler kümesi ise {Süt, Bez} kümesi
de yaygın nitelikler kümesidir
 {Süt, Bez, Bira} nitelikler kümesi olan her harekette {Süt, Bez}
kümesi de vardır
 Yaygın nitelik aday sayısını azaltma yöntemi: Yaygın nitelikler kümesi
olmayan bir kümenin üst kümeleri yaygın nitelik adayı olarak
oluşturulmaz (destek değeri hesaplanmaz)
 Yöntem:
 k-yaygın nitelikler kümesinden (k+1) yaygın nitelik adayları oluştur
 yaygın nitelik adayları için destek değeri hesapla
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 15
Apriori Yaygın nitelik Azaltma
Yöntemi
yaygın
nitelik
olmadığı
belirlendi
oluşturulmayan
üstkümeler
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 16
Apriori Algoritması: Örnek
Öğe Sayı
Ekmek 4
Kola 2
Süt 4
Bira 3
Bez 4
Yumurta 1
Öğeler kümesi Sayı
{Ekmek,Süt} 3
{Ekmek,Bira} 2
{Ekmek,Bez} 3
{Süt,Bira} 2
{Süt,Bez} 3
{Bira,Bez} 3
Öğeler Kümesi Sayı
{Ekmek, Süt, Bez} 3
1-nitelikler kümesi
2-nitelikler kümesi
(kola ya da yumurta olan
nitelikler kümesini yaygın
nitelik adayı olarak
oluşturmaya gerek yok)
3-nitelikler kümesi minsup = 3
Her nitelikler kümesi için destek hesaplansaydı,
C1 + C2 + C3 = 6 + 15 + 20 = 41
Yaygın nitelik sayısı azaltılınca,
6 + 6 + 1 = 13
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 17
Apriori Algoritması
 Pseudo-code:
Ck
: Candidate itemset of size k
Lk : frequent itemset of size k
L1 = {frequent items};
for (k = 1; Lk !=∅; k++) do begin
Ck+1 = candidates generated from Lk
;
for each transaction t in database do
increment the count of all candidates in Ck+1
that are contained in t
Lk+1 = candidates in Ck+1 with min_support
end
return ∪k Lk
;
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 18
Yaygın Nitelikler Adayı Oluşturma
 Lk-1 kümesinde nitelikler alfabetik sıralanmış olsun
 1. adım: Lk-1 kendisiyle birleştirme
insert into Ck
select p.item1, p.item2, …, p.itemk-1, q.itemk-1
from Lk-1 p, Lk-1 q
where p.item1=q.item1, …, p.itemk-2=q.itemk-2, p.itemk-1 <
q.itemk-1
 2. adım: Eleme
forall itemsets c in Ck do
forall (k-1)-subsets s of c do
if (s is not in Lk-1) then delete c from Ck
4
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 19
Örnek: Yaygın nitelikler Adayı Oluşturma
 Yaygın nitelik adayları oluşturma:
 Lk kendisiyle birleştirilir (self join)
 eleme
 Örnek:
 L3={abc, abd, acd, ace, bcd}
 Kendisiyle birleştirme: L3*L3
 abc ve abd nitelikler kümesinden abcd
 acd ve ace nitelikler kümesinden acde
 Eleme
 ade L3 kümesinin bir elemanı olmadığından acde yaygın niteliklere dahil
edilmez
 C4={abcd}
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 20
Yaygın niteliklerden İlişkilendirme
Kuralları Oluşturma
 Sadece güçlü ilişkilendirme kuralları oluşuyor
 Yaygın nitelikler minsup değerini sağlıyor
 Güçlü ilişkilendirme kuralları minconf değerini sağlıyor.
 Güven (A B)=Prob(B|A)=Destek(A∪B)
Destek(A)
 Yöntem:
 Her yaygın nitelikler kümesi f ’in altkümelerini oluştur
 Her altküme s için, s (f-s) ilişkilendirme kuralı oluştur
eğer:
destek(f) / destek(s) ≥ minconf ise
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 21
Apriori Algoritmasını Geliştirme
 Veritabanı tarama sayısını azaltma
 k-yaygın nitelikler kümesi için veritabanı k kez
taranıyor
 Hash yöntemi ile veritabanı tarama sayısını
azaltma
 Veritabanındaki hareket sayısını ve
hareketlerdeki nitelik sayısını azaltma
 yaygın olmayan niteliklerin veritabanında yer
almasına gerek yok
 Arama uzayını parçalama
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 22
Eniyilime: Hash Ağacı
 Her yaygın nitelik adayının destek değerinin
belirlenmesi için veri kümesi taranır
 Yaygın nitelik adayı sayısı çok büyük olabilir
 Karşılaştırma sayısını azaltmak için yaygın
nitelik adayları hash ağacında saklanır
 Her hareket bütün yaygın niteliklerle
karşılaştırılmak yerine hash ağacının ilgili
bölümündeki yaygın nitelikler adayları ile
karşılaştırır
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 23
Hash Ağacı Oluşturma
 15 adet 3-nitelikler kümesi
{1 4 5}, {1 2 4}, {4 5 7}, {1 2 5}, {4 5 8}, {1 5 9}, {1 3 6}, {2 3 4},
{5 6 7}, {3 4 5}, {3 5 6}, {3 5 7}, {6 8 9}, {3 6 7}, {3 6 8}
 Hash fonksiyonu kullanılarak bir hash ağacında saklanıyor
 h(p) = p mod 3
 max yaprak boyutu: bir yaprakta bulunabilecek nitelik kümesi sayısı
2 3 4
5 6 7
1 4 5 1 3 6
1 2 4
4 5 7 1 2 5
4 5 8
1 5 9
3 4 5 3 5 6
3 5 7
6 8 9
3 6 7
3 6 8
1,4,7
2,5,8
3,6,9
Hash fonksiyonu
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 24
Bir Harekette Bulunabilecek Yaygın
nitelikleri Belirleme
 t hareketinin 3-
nitelikler kümesi 1 2 3 5 6
Hareket t
1 2 3 5 6 2 3 5 6
1 2 3 5 6 1 3 5 6 1 5 6 2 3 5 6 2 5 6
3 5 6
1 2 3
1 2 5
1 2 6
1 3 5
1 3 6 1 5 6 2 3 5
2 3 6 2 5 6 3 5 6
3-nitelikler kümesi
Seviye 1
Seviye 2
Seviye 3
3 5 6
5
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 25
Bir Harekette Bulunabilecek Yaygın
nitelikleri Hash Ağacı ile Belirleme
1 5 9
1 4 5 1 3 6
3 4 5 3 6 7
3 6 8
3 5 6
3 5 7
6 8 9
2 3 4
5 6 7
1 2 4
4 5 7
1 2 5
4 5 8
1,4,7
2,5,8
3,6,9
Hash Fonksiyonu 1 2 3 5 6
1 2 + 3 5 6
1 3 + 5 6
1 5 + 6
2 + 3 5 6
3 + 5 6
1 + 2 3 5 6
hareket
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 26
Bir Harekette Bulunabilecek Yaygın
nitelikleri Hash Ağacı ile Belirleme
1 5 9
1 4 5 1 3 6
3 4 5 3 6 7
3 6 8
3 5 6
3 5 7
6 8 9
2 3 4
5 6 7
1 2 4
4 5 7
1 2 5
4 5 8
1,4,7
2,5,8
3,6,9
Hash Fonksiyonu 1 2 3 5 6
1 2 + 3 5 6
1 3 + 5 6
1 5 + 6
2 + 3 5 6
3 + 5 6
1 + 2 3 5 6
hareket
15 yaygın nitelik adayının 11’i ile karşılaştırıldı
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 27
Karmaşıklığı Etkileyen Etmenler
 Veri kümesindeki boyut sayısı (nitelik sayısı)
 her niteliğin destek değerini saklamak için daha fazla saklama
alanına ihtiyaç var
 Veri kümesinin büyüklüğü
 Veri kümesi tarandığı için veri kümesindeki hareket sayısının fazla
olması algoritmanın çalışma süresini uzatır
 Hareketlerin ortalama büyüklüğü (nitelik sayısı)
 Yoğun veri kümelerinde hareketlerdeki nitelik sayısı fazla olur
 Yaygın nitelik kümelerindeki nitelik sayısı daha fazladır
 En küçük destek değerini belirleme
 En küçük destek değerini küçültme daha fazla sayıda yaygın nitelik
oluşmasına neden olur
 Yaygın nitelik adayı sayısının ve yaygın nitelik kümesindeki
niteliklerin sayısının artmasına neden olur
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 28
Yaygın Nitelikleri Belirlemede
Sorunlar
 Sorunlar
 Veri kümesinin birçok kez taranması
 Yaygın nitelikler aday sayısının fazlalığı
 Yaygın nitelikleri bulmak için i1i2…i100
 veri kümesini tarama sayısı: 100
 Aday sayısı: (1001) + (1002) + … + (1
1
0
0
0
0) = 2100-1 = 1.27*1030 !
 Yaygın nitelikler adayları için destek değerinin hesaplanması
 Çözümler
 Veri kümesi tarama sayısını azaltma (S. Brin R. Motwani, J. Ullman, and S. Tsur. Dynamic itemset counting and implication rules for market basket data. In SIGMOD’97)
 Yaygın nitelik aday sayısını azaltma (J. Park, M. Chen, and P. Yu. An effective hash-based algorithm for mining association rules. In SIGMOD’95)
 Destek değerinin hesaplanmasını kolaylaştırma (M. Zaki et al. New
algorithms for fast discovery of association rules. In KDD’97)
 Yaygın nitelikler adayı oluşturmadan yaygın nitelikler bulunabilir. (J. Han, J. Pei, and Y. Yin, Mining Frequent Patterns without Candidate Generation. In SIGMOD'00.)
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 29
Aday Oluşturmadan Yaygın Nitelikleri
Belirleme
 Kısa yaygın niteliklere yeni nitelikler eklenerek
daha uzun yaygın nitelikler elde etme
 Örnek:
 “abc” bir yaygın nitelik
 Veri kümesinde içinde “abc” nitelikleri bulunan
hareketler (DB|abc)
 DB|abc içinde d yaygın nitelik olarak bulunursa:
“abcd” yaygın nitelik olarak belirlenir
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 30
FP-Tree Algoritması
{}
f:4 c:1
b:1
p:1
c:3 b:1
a:3
m:2 b:1
p:2 m:1
Başlık Tablosu
nitelik sayı ilk nitelik
f 4
c 4
a 3
b 3
m 3
p 3
minsup = 3
TID nitelikler (sıralı) yaygın nitelikler
100 {f, a, c, d, g, i, m, p} {f, c, a, m, p}
200 {a, b, c, f, l, m, o} {f, c, a, b, m}
300 {b, f, h, j, o, w} {f, b}
400 {b, c, k, s, p} {c, b, p}
500 {a, f, c, e, l, p, m, n} {f, c, a, m, p}
1. DB bir kez taranarak 1-
yaygın nitelik
bulunuyor
2. Yaygın nitelikler destek
sayısına göre büyükten küçüğe sıralanıor, f-list
3. DB bir kez daha
taranarak FP-ağacı oluşturuluyor. F-list=f-c-a-b-m-p
6
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 31
FP-Ağacının Özelliği
 Bütünlük
 Yaygın nitelikleri bulmak için gerekli tüm bilgiyi
barındırır
 Sıkıştırılmış
 Yaygın olmayan nitelikler FP-ağacında bulunmaz
 Destek sayısı daha büyük olan nitelikler köke
daha yakın
 Asıl veri kümesinden daha büyük değil
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 32
Örüntüleri ve Veri Kümesini Bölme
 Yaygın nitelikler f-listesine göre altkümelere
bölünür
 F-list=f-c-a-b-m-p
 p niteliksi bulunan örüntüler
 m niteliği bulunan ancak p niteliği bulunmayan
örüntüler
 ...
 c niteliği bulunan ancak a, b, m, p niteliği
bulunmayan örüntüler
 f niteliksi bulunan örüntüler
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 33
Nitelik Koşullu Örüntü Oluşturma
 Başlık tablosundan her niteliğin bulunduğu ilk düğüm bulunur.
 Bu düğümden başlayarak ağaçta niteliğin bulunduğu tüm düğümlere
ulaşılır
 Kökten niteliğe kadar olan yollar bulunur (transformed prefix paths)
nitelik Koşullu Örüntü
nitelik koşullu örüntü
c f:3
a fc:3
b fca:1, f:1, c:1
m fca:2, fcab:1
p fcam:2, cb:1
{}
f:4 c:1
b:1
p:1
c:3 b:1
a:3
m:2 b:1
p:2 m:1
Başlık Tablosu
nitelik Sayı İlk nitelik
f 4
c 4
a 3
b 3
m 3
p 3
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 34
Nitelik Koşullu Örüntülerden Koşullu FPAğaçları Oluşturma
 Her koşullu örüntü için niteliklerin destek sayısı
bulunur
 Yaygın nitelikler için koşullu FP-ağacı oluşturulur
m-koşullu örüntüler
fca:2, fcab:1
{}
f:3
c:3
a:3
m-koşullu FP-ağacı
¼ ¼
{}
f:4 c:1
b:1
p:1
c:3 b:1
a:3
m:2 b:1
p:2 m:1
Başlık Tablosu
nitelik sayı ilk nitelik
f 4
c 4
a 3
b 3
m 3
p 3
m niteliği bulunan tüm yaygın nitelikler
m,
fm, cm, am,
fcm, fam, cam,
fcam
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 35
Koşullu FP-Ağaçları
{}
f:3
c:3
a:3
m-koşullu FP-ağacı
“am” niteliklerinin koşullu
örüntüleri: (fc:3)
“cm” niteliklerinin koşullu
örüntüleri:(f:3)
“cam” niteliklerinin koşullu
örüntüleri: (f:3)
{}
f:3
cam-koşullu FP-ağacı
m:3, am:3, cm:3, fm:3, cam:3, fam:3, fcam:3, fcm:3
{}
f:3
c:3 am-koşullu FP-ağacı
{}
f:3
cm-koşullu FP-ağacı
“fm” niteliklerinin koşullu
örüntüleri:3
“fam” niteliklerinin koşullu
örüntüleri: 3
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 36
FP-Ağaçları ile Yaygın nitelikleri Bulma
 Yaygın niteliklere yinelemeli olarak yeni nitelikler
ekleme
 Yöntem:
 Her yaygın niteliğin koşullu örüntülerini ve koşullu FPağacını oluştur
 İşlemi, yeni oluşturulan her koşullu FP-ağacı için tekrarla
 Oluşturulan FP-ağaçlarında hiç nitelik bulunmayana
kadar veya ağaçta tek bir dal kalana kadar işleme
devam et
 Ağaçta tek bir dal kaldığında yaygın nitelikler dalı oluşturan
niteliklerin kombinasyonu
7
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 37
İlişkilendirme Kuralları Oluşturma
 L yaygın niteliklerden f⊂L altkümelerinin bulunması
 f→L-f kurallarının en küçük güven değeri koşulunu
sağlaması gerekir
 Eğer {A,B,C,D} yaygın nitelikler ise olası ilişkilendirme
kuralları
ABC →D, ABD →C, ACD →B, BCD →A,
A →BCD, B →ACD, C →ABD, D →ABC
AB →CD, AC → BD, AD → BC, BC →AD,
BD →AC, CD →AB
 |L| = k için 2k – 2 ilişkilendirme kuralı adayı vardır
 L → ∅ ve ∅ → L kuralları geçerli kurallar değildir
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 38
İlişkilendirme Kuralları Oluşturma
 İlişkilendirme kurallarının güven değerlerinin antimonotone özelliği yok
 c(ABC →D) değeri c(AB →D) değerinden küçük ya da
büyük olabilir
 Aynı yaygın nitelikler kümesinden L = {A,B,C,D}
oluşan ilişkilendirme kurallarının güven değerleri için
anti-monotone özelliği var
 c(ABC → D) ≥ c(AB → CD) ≥ c(A → BCD)
 İlişkilendirme kuralının solunda bulunan nitelik sayısı
büyük olan kuralların güven değerleri de büyüktür.
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 39
Apriori Algoritması için Kural Oluşturma
Elenen
kurallar
Düşük
güven
değerli
kural
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 40
Apriori Algoritması için Kural Oluşturma
 Sağ taraflarındaki niteliklerin
önekleri aynı olan iki kural
birleştirilir
 (CD=>AB,BD=>AC) kuralları
birleştirilerek D => ABC kural
adayı oluşturulur.
 AD=>BC kuralının güven
değeri büyük değilse
D => ABC kuralı elenir
CD=>AB BD=>AC
D=>ABC
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 41
Destek Değerinin Etkisi
 minsup değeri büyük belirlenirse veri
kümesinden bazı örüntüler elde edilmeyebilir:
 veri kümesinde daha az bulunan
 önemli bilgi taşıyan
 minsup değeri küçük belirlenirse
 yöntem karmaşıklaşır
 çok fazla sayıda yaygın nitelikler kümesi elde
edilir
 Tek bir destek değeri her zaman yeterli
olmayabilir.
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 42
Bulunan Kuralların Önemi
 Tarafsız Ölçüt:
 Örüntüler veri kümesinden elde edilen
istatistiklere göre sıralanır
 güven, destek, Jaccard, Gini, ...
 Taraflı Ölçüt
 Örüntüler kullanıcının değerlendirmesine göre
sıralanır
 Bulunan örüntü kullanıcının beklentisi dışındaysa
ilginçtir (Silberschatz & Tuzhilin)
8
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 43
Bulunan Kuralların Önemi
 Taraflı değerlendirme için kullanıcının beklentisinin
modellenmesi gerekir
+ Yaygın olduğu düşünülen örüntü
- Yaygın olmadığı düşünülen örüntü
Yaygın olduğu bulunan örüntü
Yaygın olmadığı bulunan örüntü
+
-
- Beklenen örüntüler
+ Beklenmeyen örüntüler
1
1
VERİ MADENCİLİĞİ
İlişkilendirme Kuralları:
Farklı Yöntemler
Yrd. Doç. Dr. Şule Gündüz Öğüdücü
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 2
Çok Katmanlı İlişkilendirme Kuralları
 Nitelikler bir hiyerarşi
oluşturabilir.
 kavram hiyerarşisi
 Daha alt katmanlarda yer alan
ürünlerin destek değeri daha
düşük
 Alt seviyelerde oluşan kurallar
özel durumları tanımlıyor
Beyaz ekmek => normal süt
Kepekli ekmek => normal süt
Kepekli ekmek => diyet süt
kuralları ekmek => süt
kuralının bir göstergesi
Yiyecek
Ekmek
Beyaz Kepekli
Süt
Normal Diyet
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 3
Çok Katmanlı İlişkilendirme Kuralları
 Destek ve güven değerlerinin katmanlar arasında
değişimi
 X1 ve X2 niteliklerinin üst düğümünde yer alan nitelik X
σ(X) ≥ σ(X1) + σ(X2)
 σ(X1 ∪ Y1) ≥ minsup, X1 niteliğinin üst düğümünde yer
alan nitelik X, Y1 niteliğinin üst düğümünde yer alan
nitelik Y
σ(X ∪ Y1) ≥ minsup, σ(X1 ∪ Y) ≥ minsup
σ(X ∪ Y) ≥ minsup
 conf(X1 ⇒ Y1) ≥ minconf ise conf(X1 ⇒ Y) ≥ minconf
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 4
Çok Katmanlı İlişkilendirme Kuralları
 1. Yaklaşım:
Her hareket t, üst katmanlardaki nitelikler cinsinden
yazılarak genişletilmiş harekete t’ dönüştürülür
t = {beyaz ekmek, normal süt}
t’ = {beyaz ekmek, normal süt, ekmek, süt, yiyecek}
t’ hareketleri için ilişkilendirme kuralları bulunur
 Problemler:
 Üst düğümlerde yer alan niteliklerin destek değerleri daha
büyük
 Farklı seviyelerde farklı destek değerleri
 Veri kümesinin boyutu artıyor
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 5
Çok Katmanlı İlişkilendirme Kuralları
 Alt katmanlarda destek değerini küçültme
 Her katmanda bağımsız hesaplama (Level-bylevel independent)
 Üst düğümleri yaygın nitelik olan niteliklerin
destek değerini hesaplama
 Tek niteliğe göre budama (Level-cross filtering by
single item)
 nitelikler kümesine göre budama (Level-cross filtering
by k-itemset)
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 6
Çok Katmanlı İlişkilendirme Kuralları
 2. Yaklaşım
İlk olarak en üst katman için yaygın nitelikler
bulunur
Her aşamada bir alt katmandaki nitelikler
arasındaki ilişkiler bulunur
 Problemler:
 Kullanışlı değil: her katman için veri kümesi
araştırılıyor
 Farklı katmanlar arasındaki ilişkiler bulunamıyor
2
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 7
Gereksiz Kuralları Eleme
 Ürünler arasındaki ilişki nedeniyle bazı kurallar
gereksiz olabilir
 Örnek
 satın_alma (X, “Ekmek”) => satın_alma(X,”Süt”) [%8, %70]
 satın_alma (X, “Beyaz Ekmek”) => satın_alma(X,”Süt”) [%2,%70]
 İlk kural ikinci kuralın üst kuralı
 Eğer bir kuralın destek değeri üst kuralının destek
değerinden tahmin edilebiliyorsa gereksizdir
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 8
Nicel İlişkilendirme Kuralları
 Örnek ilişkilendirme kuralları:
yaş:30-39, medeni durum: evli => araba sayısı:2
(destek: %40, güven: %100)
araba sayısı: 0-1 => medeni durum: bekar
(destek: %40, güven: %66,70)
Kayıt
No
Yaş Medeni
Durum
Araba
Sayısı
1 23 Bekar 1
2 25 Evli 1
3 29 Bekar 0
4 34 Evli 2
5 38 Evli 2
… … … … 10
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 9
Nicel İlişkilendirme Kuralları
 İkili değişkenlerden oluşan ilişkilendirme kurallarına dönüştürülüyor:
 Kategorik olamayan nitelik değerleri için bölmeleme
 yaş: 20-29, 30-39
 ikili değişken oluşturma
 kategorik niteliklerin her değeri için bir ikili değişken
 kategorik olmayan niteliklerin her bölmesi için bir ikili değişken
Kayıt
No
Yaş Medeni
Durum
Araba
Sayısı
1 23 Bekar 1
5 38 Evli 2 10
Kayıt
No
Yaş
20-29
Yaş
30-39
M.Durum
Evli
M.Durum
Bekar
Araba
0
Araba
1
Araba
2
1 1 0 0 1 0 1 0
5 0 1 1 0 0 0 1 10
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 10
Nicel İlişkilendirme Kuralları
 Dönüştürmeden kaynaklanan problemler
 bölme sayısı az: Bilgi kaybolması
 Destek değeri küçük: fazla sayıda kural
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 11
Yaygın Altçizge Madenciliği
 Frequent Subgraph Mining
 İlişkilendirme kuralları madenciliği yöntemleri uygulanarak yaygın altçizgeler bulunur
 Uygulama alanları
 Web madenciliği
 Biyoenformatik
:
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 12
Çizge Tanımları
 V={xi
} düğümler
kümesi
 E={wij} xi ve xj
düğümleri
arasındaki ağırlık
 Altçizge: Gi
(Vi
,Ei
)
a
b a
c c
b
(a) Etiketli Çizge
q p
p
p
r
s
t
r t
p q
a
a
c
b
(b) Altçizge
p
s
t
p
U
k
i
Vi V =1
=
{{ , } , } i Vi E = u v ∈ E ∧ u v∈
3
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 13
Çizge-Hareket Dönüşümü
(a,b,p) (a,b,q) (a,b,r) (b,c,p) (b,c,q) (b,c,r) … (d,e,r)
G1 1 0 0 0 0 1 … 0
G2 1 0 0 0 0 0 … 0
G3 0 0 1 1 0 0 … 0
G3 … … … … … … … …
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 14
Apriori Temelli Yaklaşım
 Bir altçizgenin güven değeri:
 Altçizgenin bulunduğu çizgelerin toplam
çizgelere oranı
 Apriori temelli yaklaşım
 yaygın (k+1)-altçizgeleri bulmak için kaltçizgelerin kullanılması
 düğüm ekleme: k düğüm sayısı
 ayrıt ekleme: k ayrıt sayısı
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 15
Düğüm Ekleme
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎝
⎛
=
0 0 0
0 0
0 0
0
1
q
p r
p r
p p q
MG
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎝
⎛
=
0 0 0
0
0 0
0 0
2
r
p r r
p r
p p
MG
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
=
0 0 0 0
0 0 0 0
0 0
0 0 0
0 0
3
q
r
p r r
p r
p p q
MG
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 16
Ayrıt Ekleme
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 17
Apriori Temelli Algoritma
 Yaygın 1-altçizgelerin belirlenmesi
 Yeni yaygın altçizge oluşmayana kadar tekrarla
 Aday oluşturma: Yaygın (k-1) altçizgeleri
kullanarak k-altçizgeler oluşturma
 Aday azaltma: (k-1)-altçizgesi yaygın olmayan
adayların silinmesi
 Destek hesaplaması: Kalan adaylar için destek
değerinin hesaplanması
 Aday eleme: min_sup değerini sağlamayan
adayların silinmesi
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 18
Aday Oluşturma
 Apriori yöntemi:
 İki (k-1)-yaygın niteliklerin birleştirilmesi sonucu
sadece bir k-yaygın nitelikler oluşur.
 Altçizge madenciliği
 İki (k-1)-yaygın altçizgenin birleştirilmesi sonucu
birden fazla k-yaygın altçizge oluşur
 iki (k-1)-yaygın altçizgenin birleştirilmesi için (k-2)-
altçizgelerinin aynı olması gerekir (çekirdek)
4
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 19
Düğüm Ekleme: Farklı Aday Oluşması
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎝
⎛
=
0 0 0
0 0
0 0
0
1
q
p r
p r
p p q
MG
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎝
⎛
=
0 0 0
0
0 0
0 0
2
r
p r r
p r
p p
MG
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
=
0 0 ? 0
0 0 0 ?
0 0
0 0 0
0 0
3
r
q
p r r
p r
p p q
MG
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 20
Ayrıt Ekleme: Farklı Aday Oluşması
 1. durum: düğüm etiketleri aynı
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 21
Ayrıt Ekleme: Farklı Aday Oluşması
 2. durum: çekirdekteki düğüm etiketleri aynı
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 22
Çizge Madenciliği
 Jun Huan, Wei Wang, Jan Prins, and Jiong Yang,
SPIN: Mining maximal frequent subgraphs from graph
databases. Proceedings of the 10th ACM SIGKDD
International Conference on Knowledge Discovery and
Data Mining (SIGKDD), 2004.
 X. Yan, X. J. Zhou, and J. Han, Mining Closed
Relational Graphs with Connectivity Constraints, Proc.
2005 Int. Conf. on Knowledge Discovery and Data
Mining (KDD'05), Chicago, IL, Aug. 2005.
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 23
Sıralı Diziler
 İlişkilendirme kuralları hareketlerde yer alan nitelikler arasındaki
ilişkiyi bulmayı hedefler. Zaman bilgisini kullanmaz.
{a,b,c,...}
{x,y,..}
{ , , }
 Sıralı dizi madenciliği zaman bilgisini kullanarak hareketlerin sırasına göre nitelikler arasındaki ilişkiyi bulur.
<{a,b,c,...},{x,y,..}>
<...>
1. Gün
2. Gün
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 24
Sıralı Dizi Verisi
 Örnek sıralı dizi verisi:
 müşteri hareketleri
 tıbbi veriler
 web verileri
 telefon görüşme kayıtları
 DNA dizileri
Object Timestamp Events
A 10 2, 3, 5
A 20 6, 1
A 23 1
B 11 4, 5, 6
B 17 2
B 21 7, 8, 1, 2
B 28 1, 6
C 14 1, 8, 7
5
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 25
Sıralı Dizi Tanımı
 Elemanlar nitelikler kümesi, nitelikler sıralı değildir, genelde
alfabetik sırada sıralanırlar (abc)
 Elemanların sıralı listesi (<a(abc)(ac)d(cf)>)
 Elemanlar zaman veya yer ile nitelendirilir
 Sıralı dizinin uzunluğu |s|: Sıralı diziyi oluşturan nitelikler sayısı
 k-sıralı dizi: k niteliği olan sıralı dizi
40 <eg(af)cbc>
30 <(ef)(ab)(df)cb>
20 <(ad)c(bc)(ae)>
10 <a(abc)(ac)d(cf)>
SID sıralı dizi
Sıralı dizi veritabanı
<a(abc)(ac)d(cf)>= <a(cba)(ac)d(cf)>
<a(abc)(ac)d(cf)> ≠ <a(ac)(abc)d(cf)>
Elemanlar içinde niteliklerin sırası yok (liste)
Elemanlar sıralı 9-sıralı dizi
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 26
Sıralı Dizi Örnekleri
 Web verileri:
< (Homepage) (Electronics) (Digital Cameras) (Canon Digital Camera)
(Shopping Cart) (Order Confirmation) (Return to Shopping) >
 Kütüphaneden alınan kitaplar:
<(Fellowship of the Ring) (The Two Towers) (Return of the King)>
 DNA dizileri
ACAAGATGCCATTGTCCCCCGGCCTCCTGCTGCTGCTGCTCTCCGGGGCCACGGCC
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 27
Alt Dizi Tanımı
 β=<b1 b2 … bm> sıralı dizisi içinde α=<a1 a2 … an>
sıralı dizinin bulunabilmesi için (m ≥ n):
 i
1 < i2 < … < in koşulunda a1 ⊆ bi1 , a2 ⊆ bi1, …, an ⊆ bin
 <a(abc)(ac)d(cf)> sıralı dizinin bir alt dizisi: <a(bc)dc>
 <ad>, <(ad)c(bc)(ae)> sıralı dizinin alt dizisi değil
 α dizisi için β “super sequence” olarak tanımlanır.
 s dizisi hiç bir dizinin altdizisi değilse “maximal” olarak
tanımlanır.
 Bir altdizinin destek değeri: Altdizinin bulunduğu sıralı
dizilerin toplam sıralı dizi sayısına oranı
 Sıralı dizi örüntüsü: Destek değeri en küçük destek değerine (minsup) eşit ya da büyük olan alt diziler
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 28
Sıralı Dizi Madenciliği
 Sıralı dizi veritabanında en az minsup destek
değerine sahip alt dizilerin bulunması (sıralı dizi
örüntülerinin bulunması)
sıralı dizi veritabanı
40 <eg(af)cbc>
30 <(ef)(ab)(df)cb>
20 <(ad)c(bc)(ae)>
10 <a(abc)(ac)d(cf)>
SID sıralı dizi α1= <(ab)c> minsup(α1)=2
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 29
Zorluklar
 Veri kümesi içinde çok fazla sayıda sıralı dizi
örüntüsü bulunabilir
 Sıralı dizi madenciliği algoritmasının bütün sıralı
dizi örüntülerini bulması gerekir
 Veri kümesini az sayıda tarayarak sonuç
üretmesi gerekir
 ölçeklenebilir
 Değişik veri tipleri üzerinde çalışabilmesi gerekir
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 30
Sıralı Dizi Örüntülerinin Temel Özelliği
 Apriori:
 Sıralı dizi s, minsup değerini sağlamıyorsa, s’in hiçbir üst
kümesi de minsup değerini sağlamaz.
 Örnek: <hb> minsup değerini sağlamıyor Æ <hab> ve
<(ah)b> sıralı dizileri de minsup değerini sağlamaz.
50 <a(bd)bcb(ade)>
40 <(be)(ce)d>
30 <(ah)(bf)abf>
20 <(bf)(ce)b(fg)>
10 <(bd)cb(ac)>
SID Sıralı dizi minsup =2
6
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 31
Apriori All
 Rakesh Agrawal and Ramakrishnan Srikant, Mining
Sequential Patterns, In Proc. of 11h Int. Conf. on Data
Engineering, Taipei, Taiwan, 1995.
 Apriori algoritmasının yaklaşımını kullanır
 Maximal olmayan diziler de dahil olmak üzere bütün
sıralı dizileri çıkarır
 Aday sıralı dizileri bulmak içim Apriori algoritmasının
Apriori-generate fonksiyonunu kullanır. Aday sıralı
dizilerin minsup değerlerini bulmak için sıralı dizi
verisini tarar.
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 32
Apriori All Algoritması
 5 aşamadan oluşur
1. Sıralama aşaması (sort phase)
Hareketlerden oluşan veri kümesinden sıralı dizlileri oluşturma
2. Yaygın nitelikler kümesi aşaması (large itemset phase)
Apriori ile yaygın nitelikler kümeleri bulunur
3. Dönüştürme aşaması (Transformation phase)
Her yaygın nitelikler kümesi bir tamsayı ile eşleştirilir
4. Sıralı dizi aşaması (sequence phase)
Apriori kullanılark bütün sıralı dizi örüntüleri çıkarılır
5. Maximal aşaması (maximal phase)
Maximal olmayan sıralı diziler elenir
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 33
Apriori All Algoritması (1)
 Ck:k uzunluğunda yaygın sıralı dizi adayları
 Lk:k uzunluğunda yaygın sıralı diziler
L1 = {1-frequent sequences}; //2. aşama sonucu for (k = 1; Lk !=∅; k++) do begin Ck+1 = candidates generated from Lk; for each sequence c in database do
increment the count of all candidates in Ck+1 that are contained in c
Lk+1 = candidates in Ck+1 with min_support end return ∪k Lk;
 Aday oluşturma: Lk-1 kendisiyle birleştirme
insert into Ck
select p.item1, p.item2, …, p.itemk-1, q.itemk-1
from Lk-1 p, Lk-1 q
where p.item1=q.item1, …,
p.itemk-2=q.itemk-2
Örnek:
{1,2,3}x{1,2,4}=
{1,2,3,4} ve
{1,2,4,3}
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 34
Örnek: Sıralı Dizi
Veritabanı
minsup=%40 =>en az iki farklı ID
Sonuç: <(30)(90)> (ID=1,4) <(30)(40 70)> (ID2,4)
<30><40><70><90>, <(30)(40)> <(30)(70)> <(40 70)> sıralı dizi
örüntüsü değil
5 1 90
4 3 90
4 2 40,70
4 1 30
3 1 30,50,70
2 3 40,60,70
2 2 30
2 1 10,20
1 2 90
1 1 30
ID Zaman Ürün
30 90
10
20 30
40
60
70
30
50
70
30 40
70 90
90
ID=1
ID=2
ID=3
ID=4
ID=5
t
t
t
t
t
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 35
Sıralama Aşaması
 ID
 Zaman
30 90
10
20 30
40
60
70
30
50
70
30 40
70 90
90
ID=1
ID=2
ID=3
ID=4
ID=5
t
t
t
t
t
5 1 90
4 3 90
4 2 40,70
4 1 30
3 1 30,50,70
2 3 40,60,70
2 2 30
2 1 10,20
1 2 90
1 1 30
ID Zaman Ürün
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 36
Yaygın Nitelikler Kümesi Aşaması
 Apriori algoritması kullanılarak yaygın nitelikler belirlenir.
 Sıralı dizi örüntülerinde geçen nitelikler yaygın nitelikler olması
gerekiyor
 Destek değerinin farklı hesaplanması gerekiyor
 Bir niteliğin kaç farklı “ID” için bulunduğu
5 1 90
4 3 90
4 2 40,70
4 1 30
3 1 30,50,70
2 3 40,60,70
2 2 30
2 1 10,20
1 2 90
1 1 30
ID Zaman Ürün
minsup=%40 => en az iki farklı ID
Yaygın nitelikler kümeleri:
{30}{40} {70}{40 70} {90}
7
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 37
Dönüştürme Aşaması (1)
 Her yaygın nitelikler kümesi bir tamsayı ile eşleştirilir
 İki farklı nitelikler kümesinin veritabanı içinde eşit
zamanda taranması için
 Hareketler tamsayılar ile temsil edilir
{90} 5
{40 70} 4
{70} 3
{40} 2
{30} 1
Nitelikler Tamsayı
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 38
Dönüştürme Aşaması (2)
5 <(90)>
4 <30 (40 70) 90>
3 <(30 50 70)>
2 <(10 20)30(40 60 70)>
1 <(30) (90)>
ID Sıralı Diziler
5 <{5 }>
4 <{1} { 2 3 4 } { 5 }>
3 <{1 3 }>
2 <1{2 3 4 }>
1 <{1} {5 }>
ID Tamsayı Eşleneği
30 90
10
20 30
40
60
70
30
50
70
30 40
70 90
90
ID=1
ID=2
ID=3
ID=4
ID=5
t
t
t
t
t
30 90
10
20 30
40
70
40 70
30
70
30
40
70
40 70
90
90
ID=1
ID=2
ID=3
ID=4
ID=5
t
t
t
t
t
!
!
!
1 5
1
2
3
4
1
3
1
2
3
4
5
5
ID=1
ID=2
ID=3
ID=4
ID=5
t
t
t
t
t
{90} 5
{40 70} 4
{70} 3
{40} 2
{30} 1
Nitelikler Tamsayı
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 39
Sıralı Dizi Aşaması
 Nitelikler kümesi kullanılarak istenen
destek değerini sağlayan sıralı diziler
bulunuyor
 Apriori algoritması ile aynı yaklaşım
5 <{5}>
4 <{1) { 2 3 4} { 5}>
3 <{1 3}>
2 <1{2 3 4}>
1 <{1} {5}>
ID Tamsayı Eşleneği
{90} 5
{40 70} 4
{70} 3
{40} 2
{30} 1
Nitelikler Tamsayı
({1} {5}) 2
({1} {4}) 2
({1} {3}) 3
({1} {2}) 2
{5} 3
{4} 2
{3} 3
{2} 2
{1} 4
Nitelikler Destek minsup=%40
<30><90>
<30 (40 70)>
<30><70>
<30><40>
<90>
<40 70>
<70>
<40>
<30>
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 40
Maximal Aşaması
 Maximal olmayan sıralı dizileri sil
 Başka bir sıralı dizinin altdizisi olan dizileri sil
for k=n; k=1; k- -
for each k-sequence sk do
delete all subsequences of sk
<30><90>
<30 (40 70)>
<30><70>
<30><40>
<90>
<40 70>
<70>
<40>
<30>
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 41
GSP (A Generalized Sequential Pattern
Mining Algorithm)
 Ramakrishnan Srikant, Rakesh Agrawal, Mining Sequential Patterns: Generalizations And Performance Improvements, Proc. 5th Int.
Conf. Extending Database Technology, EDBT’96
 1. Aşama:
 Veritabanını bir kez tarayarak 1 nitelikden oluşan sıralı dizi
örüntülerini bulunur
 2. Aşama: Yeni bir sıralı dizi örüntüsü bulunmayıncaya kadar
tekrarla
 Aday oluşturma: (k-1). adımda bulunan sıralı dizi örüntüleri
birleştirilerek k uzunluklu sıralı dizi örüntü adayları bulunur
 Aday azaltma: (k-1) alt dizileri minsup değerini sağlamayan adaylar
elenir
 Destek değeri hesaplama: Kalan sıralı dizi örüntü adayları için veritabanı taranarak destek değeri hesaplanır
 Aday eleme: minsup değeri sağlamayan sıralı dizi örüntü adayları elenir.
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 42
GSP: Aday Oluşturma
 İlk durum (k=2): Bir uzunluklu sıralı dizilerden iki uzunluklu sıralı diziler
oluşturma
 s11=<i1> ve s12=<i2> sıralı dizlerin birleştirilmesi sonucunda s21=
<i1 i
1>, s22= <i1 i
2>, s23= <i2 i
2>, s24= <i2 i
1> ve s25= <(i1 i
2)> sıralı
dizileri oluşur
 Genel durum (k>2):
 k uzunluklu ski ve skj sıralı dizileri şu şartlar altında birleşir:
 ski sıralı dizinin ilk niteliği ve skj sıralı dizinin son niteliği silindiğinde
oluşan alt dizinin aynı olması
 (k+1) uzunluklu sıralı dizi örüntü adayı, ski sıralı diziye skj sıralı
dizinin son niteliğinin eklenmesi ile bulunur
 skj sıralı dizinin son iki niteliği aynı elemana ait: skj sıralı dizinin son
niteliği ski sıralı dizisinin son elemanının parçası olur
 diğer durumda skj sıralı dizisinin son niteliği ski sıralı dizisinin ayrı bir
elemanı olur.
8
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 43
Örnek
 s1=<(a) (b c) (d)> ve s2 =<(b c) (d e)> sıralı dizileri birleştirilirse
 aday sıralı dizi <(a) (b c) (de)>
 s2 sıralı dizideki son iki nitelik (d ve e) aynı elemana ait
 s1=<(a) (b c) (d)> ve s2 =<(b c) (d)(e)>
sıralı dizileri birleştirilirse
 aday sıralı dizi < (a) (b c) (d)(e)>
 s2 sıralı dizideki son iki nitelik (d ve e) aynı elemana ait değil
 s1 =<(a)(b f)(d)> ve s2 =<(a) (b) (d e)> sıralı dizileri <(a) (b f) (de)>
sıralı dizi örüntü adayı oluşturmak üzere birleştirilemez
 s2 =<(b f) (d x)> veya s2 =<(b f) (d) (x)> şeklinde olmadığı için
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 44
Örnek
 Bir nitelikden oluşan dizilerin bulunması
 Adaylar
 <a>, <b>, <c>, <d>, <e>, <f>,
<g>, <h>
 Veritabanı taranarak destek sayıları hesaplanır
50 <a(bd)bcb(ade)>
40 <(be)(ce)d>
30 <(ah)(bf)abf>
20 <(bf)(ce)b(fg)>
10 <(bd)cb(ac)>
SID Sıralı Dizi
min_sup =2
<h> 1
<g> 1
<f> 2
<e> 3
<d> 3
<c> 4
<b> 5
<a> 3
Aday Des
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 45
Örnek
<f> <fa> <fb> <fc> <fd> <fe> <ff>
<e> <ea> <eb> <ec> <ed> <ee> <ef>
<d> <da> <db> <dc> <dd> <de> <df>
<c> <ca> <cb> <cc> <cd> <ce> <cf>
<b> <ba> <bb> <bc> <bd> <be> <bf>
<a> <aa> <ab> <ac> <ad> <ae> <af>
<a> <b> <c> <d> <e> <f>
<f>
<e> <(ef)>
<d> <(de)> <(df)>
<c> <(cd)> <(ce)> <(cf)>
<b> <(bc)> <(bd)> <(be)> <(bf)>
<a> <(ab)> <(ac)> <(ad)> <(ae)> <(af)>
<a> <b> <c> <d> <e> <f>
Apriori özelliği
kullanılmadan aday
sayısı
8*8+8*7/2=92
Apriori aday
sayısını
%44.57 azaltıyor
 iki uzunluklu
sıralı dizilerin
bulunması
 51 aday
36
15
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 46
Örnek
 3 uzunluklu adayların bulunması
 2 uzunluklu sıralı dizilerden 3 uzunluklu adaylar
oluşturma
 Apriori özelliği kullanılıyor
 <ab>, <aa> ve <ba> : 2 uzunluklu sıralı diziler
Æ <aba> : 3 uzunluklu sıralı dizi
 <(bd)>, <bb> ve <db>: 2 uzunluklu sıralı diziler
Æ <(bd)b>: 3 uzunluklu sıralı dizi
 46 aday oluşuyor
 3 uzunluklu sıralı dizilerin bulunması
 Veritabanı taranarak adayların destek sayıları hesaplanır
 46 adaydan 19 adet 3 uzunluklu sıralı dizi örüntüsü
bulunur
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 47
GSP Örnek
<a> <b> <c> <d> <e> <f> <g> <h>
<aa> <ab> … <af> <ba> <bb> … <ff> <(ab)> … <(ef)>
<abb> <aab> <aba> <baa> <bab> …
<abba> <(bd)bc> …
<(bd)cba>
1. adım: 8 aday, 6 adet 1-sıralı
dizi örüntüsü.
2. adım: 51 aday, 19 adet 2-
sıralı dizi örüntüsü. 10 aday
DB’de değil
3. adım: 46 aday, 19 adet 3-
sıralı dizi örüntüsü. 20 aday
DB’de değil
4. adım: 8 aday, 6 adet 4-sıralı
dizi örüntüsü
5. adım: 1 aday, 1 adet 5-sıralı
dizi örüntüsü
minsup değerini
sağlamayan aday
DB’de bulunmayan
aday
50 <a(bd)bcb(ade)>
40 <(be)(ce)d>
30 <(ah)(bf)abf>
20 <(bf)(ce)b(fg)>
10 <(bd)cb(ac)>
ID Sıralı dizi
minsup =2
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 48
GSP Örnek
9
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 49
GSP Algoritmasında Problemler
 Çok sayıda sıralı dizi örüntü adayı oluşturulabilir
 1000 adet 1-sıralı dizi örüntülerinden
adet sıralı dizi örüntü adayı oluşur.
 Veritabanı birçok kez taranır
 Uzun sıralı dizileri belirlemek çok zor
 sıralı diziler art arda eklenerek daha uzun sıralı diziler
oluşuyor
 100-sıralı dizi oluşturmak için 1030 sıralı dizi gerekiyor.
100 30 100
1
2 1 10 100 = − ≈ ⎟
⎟
⎠
⎞
⎜
⎜
⎝
⎛ ∑i= i
1,499,500 2
1000 999 1000 1000 = × × +
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 50
Sıralı Dizi Örüntü Adayı Oluşturma
 Parçala ve çöz yaklaşımı
 veritabanı yinelemeli küçültülür
 oluşan her veritabanında sıralı dizi örüntüleri bulunur
 Algoritmalar:
 J. Han J. Pei, B. Mortazavi-Asi, Q. Chen, U. Dayal and M.C. Hsu.
FreeSpan: Frequent pattern-projected sequential pattern
mining. KDD’00
 J. Pei, J. Han, B. Mortazavi-Asi, H. Pinto, Q. Chen, U. Dayal, and
MC. Hsu. Prefixspan: Mining sequential patterns e#ciently by
prefix-projected pattern growth. In Proceedings of the 17th
International Conference on Data Engineering, 2001.
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 51
FreeSpan Algoritması
 Örnek: Sıralı dizi veritabanı ve min_sup=2
 1. Adım: 1-sıralı dizi örüntülerinin bulunması ve destek değeri
küçülen sırada sıralanmaları (f-list)
f_list: b:5, c:4, a:3, d:3, e:3, f:2
Sıralı dizi Veritabanı
< (bd) c b (ac) >
< (bf) (ce) b (fg) >
< (ah) (bf) a b f >
< (be) (ce) d >
< a (bd) b c b (ade) >
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 52
FreeSpan Algoritması
 2. Adım: Arama uzayının bölünmesi. Sıralı dizi
veritabanı altkümelere bölünür
 f niteliği bulunan alt diziler
 e niteliği bulunan f niteliği bulunmayan
 d niteliği bulunan e ve f nitelikleri bulunmayan
 a niteliği bulunan d, e ve f nitelikleri bulunmayan
 c niteliği bulunan a, d, e ve f nitelikleri bulunmayan
 b niteliği bulunan
 Her alt dizi (α) için bu alt dizilerin bulunduğu sıralı
dizilerden oluşan veritabanları, α-yansımalı
veritabanları (α-projected database), oluşturulur.
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 53
FreeSpan Algoritması
 c niteliği bulunan a, d, e ve f nitelikleri bulunmayan
sıralı diziler
 <c>-yansımalı veritabanı: <b c b c>, <b c b>, <b c>,
<b b c b>
 c niteliği bulunan a, d, e ve f nitelikleri bulunmayan
bütün alt dizilerin bulunması: <bc>: 4, <cb>: 3
 Veritabanı yansıtılarak sıralı diziler bulunmaya devam
edilir.
Sıralı dizi Veritabanı
< (bd) c b (ac) >
< (bf) (ce) b (fg) >
< (ah) (bf) a b f >
< (be) (ce) d >
< a (bd) b c b (ade) >
1
1
VERİ MADENCİLİĞİ
Metin Madenciliği
Yrd. Doç. Dr. Şule Gündüz Öğüdücü
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 2
Konular
 Metin madenciliği & Bilgi erişim sistemleri
 Dizinleme
 Metin ön işleme
 İçerik tabanlı sıralama
 Olasılıklı bilgi erişim sistemleri
 Gizli anlamsal inceleme
 Terim sayısını azaltma
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 3
Metin için Veri Madenciliği
 Metin madenciliği: Veri madenciliği teknikleri ile yazılı
belgeler arasındaki (içindeki) ilişkileri, örüntüleri
bulmak.
 doğal dilde yazılmış metinler
 Aynı konudaki belgeleri bulmak
 Birbiriyle ilişkili belgeleri bulmak
 Bulunan belgeleri sıralamak
 Bilgi elde etme sistemleri birleştirilebilir
 Ortak ön işleme işlemleri: doğal dil işleme yöntemleri ile
 bilgi elde etme sistemleri metin madenciliği sonuçlarını
değerlendirmeli, yorumlamalı
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 4
Metin Madenciliğinde Sorunlar
 Metin yapısal değil
 Sorgulama sonucuyla ilintili metinleri bulmak zor
 Önemsiz veri (sözcük) çok fazla
 Hatalar var
 Metin içinde hatalar var
 Kavram oluşturmak zor: eş anlamlı, eşsesli, üst grup
 Anlam çıkarmak zor: X’in iyi bir bilgisayar olduğunu
düşünüyorum - X’in iyi bir bilgisayar olduğundan
şüpheliyim
 Sonuç
 Belgeler arasındaki ilişkilendirme hatalı
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 5
Metin Madenciliği Araçları
 Ticari ürünler
 http://www.clearforest.com/
 http://www.trl.ibm.com/projects/textmining/takmi/takmi_e.htm
 http://www.megaputer.com/
 Metin inceleme
 http://www.textanalysis.info/
 Problem
 Dile özel çözümler
 Sonuçlar yetersiz
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 6
Metin Veritabanları & Bilgi Erişim Sistemleri
 Metin Veritabanları (belge veritabanları)
 Farklı kaynaklardan dokümanlar: haber, makale, kitap,
elektronik kütüphane, elektronik posta, web sayfaları..
 Veri genelde yapısal değil
 Bilgi erişim sistemleri büyük miktardaki veri üzerinde
başarılı değil
 Bilgi Erişim (Information Retrival) Sistemleri
 Veritabanları ile birlikte gelişmiş bir araştırma alanı
 Bilgi belgeler şeklinde yer alıyor
2
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 7
Bilgi Erişim Sistemi
 Kullanıcının ilgi alanına ve isteğine en uygun belgeleri bulma
 Kullanıcın girdiği bir sorgulamaya göre
 Kullanıcının ziyaret ettiği sayfalara göre
 Internet ortamında web sayfalarının içeriğinin
incelenmesini gerektirir
 Bilgi erişim yönteminde problemler
 Büyük bir belgeler kümesindeki belgeleri işaretleme
 erişimin kolay olması için
 Seçilen belgelerin sıralanması
 Belgelerin sınıflandırılması: veri madenciliği yöntemleri
kullanılabilir
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 8
Konular
 Metin madenciliği & Bilgi erişim sistemleri
 Dizinleme
 Metin ön işleme
 İçerik tabanlı sıralama
 Olasılıklı bilgi erişim sistemleri
 Gizli anlamsal inceleme
 Terim sayısını azaltma
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 9
Dizin Oluşturma
 Ters dizin
 Belgelerden oluşan veri kümesinde her
sözcüğün hangi belgelerde görüldüğü işaretlenir
 Büyük veri kümeleri için etkili
 Terim ω
 sözcükler veya ifadeler
 Sözcük dağarcığı V
 Terimlerden oluşan küme
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 10
Ters Dizin
 Sözlük
 her anahtar bir terim ω ∈ V
 anahtara ait veriler zincir (atama listesi) b(ω): ω
teriminin, belgeler kümesinde her görüldüğü
yeri işaret eden işaretçiler listesi
 belge kimlik numarası (DID): belgenin küme içinde
kaçıncı sırada yer aldığı
 terimin her görüldüğü yer için ayrı bir işaretçi
 DID
 Terimin belge içindeki konumu
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 11
Ters Dizin
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 12
Ters Dizin Oluşturma
 Belgeler ayrıştırılır
 Terimler bulunur ωi
 Eğer ωi dizinde yer almıyorsa eklenir
 Terimin bulunduğu yer zincire eklenir
 Ters dizin boyutu = Ω(|V|)
 Hash tablosu kullanarak gerçeklenebilir
 Zincirler bellekte
 Zincirler diskte
 Diske erişim süresinden dolayı elverişsiz
 Özel ikincil depolama yapıları kullanılması gerekir
3
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 13
Zincirlerin Sıkıştırılması
 Zincir için gerekli saklama alanını azaltma
 her terim için zincir DID’ye göre sıralanır
 DID’ler arasındaki fark saklanır
 Bellek kullanımı önemli ölçüde azalır
 Belgeler kümesinde sık yer alan terimlerin DID’leri
arasında fark da azdır
 Küçük sayılar kodlanarak bellekte daha az yer kaplarlar
 Örnek
 DID listesi: (14, 22, 38, 42, 66, 122, 131, 226 )
 DID’ler arasındaki fark listesi: (14, 8, 16, 4, 24, 56, 9, 95)
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 14
Ters Dizin ile Arama
 Bir belgeler kümesi için oluşturulmuş ters
dizinde bir terimi ω bulmak için
 ters dizinde ω terimine ait zincir b(ω) bulunur
 zincir taranarak terimin bulunduğu yerlerin
listesi elde edilir
 Bir belgeler kümesi için oluşturulmuş ters
dizinde k adet terim bulmak için
 k adet liste oluşturulur
 küme işlemleri ile listeler birleştirilir
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 15
Konular
 Metin madenciliği & Bilgi erişim sistemleri
 Dizinleme
 Metin ön işleme
 İçerik tabanlı sıralama
 Olasılıklı bilgi erişim sistemleri
 Gizli anlamsal inceleme
 Terim sayısını azaltma
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 16
Metin Ön İşleme
 Belgeler için dizin oluşturmadan önce ön işleme
işlemleri
 İşaretleme
 Metin içindeki terimleri ayıklama
 HTML etiketlerinden arındırma
 Farklı terimleri belirleme
 Kök bulma: Aynı kökten gelen farklı ek almış
sözcüklerin köklerini bulma
 Sık geçen sözcükleri ayıklama: bağlaçlar, edatlar
 Terim sayısında %20-30 oranında azalma
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 17
Kök Bulma
 Sözcüklerin biçimbirimsel çözümlemesini yaparak
terimleri elde etmek
 Örnek: İçinde balıkçılık sözcüğü geçen bir sorgulama
için, içinde balık ve balıkçı geçen belgelerin bulunması
 İngilizce için kök bulma: Porter Stemming Algorithm
 http://www.tartarus.org/~martin/PorterStemmer/
 Türkçe için kök bulma: Zemberek projesi
 https://zemberek.dev.java.net/
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 18
Konular
 Metin madenciliği & Bilgi erişim sistemleri
 Dizinleme
 Metin ön işleme
 İçerik tabanlı sıralama
 Olasılıklı bilgi erişim sistemleri
 Gizli anlamsal inceleme
 Terim sayısını azaltma
4
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 19
Sorgulama Sonuçlarını Sıralama
 Sorgulama içinde geçen terimlerin yer aldığı
belgelerin sayısı çok fazla
 data mining için Google arama motorunda
dönen sonuç: 68.400.000
 kullanıcı ancak küçük bir kısmını inceleyebilir
 sorgulama sonuçlarını sıralamak gerekir
 sorgulamayla daha ilgili olan sonuçların başlarda yer
alması
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 20
Vektör Uzayı Modeli
 Belgeler çok boyutlu vektör uzayında temsil
edilir
 Belgeler terim vektörleri biçiminde
d = (ω(1), ω(2), ω(3), …, ω(|d|))
 Belgeler kümesindeki ayrık terim sayısı vektör
uzayının boyutunu belirler
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 21
Örnek
 Belgelerin boolean modeline göre temsil edilmesi:
V = [ web, graph, net, page, complex ]
V1 = [1 1 0 0 0]
V2 = [1 1 1 0 0]
V3 = [1 0 0 1 1]
d page web complex page web complex 3
d graph web net graph net graph web net 2
d1 web web graph web graph
belge metin terimler
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 22
Vektör Uzayı Modeli
 x, x’: belge vektörleri
 ω1, ω2 , ω3 :terimler
 Vektör uzayında
belgelerin gösterilimi
seyrek: |V|>>|d|
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 23
Terim Sıklığı (TF)
 Bir belge içinde, diğer terimlere göre daha sık yer alan
bir terimin önemi de daha fazladır
 nij : ωj teriminin di belgesinde yer alma sayısı
 Terim sıklığı (term frequency):
| | i
ij
ij d
n TF =
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 24
Devrik Belge Sıklığı (IDF)
 Belgeler kümesinde daha az sayıda belgede görülen bir terimin
ayırt edici özelliği daha fazladır
 nj : belge sıklığı (document frequency: df) - ωj teriminin
geçtiği belge sayısı
 n : belgeler kümesindeki belge sayısı
 ωj teriminin devrik belge sıklığı (Inverse Document Frequency):
 Belge sıklığı (df) arttıkça, devrik belge sıklığı (idf) azalır
j
j n
n IDF = log
5
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 25
Tam Ağırlıklandırma (TF-IDF)
 Bir belgede çok bulunan ancak diğer belgelerde daha
az görülen bir terimin ağırlığı daha fazla
 ωj teriminin di belgesindeki TF-IDF ağırlığı:
ij ij j x = TF × IDF
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 26
Belgeler Arası Benzerlik
 Sorgulama ile herbir belge arasındaki benzerlik
hesaplanıp, benzerlik sonucuna göre sıralanır
 Herhangi iki belge arasındaki benzerlik
s(d, d′)∈ R
 Vektör uzayı modelinde kosinüs benzerliği
belgeler arası benzerliği hesaplamak için
kullanılabilir
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 27
Grafik Gösterilim
 dg ω3
ω1
ω2
D1 = 2 ω1+ 3 ω2 + 5 ω3
D2 = 3 ω1 + 7 ω2 + ω3
Q = 0 ω1 + 0 ω2 + 2 ω3
7
2 3
5
Örnek:
D1 = 2 ω1 + 3 ω2 + 5 ω3
D2 = 3 ω1 + 7 ω2 + ω3
Q = 0 ω1 + 0 ω2 + 2 ω3
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 28
Kosinüs Benzerliği
 İki vektör arasındaki açının kosinüsü
cos(d1,d2)=d1zd2 / ||d1|| ||d2||
di
zdj
: iki dokümanın vektör çarpımı
||di
||: di dokümanının uzunluğu
 Örnek
d1 = 3 2 0 5 0 0 0 2 0 0
d2 = 1 0 0 0 0 0 0 1 0 2
d1 • d2
= 3*1 + 2*0 + 0*0 + 5*0 + 0*0 + 0*0 + 0*0 + 2*1 + 0*0 + 0*2 = 5
||d1
|| = (3*3+2*2+0*0+5*5+0*0+0*0+0*0+2*2+0*0+0*0)0.5 = (42) 0.5 = 6.481
||d2
|| = (1*1+0*0+0*0+0*0+0*0+0*0+0*0+1*1+0*0+2*2) 0.5 = (6) 0.5 = 2.245
cos( d1
, d2 ) = .3150
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 29
Sonuçların Değerlendirilmesi
 Belgeler kümesindeki belgelerin vektör uzayı modeli
bulunur
 Kullanıcı sorgusu Q için vektör uzayı modeli bulunur
 Belgeler kümesindeki her belge için sorgulamayla olan
benzerliği hesaplanır s(di
,Q), i=1,2,...,n
 En fazla benzerlik değerine sahip olan belgeler kümesi
R erişim çıktısı olarak belirlenir
 Belgeler kümesinde sorgulamayla ilgili belgeler kümesi
R* ve R karşılaştırılır.
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 30
Sonuçların Değerlendirilmesi
 Duyarlılık (Precision): Erişim çıktısındaki ilgili belge sayısının
erişim çıktısındaki belge sayısına oranı
R
R R precision | *∩ | =
R*: İlgili
belgeler
R* & R R: Erişim çıktısı
Belgeler kümesi
 Anma (Recall): Erişim çıktısındaki ilgili belge sayısının belgeler
kümesinde ilgili belgeler sayısına oranı
| *|
| * |
R
R R recall ∩ =
6
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 31
Konular
 Metin madenciliği & Bilgi erişim sistemleri
 Dizinleme
 Metin ön işleme
 İçerik tabanlı sıralama
 Olasılıklı bilgi erişim sistemleri
 Gizli anlamsal inceleme
 Terim sayısını azaltma
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 32
Olasılıklı Bilgi Erişim Sistemleri
 Temel varsayım: Kullanıcının sorgulamasına
göre sadece ilgili belgelerden oluşan bir
belgeler kümesi var (ideal durum)
 Probabilistic Ranking Principle (PRP)
(Robertson, 1977)
 Belgelerin kullanıcının sorgulamasına ilgili olma
olasılığına göre sıralanması
 Olasılıklar eldeki veriye göre mümkün olan en
doğru şekilde hesaplanır
 Eldeki veri ile gerçeklenebilecek en iyi sistem
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 33
Olasılıklı Bilgi Erişim Sistemleri
 Sorgu terimlerinin bir belgede bulunabilme olasılığı
P(R | d,q)
 Belgeler olasılıklara azalacak şekilde sıralanır
d’ : erişim çıktısında yer alamayan belge
( | , ) ( | , ) ' P R d q ≥ P R d q
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 34
Konular
 Metin madenciliği & Bilgi erişim sistemleri
 Dizinleme
 Metin ön işleme
 İçerik tabanlı sıralama
 Olasılıklı bilgi erişim sistemleri
 Gizli anlamsal inceleme
 Terim sayısını azaltma
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 35
Gizli Anlamsal İnceleme
 Latent Semantic Analysis
 Vektör uzayı modeli sorgulama içinde geçen terimler
belge içinde de yer alıyorsa iyi sonuç veriyor
 Doğal dilin zenginliği nedeniyle sorunlar
 Kullanıcı sorgulamalarında genelde kavramlar yer alıyor
 eş anlamlı sözcükler: hediye – armağan
 anma değerini etkiliyor
 eş sesli sözcükler: çay
 kesinlik değerini etkiliyor
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 36
Latent Semantic Indexing (LSI)
 Lineer cebirdeki tekil değer ayrışımı (singular value decomposition,
SVD) yöntemi kullanılır
 Veri içindeki gizli yapıyı bulmayı hedefler
 Sözcükler ve kavramlar arasındaki önemli ilişkileri bulmayı hedefler
 D: terim – belge matrisi D = [d1 . . . dn]
T
 her satır belgelerin vektör uzayı modelindeki gösterilimi
 her kolon terimin belgede yer alma sayısı
 D matrisinin tekil değer ayrışım matrisi Σ hesaplanır
 Tekil değer ayrışım matrisindeki en büyük K değer dışındakiler sıfırlanır
 D terim belge matrisi yeniden oluşturulur
T D =UΣV
Σˆ
T Dˆ =UΣˆV
7
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 37
Konular
 Metin madenciliği & Bilgi erişim sistemleri
 Dizinleme
 Metin ön işleme
 İçerik tabanlı sıralama
 Olasılıklı bilgi erişim sistemleri
 Gizli anlamsal inceleme
 Terim sayısını azaltma
http://www3.itu.edu.tr/~sgunduz/courses/verimaden/ 38
Nitelik Seçme
 Nitelik -> terim
 Belgeler kümesindeki tüm belgelerdeki ayrık
terim sayısı çok fazla
 belgeler arasında ayırıcılık sağlamayan terimler
 model öğrenme sırasında zaman karmaşıklığı
artıyor
Veri Madenciliği Dersi
Son
Bilgisayarlı Grafik Dersi
Giriş
Biligisayar Grafikleri
Bilgisayar Grafikleri
Bölüm 1
Biligisayar Grafikleri
Bilgisayar Grafiklerine Giriş
 Bilgisayar Grafikleri Nedir?
Oluşturulan veya toplanan verilerin bilgisayar teknolojileri vasıtasıyla
görüntülü şekilde sunulma yöntemlerini inceleyen bilgisayar bilimleri
dalıdır. Başka bir deyişle bilgisayarda görüntü oluşturma ile ilgili
herşeydir. “Bilgisayar Grafikleri” nin en önemli hedefi oluşturulan
görüntülere gerçeklik kazandırmaktır(realistic looking images).
Bunun yanında birde İnteraktif bilgisayar grafikleri kavramı
mevcuttur . Bunun anlamı, kullanıcının geribesleme sürecinin
döngüsü içerisinde olmasıdır. Burada kullanıcı ile grafik uygulaması
arasında etkileşim söz konusudur.
Biligisayar Grafikleri
Bilgisayar Grafiklerine Giriş-1
Aşağıdaki şekilde “interaktif bilgisayar grafikleri” nin blok diyagramı
gösterilmiştir. Şekilden de görüldüğü gibi kullanıcı grafik sistemine bir
takım girdiler ve komutlar göndermekte, karşılığında da bir görüntü
almaktadır. Grafik sisteminin görevi,kullanıcı tarafından verilen girdi
üzerinde birtakım işlemler yaparak kullanıcı istekleri doğrultusunda
girdiyi değiştirmektir. Kullanıcı da çıktıyı analiz ederek bir takım yorumlarda bulunmaktadır.
Resimi
Değiştir
Değişikliği
Yorumla
Grafik Sistemi Kullanıcı
Input
Cihazı
Display
Biligisayar Grafikleri
Grafik Sistemi
Aşağıdaki şekilde bir grafik sisteminin elemanları gösterilmiştir. Klavye
, fare ve touchpad input cihazlarıdır. Bu input cihazlarından alınan verler kabaca CPU,hafıza(Ram) ve Frame Buffer dan oluşan bir işleme meanizmasına iletilir. Burada işlenen görüntüler ekrana yansıtılır.
Biligisayar Grafikleri
Bilgisayar Grafiklerinin Tarihi
Aşağıdaki maddelerde bilgisayar grafiklerinin kullanım alanlarının
kronolojik tablosu çizilmiştir. Görüldüğü gibi bilgisayar grafikleri
yaygın kullanım alanları bulmakta ve hayatımızın değişmez parçası
gelimiş bulunmaktadır. Çoğumuzun çok hoşlanarak izlediğimiz holywood
filimlerinin o çarpıcı sahneleri,görüntü efektleri de bundan nasibini almış
bulunmaktadır.
 Bilgisayar Destekli Tasarım (CAD) 1965 -
 Simülatörler (c.1975-)
 Bitmap grafikli kullanıcı arayüzleri (70’in sonu)
 Interaktif raster grafikler (80’li yıllar)
 Virtual reality (80’li yılların sonlarında )
 Bilgisayar animasyonu
 Visualization (Hayal canlandırma)
 Bilgisayar sanatı (Computer Arts)
 Web/Internet tabanlı grafikler
Biligisayar Grafikleri
Grafik: Kavramsal(conseptual) Model-Gerçek Dünya
Gerçek Obje
İnsan Gözü
Gerçek Işık
Kavramsal Model , görüntünün bilgisayarda sunulmasının soyut bir
biçimidir. Bir görüntüyü oluşturan obje, ışık kaynağı ve bakış açısı gibi
kavramların nasıl biraraya getirilerek bir görüntü modelinin oluşumunu
inceler. Aşağıdaki resime bakıldığında bir görüntünün oluşumunda etkin
olan 3 faktör ve gerçek dünyadaki modeli gösterilmiştir. Burada, gerçek
obje tarafından yansıtılan ışık insan gözü tarafından algılanır, göz bu
bilgileri aynı zamanda beyine göndererek görme hafızasında görüntünün
oluşmasını sağlar. Basitçe görme olayı bu şekildedir.
Biligisayar Grafikleri
Grafik: Kavramsal(conseptual) Model-Bilgisayar Dünyası
İnsan Gözü
Grafik
Sistemi
Gerçek Obje
Görüntüleme
Cihazı
Sentetik
Model
Sentetik
Kamera
Sentetik
Işık Kaynağı
Bigisayar dünyasında ise gerçek dünyanın yapay ve sanal bir modeli
mevcuttur. Gerçek obje geometrik şekiller vasıtasıyla oluşturulur ve buna
sentetik model denir. Sentetik model , sentetik ışık kaynağı kullanır. Bütün
bunlara da sentetik kameradan bakılır. Oluşan görüntü tamamen hayali ve
mantıksaldır. Herşey bizim hayal gücümüze bağlıdır. Sonuçta grafik sistemi
tarafından oluşturulan hayali görüntü görüntüleme cihazı vasıtasıyla
gerçek dünyaya yansıtılır.
Biligisayar Grafikleri
Kavramsal Model Diyagramı
Uygulama
Modeli
Uygulama
Programı
Grafik
Sistemi
Output
Cihazı
Input
Cihazı
Kavramsal modelin diyagramı aşağıdaki resimdeki gibidir. Uygulama
modeli, uygulama programı,grafik sistemi ve i/o birimlerinden
oluşmaktadır. Bu birimleri birbirleriyle etkileşim içerisindedirler.
Biligisayar Grafikleri
Grafik Oluşum Süreci
Grafik oluşum süreci 3 temel aşamadan oluşmaktadır. Bunlar
•Modelleme
•Renderleme
•Görüntüleme
Modelleme, geometrik ve texture modellerinden oluşmaktadır. Geometrik
modelleme objenin bir takım matematiksel ve geometrik figürler ile modelinin
kurulmasıdır.Başka bir deyişle modelin iskeletinin oluşturulmasıdır. Texture
modelleme de oluşturulan iskeletin giydirilmesidir. Texture, kaplama,örtü
anlamlarına gelir ve 2 boyutlu texture’ları 3 boyutlu geometrik modellere
uygulayarak 3 boyutlu katı cisimler oluşturulur.İkinci aşama olan rendering
sentetik modelin görüntüleme cihazlarının anlayabileceği şekle sokmak ile
ilgilidir.Renderleme, görüntü parçalarını (geometrik ve texture modelleri)
biraraya getirerek bir bütün haline getirmek işlemidir. Son olarak görüntüleme
aşamasında görüntünün görüntüleme cihazlarına iletilmesi ve görüntülenmesidir.
Biligisayar Grafikleri
Grafik Oluşum Süreci Şeması
Rendering
Texture
Modelleri
Görüntüleme
Geometrik
Modeller
Biligisayar Grafikleri
Geometrik Modelleme
Geometrik modelleme objenin bir takım matematiksel ve
geometrik ilkeller ile modelinin kurulmasıdır.Başka bir deyişle
modelin iskeletinin oluşturulmasıdır. Buradaki illkeller kelimesi
inglizce primitives için kullanılmıştır. Yani en basit geometrik
primitifler veya şekiller de denebilir. Bunlar noktalar, çizgiler, kare,
üçgenler ve çokgenler,yüzeylerdir. Geometrik modellemede gerçek
objenin sentetik (yapay) modeli bu primitifler yardımıyla kurulur
ve renderleme aşamasına gönderilir. Renderlenmiş model gerçek
objenin bir prototipi olur.
Biligisayar Grafikleri
Geometrik Modelleme-Şeması
Rendering
Noktalar
Yüzeyler
Model
kütüphanesi
Çizgiler
Geometrik
Modelleme
Noktalar,Çizgiler,
Yüzeyler, …
Biligisayar Grafikleri
Texture Modelleme
Geometirk modellemede oluşturulacak objenin bir iskeleti
oluşturulur demiştik. Texture modelleme de oluşturulan iskelete bir
beden giydirme gibi bir şeydir. Texture,inglizcede kaplama,örtü
anlamlarına gelir ve 2 boyutlu texture’ları 3 boyutlu geometrik
modellere uygulayarak 3 boyutlu katı cisimler oluşturulur. Bu
aşamadan sonra model renderleme aşamasından geçer ve görüntü
hazır hale getirilmiş olur.
Biligisayar Grafikleri
Texture Modelleme -Şeması
Rendering
Skaner
Boyama
Görüntü
kütüphanesi
Kamera
Texture
Yoğunluk/renk
Pikseller
Biligisayar Grafikleri
Rendering
Rendering kelimesi inglizce render – sunma kelimesinden
gelmektedir ve sentetik modelin görüntüleme cihazlarının
anlayabileceği şekle dönüştürülerek sunulmasıyla ilgilidir.
Renderleme, görüntü parçalarını (geometrik ve texture modelleri)
biraraya getirerek bir bütün haline getirme işlemidir. Asıl görüntü
üretimi bu aşamada gerçekleştirilir. Üretilen görüntü görüntüleme
cihazları vasıtasıyla kullanıcıya sunulur.
Biligisayar Grafikleri
Rendering-Şema
Rendering
Görüntü üretme
Yazı Modelleri
Geometrik Modelller
+ =
Görüntüleme
Biligisayar Grafikleri
Görüntüleme
Görüntüleme aşamasında görüntünün görüntüleme cihazlarına
iletilmesi ve görüntülenmesi ile ilgili konuları kapsar. Son hale
getirilmiş görüntü verisi (renderlenmiş görüntü) frame buffer denen
ve sadece görüntü saklanması için tahsis edilmil olan hafıza
biriminde tutulur. Frame buffer grafik sisteminin bir parçasıdır.
Grafik sistemi buradaki grafik verilerini görüntüleme cihazına
gönderir.
Biligisayar Grafikleri
Görüntüleme-Şema
Rendering
Donanım
Frame Buffer
Görüntüleme
Cihazı
Biligisayar Grafikleri
Frame Buffer
Frame Buffer
Görüntülenecek görüntüyü depolamak
için kullanılan hafıza birimidir. Sadece
görüntü verisini tutmakla yükümlüdür. İki
tür frame buffer mevcuttur. Bunlar
monochrome (siyah beyaz) ve renkli frame
bufferlardır.
Biligisayar Grafikleri
Siyah-Beyaz (monochrome)Frame Buffer
1 0 1 1 0 0 1 1
D/A
Çevirici
Bit 1
Bit 2
Bit 3
Bit 4
Bit n CRT
Siyah-Beyaz frame bufferda bir adet dijital/analog çevirici
mevcuttur. Bu d/a çevirici frame bufferda tutulan dijital görüntü
verilerini analog bir cihaz olan CRT cihazının anlayabileceği
şekilde çevirmek ile yükümlüdür.
Biligisayar Grafikleri
Renkli Frame Buffer
1 0 1 1 0 0 1 1
Bit 1
Bit 2
Bit 3
Bit 4
Bit n
CRT
0 1 0 1
Kırmızı
D/A
Yeşil
D/A
Mavi
D/A
Siyah beyaz frame bufferin aksine renkli frame bufferda bir adet değil üç adet
dijital/analog çevirici bulunmaktadır. Üç d/a çevirici olmasının sebebi,renkli
dijital görüntülerde 3 adet temel rengin kullanılması ile ilgilidir. Bu renkler
kırmızı, yeşil ve mavidir. Bütün diğer renkler bu üç rengin bellirli bir oranda
karışımlarından elde edilir. Her bir renk için ayrı bir d/a çevirici mevcuttur. Bu
da grafik görüntüleme sürecini hızlandıran faktörlerdendir(renkli görüntülerde.)
Biligisayar Grafikleri
Bazı Genel Kavramlar
Piksel: Birim – frame buffer da tutulan bir birim görüntü verisine denir.
Görüntü boyutu:Görüntünün piksel cinsinden eni ve boyu anlamına gelir.
Renk Derinliği: Piksel başına düşen bit sayısı
Buffer boyutu: Buffer için ayrılan toplam hafıza miktarı
Biligisayar Grafikleri
Ne Kadar Hafıza?
Bir görüntüyü Frame Bufferda saklamak için ne kadar hafıza gerekir? Bu hafıza
nasıl hesaplanır?Bunun için aşağıdaki formülü kullanmak yeterlidir :
Gereken Buffer boyutu = genişlik * yükseklik *renk derinliği
Burada genişlik ve yükseklik görüntü parametreleridir.
Örnek:
Eğer: Genişlik = 640, Yükseklik = 480, renk derinliği = 24 bit
Buffer boyutu = 640 * 480 * 24 = 921,600 byte
Eğer Genişlik = 640, Yükseklik = 480, renk derinliği = 32 bit
Buffer boyutu = 640 * 480 * 32 = 1,228,800 byte
Biligisayar Grafikleri
Display (görüntüleme) Cihazları
Günümüzde yaygın olarak kullanılan iki tip görüntüleme teknolojisi mevcuttur.
Bunlar :
•CRT (Cathode Ray Tube) teknolojisi
•LCD (Liquid Crystal Displays ) teknolojisi
CRT, daha fazla televisyon ve bilgisayar monitörlerinde kullanılırken LCD
teknolojisi daha çok tajınabilir bilgisayar,avuç içi bilgisayarlar, kol saatlerinde
kullanılmaktadır.
CRT LCD
Biligisayar Grafikleri
Çıktı Çıhazlarının sınıflandırılması
 Sert Çıktı (Hard Copy)
– Yazıcılar
Nokta matris
Püskürtmeli
Thermal transfer
Laser
– Çiziciler
 Yumuşak Çıktı (Soft copy)
– CRT ekranlar
– Düz panel
LCD ekranlar
Electroluminescent
Plasma
– Projektör
Biligisayar Grafikleri
CRT (Cathode Ray Tubes) Teknolojisi
Günümüzde kullandığımız masa üstü pc ve workstation’ların yanı sıra
hemen hemen bütün televisyon ekranları bu teknolojiyi kullanmaktadır.
CRT cihazları analog cihazlardır ve dijital bir cihaz olan bilgisayar
tarafından kullanılır. CRT’nin bileşenleri şunlardır : elektron tabanca,
focusing system, deflection system, fosfor kaplı ekran.
Elektron tabancasından ateşlenen ışık demeti fosfor kaplı ekranın belli
bir bölgesine çarparak değişik renklerde ışınlar meydana getirir. Bu
ışınların ömrü kullanılan fosfor tipine değişmekte olup 10-60 mikrosaniye
arasındadır. Oluşturulan görüntünün ekranda bir müddet kalabilmesi için
bu ışınların belli bir aralıklarla tekraralnmaları gerekir. Bu işleme
refreshing denir ve ekranı tazeleme anlamına gelir. Ekranın tazelenme
hızına da refrash rate denir.
Avantajları: Dezavantajları:
Düşük fiyat Büyük hacim/ağırlık
İyi görüntü kalitesi Boyut 45 inçten küçük
Geniş görüntüleme açısı Tekrarlanabilirlik
Kolay grayscale Yüksek voltaj
Kolay adresleme
Biligisayar Grafikleri
CRT-Şekil
Biligisayar Grafikleri
CRT (Cathode Ray Tubes) Bileşenlerinin Görevleri
CRT bileşenlerinin görevleri aşağıdaki şekildedir:
•Elektron Tabanca : Elektron üretme ve gönderme işlemini yapar
•Focusing System : Ekrana çizilecek şekli oluşturmakla yükümlüdür
•Deflection System : Elektronun ekrana çarptığı yerde ışık oluşturur
•Fosfor Kaplı Ekran : Görüntünün uygun yerde oluşmasını sağlar
CRT teknolojisi 2 ye ayrılır: Raster scan display ve Random scan display
cihazları.
Random Scan Display : Görüntü refresh edilmesi gerekir. Gölgelendirme
yapılamaz. Görüntü bir noktadan başlayarak son noktaya kadar çizgilerle
oluşturulur.Bu nedenle büyük görüntülerde ekran gidip gelir.Buna flickering
denir.
Raster Scan Display :Görüntü çizgiler şeklinde oluşturulur. Çizgiler üzerindeki
pikseller kontrol edilir ve gerkli bölgelerdeki renkleri ayarlanır. Bu işleme
rasterizasyon denir. Random scan’dan daha gelişmiş teknolojidir.
Biligisayar Grafikleri
LCD (Liquid Crystal Displays)
Avantajları Dezavantajları
İnce/Hafif Görüntü < 13 inch (pasif)
Sağlam ve güvenilir < 16 inch (aktif matris)
Düşük voltaj Yanıt zamanı (response time)
Fiyatı yüksek
Sınırlı görüntüleme açısı
Biligisayar Grafikleri
Basit Raster Display Sistem Mimarisi
Sistem Bus
CPU Hafıza Frame
Buffer
Video
Controller
I/O
Display
Bu sistemde Grafik sistemi sistem işlemcisini ve sistem hafızasını
kullanmaktadır. Bu nedenle işlemci boş yere meşgul edilmekte ve
verimi düşmektedir. Verim düşüşünü önlemek için grafik
sisteminin bünyesine görüntü işlemcisi ve video hafızası
eklenmiştir.
Biligisayar Grafikleri
Görüntü İşlemcisine Sahip Raster Display Sistem Mimarisi
Sistem Bus
CPU
Display
Hafızası
Frame
Buffer
I/O
Video
Controller
Display
Display
CPU
Sistem
Hafızası
Aşağıdaki şekilde daha gelişmiş bir sistem gösterilmektedir.
Görüntü sisteminin kendi görüntü işlemcisi ve görüntü hafızası
mevcuttur. Dolayısıyla işlemciyi çok meşgul eden görüntüleme
işlemleri sistem içindeki diğer işlemlerden özerk hale getirilmiş ve
sistemin verimi artırılmıştır.
Biligisayar Grafikleri
Bigisayar Grafiklerinin kullanım alanları
Günümüzde bilgisayar grafiklerinin kullanım alanları çok geniştir.
Aşağıdaki örnekler bunun en çok kullanılanlarıdır.
Dizayn : mimari, makine tasarımı, moda alanında
Simulasyon : eğitim, uçuş ve araba sürme simulasyonları
Sanat ve Eğlence : oyunlar, filimler ve reklamlar
Bilgi Sunma : bilimsel vizualizasyon: hava durumu, kimya ve eczacılık
Kullanıcı Arayüzleri: pencereleme sistemi, sanal gerçeklik
Sıradaki slaytlarda yukarıda sıralanmış olan kullanım alanlarıyla ilgili
uygulamaları görebilirsiniz.
Biligisayar Grafikleri
Peki Neden Bilgisayar Grafikleri ?
Aşağıdaki nedenlerden dolayı bilgisayar grafikleri ürünleri tercih konusu
olmuştur :
 Fiyat : sistemin ucuz prototiplerini oluşturma olanağı (CAD), eğitim
(örneğin uçuş simulasyonu vb.) ucuzluğu.
 Mümkün olmayanı mümkün kılma :sanal gerçeklik. Örneğin mars
gezegeninde yürüme simulasyonu.
 Bandwith : Band genişliği. İnsanları daha çabuk anlamasını sağlama.
Yani “Bir resim bin sözden daha iyi anlatabilir.”
 Kullanıcı Dostu : 3 boyutlu kullanıcı arayüzleri, pencereleme sistemi
Biligisayar Grafikleri
Neler Yapabiliriz…
Biligisayar Grafikleri
Bilgisayar Grafikleri Uygulamaları-Filimler
- Filimler – Geri’s Game
“Jurassic Park”
3 adet Academy Awards® ödülü-görsel veses efektleri için
"Geri's Game"
Academy Awards Ödülü Sahibi- animasyonlu en
iyi kısa film dalında, 1997.
Biligisayar Grafikleri
Bilgisayar Grafikleri Uygulamaları-Filimler-1
- Filimler “Shrek"
Dreamworks - 2001.
Biligisayar Grafikleri
Bilgisayar Grafikleri Uygulamaları-Oyunlar
- Video Games
“Tekken Tag Tournament”
Playstation 2
Biligisayar Grafikleri
Bilgisayar Grafikleri Uygulamaları-Bilimsel Vizualizasyon
-Bilimsel Vizualizasyon
Biligisayar Grafikleri
Bilgisayar Grafikleri Uygulamaları-Bilimsel Vizualizasyon-1
-Bilimsel Vizualizasyon (visualization)
Biligisayar Grafikleri
Bilgisayar Grafikleri Uygulamaları-Bilimsel Vizualizasyon-2
- Bilimsel Vizualizasyon (visualization)
Biligisayar Grafikleri
Bilgisayar Grafikleri Uygulamaları-CAD
- CAD-Bilgisayar Destekli Tasarım
Biligisayar Grafikleri
Bilgisayar Grafikleri Uygulamaları-Web Grafikleri
-Web Grafikleri
Biligisayar Grafikleri
Bilgisayar Grafikleri Uygulamaları-Sanal Gerçeklik
-Sanal Gerçeklik
-Genişletilmiş Gerçeklik (Augmented
Reality )
-İnsan Etkileşimi
Biligisayar Grafikleri
Grafik Programları
Biligisayar Grafikleri
İki Boyutlu Görüntüler
 Görüntüler iki boyutlu
(2D) şekillerdir
 X ekseni (yatay),ve Y
ekseni (düşey)
kullanılarak
tanımlanırlar
 Görüntüler piksellerden
oluşmaktadır
(0,0) +X
+Y
Biligisayar Grafikleri
Görüntüler
 Grafik Görüntüler Sentetiktirler. Model fiziki olarak olabilirde
olmayabilirde . Geleneksel görüntüler gibi oluşturulurlar.
Gerçek hayatta gördüğümüz gerçek objeler 3Boyutlu modeller
şeklinde grafik verisine çevirilerek bilgisayarda işlenir.
3D
modeller
Görme Grafik
Biligisayar Grafikleri
Görüntüler-1
Görüntüler piksellerden oluşur. Piksellerden oluşan
görüntünün kalitesi renk yoğunluğu ve çözünürlüğe bağlıdır.
Piksel : Dijital görüntünün en küçük bölünemeyen
birimidir.Pikseller baştan başa her zaman aynı
renkteler.Görüntü , piksellerden oluşan 2 boyutlu bir dizidir.
Çözünürlük : Görüntüdeki piksellerin birbirine olan
uzaklıklarının ölçüsüne denir. Eğer 12 inç genişliğindeki bir
ekranda 1,024 piksel görüntüleniyorsa , görüntü- inç baçına
85 piksel çözünürlüğündedir.
Biligisayar Grafikleri
Görüntüler Piksellerden Oluşur-Şekil
Biligisayar Grafikleri
Işık
 Görülebilen ışık elektromanyetik radyasyondur.
 Algılanan elektromanyetik enerjinin dalga uzunluğu 350-780 nm
arasında değişir
Biligisayar Grafikleri
Görme Sistemi
Cornea: ışığı algılar
Lens: görüntü odağı
Iris: ışık miktarını kontrol eder
Retina: görüntü şekillendirme
Biligisayar Grafikleri
Bizim Gözlerimiz
Görsel Keskinlik
Gözün detayları görebilme kabiliyetinin ölçüsüdür.(çözünürlük)
Retina
Büyük ölçüde çubuklar ve konilerden oluşur.
Biligisayar Grafikleri
İnsan Gözü
Biligisayar Grafikleri
Duyarlı Elementler
Retina büyük ölçüde çubuklar ve konilerden oluşur.
(orj: Retina is largly composed of Rods and Cones)
Çubuklar:
Işık yoğunluğunun algılanmasını , gecede görme ve
hareketi sağlar.
Koniler:
Renk algılama ve ayırmayı sağlar.
Bilgisayar grafiklerinde daha çok koniler üzerine yoğunlaşılır.
Biligisayar Grafikleri
Renk Duyarlılığı
Koniler
• Renk algılamayı belirler
• Üç Tip : Kırmızı,Yeşil,Mavi (RGBred,green,blue)
• (RGB) Kırmızı, Yeşil ve Mavi koniler
ışığın değişik dalga boylarına duyarlıdır.
Biligisayar Grafikleri
Renk Uzayı
RGB Renk Küpü
RGB
HSV
YUV
YCrCb
YIQ
Biligisayar Grafikleri
Katkı Renk
Kırmızı
Mavi Yeşil
Sarı
Açık mavi
Beyaz
Pembe
Peki eğer bilgisayarda sadece RGB renkleri kullanılıyorsa diğer
renkler nereden geliyor sorusu akla gelebilir. Diğer renkler, bu üç
temel rengin belli bir oranda karışımından ve alfa değeri ile
belirlenir. Burada alfa değeri opacity-sönüklük,donukluktur.
Biligisayar Grafikleri
Unutmayın…
 Grafik Görüntüler Sentetiktir
– Model fiziki olarak olabilir yada olmayabilir
– Geleneksel görüntüler gibi oluşturulurlar
 Görüntüler piksellerden oluşur
– Yoğunluk/renk
– Çözünürlük
 Algılama
– Işıklandırma
– İnsanın Görme Sistemi
Biligisayar Grafikleri
Bu Dersin Ödevi
 Download kısmından “gasket.cpp” programını ve derleme direktiflerini
indiriniz.
 Derleme direktiflerini kullanarak komut satırından programı derleyiniz ve
inceleyiniz.
 Programın derlenmiş halini e-mail ile gönderiniz
Bilgisayar Grafikleri
Bilgisayar Grafikleri
Bölüm 2
Bilgisayar Grafikleri
OpenGL Nedir?
Hiç kuşkusuz, OpenGL , 2D ve 3D uygulamaları geliştirmede üstün bir API
endüstrisi olup bilimsel, mühendislik ve özel etki geliştirimlerinde yeğlenen bir
platform olan ünlü SGI iş istasyonlarını yapan Silicon Graphics IRIS GLkitaplığı'na izleyicisi olabileceği düşünülmektedir. SGI, gelecek için kolay
kullanımlı, sezgiyle anlaşılabilen, taşınabilir ve network uyumlu API yapmak için
OpenGL'e deneyimleri ile destek olmuştur. Aynı zamanda SGI'ı açık sistemlerin
önemini farkettikleri için kredilendirebiliriz. Birçok yazılım ve donanım üreticisi
geri planda OpenGL'in özelliklilendirilmesinde rol almışlardır. Bu yaklaşım
nedeniyle, OpenGL uygulamaları; kişisel bilgisayarda windows95'den, görkemli
linux sistemimize, UNIX iş istasyonlarından, anayapı süperbilgisayarlara,
piyasada bulunan tüm platformlara kolaylıkla yerleştirilebilmektedir. Mimari
İnceleme Kurulu değişiklikleri onaylayarak ya da geri çevirerek veya uygunluk
testleri öngörerek OpenGL özelliklilendirilmelerini denetim altında tutmaktadır.
Bilgisayar Grafikleri
OpenGL Nedir? -1
SGI'ın eski IRIS GL-kitaplığının tersine, OpenGL taslak olarak platform ve
işletim sisteminden bağımsızdır. Network'u algılayabildiği için OpenGL
uygulamasını bir sunumcu ve çoğunlukla grafikleri görüntüleştiren bir istemciye
ayırmak mümkündür. OpenGL komutlarını network üzerinden sunumcu ve
istemci arasında kullanmak için bir protokol vardır. Sunumcu ile kullanıcının
aynı tür platformda çalışma zorunluluğu olmamasını sağlayan işletim sistemi
bağımsızlığı da büyük bir avantaj olarak gözükmektedir. Çoğunlukla, sunumcu
karmaşık bir simülasyon çalıştıran bir süper bilgisayar ve istemci de grafik
görüntülemeye tahsis edilmiş basit bir iş istasyonudur.
Bütün bunlardan başka OpenGL veriyollulaştırılmış, yüksek performanslı grafik
görüntüleştirme kitaplığı olmakla birlikte OpenGL'in enbasitögelerini donanım
düzeyinde devreye sokan grafik hızlandırıcı kartlar ve özelyapılı 3D kartları da
vardır. Yakın zamana kadar bu gelişmiş grafik kartları çok pahalıydı ve sadece
SGI iş istasyonları ile diğer UNIX iş istasyonları için olanları bulunmaktaydı.
Bilgisayar Grafikleri
OpenGL Nedir? -2
Herşey çok çabuk değişiyor! Silicon Graphics'in cömert lisanslarına ve sürücü
geliştirme programlarına teşekkürler.Böylece kişisel bilgisayar kullanıcıları için
çok daha fazla OpenGL donanımı göreceğiz. Linux kullanıcıları bu fırsattan
hoşnut olabilirler. Evet 3Dfx Interactive adında bir firma bir seri 3D grafik kartı
ve Kayar Kitaplık Linux İşletim sistemine destek sunmaktalar. Bu, Linux
pazarının burada kalıcı olduğunu anlayan bazı donanım üreticilerinde büyük bir
tutum değişikliğine neden olmuştur. Linux taraftarları bu tür atılımlara destek
olmalılar ya da bunları özendirmelidirler.
Bilgisayar Grafikleri
OpenGL Nedir? -3
OpenGL'in donanımdan bağımsız olmasını sağlamak için; kullanıcı girdisini
sağlamak için kullanılan komutlar ile pencere işlemleri için kullanılan komutlar
devre dışı bırakılmıştır. Bu OpenGL kullanımı için büyük bir kısıt gibi
görünebilir. Fakat ilerde göreceğimiz , gibi OpenGL'i pencere işlemlerini ve
kullanıcı girişleriyle ilgilenecek diğer esnek program kitaplıklarıyla birleştirmek
mümkündür. Ayrıca, OpenGL zor modellemeler (moleküller, uçaklar, evler,
kuşlar vb) için hiçbir komut bulundurmaz. OpenGL'de sadece çok basit
geometrik cisimler bulunur (nokta, doğru ve çokgenler). Program geliştiren kişi
modellerini bu birkaç basit cisimi kullanarak oluşturmalıdır. Daha karmaşık
modelleri yapmaya olanak sağlayan OpenGL'le ilişkili kitaplıklar da bulunmakta
olup herhangibir kullanıcı bu kitaplıkları kendi modellerini oluşturmak için
kullanabilir.
Bilgisayar Grafikleri
OpenGL’in Sağladığı Bazı Özellikler
OpenGL için en yaygınbilinen C arayüzünü kullanaılmaktadır. Bununla
birlikte diğer diller : FORTRAN, C++, Ada ve Java için de OpenGL son
derece kullanışlıdır.
Aşağıdaki yazı fazla ayrıntısına girmeden OpenGL'in yerine getirdiği bazı
özellikleri anlatmaktadır.
 Geometrik Enbasitögeler Nesnelerin matematiksel tanımlamalarını
yapmamızı sağlar. Şimdiki basit enbasitögeler: noktalar, doğrular,
çokgenler,şekiller ve . bitmap'lerdir;
 Renk Kodlaması RGBA (Kırmızı-Yeşil-Mavi-Alpha) 'da ya da renk
kataloğunda . modunda .
 Gözdengeçirme ve Modelleme nesneleri 3 Boyutlu ortamda düzenlemeye
kameramızı uzayda dolaştırıp, gözdengeöirilecek resim için istenilen noktayı
seçmeye izin verir.
Bilgisayar Grafikleri
OpenGL’in Sağladığı Bazı Özellikler-1
 Doku Dönüştürümü modelimizdeki çokgenlere gerçek görünüşlü yüzeyler
görüntüleyerek modelimize gerçekçilik katar.
 Malzeme Aydünlatma tüm 3 boyutlu grafiklerin vazgeçilmez bir parçasıdır. OpenGL
maddenin özelliklerini veren her noktanın rengini ve odadaki ışık kaynağını hesaplayan
komutlar sağlar.
 Çift Tamponlama animasyonlarda oluşan titremeyi gidermeye yardım eder.
Animasyonda birbirini izleyen her bir çerçeve ayrı bir bellek tamponunda oluşturulur.
Ve sadece çerçevenin görüntülenmesi tamamlandığında ekranda görülebilir.
 Anti-aliasing bilgisayar ekranında çizilmiş doğruların uçlarında oluşan çentikleri
azaltır. Çentik uçlu doğrular genellikle düşük çözünürlükte çizildiklerinde oluşular.
Anti-aliasing, mimari zig-zag ları azaltmak için rengi ve doğruların yakınındaki
pixellerin yoğunluğunu değiştirir.
 Gouraud gölgelemesi3 boyutlu cisme düzgün bir gölgeleme uygulamak için kullanılan
bir yöntemdir ve cismin yüzeyleri boyunca ince renk farkları sağlar.
 Z-buffering Üç boyutlu cismin Z koordinatının izini tutar. Z-buffer'ı 'nin; gözlemcinin
cisminin yaklaşık izini sürer. Z-Buferring aynı zamanda saklı yüzeyin yerinin
değiştirilmesimde önemlidir.
Bilgisayar Grafikleri
OpenGL’in Sağladığı Bazı Özellikler-2
 Sis, duman ve pus gibi Atmosfer Etkileri bilgisayarda şekillerin daha gerçekçi
olmasını sağlar. Atmosfer etkileri olmaksızın şekiller bazen çok sert hatlı ve gerçek dışı
gözükür. Sis terimi gerçekten pusu, nemi, dumanı, kirliliği ya da şekillere bir derinlik
katarak basitçe hava etkilerini taklit eden bir algoritmayı tanımlar.
 Alfa Birleştirimi, çerçeve tamponunda depolanmış pikselle renk birleştirimine izin
vererek, RGBA kodunun Alfa değerini (dağıtıilmış malzeme değeri) kullanır. Örneğin,
kırmızı bir kutu önünde geçirgen açık mavi bir pencerenin çizimini düşünelim. Alfa
birleştirimi pencere nesnesinin geçirgenliğini öylesine âenzeştirir ki cam içinden
görünen kutu bir çingene mavisi tonuyla gözükür.
 İince Metal Düzlemler ekranın bazı bölümlerine çizim kısıtlaması getirir.
 Görüntü Listeleri çizim komutlarının daha sonraki bi görıntıleştirme için
depolanmasına olanak sağlar. Uygun biçimde kullanıldığında, görüntü listeleri
görüntüleştirme performansını büyük oranda yükseltebilir.
 Çokterimlisel Hesaplayıcılar düzgün olmayan oransal B-spline'lara destek vermeyi
sağlarlar. Bu, arada çok sayıda noktanın kullanımına gereksinim duyurmaksızın birkaç
referans noktası üzerinden düzgün eğriler çizilebilmesine olanak sağlar.
Bilgisayar Grafikleri
OpenGL’in Sağladığı Bazı Özellikler-3
 Geribesleme, Seçim ve Gerialım özellikleri kullanıcıya ekran üzerinde çizilmiş bir
nesnenin gerialımı ya da ekran üzerinde bir bölgenin seçimi iöin olanak sağlar.
Geribesleme modu görüntüleştirme hesaplamalarının geliştirici tarafından elde
edilebilmesine olanak sağlar.
 Raster enbasitögeleri (bitmap'ler ve piksel dikdörtgenleri)
 Piksel İşlemleri
 Dönüşümler: dönme, ölçekleme, Ötelemelers, 3 Boyutta perspektifler
Sözettiğimiz gibi, OpenGL'i gerçekten taşınabilir ve platformdan bağımsız yapabilmek için
pencereleme sistemi ile arayüzleşen tüm komutların, sözgelimi: pencere açma, pencere
kapama, pencere ölçekleme, pnecere yenidenbiçimlendirme, imleç konumunun okunması;
ve aynı zamanda verigiriş aygıtlarıyla aray¢uzleşen tüm komutların (sözgelimi klavyeden
bilgi girişi) kurban edilmesi gerekmekteydi. Bu etkinliklerin tümü yüksek derecede işletim
sistemine bağlıdır. Kökeninde, GL-kitaplığı pencere ve çevrebirim etkileşimlerinde kendi
komutlarına sahipti. Ancak, bunlar IRIX'e (SGI işletim sistemi) özgü bulunmaktaydı.
Kendi platformunu bilmek ve pencere etkileşimlerini özgün platformunda gerçekleştirmek
OpenGL geliçtiricisine kalmış bir konudur.
Bilgisayar Grafikleri
OpenGL’ın Tarihi
 SGI firmasının Iris GL’ı idi – “Open”GL oldu
 “Open” standardı- geniş donanım platformlarında desteklenmesini
sağladı
 OpenGL v1.0 (1992)
 OpenGL v1.1 (1995)
 OpenGL v1.2 (şu anda bulunan en son sürüm)
 OpenGL Architecture Review Board (ARB) tarafından yönetilir.
Bilgisayar Grafikleri
OpenGL Avantajları Özeti
 En çok kabul gören grafik standartıdır
 Güçlü ve Kararlı (stable)
 Güvenilir ve Taşınabilir
 Sürekli Gelişmekte
 Ölçeklenebilir (scaleble)
 Kullanımı kolay
Bilgisayar Grafikleri
OpenGL Boru Hatları
OpenGL teknolojisinin iki adet çalışma biçimi vardır. Bunlara
“OpenGL pipeline” denir ,yani OpenGL boru hattı tabiri kullanılır.
Bunlar :
– Piksel-tabanlı, görüntü ilkelleri(primitive) boru hattı.
– Geometrik, vertex-tabanlı görüntü ilkelleri.
Texture- her iki boru hattını birleştirerek kullanır.Çünkü basit
görüntü ve bitmaplar pixel tabanlı görüntülerdir ve geometrik
modellere uygulanırlar.
Bilgisayar Grafikleri
OpenGL Mimarisi
Bilgisayar Grafikleri
OpenGL Nasıl Çalışır?
OpenGL’in naslıl çalıştığını anlamak için onun bir çizimi nasıl
oluşturduğuna bakmak lazım.OpenGL de bir şey çizmek için geometrik
ilkelleri (geometric primitives -noktalar, çizgiler ve çokgenler) ve görüntü
ilkelleri (resimler ,bitmaplar) kullanılır. Daha sonra OpenGL’in Durum
mekanizması olarak adlandırılan mekanizmaya başvurularak çizilecek
objenin renk,madde, ışık kaynağı ve bunun gibi özellikleri ayarlanır ve
yönetilir.
Bilgisayar Grafikleri
Pencere Yönetimi Ve Pencere Yönetimi API’si
Daha önce de söylendiği gibi OpenGL pencere ve işletim sisteminden bağımsız
olarak tasarlanmıştır.OpenGL pencere yönetimi, kullanıcı etkileşimi, ve dosya I/O
için herhangi fonksiyonları içermez.Pencereleme mekanizmasını sağlamak
evsahibi ortamlar sorumluluğundadır. Bu saydığımız özellikler say OpenGL’i
taşınabilir kılmıştır.
OpenGL de işletim sistemi tarafından sağlanan pencereleri yönetmek için
aşağıdaki API’lere ihtiyaç var.
 GLX/AGL/WGL-Xwindow ve MS Windows ortamları için
– OpenGL ve pencereleme sistemler arasında arabulucu kütüphaneler.
 GLUT ve AUX-OpenGL Utility ve yardımcı kütüphaneleridir.Bu
kütüphanelerde programcının işini kolaylaştıracak birçok hazır rutin mevcuttur.
Bilgisayar Grafikleri
OpenGL API ,Uygulama Programı ve İşletim Sistemi
Aşağıdaki şekilde uygulama programı, OpenGL Api ve işletim sistemi
arasındaki etkileşim tasvir edilmiştir. Görüldüğü gibi uygulama programları
ortamlarına bağlı olarak (unix-GLX,AGL, Win32-WGL) OpenGL’in bu
arabulucu api’leri vasıtasıyla işletim sistemi ile haberleşirler.
Bilgisayar Grafikleri
OpenGL- Temel Kütüphaneleri ve İşlevleri
 GL : OpenGL’in platform bağımsız “çekirdek” kütüphanesidir.
 GLU : Değişik grafik fonksiyonlarını içeren yardımcı
kütüphane.
 GLUT/AUX : İşletim sisteminin pencereleme sistemi
tarafından sağlanan pencerelerin OpenGL programları
tarafından yönetimini sağlayan “utility toolkit”
kütüphaneleridir.
Bilgisayar Grafikleri
Kütüphaneler Ve Başlıklar
glut.h Pencere Yönetimi
glaux.h
glut32.lib (PC)
-lglut (UNIX)
glaux.lib (PC)
-lglaux (UNIX)
Utility toolkitler
Birçok aksesuvar
fonkiyon içerir
glu32.lib (PC) glu.h
-lglu
Yardımcı Küpüphane
“çekirdek”
Küpüphane
opengl32.lib (PC) gl.h
-lgl (UNIX)
OpenGL
Küpüphane İsmi Küpüphane dosyası Başlık Dosyası Not
Bilgisayar Grafikleri
OpenGL Temel Kütüphanelerinin Kullanımı Örneği
#include <GL/gl.h> // “çekirdek”-en az gereksinim
#include <GL/glu.h> // yardımcı fonksiyonlar
#include <GL/glut.h> // pencere yöneticisi
void main( int argc, char **argv )
{
…..
}
Aşağıdaki örnek tipik bir OpenGL programının iskeletidir
Bilgisayar Grafikleri
OpenGL Veri Tipleri
OpenGL kodunun taşınabilirliğini kolaylaştırmak için OpenGL
kendi veri tiplerini tanımlar. Bu veri tipleri C’nin veri tipleri ile
aynı işlevi görür.
GLshort A[10]; short A[10];
GLdouble B; double B;
Bilgisayar Grafikleri
OpenGL Veri Tipleri Tablosu
GLubyte, GLboolean 8-bit unsigned integer unsigned char
GLdouble 64-bit float double
GLfloat 32-bit float float
GLint, GLsizei 32-bit integer long
GLshort 16-bit integer short
GLunit, GLenum, GLbitfield 32-bit unsigned integer unsigned long
GLushort 16-bit unsigned short unsigned short
GLbyte 8-bit integer signed char
OpenGL Veri Tipi Gösterimi C’deki karşılığı
Bilgisayar Grafikleri
OpenGL’de Fonksiyon İsimleri
OpenGL fonksiyonlarının tümü belli bir isimlendirme standardına
uyar. Fonksiyon ismi fonksiyonun hangi kütüphaneden geldiğini,
kaç adet argüman aldığını ve argümanların tiplerini belirler.
<Kütüphane öneki><çekirdek komut><Argüman sayısı><Veri Tipi>
Bilgisayar Grafikleri
OpenGL Fonksiyon İsimleri-Örnek 1
glColor3f(…)
gl kütüp. Çekirdek komut, argüman sayısı, argüman tipi
gl -OpenGL
Glu- GLU
glut- GLUT
f: argüman float tipinde
i: argüman integer tipinde
v: argüman vector’dur
Bilgisayar Grafikleri
OpenGL Fonksiyon İsimleri-Örnek 2
Bilgisayar Grafikleri
OpenGL Programı Tasarım Aşamaları
Genel olarak herhangi bir OpenGL programı yazılırken aşağıdaki adımlar
takib edilir :
1-GL ve GLUT ayarlanır : Pencere açma, görüntüleme modu, ……
2-OpenGL’ı başlangıç duruma getirme : Arka renk, ışık, bakma
pozisyonları, ……
3-Callback fonksiyonlarını kayda geçirme : Renderleme fonksiyonu
, etkileşim (klayve, fare)
4-Olay işleme döngüsü: glutMainLoop()fonksiyonu yazılır.
Bilgisayar Grafikleri
Basit Bir Örnek
void main (int argc, char **argv)
{
glutInit (&argc, argv); //GLUT başlatma
glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB);// görüntüleme modu
glutInitWindowSize (500, 500);
glutCreateWindow (“Benim İlk Programım");//pencere oluşturma
myinit ();
glutDisplayFunc ( display ); //Bir Callback fonksiyonu
glutReshapeFunc ( resize ); //Bir Callback fonksiyonu
glutKeyboardFunc ( key ); //Bir Callback fonksiyonu
glutMainLoop ();
}
Bilgisayar Grafikleri
GLUT Başlatma Fonksiyonları
• Standard GLUT başlatma
glutInit (int argc, char ** argv)
• Görüntüleme modeli
glutInitDisplayMode (unsigned int mode)
• Pencere boyutu ve yeri
glutInitWindowSize (int width, int height)
glutInitWindowPosition(int x, int y)
• Pencereyi oluştur
glutCreateWindow (char *name);
Bilgisayar Grafikleri
OpenGL’ı Başlangıç Duruma Getirme
void myinit(void)
{
glClearColor(1.0, 1.0, 1.0, 1.0); // arka renk
glColor3f(1.0, 0.0, 0.0); // çizgi rengi
glMatrixMode(GL_PROJECTION); // görüntüleme modeli
glLoadIdentity();
gluOrtho2D(0.0, 500.0, 0.0, 500.0);
glMatrixMode(GL_MODELVIEW);
}
Bilgisayar Grafikleri
Callback Fonksiyonları
 Callback Fonksiyonları
Bir olay olduğunda çağırılacak kod rutinleridir . Örneğin pencerenin
boyutunu değiştirme, yeniden çizme, kullanıcı girdisi, vb. işlemler için
tahsis edilen fonksiyonlara denir. OpenGL tarafından sağlanan standard
callback fonksiyonları vardır ancak programcı kendi istediği callback
fonksiyonlarını da yazabilir. Tanımlanan Callback fonksiyonları
“register” edilmeleri,yani kayda geçirilmeleri gerekir. Başka bir deyişle
tanımlanan callback fonksiyonları sisteme tanıtılmaları gerekir (şu olay
olduğunda şu fonksiyonu çağır diyebilmek için)
 GLUT-olay işlemmeyi sürdürmek için callback mekanizmasını
kullanır.
Bilgisayar Grafikleri
GLUT Callback Fonksiyonları
 Pencere içeriğini tazelemek için kullanılır
glutDisplayFunc()
 Pencere boyutu değişti veya hareket ettirildi
glutReshapeFunc()
 Tuş basılma olayı
glutKeyboardFunc()
 Fare butonu olayı
glutMouseFunc()
 Fare butonu basılı iken hareket etmesi olayı
glutMotionFunc()
 Fare butonunun durumuna bakılmaksızın hareket etmesi olayı
glutPassiveMouseFunc()
 Hiçbir şey olmadığında çağırılır
glutIdleFunc()
Bilgisayar Grafikleri
GLUT Callback Fonksiyonlarını Kayda Geçirme
//Callback fonksiyonlarını kayda geçirme aşağıdaki gibidir.burada display,
resize ve key kelimeleri birer callback fonksiyonudur.
void main (int argc, char **argv)
{
……
glutDisplayFunc ( display ); // display callback fonksiyonu
glutReshapeFunc ( resize ); // window resize callback fonk.
glutKeyboardFunc ( key ); // keyboard callback fonksiyonu
……
}
Bilgisayar Grafikleri
Rendering Callback Fonksiyonu
void display( void )
{
typedef GLfloat point2[2];
point2 vertices[3]={{0.0, 0.0}, {250.0, 500.0}, {500.0, 0.0}};
int i, j, k; int rand();
glClear(GL_COLOR_BUFFER_BIT);
for( k=0; k<5000; k++)
……}
Son görüntü renderleme işleminden sonra oluştuğu için bu callback fonksiyonunun
özel bir yeri vardır.OpenGL’ın tüm rendering işlemi burada yapılır. Aşağıdaki
örekte display() fonksiyonu basit bir renderleme callback fonksiyonudur. Bu
fonksiyon bir önceki slaytta gösterildiği gibi kayda geçirilir.
Bilgisayar Grafikleri
Pencere Boyut Değişme Callback Fonksiyonu
void resize(int w, int h)
{
glViewport(0, 0, w, h);
glMatrixMode(GL_PROJECTION);
glLoadIdentity();
……
display();
}
Pencere boyutu değiştiğinde veya taşındığında çağırılan bir callback
fonksiyonu örneği
Bilgisayar Grafikleri
Klavye Input Callback Fonksiyonu
void key( char mkey, int x, int y )
{
switch( mkey )
{
case ‘q’ :
exit( EXIT_SUCCESS );
break;
……
}
Bir tuşa basıldığında çağırılan callback fonksiyonu örneği
Bilgisayar Grafikleri
Olay Süreci Döngüsü
void main (int argc, char **argv)
{
……
glutMainLoop();
}
OpenGL uygulamalarında uygulamanın olayları algıladığı bloktur. Uygulama
callback fonksiyon çağrılarını buradan yönetir.Sistemde herhangi bir olay veya
çağırı oluştuğunda bu olaylar “olay süreci döngüsü” ’ne iletilirler. Bu
mekanizmada uygun callback fonksiyonunu meydana gelen olayla
ilişkilendirir.
Bilgisayar Grafikleri
Grafik Sistemi ve Grafik API’sinin Sağladıkları
Kullanıcı
Programı
Grafik
Sistemi
I/O Cihazı
Data
Fonksiyon
çağırıları Output
Input
Grafik API’si
Aşağıdaki şekle bakıldığında kullanıcı programı,Grafik API’si ve I/O cihazları
arasındaki iş akışı görülür . Kullanıcı programı API fonksiyon çağrıları
yardımıyla grafik sisteminin kaynaklarını kullanır.Grafik sistemi aynı zamanda
I/O arayüzü ile etkileşim içerisindedir.Bir sonraki slaytta Grafik API’lerinin
sağladıkları özellikler yer almaktadır.
Bilgisayar Grafikleri
OpenGL Grafik API’sinin sağladığı özellikler
 Primitifler
– nokta, çizgi, çokgen, bitmap, veya görüntü.
 Transformasyon işlemleri
– Döndürme, yerdeğiştirme, 3D koordinat uzayında bakış açısı.
 Renk modu
– RGB, RGBA, Color index.
 Maddelerin ışıklandırılması ve gölgelendirilmesi
 Bufferlama
– Double buffering, Z-buffering, Accumulation buffer.
 Texture mapping
Bu özellikler ileriki konularda ele alınacaktır.
Bilgisayar Grafikleri
Vertex Kavramı
Vertex :nokta, uzayda bir yer anlamına gelir. OpenGL de oluşturulan bütün
görüntüler vertex’ler vasıtasıyla oluşturulur. Vertexler glVertex*() komutu ile
tanımlanır.Burada * işaretinin yerine 2f yada 3f olabilir.
örnek: glBegin(GL_LİNES);
glVertex2f(0.0,0.0);
glVertex2f(0.1,0.1);
glEnd();
Bu örnekte glBegin() fonksiyonu aşağıda verilen primitiflerden herhangisini
alabilir. glBegin()’in aldığı primitif, vertexler ile belirlenen noktaları
birleştirmede kullanılır.
Bilgisayar Grafikleri
OpenGL Geometrik Primitifleri
Tüm geometrik primitifler vertix’ler ile tanımanır
GL_POINTS GL_LINES GL_LINE_STRIP GL_LINE_LOOP
GL_POLYGON GL_QUADS GL_TRIANGLES GL_TRIANGLE_FAN
Bilgisayar Grafikleri
OpenGL Geometrik Primitifleri İşlevleri
 GL_POINTS: her vertex ayrı bir nokta olarak ele alır
 GL_LİNES: her vertex çiftini bağımsız çizgi olarak ele alır
 GL_LINE_STRIP : ilk vertex ile son vertex’i çizgilerle birleştirir
 GL_LINE_LOOP : ilk ve son vertex aralarını çizgilerle birleştirir ve en son
olarak baş vertexe döner.
 GL_POLYGON : vertex koordinatlarını kullanarak tek bir çokgen çizer
 GL_QUADS : her dört vertex bağımsız bir dörtgen olarak ele alınır
 GL_TRIANGLES : her üç vertex bağımsız bir üçgen olarak ele alınır
 GL_TRIANGLE_FAN : bir birine bağlı üçgenler kümesi oluşturur.
Bilgisayar Grafikleri
Geometrik Primitifleri Tanımlama
Geometrik primitifler bir çift glBegin() ve glEnd() fonksiyonları arasında
tanımlanır. Bu iki komut arasında geometrik primitifin koordinatlarını
belirleyen bir veya birden fazla glVertex*() komutu yer alır.
glBegin( tip );
glVertex*(…);
……
glVertex*(…);
glEnd();
Tip parametresi, vertix’lerin nasıl birleştiğini belirtir.
Bilgisayar Grafikleri
Örnek-Kare Çizimi
void drawSquare (GLfloat *color)
{
glColor3fv ( color ); // çizileçek şeklin rengi
glBegin(GL_POLYGON);
glVertex2f ( 0.0, 0.0 );
glVertex2f ( 1.0, 0.0 );
glVertex2f ( 1.1, 1.1 );
glVertex2f ( 0.0, 1.0 );
glEnd();
}
Bilgisayar Grafikleri
Ödev -1
 Noktayı 400, 400’e getirin ve daha büyük yapın
 Alt sağ köşeden üst sol köşeye bir çizgi çizin
 Üçgenin boyutunu 2’ye katlayın ve yeşile boyayın
 Polygon’a 2 nokta daha ekleyerek kırmızıya boyayın
 Dördüzü kareye dönüştürün.
Bolum2.c programında aşağıdaki değişiklikleri yaparak deneyin.
Not: Programlar Download kısmından indirilebilir.
Bilgisayar Grafikleri
Birkaç Örnek Program
gears teapot1 glutmech1
Şimdiye kadar gördüğümüz bütün OpenGL programlama tekniklerini aşağıda
gösterilen programlarda görebilirsiniz. Bu programları download kısmından
indirerek kodlarını inceleyiniz ve programların çalışmalarını anlamaya
çalışınız.
Bilgisayar Grafikleri
Alıştırmalar
 4x4 Satranç Tahtası Çizin
 4x4 kareler
 Kereler yeşil ve kırmızı renkte
 Her kare 50x50 piksel büyüklüğünde
 Bir Ev Çizin
 1 kapı
 2 pencere
 1 zemin
 NOT: Cevap programlar download bölümünde mevcuttur.
Bilgisayar Grafikleri
Diğer Basit OpenGL Özellikleri
glClearColor(x, y, z, a);
– Art alanı boyama fonksiyonudur
– 4. argüman saydamlığı belirler; 1.0 tamamen saydam
– Durum değişkenini set eder
glPointSize(x);
– Nokta büyüklüğünü “X” piksele ayarlar
– Not: bu cihaz bağımsız bir özellik değildir. Yani çihazlara göre değişir
– Durum değişkenini set eder
glLinewidth (x);
-çizgi genişliğini x değeriyle belirler.
Bilgisayar Grafikleri
Özellikler (Attributes)
 Özellikler geometrik primitiflerin nasıl renderleneceğini belirler
 OpenGL vertexleri her işlediğinde ,kendi iç özellik tablosuna
başvurarak vertex’in nasıl transform edileceğini,nasıl render
edileceğini veya diğer OpenGL modlarını belirler.
(internal attribute table -dahili özellik tablosu)
Örnek için bir sonraki slayda bakınız.
Bilgisayar Grafikleri
Örnek
glPointSize(3.0);//nokta büyüklüğü tanımlandı
glShadeModel(GL_SMOOTH); // özellik tablosunda gölgelendirme için
glBegin(GL_LINE); // GL_SMOOTH set edildi,yani düz bir gölgelendir
glColor4f(1.0, 1.0, 1.0, 1.0);// me modeli olacak
glVertex2f(5.0, 5.0);
glColor3f(0.0, 1.0, 0.0);
glVertex2f(25.0, 5.0);
glEnd();
Bilgisayar Grafikleri
OpenGL Renk Modeli
 OpenGL’da 2 renk modeli vardır
– RGB (Gerçek Renk)
– Indexed Color (Renk Haritası)
 Pencerenin renk modeli pencereleme sistemi tarafından
sağlanır.
Bir sonraki slaytlarda her iki renk modeli ayrıntılı olarak ele
alınacaktır.
Bilgisayar Grafikleri
RGB Renk Modeli
RGB Renk Modeli’nde her pikselin “Red, Green, Blue”,yani “Kırmızı,
Yeşil, Mavi” bileşenleri mevcüttur .RGB modunda, bir pikselin rengi
diğerlerinden bağımsızdır.Yani her piksel için ayrı ayrı renk özellikleri
atanabilir. Aşağıdaki şekil bunu daha iyi açıklamaktadır.
Kırmızı
Yeşil
Mavi
Bilgisayar Grafikleri
RGB Renk Komutları
glColor*(…) fonksiyonu
vertex’lerin rengini belirler.Bir kere çağırılan glColor*() fonksiyonu, bir
sonraki çağırma gelene kadar aynı rengi korur.
glClearColor(r, g, b, a) : pencerenin art alanının rengini belirler
glutInitDisplayMode(mod) :Görüntülem renk modunu belirler.RGBA isteniyorsa
mod olarak GLUT_RGBA , İndexed color isteniyorsa mod olarak GLUT_INDEX
parametresi alınır.
Bilgisayar Grafikleri
Örnek
glutInitDisplayMode (GLUT_RGBA);// görüntüleme modu
glClearColor(1.0, 1.0, 1.0, 1.0); //artalan rengi
void drawLine (GLfloat *color)
{
glColor3fv ( color ); //vertex rengi
glBegin(GL_LINE);
glVertex2f ( 0.0, 0.0 );
glVertex2f ( 1.0, 0.0 );
glEnd();
}
Bilgisayar Grafikleri
Indexed Color
Color-index modu RGB moduna nazaran daha az hafıza kapladığı
için önemlidir.Bunun nedeni de Color-map olarak tanımlanan
renk başvuru tablosunu kullanmasıdır. Color-index modunda aynı
index’e sahip her piksel “color-map” ta aynı yuvayı kullanır(pointer
kavramı gibi düşünülebilir).
Bilgisayar Grafikleri
Renk Başvuru Tablosu
… … …
187
0
Mavi
120 123
0 0
Kırmızı Yeşil Index
0
1
255
254
253
…
8 bit 8 bit 8 bit
Bilgisayar Grafikleri
RGBA’ya Karşı Color Index Modu
… … …
187
0
B
120 123
0 0
R G Index
0
1
2
…
255
254
RGBA modeli
Color index modeli
Bilgisayar Grafikleri
Color Index Komutları
glIndex*(…) : Vertex rengini belirler
glClearIndex(Glfloat index) : color buffer’ın silineceği
renk(doldurulacağı).Yani artalan rengini belirler.
glutSetColor(int color, GLfloat r, GLfloat g, GLfloat b ) :
pencere için renk tablosuna eklemeler yapar
Bilgisayar Grafikleri
Cube Programı
Konusu: renk belirleme ilkeleri - program kodunu inceleyiniz.Program kodunu
download bölümünden indirebilirsiniz.
Bilgisayar Grafikleri
OpenGL Durum Makinesi (State Machine)
OpenGL bir durum makinesi gibi çalışır. Durum, uygulamalar tarafından
değiştirilebilen bir takım değişkenlere sahiptir.Örnegin glClearColor*()
fonksiyonunu kullanarak renk bufferini mavi renkle silersek durum
makinesinin uygun değişkeni mavi değeri alır ve bir sonraki komut gelene
kadar durumunu korur. Geçerli görüntüleme konumu, çizgi genişliği, madde
özellikleri, temizleme rengi gibi özellikler durum makinesinin diğer ögeleridir.
Bilgisayar Grafikleri
OpenGL’da Durum Yönetimi
Vertex özelliklerini belirlemek için aşağıdaki
fonksiyonlar kullanılır.
– glPointSize(...) -- nokta boyutu
– glLineWidth(…) -- çizgi genişliği
– glColor*(…) -- renk
– glNormal*(…) -- normal
– glTexCoord*(…) -- texturing
Durum Fonksiyonlarını yönetmek için ise
glEnable(...) ve glDisable(...) komutları kullanılır
glEnable() fonksiyonu durum fonksiyonunu
aktif yaparken glDisable() fonksiyonu durum
fonksiyonunu pasif yapar.
Özellikler
Bilgisayar Grafikleri
Örnek:
glEnable(GL_LIGHTING);//GL_LIGHTING durum değişkeni
glShadeModel(GL_SMOOTH); // kontrolü örneği. Aktif yapıldı
glBegin(GL_LINE);
glColor3f(1.0, 1.0, 1.0);
glVertex2f(5.0, 5.0);
glColor3f(0.0, 1.0, 0.0);
glVertex2f(25.0, 5.0);
glEnd();
glDisable(GL_LIGHTING);// Durum değişkeni pasif yapıldı
Bilgisayar Grafikleri
Transformasyon
 Transformasyon 3D objelerin 2D ekranda gösterilmesini sağlar.
 Grafik transformasyon süreci, bir şeyin fotografını fotograf
makinesiyle çekmeye benzer.
 Her transformayon, vertex’in bir koordinat sistemindeki
gösterimini diğer bir koordinat sistemine taşıma gibi düşünülebilir.
Bilgisayar Grafikleri
Sentetik Kamera Modeli
Kamera
Model
Bilgisayar Grafikleri
Transformasyonlar Ve Kamera Benzetmesi
 Görüntüleme transformasyonu
– Kameranın yerleştirilmesi ve odaklanması.
 Modelleme transformasyonu
– Modelin yerleştirilmesi ve hareket ettirilmesi
 Projeksiyon transformasyonu
– Kameranın lensinin ayarları
 Bakış Açısı transformasyonu
– Fiziki fotografın büyültülüp küçültülmesi
Bilgisayar Grafikleri
koordinat Transformasyonu
 Her transformayon, vertex’in bir
koordinat sistemindeki gösterimini diğer bir
koordinat sistemine taşıma gibi
düşünülebilir.
Bilgisayar Grafikleri
Transformasyonlar Ve Koordinat Sistemleri
 Görüntüleme transformasyonu
– Kamerayı belirleme (kamera koordinatları)
 Modelleme transformasyonu
– Geometrik belirleme (dünya koordinatları)
 Projeksiyon transformasyonu
– pencere koordinatları
 Bakış Açısı transformasyonu
– Ekrana map etme (ekran koordinatları)
Bilgisayar Grafikleri
OpenGL de Transformasyon
 Transformasyonlar matris işlemleriyle belirlenir. İstenen transformasyon
basit transformasyon dizisi ve bu transformasyonların birleştirilmesiyle
elde edilebilir.
 Transformasyon matrisi genellikle 4x4 matris ile ifade edilir.
 OpenGL, desteklenen bütün matris tiperi için yığınlar sağlar..
 Daha fazla bilgi için Bölüm 4’e (döndürme,çevirme, ölçekleme) bakınız.
Bilgisayar Grafikleri
OpenGL Transformasyon Boru Hattı
Bilgisayar Grafikleri
Görüntüleme (Viewing)
 Görüntüleme Hacmi(viewing volume)
 Projeksiyon (Ortografik veya Paralel)
 Bakış Açısı Transformasyonu(viewpoint transf.)
Bilgisayar Grafikleri
Koordinat Sistemini Belirleme
+X
+Z
+Y
Default olarak
kamera orijin
noktasındadır
ve negatif zeksenine
bakmakta.
Bilgisayar Grafikleri
OpenGL Ve Windows Ekranı
Unutmayın: OpenGL’in Y koordinatları Windows ekran Y
koordinatlarının tam tersidir ama XWindows sistemi ile
aynıdır.
Pozitif
X
Y
Pozitif
OpenGL Ekran Haritalama
(50, 50)
(0, 0)
Pozitif
X
Y Pozitif
Windows Ekran Haritalama
(50, 50)
(0, 0)
Bilgisayar Grafikleri
Görüntüleme Hacmi
Yakın-Plan
Uzak-Plan
Görüntüleme
hacmi
Bilgisayar Grafikleri
Ortografik Projeksiyon
Obje vertexlerinin
izdüşümleri sonsuza
kadar mevcuttur.
• Görüntüleme hacmi
dışında kalan
noktalar kesilir
(clipped out ) .
• Mesafe, objenin
görünüşteki boyutunu
değiştirmez.
Kesilen
Kısım
Görüntü
Bilgisayar Grafikleri
Ortografik Görüntüleme Hacmi
Yakın-plan Uzak-plan
Görüntüleme
Hacmi
Kesilen Kısım
Görüntüleme
Diktörtgeni
sol
sağ
üst
alt
Bilgisayar Grafikleri
Ortografik Projeksiyon Komutları
 glOrtho( sol, sağ, alt, üst, zNear, zFar )
Ortografik görüntüleme hacmi için bir matris oluşturur ve geçerli matrisi bu
matris ile çarpar.
• gluOrtho2D( sol, sağ, alt, üst )
2D koordinatları ekrana yansıtamak için bir matris
oluşturur ve geçerli matrisi bu matris ile çarpar.
Bilgisayar Grafikleri
Genel-Amaçlı Transformasyon Komutları
 glMatrixMode(mod)
Ne tür transformasyon matrisinin değiştirildiğini belirler.
mod:
GL_MODELVIEW
GL_PROJECTION
Bilgisayar Grafikleri
Genel-Amaçlı Transformasyon Komutları-1
• glLoadIdentity( void )
Geçerli değişebilir matrisi 4x4 özdeş şekle
getirir.
Bilgisayar Grafikleri
Ortografik Projeksiyon Örneği
glMatrixMode(GL_PROJECTION)
glLoadIdentity();
gluOrtho2D(0.0, 500.0, 0.0, 500.0);
glMatrixMode(GL_MODELVIEW);
Bu satırlar alt sol köşesi 2D sisteminin orijininde olacak şekilde
bir 500x500 görüntüleme dörtgeni tanımlar.
Bilgisayar Grafikleri
Bakış Açısı
 Bakış Açısı
– Kesilen alanların çiziminde kullanılan, pencerenin bir bölgesidir.(the
region within the window that will be used for drawing the clipping area.)
– Default olarak açık olan pencere diktörtgeninin tüm alanı olarak set
edilmiştir.
– Pencere koordinatları cinsinden hesaplanır ve bu koordinatlar pencerenin
alt-sol köşesine göre piksel pozisyonlarını ekrana yansıtırlar.
Bilgisayar Grafikleri
Bakış Açısı Transformasyonu
Bakış açısı pencere
boyutu kadar
tanımlanmıştır.
Bakış açısı
pencerenin yarı
boyutu kadar
tanımlanmıştır.
h
w
h
w
Bilgisayar Grafikleri
Aspect Ratio
 Dikdörgen için Aspect Ratio eninin boyuna oranıdır :
örnek: Aspect Ratio = en/boy
 Bakış açısının aspect ratio’su görüntüleme transformasyonunun aynısı
olmalıdır, yoksa çıktı görüntünin biçimi bozulabilir.
Bilgisayar Grafikleri
Bakış Açısı Komutları
 glViewport( x, y, genişlik,yükseklik )
Pencere içine çıktı görüntünün map edileceği bir diktörtgen tanımlar.
(x, y) bakış açısının alt sol köşesini tanımlar.
(genişlik,yükseklik) bakış açısı dikdörtgeninin boyutunu belirler.
Bilgisayar Grafikleri
Hepsi Bir Arada...
 Geometri Komutları
– glBegin, glEnd, glVertex
 Durum Kontrol Komutları
– glutInitDisplayMode, glEnable, glDisable, glColor,
 Ortografik Projeksiyon Komutları
– glOrtho, gluOrtho2D, glMatrixMode, glLoadIdentity
 Bakış Açısı Komutları
– glViewport
Bilgisayar Grafikleri
Örnek: Bolum2.cpp (kodu inceleyin)
Bilgisayar Grafikleri
Sierpinski Gasket Programı : Slide 1
#include <glut.h>
void myinit(void)
{
/* attributes */
glClearColor(1.0, 1.0, 1.0, 0.0); /* white background */
glColor3f(1.0, 0.0, 0.0); /* draw in red */
/* set up viewing */
/* 500 x 500 window with origin lower left */
glMatrixMode(GL_PROJECTION);
glLoadIdentity();
gluOrtho2D(0.0, 500.0, 0.0, 500.0);
glMatrixMode(GL_MODELVIEW);
}
Bilgisayar Grafikleri
Sierpinski Gasket Programı : Slide 2
void display( void )
{
/* define a point data type */
typedef GLfloat point2[2];
point2 vertices[3]={{0.0,0.0},{250.0,500.0},{500.0,0.0}};
/* A triangle */
int i, j, k;
long rand(); /* standard random number generator */
point2 p ={100.0,100.0}; /* An srbitrary initial point */
glClear(GL_COLOR_BUFFER_BIT); /*clear the window */
Bilgisayar Grafikleri
Sierpinski Gasket Programı : Slide 3
/* computes and plots 5000 new points */
for( k=0; k<5000; k++)
{
j=rand()%3; /* pick a vertex at random */
/* Compute point halfway between vertex and old point */
p[0] = (p[0]+vertices[j][0])/2.0;
p[1] = (p[1]+vertices[j][1])/2.0;
/* plot new point */
glBegin(GL_POINTS);
glVertex2fv(p);
glEnd();
}
glFlush(); /* clear buffers */
}
Bilgisayar Grafikleri
Sierpinski Gasket Programı : Slide 4
void main(int argc, char** argv)
{
/* Standard GLUT initialization */
glutInit(&argc,argv);
glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB);
/* default, not needed */
glutInitWindowSize(500,500);
/* 500 x 500 pixel window */
glutInitWindowPosition(0,0);
/* place window top left on display */
glutCreateWindow("Sierpinski Gasket");
/* window title */
glutDisplayFunc(display);
/* display callback invoked when window opened */
myinit(); /* set attributes */
glutMainLoop(); /* enter event loop */
}
Bilgisayar Grafikleri
Ödev
 Aşağıdaki OpenGL Geometrik Primitiflerini en az 1 kere kullanarak 2-
boyutlu objeler oluşturun.
– GL_POINTS
– GL_LINES
– GL_LINE_STRIP
– GL_LINE_LOOP
– GL_POLYGON
– GL_TRANGLES
– GL_QUADS
– GL_TRANGLE_STRIP
– GL_QUAD_STRIP
– GL_TRANGLE_FAN
Bilgisayar Grafikleri
Bilgisayar Grafikleri
Bölüm 3
Bilgisayar Grafikleri
Bu Derste Göreceklerimiz
 Input Cihaz Tipleri
 Interaktif Grafik Programlama
Bilgisayar Grafikleri
Etkileşim
Etkileşim, bilgisayar grafikleri uygulamalarının en önemli
bileşenlerindendir. Buradaki etkileşim uygulama programı ile
grafik kütüphaneleri arasındaki etkileşimi içine almakla
birlikte kullanıcı-uygulama programı ekseni etrafında
yoğunlaşmaktadır. Üst seviye etkileşim olarak
adlandırdığımız kullanıcı-uygulama programı seviyesinde
kullanıcı tarafından uygulama programına verilen komutlar ve
programdan alınan yanıtlar söz konusudur. Uygulama
programı aynı zamanda üst seviye etkileşimde elde ettiği
verileri alt seviye etkileşim olarak adlandırdığımız “uygulama
programı-grafik API-Grafik Sistemi” sürecine taşır.
Bilgisayar Grafikleri
Grafik Sistemi İle Etkileşim
Görüntü
Değiştirme
Değiştirme
isteği
Grafik Sistemi Kullanıcı
Input
Cihazı
Display
Grafik sistemi ve kullanıcı arasındaki etkileşim uygulama progmaı+Grafik
API toplamı tarafından gerçekleştirilmektedir. Aşağıdaki şekilde bu tablo
kabaca tasvir edilmiştir. Ara katman olan uygulama-grafik API katmanı
gizli katmandır.
Bilgisayar Grafikleri
GL Kütüphanesi Organizasyonu
(X Windows altında)
OpenGl
Uygulama
Programı
GLU
GL
GLUT
GLX
Xlib, Xtk
Frame
buffer
X Window grafik sisteminde uygulama programı temel ve ardımcı
OpenGL kütüphaneleri yardımıyla işletim sisteminin grafik
kütüphaneleri olan Xlib ve Xtk ile etkileşimde bulunur.
Bilgisayar Grafikleri
GL Kütüphanesi Organizasyonu
(MS Window altında)
Window OS
Uygulama
GL GLU GLUT
MS Windows ortamında durum biraz farklıdır. Win32 sisteminde
uygulama programı OpenGL’in temel ve yardımcı
kütüphanelerinin yanısıra direk olarak işletim sisteminin
kaynaklarından faydalanabilmektedir.
Bilgisayar Grafikleri
Input Cihazları
İnput Cihazlarını 2 kategoriye ayırabiliriz:
• Fiziki cihazlar – gerçek-dünya fiziki özellikleriyle tanımlanabilirler.
(fare, klavye, joystik…)
• Lojikal cihazlar – kullanıcı programının yüksek seviye arayüzü ile
karakterize edilir. Cihaz verisinin soyutlanmış şeklidir.
(fonksiyonlar, windows cihaz sürücüleri)
Bilgisayar Grafikleri
Fiziki İnput Cihaz Türleri
 Klavye
 Seçim cihazları
 Locator’lar
Yukarıdaki fiziki cihaz türlerinden herbiri ileriki slaytlarda açıklanmıştır.
Bilgisayar Grafikleri
Klavye
 Spesifik özelliklere sahip karakterler döndürür
Bilgisayar Grafikleri
Seçim
 Bir kaç opsiyon içinden seçilenini döndürür.Genel olarak önceden
tanımlanmış olan işlemler mevcuttur ve kullanıcı bu işlemlerden
herhangi birini seçmektedir.
- Buton Kutusu
- Fonksiyon keypad
Bilgisayar Grafikleri
Locator Cihazlar
 konum ve/veya yönlendirme (orientation) bilgisi döndürürler. Bu
cihazların aşağıdaki türleri mevcuttur :
– Fare
– Trackball
– Tablet
– Joystik
– Touch screen
Bilgisayar Grafikleri
3D Input Cihazlar
 3 boyutlu konum ve /veya yönlendirme(orientation) bilgisi
döndürürler. Aşağıdaki türleri mevcuttur :
– Digitizer
– 3D Spaceball
– Glove
– Tracker
Bilgisayar Grafikleri
3D Input Cihazlar-Digitizer
Digitizer
- 3D model
Bilgisayar Grafikleri
3D Input Cihazlar-Spaceball
3D Spaceball
Bilgisayar Grafikleri
3D Input Cihazlar-Glove (eldiven)
Haptic Glove Tracking özellikli el ve
parmak- konum / yönlendirme
Bilgisayar Grafikleri
3D Input Cihazlar-Tracker
Hareket Tracker’ı
- Manyetik
- Akustik
- Inertial(atıl)
- Optikal
- GPS
Bilgisayar Grafikleri
Lojikal Cihazlar
Uygulama programı açısından karakterize edilen cihazlardır. Aşağıdaki
türleri mevcuttur:
– Kullanıcı programının yüksek-seviye arayüzü olarak
– Cihaz verisinin soyutlanmış şekli olarak
Bilgisayar Grafikleri
Lojikal Cihaz Tipleri
 Katar (String)
– ASCII katarlarını döndürür
 Locator
– Konum ve yönlendirme bilgisi döndürür
 Pick
– Obje tanımlayıcı bilgisi döndürür
 Seçim(choise)
– Bir kaç opsiyon içinden seçilenini döndürür
 Çevirim (Dial)
– Analog input’u dönderir
 Stroke – Konum dizisi dönderir.
Bilgisayar Grafikleri
Input Cihazlarının Davranışları
İnput cihazlaının darvanışları iki şekilde tanımlanır.
1-Ölçme: cihaz , kullanıcı programına ne döndürür
2-Trigger: ölçümlerin döndürülmesi
Bilgisayar Grafikleri
Iput Cihazını Okuma Yolları
İnput cihazından üç şekilde okuma yapılabilir. Bunlar :
 Örnek modu(sample mode)
 İstek modu(request mode)
 Olay modu(event mode)
Bilgisayar Grafikleri
Örnek Modu(sample mode)
Çalışma şekli aşağıdaki gibidir:
“Merhaba, şu anda cihazda ne var? Bana veriyi hemmen ver! “
Ölçme
süreci
Program
örnek
(1)
ölçme
(2)
- trigger’a ihtiyaç yok
- anında döndürme
- Fonksiyon çağrısından önce veri hazırlanır.
Bilgisayar Grafikleri
İstek Modu(request mode)
Cihaz tetiklenene kadar ölçülen değerler döndürülmez. Tetikleme
gelidği anda ölçülen değerler istek birimine gönderilir.
- Tetiklemeyi bekler
- C deki “ scanf() ” fonksiyonu gibidir
Ölçme
Süreci Program
İstek
(1)
ölçme
(4)
Trigger
Süreci
Trigger
(3)
(2)
Bilgisayar Grafikleri
Olay Modu-1
Cihaz tetiklenene kadar ve kullanıcı herhangi bir şey yapana kadar
bekle
• İki asenkron süreç
- Olay üretimi (cihaz tetiklenmesi)
- Kullanıcı isteği (olay sorgulama)
• Olay üretimi ve süreçler birbirinden bağımsız
• Birden fazla input cihazı olabilir
Bilgisayar Grafikleri
Olay Modu-2
Windows’un olay mekanizmasını ele alalım
- Cihaz triggeri ile bir
olay üret
- Olayı “olay
kuyruğu”na koy
- olay kuyruğunu ve
süreci incele
Olay
süreci
Fare
Klavye
…
süreç
Olay 1
Olay 2
Olay 3
…
Olay
kuyruğu
Olay
kaynağı
Bilgisayar Grafikleri
Olay Modu-3
İki asenkron süreç
Ölçme
Süreci
Program
bekleme
(1)
Olay
(2)
Trigger
Süreci
Olay
Kuytuğu
Trigger
(1)
Ölçme
(2)
Bilgisayar Grafikleri
Interaktif Grafik Programlama
Aşağıdaki konular ele alınacaktır:
 GLUT programlama
 Olay işlemek için “Callback mekanizması”
 Olay-yönelimli (event-driven) Input modu
Bilgisayar Grafikleri
GLUT Programlama-Giriş
 Tasarımsal nedenlerden dolayı OpenGL özelliklerinde pencere
bağımlılığından kaçınılmıştır. Böylelikle oluşan arayüz taşınabilir,
veriyollarıyla bezenmiş bir 2 ve 3 boyutlu görüntüleştirme kitaplığı
niteliğindedir. Pencere açma ve görüntüleştirme yerel pencere
sistemine kalmış bir konudur. OpenGL kitaplığı, yerel sistemle,
yardımcı kitaplıklar aracılığıyla iletişimde bulunur. Sözgelimi, GLX
yardımcı kitaplığı OpenGL ile X pencere sistemi arasında iletişim
sağlar.
 OpenGL elaygıt takımı (GLUT: OpenGL Utility Toolkit), pencere
sisteminden bağımsız OpenGL programları yazmak için ANSI C ve
FORTRAN bağlantılarûndan oluşur. Bu yazılım Mark J. Kilgard
tarafından yazılmış olup OpenGL tanımlamalarında açık kalmış olan
büyük bir boşluğu örtmektedir. Erek ortamdan (target platform)
bağımsız olarak ortak bir pencere sistemi kullanımına olanak sağlar.
Bilgisayar Grafikleri
GLUT Programlama-Giriş-1
 GLUT göresel olarak küçük ve öğrenmesi kolay bir yapıdır. Tasarımı iyi olup
yazarı tarafından çok güzel bir bilgi dağarcığı da hazırlanmış bulunmaktadır.
GLUT API, OpenGL gibi, bir durum motorudur. Bunun anlamı, GLUT'un
uygulamanın çalıştırılması sürecinde etkin olan durum değişkenlerine sahip
olduğudur. GLUT motorunun başlangıç durumları bir çok uygulamaya
uyabilecek biçimde seçilmiştir. Program, uygun gördükçe, durum değişken
değerlerini değiştirebilir. Herhangi bir GLUT fonksiyonunun uyarılması
durumunda, fonksiyonun etkimesi o andaki durum değişkenlerinin değerlerine
göre ayarlanır. GLUT fonksiyonları kolay yapıda olup yalnızca bir kaç
parametre alırlar. Fonksiyonlardan genellikle gösterici (pointer) döndürülmez ve
fonksiyonlara gönderilen göstericiler ise yalnızca katar ve geçirgen olmayan
fontlar için olanlarla kısıtlanmışlardır
Bilgisayar Grafikleri
GLUT Fonksiyonlarının sınıflandırılması
 GLUT fonksiyonları, işlevselliklerine göre, bir kaç alt API'ye sınıflandırılabilirler:
 Başlatım
 Başlangıç Olay İşlemesi
 Pencere İşletimi
 Örtükatman (overlay) İşletimi
 Mönü İşletimi
 Callback Fonksiyonlarını Kayda Geçirme
 Renk İndeksi, Renk Haritası İşletimi
 Duruma Geridönüş
 Font Görüntüleştirimi
 Geometric Biçim Görüntüleştirimi
 Bu derste, basit bir OpenGL programını başlatmak için gerekli olan başlatım,
pencere işletimi, olay işleme fonksiyonlarından bazılarını inceleyip anlamaya
çalışacağız
Bilgisayar Grafikleri
Başlatımlar
GLUT kullanan tüm OPenGL programları GLUT durum motorunu başlatacak biçimde
başlamalıdırlar. GLUT başlatım fonksiyonları glutInit- önekine sahip olmalıdırlar. Ana
başlatım yordamı glutInit'dir:
Kullanım: glutInit(int **argcp, char **argv);
argcp anaprogramdan, programın düzeltilmemiş argc değişkenine bir göstericidir.
Döndürüldüğünde argcp tarafından gösterilmekte olan argcp değeri güncellenir. Bunun
nedeni, glutInit fonksiyonunun, GLUT kitaplığı ile ilgili olan güdümsatırı seçeneklerini çekip
çıkarmasıdır. Sözgelimi, X pencere sistemi ortamında, X pencere sistemiyle ilgili
seçeneklerden GLUT'la bağlantılı olanların algılanması gibi. argv program'ın, anaprogram
için, düzeltilmemiş argv değişkenidir. glutInit GLUT durum değişkenlerinin başlatımını ve
pencere sistemi ile bir oturum için iletişimin sağlanmasını üstlenir. glutInit'ten önce başlatılan
bir kaç yordam varolup bunlar glutInit- önekine sahiptirler. Bu yordamlar benimsenen
pencere başlatım durumunu ayarlamakta kullanılırlar.
Sözgelimi:
Kullanım:
glutInitWindowPosition(int x, int **y);
glutInitWindowSize(int width, int **height);
x,y = piksel türünden pencerenin ekrandaki konumu (sol üst köşe)
width,height piksel türünden pencere en ve boyu.
Bilgisayar Grafikleri
Başlatımlar-1
Tüm OPenGL uygulamasında kaçınılmaz olarak bulunan başka bir başlatım yordamı,
(glutInitDisplayMode()) daha bulunmaktadır:
Kullanım: glutInitDisplayMode(unsigned int mode);
mode güsterim modu olup GLUT güsterim modu bit maskelerinin bit türü bir
OR'lamasıdır.Olabilir bit maske değerleri aşağıda verilmektedir :
GLUT_RGBA : Bir RGBA mode pencere seçer. Bu, ne GLUT_RGBA ne de
GLUT_INDEX belirtilmedikçe, benimsenen değer olarak kalır
GLUT_RGB :GLUT_RGBA ile aynı.
GLUT_INDEX : Renk indeks pencere modunu seçer.GLUT_RGBA'ya baskındır.
GLUT_SINGLE:Tek bir tamponlu pencere seçer. Bu benimsenen yapıdır.
GLUT_DOUBLE: Çift tamponlanmış bir pencere seçer. GLUT_SINGLE'a baskındır.
GLUT_ACCUM :Depolama tamponlu bir pencere seçer.
GLUT_ALPHA : Renk tamponuna(larına) alfa bileşenli bir pencere seçer.
GLUT_DEPTH: Derinlik tamponlu bir pencere seçer.
GLUT_STENCIL :Örüntü yedekleme tamponlu bir pencere seçer.
GLUT_MULTISAMPLE :Multismapling destekli bir pencere seçer.
GLUT_STEREO : Bir stereo pencere seçer.
GLUT_LUMINANCE : "luminance" renk modelli bir stereo pencere seçer.
Bilgisayar Grafikleri
Basit Başlatım Örnek 1
#include <GL/glut.h>
void main(int argcp, char **argv){
/* pencere boyutu ve konumu belirle */
glutInitWindowSize(640, 480);
glutInitWindowPosition(0, 0);
/* Display mode seçme:
Single buffer & RGBA color */
glutInitDisplayMode(GLUT_RGBA | GLUT_SINGLE);
/* GLUT durum başlatımı */
glutInit(&argcp, argv);
.....daha fazla kod
};
Bilgisayar Grafikleri
Basit Başlatım Örnek 2
#include <GL/glut.h>
void main(int argcp, char **argv){
/* pencere boyutu ve konumu belirle */
glutInitWindowSize(640, 480);
glutInitWindowPosition(0, 0);
/* Display mode seçme :
Double buffer & RGBA color */
glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE);
/* GLUT durum başlatımı */
glutInit(&argcp, argv);
.....daha fazla kod
};
Bilgisayar Grafikleri
Örnek 1 ve Örnek 2 Arasındaki Fark
 Bu ikisi arasındaki ana ayrılık, ikinci örnekte gösterimin
bir çift tampon modunda başlatımıdır. Bu durum
canlandırımlar için idealdir, çünkü bu yapı canlandırım
sürecindeki kırpışmaları ortadan kaldırır.
Bilgisayar Grafikleri
Olay İşleme
Yukarıda sözedildiği gibi, GLUT bir durum motorudur. Şimdi de onun olay geliştiren bir
motor olarak da tasarlandığını öğreneceğiz. Bunun anlamı, bir sayaç'ın ya da sürekli bir
döngünün uygun başlatımlar sonrasında devreye girıdiğidir. Bunlar, GLUT'a belirtimi
yapılan tüm olay ve süreçlerin başlatılmasını sağlarlar. Olaylar şunlardır: tıklatılan bir fare,
kapatılan bir pencere, bir pencerenin yeniden biçimlendirilmesi, imleç hareketi, basılan
klavye tuşları, ve daha da ilginci, hiçbirşeyin olmadığı boş olay. Olası olayların her biri
GLUT sayaç ya da olay geliştirme döngüsünün değişkenlerinden birine kaydedilmelidir.
Böylece, bu olayların tetiklenip tetiklenmediği sürekli denetlenebilir duruma gelmiş olur.
Sözgelimi, "fareyi tıklat"ı bir olay olarak GLUT'a kaydedip gözlemleyebiliriz. Olaylar
callback fonksiyonları ile kaydedilirler. Tümünde yazımkuralı glut[someEvent]Func
biçimindedir. Fare tıklama durumunda bu glutMouseFunc biçiminde olacaktır. Bir
callback fonksiyonu kaydı GLUT motoruna hangi kullanıcı tanımlı fonksiyonun olayın
tetiklenmesi durumunda çağırılacağını söyler. Dolayısıyla, farenin sol (ya da sağ,..) tuşu
tıklatıldığında ne yapılacağını tanımlayan MyMouse adlı kendi yordamımı yazacak olursam
o zaman geriçağırış fonksiyonumu main() içinde glutInit() sonrasında
"glutMouseFunc(MyMouse);“ deyimini kullanarak kaydedebilirim.
Bilgisayar Grafikleri
Olay İşleme-1
GLUT içinde hangi geriçağırma fonksiyonlarına ve olaylara olanak sağlandığını
daha sonraya bırakalım. Bu anda önemli olan nokta uygulamamızdaki tüm önemli
olaylar kaydedildikten sonra GLUT'un olay işleme yordamı olan
glutMainLoop()'un uyarılmasıdır. Bu fonksiyonun geri dönüşü yoktur,
programımız temelde sonsuz bir döngüye girer. Bu döngü gerekli olan önceden
kayıtlı callback fonksiyonları çağırır. Tüm OpenGL uygulamalı main()
fonksiyonları, bu nedenle, bir glutMainLoop() deyimi ile sona ermelidir.
Dolayısıyla, bizim canlandırım şablonumuzda:
Bilgisayar Grafikleri
Olay İşleme-2
Dolayısıyla, bizim canlandırım şablonumuzda:
#include <GL/glut.h>
void main(int argcp, char **argv){
/* GLUT durum başlatımı */
glutInit(&argcp, argv);
glutInitWindowSize(640, 480);
glutInitWindowPosition(0, 0);
/* pencere oluşturma */
glutCreateWindow("My OpenGL Application");
/* Display mode seçme:
Double buffer & RGBA color */
glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE);
/* Callback Fonksiyonlarını kayda geçirme */
.....
/* Olay işleme mekanizmasını başlat */
glutMainLoop();
};
Bilgisayar Grafikleri
Olay İşleme-3
Görüldüğü gibi, uygulamaya önceden sözü edilmeyen fazladan kod eklemiştir .
Bu, glutCreateWindow(char **name), GLUT'un pencere işletim fonksiyonlarından
biridir. Bu, işte, OpenGL & GLUT tasarım felsefesinin en çok beğenilen bir
yanıdır. Yalnızca adına bakarak fonksiyonun ne yaptığı hakkında bilgi edinmek
mümkündür!. Ayrıca, tabandaki pencere sistemine OpenGL uygulamamız için
pencere açtırma güdümünü de gönderebilmektedir. Açılacak pencere bir katar ile
aktarılan ada sahip olacaktır. Pencere sisteminde bu ad pencerenin sol üst köşesine
yazılacaktır. GLUT'un pencere işletim bölümü inceleyeceğimiz daha bir çok
fonksiyon barındırmaktadır. Öte yandan, burada başlatım fonksiyonlarını onların
glutInit()'den sonra da yerleştirilebileceğini göstermek üzere yeniden
düzenlemiştir.
Bilgisayar Grafikleri
Olay İşleme-4
Olaylara dönelim... Şimdi, tüm canlandırım programları için çok temel olan iki
callback fonksiyonları üzerinde duralım . Bunlar gösterim fonksiyonunu varolan
pencere için düzenleyen glutDisplayFunc ve boş callback'ları düzenleyen
glutIdleFunc fonksiyonlarıdır. Her iki fonksiyon da void *(void) türü birer
fonksiyondurlar. Diyelim ki canlandırım şablonumuz için iki tane ek callback
fonksiyonu yazıyoruz. Bunlar, görüntümüzü pencere üzerine çizen OpenGL
yönermelerini devreye sokan void MyDisplay(void) ve kullanıcıdan herhangi bir
veri girişi olmadığında çağrılan, yani GLUT'un olay işleme makinası sonsuz
döngüde (glutMainLoop()) ilerlerken tetiklenmiş bir olay bulamadığında devreye
sokulan, void MyIdle(void) fonksiyonları olarak düşünülebilirler. Bir canlandırım
programında neden bir Boş geriçağırma fonksiyonu kaydına gereksinim
duyuyorum dersiniz? Yanıt şöyledir: Çünkü, canlandırım süresince gösterilen,
görüntülerin (çerçevelerin) her birini, kullanıcıdan gelecek verilerden bağımsız
olarak düzeltmek istersem OpenGL programının çalıştırılması süresince sık sık
çağrılarak çerçeveleri MyDisplay() çizilmelerinden önce değiştirebilen bir
fonksiyon (boş geriçağırma) fonksiyonu varolmalıdır.
Bilgisayar Grafikleri
Bir Canlandırma (animasyon) Programı Şablonu
#include <GL/glut.h>
void MyIdle(void){
/* Bir sonraki çerçeveyi tanımlayan değişkenler üzerinde değişiklik
yapan kod. */
....
};
void MyDisplay(void){
/* çerçeveyi çizen OpenGL kodu */
....
/* Çerçeve çizildikten sonra bufferlar swap edilir */
glutSwapBuffers();
};
void main(int argcp, char **argv){
/* GLUT durumunu başlat */
glutInit(&argcp, argv);
glutInitWindowSize(640, 480);
glutInitWindowPosition(0, 0);
Bilgisayar Grafikleri
Bir Canlandırma (animasyon) Programı Şablonu(devamı)
/* Pencere açma işlemi */
glutCreateWindow("My OpenGL Application");
/* Display mode türü seçimi:
Double buffer & RGBA color */
glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE);
/* Callback fonksiyonları register edilir */
glutDisplayFunc(MyDisplay)
glutIdleFunc(MyIdle)
/* Olay işleme mekanizması başlatılır */
glutMainLoop();
};
Bilgisayar Grafikleri
Sonuç
Gördüğınüz gibi MyDisplay sonuna yeni bir GLUT fonksiyonu,
glutSwapBuffers() eklemiştir. Bu, canlandırımlarda çok yararlıdır. Burada, bir
gösterilen diğeri gizlenen, çift tampon modunda pencere kullanıyoruz. Bu
durumda OpenGL yönermelerinin görüntülenmesi daima gizli tampon içine
yapılır. glutSwapBuffers, çağrıldığında, tamponları değiştokuş ederek çizileni
pencere içinde görüntüler. Bu teknik, bilgisayar canlandırımlarında, çerçeve
içeriğinin satır satır oluşturumunu insan gözünden saklaması nedeniyle, genellikle
tercih edilir. Artık, OpenGL uygulamalarını yazmaya başlamak için yeterince
malzeme elimizde bulunmaktadır. Eksik olan tek şey MyDisplay() içindeki,
gerçekte çizimi gerçekleştiren OpenGL yönermeleridir.
Bilgisayar Grafikleri
GLUT Olay Callback Fonksiyonları
GLUT genel olarak kullanılan input olaylarını yönetebilir
Örn:
 Tuş aksiyonu
 Fare aksiyonu
 Idle (hiç bir şey yokken çağırılır)
 Pencere olayları (içerik, boyut veya hareket)
Bilgisayar Grafikleri
Klavye Olayı
void keyboard_callback_func ( unsigned char key, int x, int y )
{
switch (key)
{
case ‘q’ :
exit (0);
break;
……
}
Klavye üzerinde bir tuş basıldığında çağrılır
glutKeyboardFunc ( keyboard_callback_func );
Bilgisayar Grafikleri
Özel Klavye Olayı
void special_callback_func ( unsigned char key, int x, int y )
{
switch (key)
{
….
Klavye üzerinde fonksiyon tuşları veya yön tuşları basıldığında aktif
olur
glutSpecialFunc ( special_callback_func );
Bilgisayar Grafikleri
Fare Olayı
void mouse_callback_func ( int button, int state, int x, int y )
- button: hangi buton basıldı/bırakıldı.
GLUT_LEFT_BUTTON, GLUT_MIDDLE_BUTTON, GLUT_RIGHT_BUTTON
- state: aksiyon durumu.
GLUT_DOWN, GLUT_UP
- x, y: konum
Fare butonu basıldığında/bırakıldığında aktif olur
glutMouseFunc ( mouse_callback_func );
Bilgisayar Grafikleri
Fare Olayı-1
void mouse_callback_func ( int button, int state, int x, int y )
{
if ( button == GLUT_LEFT_BUTTON && state ==
GLUT_DOWN )
exit (0);
……
}
Bilgisayar Grafikleri
Fare Pasif Hareket Olayı
void mouse_passivemotion_func (int x, int y )
- x, y: konum
Fare pencere içerisinde butona basılmadan gezdirildiğinde
kullanılabilir
glutPassiveMotionFunc ( mouse_passivemotion_func );
Bilgisayar Grafikleri
Fare Hareket Olayı
void mouse_motion_func (int x, int y )
- x, y: konum
Farenin, pencere içerisinde hareket ettirilmesi ve 1 yada daha fazla
butonunun basılması olayı
glutMotionFunc ( mouse_motion_func );
Bilgisayar Grafikleri
Fare Girme Olayı(mouse entry)
void mouse_motion_func (int state )
- GLUT_LEFT veya GLUT_ENTERED
Fare,pencere alanına girmesi ve butonlarından 1 veya daha fazlasının
basılması olayı
glutEntryFunc ( mouse_entry_func );
Bilgisayar Grafikleri
Pencere Olayları-Yeniden Şekillendirme Olayı
- Objeyi yeniden çizer
- “Aspect ratio” yu korur.(aspec ratio bkz. Bölüm 2)
Pencere boyutu değiştiğinde veya şekli değiştiğinde aktif olur.
glutReshapeFunc ( reshape_callback_func );
Bilgisayar Grafikleri
Pencere Olayları-Yeniden Şekillendirme Olayı-1
glutReshapeFunc ( reshape_callback_func );
void reshape_callback_func ( int width, int height )
- width, height: yeni pencerenin eni ve boyu
Bilgisayar Grafikleri
Pencere Olayları-Görünme Olayı
glutVisibilityFunc ( visibility_callback_func );
void visibility_callback_func ( int state )
state: GLUT_NOT_VISIBLE veya GLUT_VISIBLE
-GLUT_VISIBLE –pencerenin tamamı veya bir kısmı visible olabilir demektir.
-GLUT_NOT_VISIBLE – pencerenin hiç bir parçası görünmüyor anlamına gelir.
Pencerenin görünme(visibility) özelliği değiştiğinde aktif olur
Bilgisayar Grafikleri
Display Callback
void display_callback_func ( void )
{
Bütün çizimlerinizi burada yapın!
}
Pencerenin yeniden görüntülenmesi gerektiğinde çağrılır. Örneğin,
pencere ilk defa açıldığında.Bu fonksiyon GLUT programında
mutlaka bulunmalı
glutDisplayFunc ( display_callback_func );
Bilgisayar Grafikleri
Idle Callback
void idle_callback_func ( void )
{
t += 10;
…..
}
Bu fonksiyon hiçbirşey yapılmadığında çağırılır. Animasyon ve
devamlı yenilemelerde çok kullanışlıdır.
glutIdleFunc ( idle_callback_func );
Bilgisayar Grafikleri
Menu Status (State) Callback
Pop-up menüler kullanıcı tarafından kullanılıyor iken
GLUT_MENU_IN_USE durum parametresi ile çağırılır; Kullanıcı
pop-up menüyü kapattığında GLUT_MENU_NOT_IN_USE durum
parametresi ile çağırılır. x ve y parametreleri,menüyü kullanıma sokan
buton basılma veya buton bırakılma olayının pencere koordinatları
cinsinden konumunu belirlerler. MenuState ,MenuStatus’un
deprecated şeklidir( x,y parametreleri yoktur).
glutMenuStatusFunc(int status, int x, int y);
glutMenuStateFunc(int status);
Bilgisayar Grafikleri
Menü Yönetimi
GLUT ,interaktif kontrol için pop-up menü fonksiyonları sağlar.
glutCreateMenu ( menu_callback_func );
void menu_callback_func ( int ID )
{
Menü Kontrolünüzü buraya koyun!
}
Bilgisayar Grafikleri
Menü Oluşturma
glutAddMenuEntry ( const char *label, int value );
- label: menu biriminin kullanıcıya gösterilen ismi
- value: bu birim seçildiğinde ID’si , menü callback
fonksiyonuna gönderilir.
Bilgisayar Grafikleri
Menü Oluşturma-1
glutAttachMenu ( int button );
- button: menu ile hangi fare butonu ilişkilendirilecek
GLUT_LEFT_BUTTON, GLUT_MIDDLE_BUTTON, GLUT_RIGHT_BUTTON
Bilgisayar Grafikleri
Seçim Geliştirme: GLUT’ta Menüler
 Dört Adım:
– Menü oluştur: glutCreateMenu(menu);
– Menu girdilerini belirle: glutAddMenuEntry
– Menüyü fare butonuna bağla: glutAttachMenu
– Callback fonksiyonunu belirle:
void menu(int id);
Bilgisayar Grafikleri
GLUT’ta Menu Oluşturma
int glutCreateMenu(void (*func)(int value));
Yeni pop-up menü oluşturur.
Menü için tek,integer tipinde bir belirleyici döndürür
Parametre olarak tek callback fonksiyonu alır. Callback
fonksiyonunun integer parametresi menü seçimine map
edilmiştir.
Menu Identifier Callback Fonksiyonu Seçim
Bilgisayar Grafikleri
Menüyü Fare Butonuna Bağlama
void glutAttachMenu(int button);
Geçerli menüyü seçilmiş butona bağlar.
button GLUT tarafından belirlenmiş buton değişkenlerinden biri:
GLUT_LEFT_BUTTON, GLUT_MIDDLE_BUTTON,
GLUT_RIGHT_BUTTON
Bilgisayar Grafikleri
Menüye Girdilerini Ekleme
void glutAddMenuEntry(char *name, int value);
Menüde gözükecek
birim ismi
Callback fonksiyonuna
verilecek değer
Geçerli menün’nün alt kısmına yeni eleman ekler
Bilgisayar Grafikleri
Alt-menü Oluşturma
void glutAddSubMenu(char *name, int menu);
Kendisinden taşacak alt-menü’yu belirleyen
menü biriminin ismi.
Taşacak olan alt-menü’nün
tanımlayıcısı
Bilgisayar Grafikleri
Hepsi Bir Arada – Bir Örnek
Problem:
 Bir pencerede bir viewport(bakış açısı) oluşturun. Viewportun
boyutu 256x256 piksel ve artalanı beyaz renkte.Bu viewport yüzey
rengi mavi olan bir kareyi göstersin.
 Farenin sağ tuşuna basıldığında pop-up menu oluşsun. Pop-up
menünün sadece 1 adet girdisi mevcuttur ve programdan çıkmaya
yaramktadır.
Bilgisayar Grafikleri
Main Fonksiyonu
void main (int argc, char **argv)
{
glutInit ( &argc, argv );
glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB);
glutInitWindowSize (256, 256);
glutCreateWindow (“Benim İlk Programım");
myinit ();
glutDisplayFunc ( square ); // callback fonksiyonunu kayda geçirme
glutMainLoop ();
}
Bilgisayar Grafikleri
OpenGL Başlatılması
void myinit (void)
{
glClearColor (1.0, 1.0, 1.0, 0.0); // artalan-beyaz
glMatrixMode(GL_PROJECTION);
glLoadIdentity();
gluOrtho2D (0.0, 256.0, 0.0, 256.0);
glMatrixMode(GL_MODELVIEW);
glClear(GL_COLOR_BUFFER_BIT); // pencere temizle
}
Bilgisayar Grafikleri
Display Callback Fonksiyonu
void square (void)
{
typedef GLfloat point2D[2];
point2D vertices[4] = {{100.0, 100.0},{200.0, 100.0},{200.0, 200.0},{100.0, 200.0}};
glClear(GL_COLOR_BUFFER_BIT); // pencere temizle
glColor3f (0.0, 0.0, 1.0);
glBegin(GL_POLYGON);
glVertex2fv (vertices[0]); glVertex2fv (vertices[1]);
glVertex2fv (vertices[2]); glVertex2fv (vertices[3]);
glEnd();
glFlush();
}
Bilgisayar Grafikleri
Çıktısı Nasıl Görünmekte?
Bilgisayar Grafikleri
Etkileşim Ekleme
void main (int argc, char **argv)
{
glutInit ( &argc, argv );
glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB);
glutInitWindowSize (256, 256);
glutCreateWindow (“My First Program");
myinit ();
glutCreateMenu (menu); // menü callback fonksiyonu kaydedildi
glutAddMenuEntry(“Quit”, 1);
glutAttachMenu(GLUT_RIGHT_BUTTON);
glutDisplayFunc ( square ); //display callback fonksiyonu kayda geçti
glutMainLoop ();
}
Bilgisayar Grafikleri
Menü Callback Fonksiyonu
void menu (int ID)
{
if ( ID == 1 )
exit (1);
}
Bilgisayar Grafikleri
Şimdi Nasıl Görünmekte?
Bilgisayar Grafikleri
Örnek: Basit Kare Çizme Programı
 Bir pencere aç.
 Pencereyi siyaha boya.
 Farenin sol tuşunun her basılışında basılma yerine bir kutu çiz. Kutunun
rengi her defasında random olarak RGB uzayından seçilmelidir.
 Pencere boyutu değştiğinde pencereyi sil.
 Farenin sağ tuşu basıldığında programdan çık.
Bilgisayar Grafikleri
Kaynak Kodu : Sayfa 1
/* This program illustrates the use of the glut library for
interfacing with a Window System */
/* The program opens a window, clears it to black,
then draws a box at the location of the mouse each time the
left button is clicked. The right button exits the program
The program also reacts correctly when the window is
moved or resized by clearing the new window to black*/
#include <GL/gl.h>
#include <GL/glut.h>
/* globals */
GLsizei wh = 500, ww = 500; /* initial window size */
GLfloat size = 3.0; /* half side length of square */
Bilgisayar Grafikleri
void drawSquare(int x, int y)
{
y=wh-y;
glColor3ub( (char) random()%256, (char) random()%256,
(char) random()%256);
glBegin(GL_POLYGON);
glVertex2f(x+size, y+size);
glVertex2f(x-size, y+size);
glVertex2f(x-size, y-size);
glVertex2f(x+size, y-size);
glEnd();
glFlush();
}
Kaynak Kodu : Sayfa 2
Bilgisayar Grafikleri
void myReshape(GLsizei w, GLsizei h)
{
/* adjust clipping box */
glMatrixMode(GL_PROJECTION);
glLoadIdentity();
glOrtho(0.0, (GLdouble)w, 0.0, (GLdouble)h, -1.0, 1.0);
glMatrixMode(GL_MODELVIEW);
glLoadIdentity();
/* adjust viewport and clear */
glViewport(0,0,w,h);
glClearColor (0.0, 0.0, 0.0, 0.0);
glClear(GL_COLOR_BUFFER_BIT);
glFlush();
/* set global size for use by drawing routine */
ww = w;
wh = h;
}
Kaynak Kodu : Sayfa 3
Bilgisayar Grafikleri
void myinit(void)
{
glViewport(0,0,ww,wh);
/* Pick 2D clipping window to match size of screen window
This choice avoids having to scale object coordinates
each time window is resized */
glMatrixMode(GL_PROJECTION);
glLoadIdentity();
glOrtho(0.0, (GLdouble) ww , 0.0, (GLdouble) wh , -1.0, 1.0);
/* set clear color to black and clear window */
glClearColor (0.0, 0.0, 0.0, 0.0);
glClear(GL_COLOR_BUFFER_BIT);
glFlush();
/* callback routine for reshape event */
glutReshapeFunc(myReshape);
}
Kaynak Kodu : Sayfa 4
Bilgisayar Grafikleri
void mouse(int btn, int state, int x, int y)
{
if(btn==GLUT_RIGHT_BUTTON&state==GLUT_DOWN) exit();
}
int main(int argc, char** argv)
{
glutInit(&argc,argv);
glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB);
glutCreateWindow("square");
myinit ();
glutReshapeFunc (myReshape);
glutMouseFunc (mouse);
glutMotionFunc(drawSquare);
glutMainLoop();
}
Kaynak Kodu : Sayfa 5
Bilgisayar Grafikleri
“Square” Programının Çıktısı
Bilgisayar Grafikleri
Örnek: Paint Programı
 Çizim için basit geometrik şekillerden birisini seç.
 8 renkten birini seç.
 Doldurma işlemini aç/kapa.
 Nokta boyutunu büyütme veya küçültme.
 Menü kontrolü altında ekranı sil veya programdan çık.
Bilgisayar Grafikleri
#define NULL 0
#include <GL/gl.h>
#include <GL/glut.h>
void mouse(int, int, int, int);
void display(void);
void idle(void);
void drawSquare(int, int);
void myReshape(GLsizei, GLsizei);
void myinit(void);
void screen_box(int, int, int);
void right_menu(int);
void middle_menu(int);
void color_menu(int);
void pixel_menu(int);
void fill_menu(int);
long time(int);
int pick(int, int);
Kaynak Kodu : Sayfa 1
Bilgisayar Grafikleri
/* globals */
GLsizei wh = 500, ww = 500; /* initial window
size */
GLfloat size = 3.0; /* half side length of
square */
int base; /* font list base */
long baset; /*time base */
GLfloat r = 1.0, g = 1.0, b = 1.0; /* drawing
color */
int fill = 0; /* fill flag */
void drawSquare(int x, int y)
{
y=wh-y;
glColor3ub( (char) random()%256,
(char) random()%256, (char)
random()%256);
glBegin(GL_POLYGON);
glVertex2f(x+size, y+size);
glVertex2f(x-size, y+size);
glVertex2f(x-size, y-size);
glVertex2f(x+size, y-size);
glEnd();
}
Kaynak Kodu : Sayfa 2
Bilgisayar Grafikleri
/* rehaping routine called whenever window is
resized
or moved */
void myReshape(GLsizei w, GLsizei h)
{
/* adjust clipping box */
glMatrixMode(GL_PROJECTION);
glLoadIdentity();
glOrtho(0.0, (GLdouble)w, 0.0,
(GLdouble)h, -1.0, 1.0);
glMatrixMode(GL_MODELVIEW);
glLoadIdentity();
/* adjust viewport and clear */
glViewport(0,0,w,h);
glClearColor (1.0, 1.0, 1.0, 0.0);
glClear(GL_COLOR_BUFFER_BIT);
display();
glFlush();
Kaynak Kodu : Sayfa 3
Bilgisayar Grafikleri
/* set global size for use by drawing
routine */
ww = w;
wh = h;
}
void myinit(void)
{
/* set up a font in display list */
int i;
baset = time(0);
base = glGenLists(128);
for(i=0;i<128;i++)
{
glNewList(base+i,
GL_COMPILE);
glutBitmapCharacter(GLUT_BITMAP_9_BY_15,
i);
glEndList();
}
glListBase(base);
Kaynak Kodu : Sayfa 4
Bilgisayar Grafikleri
glViewport(0,0,ww,wh);
/* Pick 2D clipping window to match size of
X window
This choice avoids having to scale object
coordinates
each time window is resized */
glMatrixMode(GL_PROJECTION);
glLoadIdentity();
glOrtho(0.0, (GLdouble) ww , 0.0,
(GLdouble) wh , -1.0, 1.0);
/* set clear color to black and clear
window */
glClearColor (0.0, 0.0, 0.0, 0.0);
glClear(GL_COLOR_BUFFER_BIT);
glFlush();
}
Kaynak Kodu : Sayfa 5
Bilgisayar Grafikleri
void mouse(int btn, int state, int x, int y)
{
static int draw_mode = 0; /* drawing mode
*/
static int count;
int where;
static int xp[2],yp[2];

if(btn==GLUT_LEFT_BUTTON&state==GLUT_DOWN)
{
glPushAttrib(GL_ALL_ATTRIB_BITS);
glutIdleFunc(NULL);

where = pick(x,y);
glColor3f(r, g, b);
if(where != 0)
{
count = 0;
draw_mode = where;
}
else if(draw_mode == 1 & count == 0)
{
count = 1;
xp[0] = x;
yp[0] = y;
}
Kaynak Kodu : Sayfa 6
Bilgisayar Grafikleri
else if(draw_mode == 1 & count != 0)
{
glBegin(GL_LINES);
glVertex2i(x,wh-y);
glVertex2i(xp[0],whyp[0]);
glEnd();
draw_mode=0;
count=0;
}
else if(draw_mode == 2 & count == 0)
{
count = 1;
xp[0] = x;
yp[0] = y;
}
Kaynak Kodu : Sayfa 7
Bilgisayar Grafikleri
else if(draw_mode == 2 & count != 0)
{
if(fill) glBegin(GL_POLYGON);
else glBegin(GL_LINE_LOOP);
glVertex2i(x,wh-y);
glVertex2i(x,wh-yp[0]);
glVertex2i(xp[0],whyp[0]);
glVertex2i(xp[0],wh-y);
glEnd();
draw_mode=0;
count=0;
}
else if(draw_mode == 3 & count == 0)
{
count = 1;
xp[0] = x;
yp[0] = y;
}
else if(draw_mode == 3 & count == 1)
{
count = 2;
xp[1] = x;
yp[1] = y;
}
Kaynak Kodu : Sayfa 8
Bilgisayar Grafikleri
else if(draw_mode == 3 & count == 2)
{
if(fill) glBegin(GL_POLYGON);
else glBegin(GL_LINE_LOOP);
glVertex2i(xp[0],whyp[0]);
glVertex2i(xp[1],whyp[1]);
glVertex2i(x,wh-y);
glEnd();
draw_mode=0;
count=0;
}
else if(draw_mode == 4 )
{
drawSquare(x,y);
count++;
}
glutIdleFunc(idle);
glPopAttrib();
glFlush();
}
}
Kaynak Kodu : Sayfa 9
Bilgisayar Grafikleri
int pick(int x, int y)
{
y = wh - y;
if(y < wh-ww/10) return 0;
else if(x < ww/10) return 1;
else if(x < ww/5) return 2;
else if(x < 3*ww/10) return 3;
else if(x < 2*ww/5) return 4;
else return 0;
}
void screen_box(int x, int y, int s )
{
glBegin(GL_QUADS);
glVertex2i(x, y);
glVertex2i(x+s, y);
glVertex2i(x+s, y+s);
glVertex2i(x, y+s);
glEnd();
}
Kaynak Kodu : Sayfa 10
Bilgisayar Grafikleri
void idle(void)
{
char out[]="00:00:00";
long t, time();
int min, sec, hr;
glPushAttrib(GL_ALL_ATTRIB_BITS);
t=time(0)-baset;
hr=t/3600;
min = (t - 3600*hr) /60;
sec = (t - 3600*hr - 60*min);
hr = hr%24;
out[0]='0'+hr/10;
out[1]='0'+hr%10;
out[3]='0'+min/10;
out[4]='0'+min%10;
out[6]='0'+sec/10;
out[7]='0'+sec%10;
Kaynak Kodu : Sayfa 11
Bilgisayar Grafikleri
glRasterPos2i(ww-80, wh-15);
glColor3f(0.0,0.0,0.0);
glBegin(GL_QUADS);
glVertex2i(ww-80, wh-15);
glVertex2i(ww, wh-15);
glVertex2i(ww, wh);
glVertex2i(ww-80, wh);
glEnd();
glColor3f(1.0,1.0,1.0);
glCallLists( strlen(out) , GL_BYTE,
out);
glFlush();
glPopAttrib();
}
Kaynak Kodu : Sayfa 12
Bilgisayar Grafikleri
void right_menu(int id)
{
glutIdleFunc(NULL);
if(id == 1) exit();
else display();
glutIdleFunc(idle);
}
void middle_menu(int id)
{
glutIdleFunc(NULL);
glutIdleFunc(idle);
}
void color_menu(int id)
{
glutIdleFunc(NULL);
if(id == 1) {r = 1.0; g = 0.0; b = 0.0;}
else if(id == 2) {r = 0.0; g = 1.0; b =
0.0;}
else if(id == 3) {r = 0.0; g = 0.0; b =
1.0;}
else if(id == 4) {r = 0.0; g = 1.0; b =
1.0;}
Kaynak Kodu : Sayfa 13
Bilgisayar Grafikleri
else if(id == 5) {r = 1.0; g = 0.0; b =
1.0;}
else if(id == 6) {r = 1.0; g = 1.0; b =
0.0;}
else if(id == 7) {r = 1.0; g = 1.0; b =
1.0;}
else if(id == 8) {r = 0.0; g = 0.0; b =
0.0;}
glutIdleFunc(idle);
}
void pixel_menu(int id)
{
glutIdleFunc(NULL);
if (id == 1) size = 2 * size;
else if (size > 1) size = size/2;
glutIdleFunc(idle);
}
void fill_menu(int id)
{
glutIdleFunc(NULL);
if (id == 1) fill = 1;
else fill = 0;
glutIdleFunc(idle);
}
Kaynak Kodu : Sayfa 14
Bilgisayar Grafikleri
void display(void)
{
glPushAttrib(GL_ALL_ATTRIB_BITS);
glutIdleFunc(NULL);
glClearColor (0.0, 0.0, 0.0, 0.0);
glClear(GL_COLOR_BUFFER_BIT);
glColor3f(1.0, 1.0, 1.0);
screen_box(0,wh-ww/10,ww/10);
glColor3f(1.0, 0.0, 0.0);
screen_box(ww/10,wh-ww/10,ww/10);
glColor3f(0.0, 1.0, 0.0);
screen_box(ww/5,wh-ww/10,ww/10);
glColor3f(0.0, 0.0, 1.0);
screen_box(3*ww/10,wh-ww/10,ww/10);
glColor3f(0.0, 0.0, 0.0);
screen_box(ww/10+ww/40,whww/10+ww/40,ww/20);
glBegin(GL_LINES);
glVertex2i(wh/40,wh-ww/20);
glVertex2i(wh/40+ww/20,wh-ww/20);
glEnd();
Kaynak Kodu : Sayfa 15
Bilgisayar Grafikleri
glBegin(GL_TRIANGLES);
glVertex2i(ww/5+ww/40,whww/10+ww/40);
glVertex2i(ww/5+ww/20,wh-ww/40);
glVertex2i(ww/5+3*ww/40,whww/10+ww/40);
glEnd();
glPointSize(3.0);
glBegin(GL_POINTS);
glVertex2i(3*ww/10+ww/20, wh-ww/20);
glEnd();
glutIdleFunc(idle);
glFlush();
glPopAttrib();
}
Kaynak Kodu : Sayfa 16
Bilgisayar Grafikleri
int main(int argc, char** argv)
{
int c_menu, p_menu, f_menu;
glutInit(&argc,argv);
glutInitDisplayMode (GLUT_SINGLE |
GLUT_RGB);
glutCreateWindow("square");
glutDisplayFunc(display);
c_menu = glutCreateMenu(color_menu);
glutAddMenuEntry("Red",1);
glutAddMenuEntry("Green",2);
glutAddMenuEntry("Blue",3);
glutAddMenuEntry("Cyan",4);
glutAddMenuEntry("Magenta",5);
glutAddMenuEntry("Yellow",6);
glutAddMenuEntry("White",7);
glutAddMenuEntry("Black",8);
p_menu = glutCreateMenu(pixel_menu);
glutAddMenuEntry("increase pixel size",
1);
glutAddMenuEntry("decrease pixel size",
2);
f_menu = glutCreateMenu(fill_menu);
glutAddMenuEntry("fill on", 1);
glutAddMenuEntry("fill off", 2);
Kaynak Kodu : Sayfa 17
Bilgisayar Grafikleri
glutCreateMenu(right_menu);
glutAddMenuEntry("quit",1);
glutAddMenuEntry("clear",2);
glutAttachMenu(GLUT_RIGHT_BUTTON);
glutCreateMenu(middle_menu);
glutAddSubMenu("Colors", c_menu);
glutAddSubMenu("Pixel Size", p_menu);
glutAddSubMenu("Fill", f_menu);
glutAttachMenu(GLUT_MIDDLE_BUTTON);
myinit ();
glutReshapeFunc (myReshape);
glutMouseFunc (mouse);
glutIdleFunc(idle);
glutMainLoop();
}
Kaynak Kodu : Sayfa 18
Bilgisayar Grafikleri
Programın Çıktı Görüntüsü
Bilgisayar Grafikleri
Single Buffering ve Double Buffering
Single buffering statik grafikler için iyidir, double buffering ise
animasyon grafikleri için gereklidir.
glutInitDisplayMode ( GLUT_SINGLE | GLUT_RGB );
glutInitDisplayMode ( GLUT_DOUBLE | GLUT_RGB ); ve
glutSwapBuffers ();
Bilgisayar Grafikleri
Programa Animasyon Ekleme
 Single_double.c programını çalıştırınız
Bilgisayar Grafikleri
Alıştırmalar
 Aşağıdaki işlemleri yapan programı yazınız :
 Bir üçgen çizecek
 Üçgeni döndürerek ekran boyunca hareket ettirsin
 Hareket , farenin sol tuşuna duyarlı olsun. Sol tuş basıldığında
üçgen fare tuşunun basıldığı noktaya doğru hareket etsin ve sonra
dönmeye ve hareket etmeye devam etsin.
 Farenin sağ tuşu basıldığında programdan çıksın.
Bilgisayar Grafikleri
Ödev
 Aşağıdaki işlemleri yapan OpenGl programını geliştiriniz.
– Farenin sağ tuşuna bağlanmış bir menu ve bir veya birkaç alt menü.
Menünün 4 adet elemanı olsun ve herhangisi seçildiğinde ekrana bir
şekil çizsin
– Çizilecek şeklin rengini belirlemek için klavyeden input almak
– Seçilen şeklin nerede çizileceğini fare hareketi ile belirlemek.
 Şekil basit bir primitif (üçgen,kare, vb.) veya daha kompleks bir görüntü
olabilir.
Bilgisayar Grafikleri
Bilgisayar Grafikleri
Bölüm 4
Bilgisayar Grafikleri
Bu Derste Göreceklerimiz
2D transformasyon
Yer Değiştirme(translation)
Döndürme(rotation)
Ölçeklendirme(scale)
3D transformasyon
Yer Değiştirme(translation)
Döndürme(rotation)
Ölçeklendirme(scale)
OpenGL’de Transformasyon Gerçekleştirme
Bilgisayar Grafikleri
Giriş
GEOMETRİK TRANSFORMASYONLAR
Dönüşümler, nesnelerin koordinat tanımlarının değiştirilmesi için yapılan
işlemlerdir. Nesnelerin konum, boyut, şekil gibi özelliklerinin değiştirilmesi
gerektiğinde kullanılırlar. Temel geometrik dönüşümler kapsamına yer
değiştirme (translation), döndürme (rotation) ve ölçeklendirme (scaling) girer.
Transformasyonlar 3D objelerin 2D ekranda görüntülenmelerini sağlar
Grafik transformasyon süreci makine ile fotograf çekmek gibidir.
Her transformasyon, vertexlerin bir koordinat sistemindeki tanımını diğer bir
koordinat sistemine taşımak gibi düşünülebilir.
Bilgisayar Grafikleri
Obje Koordinatları
Objeler genellikle kendi yerel
koordinat sistemlerinde tanımlanırlar.
Bir obje global bir sistemin alt kümesi
ise o objeyi evrensel kümeye dahil
etmek için obje önce kendi koordinat
sisteminde tanımlanır, daha sonra
evrensel uzay koordinatları cinsinden
konumu belirlenir. Evrensel uzay
koordinat sistemine “dünya
koordinatları ” denir.
Bilgisayar Grafikleri
Dünya Koordinatları
Yandaki şekilde görüldüğü gibi
birbirinden bağımsız üz obje (2
küp ve bir silindir) dünya
koordinatlarında
konumlandırılmış durumda.
Objelerin yapısı ile ilgili bir
değişiklik yapılacaksa objelerin
kendi koordinat sistemleri içinde
düşünmek gerekir. Dünya
koordinatlarında yapılan
değişiklik objenin konumu ve
görünümünde değişiklikten başka
birşey değildir. Objelerin
koordinatları tek , global bir
koordinatlarla tanımlanır.
Bilgisayar Grafikleri
Ekran Koordinatları
Yukarıda “obje koordinatları” ve
“dünya koordinatları” hakkında
bahsettik. Bunların yanında bir de
“ekran koordinatları” kavramı
vardır. Bir model oluşturulurken
objeler öncelikle kendi koordinat
sistemlerinde tanımlanır ve dünya
koordinatlarında konumlandırılırlar.
Modeli kurarken tamamen dünya
koordinatları cinsinden düşünürüz. Modelimizi bilgisayar ortamına taşımak için
modelin ekran koordinatları cinsinden ifade edilmeleri gerekir. Bahsettiğimiz koordinat
sistemleri arasında geçiş ve dönüşüm yapmak için transformasyonlar kullanılır.
Aşağıdaki konularda 2Boyutlu ve 3Boyutlu transformasyonlar anlatılmaktadır.
Bilgisayar Grafikleri
Koordinat Hiyerarşisi
Obje #1
Obje Koordinatları
Transformasyon
Obje #1 ->
Dünya
Obje #2
Obje Koordinatları
Transformasyon
Obje #2 ->
Dünya
Obje #3
Obje Koordinatları
Transformasyon
Obje #3 ->
Dünya
Dünya Koordinatları
Transformasyon
Dünya -> Ekran
Ekran Koordinatları
Bilgisayar Grafikleri
2 Boyutlu Transformasyon-Yer Değiştirme(Translation)
Bir nesnenin bir doğru üzerinde bir noktadan bir noktaya
getirilmesidir. İki boyutlu bir uzayda bir noktanın yeri,
noktanın ilk konumuna P(x,y), yer değiştirme uzaklıkları
eklenerek (tx, ty) değiştirilir. Noktanın yeni konumu P'(x',y')
olur (Şekle bkz).
P(x,y): Noktanın ilk konumu
P'(x',y'): Noktanın yer değiştirme işleminden sonraki
konumuP(x,y)P'(x',y')T(tx,ty)xy
T(tx, ty): Yer değiştirme uzaklıkları
olmak üzere x' = x + tx ve y' = y + ty olur
P'(x',y')
T(tx
,ty
)
x
P(x,y)
y







2
1
x
x
P 









2
1
x
x
P 






y
x
t
t
T
Bir noktanın P
konumundan P'
konumuna
getirilmesi
Bilgisayar Grafikleri
2 Boyutlu Transformasyon-Yer Değiştirme(Translation)-1
T yer değiştirme vektörü, P ve P' noktanın ilk ve son koordinat konumlarını
gösteren sütun vektörleri olmak üzere, iki boyutlu yer değiştirme denklemleri :
P' = T + P şeklinde ifade edilir.
Yer değiştirme dönüşümünde nesnelerin her noktası eşit miktarlarda hareket
ettirildiğinden nesnelerde bozulma olmaz.
Çokgenlerin bir konumdan diğer bir konuma taşınmasında tüm köşelerine yer
değiştirme dönüşümünün uygulanması yeterli olur.
Daire gibi eğrisel nesnelerin hareketinde sadece merkez koordinatlarının yeri
değiştirilerek nesne yeniden çizdirilir.
Bilgisayar Grafikleri
2 Boyutlu Transformasyon-Döndütme(Rotation)
Döndürme bir noktanın dairesel bir yol üzerinde hareket ettirilmesi
işlemidir. Döndürme işlemi için  (döndürme açısı) ve döndürme
işleminin yapılacağı (xr,yr) sabit (pivot) noktasının (döndürme noktası)
belirtilmesi gerekir (Şekle bkz.Saat hareketinin tersi yönündeki
dönmeler pozitiftir ( açısının pozitif değerleri). Saat hareketi
yönündeki dönmeler ise negatiftir ( açısının negatif değerleri).
P
P'
x
y

xr
yr
P noktasının sabit bir
nokta etrafında
döndürülmesi
Bilgisayar Grafikleri
2 Boyutlu Transformasyon-Döndütme(Rotation)-1
Döndürme işleminden sonraki koordinatlar  ve  açıları cinsinden ifade edilebilir
(Şekle bkz).P(x,y) noktasının orijin (koordinat başlangıç noktası) etrafında
döndürülmesi sonucunda noktanın yeni konumu P'(x',y') şu şekilde hesaplanır :
x' = r cos(+) = r cos cos - r sin sin
y' = r sin(+) = r cos sin + r sin cos
Noktanın kutupsal koordinatlarda ilk konumu x = r cos, y = r sin x ve y yerine
konulduğunda, x' = x cos - y sin
y' = x sin + y cos
P(x,y) noktasının orijin
(koordinat başlangıç noktası)
etrafında döndürülmesi
P(x,y)
P'(x',y')
x
y


Bilgisayar Grafikleri
2 Boyutlu Transformasyon-Döndütme(Rotation)-2
cos -sin 0
R = sin cos 0
0 0 1
R döndürme matrisi olmak üzere döndürme denklemlerinin matris
şeklindeki ifadesi aşağıdaki gibidir :
cos -sin 0 x x cos - y sin
P' = sin cos 0 . y = x sin + y cos
0 0 1 1 1
Bilgisayar Grafikleri
Ölçeklendirme (Scaling)
Nesnelerin boyutunu değiştiren dönüşümdür. Noktaların koordinat
değerlerinin, ölçeklendirme faktörleri ile çarpılması ile elde edilir.
x' = x . sx
y' = y . sy
Dönüşüm denklemleri,
sx ve sy'nin 1'den küçük değerleri nesnenin boyutunu küçültür (küçültme işlemi)
sx ve sy'nin 1'den büyük değerleri nesnenin boyutunu büyütür (büyütme işlemi)
sx ve sy'nin 1'e eşit olması nesnenin boyutunu değiştirmez
sx = sy yani her ikisine de aynı değerin verilmesi ölçeklendirilmiş nesnelerin göreceli
oranlarının aynı kalmasını sağlar ki buna düzgün ölçeklendirme denilir.
x' sx 0 0 x x . sx
y‘ = 0 sy 0 . y = y . sy
1 0 0 1 1 1
P' S P
ölçeklendirme matrisi
Bilgisayar Grafikleri
Bileşik Dönüşümler (Composite Transformations)
Nesnelere arka arkaya dönüşümlerin uygulanması gerektiğinde tüm dönüşümlere
denk gelen bileşik dönüşüm matrisi oluşturulur, sonra nesnelerin tüm noktalarına
bu bileşik dönüşüm uygulanır. Sütun matrisleri gösteriminde bileşik dönüşüm,
matrislerin sağdan sola doğru çarpılması ile elde edilir. Arka arkaya benzer
dönüşümlerin uygulanmasında bazı kolaylıklar vardır .Ardışık yer değiştirmede
bileşik dönüşüm matrisi yer değiştirme uzaklıklarının toplanması ile elde edilir :
1 0 tx2 1 0 tx1 1 0 tx1+tx2
0 1 ty2 *
0 1 ty1 = 0 1 ty1+ty2
0 0 1 0 0 1 0 0 1
T(tx2,ty2) T(tx1,ty1) T (tx1+tx2,ty1+tx2)
Bilgisayar Grafikleri
Bileşik Dönüşümler (Composite Transformations)-1
Ardışık döndürmede bileşik dönüşümler açıların toplanması ile elde edilir :
R(2) . R(1) = R(1+2)
P' = R(2) . R(1) . P = R(1+2).P
Ardışık ölçeklendirmede bileşik dönüşüm ölçeklendirme faktörlerinin çarpımına
eşittir :
Sx2 0 0 Sx1 0 0 Sx1+Sx2 0 0
0 Sy2 0 *
0 Sy1 0 = 0 Sy1+Sy2 0
0 0 1 0 0 1 0 0 1
S(sx2,sy2) S(sx1,sy1) S (sx1.sx2,sy1.sy2)
Bilgisayar Grafikleri
Üç Boyutlu Dönüşümler
İki boyutlu dönüşümlerin z ekseni ve koordinatları da dikkate
alınarak genişletilmesi ile elde edilirler.
Bilgisayar Grafikleri
Üç Boyutlu Dönüşümler –Yer Değiştirme
P : noktanın ilk konumunu belirten vektör
P' : noktanın (dönüşümden sonraki) son konumunu gösteren vektör
T : yer değiştirme matrisi olmak üzere,
P' = T . P olarak hesaplanır :
x' 1 0 0 tx x
y‘ = 0 1 0 ty . y
z' 0 0 1 tz
z
1 0 0 0 1 1
tx, ty, tz, sırası ile x, y, z eksenlerindeki yer değiştirme uzaklıkları olmak üzere matris
gösterimine karşılık gelen denklemler şu şekilde yazılabilir :
x' = x+tx
y' = y+ty
z' = z+tz
Bilgisayar Grafikleri
Üç Boyutlu Dönüşümler –Yer Değiştirme-1
Üç boyutlu uzayda bir nesne, tanımlı her noktasına dönüşüm işleminin
uygulanması ile taşınır. Çokgen yüzeyler şeklinde ifade edilebilen nesnelerin her
köşe noktasına dönüşüm uygulandıktan sonra, nesnenin yüzeylerinin çokgenler
şeklinde yeniden çizilmesi ile yer değiştirme işlemi gerçekleştirilir (Şekle bkz).
x
y
z
P1
P1
'
Üç boyutlu uzayda
bir nesnenin yer
değiştirmesi
Bilgisayar Grafikleri
Üç Boyutlu Dönüşümler –Döndürme
Üç boyutlu döndürme işlemi için döndürme ekseninin ve döndürme açısının
belirtilmesi gerekmektedir.
Koordinat eksenlerinde döndürmeler
Z ekseni etrafında döndürme
x
y
z
P1
P1
'
x' = x cos - y sin y' = x sin + y cos
z' = z P' = Rz().P
x' cos -sin 0 0 x
y‘ = sin cos 0 0 y
*
z' 0 0 1 0 z
1 0 0 0 1 1
Bilgisayar Grafikleri
Üç Boyutlu Dönüşümler –Döndürme-1
X ekseni etrafında döndürme
y' = y cos - z sin z' = y sin + z cos
x' = x P' = Rx().P
x' 1 0 0 0 x
y‘ = 0 cos -sin  0 y
z' 0 sin  cos  0 * z
1 0 0 0 1 1
x
y
z
P1
P1
'
Üç boyutlu uzayda bir
noktanın X eksenlerinde
döndürülmesi
Bilgisayar Grafikleri
Üç Boyutlu Dönüşümler –Döndürme-2
Y ekseni etrafında döndürme
z' = z cos - x sin x' = z sin + x cos
y' = y P' = Ry().P
x' cos 0 sin  0 x
y‘ = 0 1 0 0 y
z' -sin  0 cos  0 * z
1 0 0 0 1 1
x
y
z
P1
P1
'
Üç boyutlu uzayda bir
noktanın Y eksenlerinde
döndürülmesi
Bilgisayar Grafikleri
Ölçeklendirme
P, noktanın ilk konumunu belirten vektör
P', noktanın (dönüşümden sonraki) son
konumunu belirten vektör
S, ölçeklendirme matrisi olmak
üzere,xyz
P' = S . P olarak hesaplanır
x' = x . sx
y' = y . sy
z' = z . sz
x
y
z
Üç boyutlu uzayda bir nesnenin
ölçeklendirilmesi
x' sx 0 0 0 x
y' = 0 sy 0 0 * y
z' 0 0 sz 0 z
1 0 0 0 1 1
Bilgisayar Grafikleri
Örnek Programlar
Aşağıda gösterilen programlar transformasyon konusu ile ilgilidir. Dowlnoad bölüünden programları indirerek inceleyiniz.
Bilgisayar Grafikleri
OpenGL’de Transformasyon Gerçekleştirme
 Transformasyon Modelleme
– Yer değiştirme
– Döndürme
– Ölçekleme
 Transformasyonların kompozisyonu
– Matris Yığını
 Uygulamalar
Bilgisayar Grafikleri
Transformasyonlar Ve Fotoğraf Makinesi
Benzetmesi
Bir şeyi transform etmek o şeyin fotoğrafını çekmek gibi bir şey denilebilir. Nasılki bir şeyin
fotoğrafını çekerken ışığın gelen yönü,ortam aydnılığı gibi faktörler göz önünde bulundurulurtransformasyonda da bir takım şeylere dikkat edilmesi gerekir. Dikkat edilmesi gereken
özelliklere göre transformasyon 4’e ayrılır. Bunlar :
Görüntüleme transformasyonu:Kameranın yerleştirilmesi ve odaklanması.
Modelleme transformasyonu :Modelin yerleştirilmesi ve hareket ettirilmesi
Projeksiyon transformasyonu :Kameranın lensinin ayarları
Bakış Açısı transformasyonu :Fiziki fotografın büyültülüp küçültülmesi
Fotoğraf
Makinesi Model
Bilgisayar Grafikleri
OpenGL de Transformasyon
Transformasyonlar matris işlemleriyle belirlenir. İstenen transformasyon basit
transformasyon dizisi ve bu transformasyonların birleştirilmesiyle elde edilebilir.
Transformasyon matrisi genellikle 4x4 matris ile ifade edilir.
OpenGL’da, transformasyon matrisleri “durum”’un(state) bir parçasıdır. Her
hangi vertex’e uygulanmadan önce bu matrisler tanımlanmış olmaları gerekiyor.
Modellemede ,genellikle kendi koordinat sistemlerinde tanımlanmış objelerle
çalışılır ve bu objeleri sahneye (scene) çıkarmak için transform (yerdeğiştirme ,
döndürme , ölçekleme) edilmeleri gerekir.OpenGL , desteklediği bütün matris
türleri için (model-view, projection, texture) matris yığınları sağlar.
Bilgisayar Grafikleri
OpenGL Transformasyon Boru Hattı
Bilgisayar Grafikleri
Geçerli Transformasyon Matrisi
Geçerli Transformasyon Matrisi (GTM) : Herhangi bir vertex’i takip eden
vertexe uygulanan matrise GTM denir (orj: the matrix that is applied to any
vertex that is defined subsequent to its setting). Eğer GTM’yi değiştirirsek,
sistemin durumunu(Bölüm3-OpenGL Durum Makinesi) değiştirmiş oluruz.
GTM ,bir takim fonksiyonları ile değiştirilebilen 4 x 4 matristir. GTM –
OpenGL Durum Makinesinin bir durumu olduğu için bir matris aracılığıyla
(matris çarpımı ile) set/reset/değiştirme yapılabilir.Her hangi bir vertex
koordinatlarını transfor edeceksek, önce o vertex için istenilen GTM matrisi
belirlenmeli ve durum makinesine bildirilmelidir.
Örnek:
G <= M // M matrisini ata
G <= GT // T ile çarp
G <= GS // S ile çarp
G <= GR // R ile çarp
Bilgisayar Grafikleri
Geçerli Transformasyon Matrisi-1
Her transformasyon aslında yeni bir matris oluşturur ve GTM ile çarpılır;
çarpım sonucu, yeni GTM oluşur.GTM , çarpan transformasyon
matrislerin kumulatif (gittikçe artan) toplamlarına eşittir.
Örnek:
Eğer G <= M; G<= GT; G <= GR; G <= GS
O Halde G = M T R S
Bilgisayar Grafikleri
Transformasyon Belirleme Yöntemleri
OpenGL’da genellikle 2 transformasyon belirleme yöntemi kullanılır. Bunlar:
-Matrislerle transformasyon belirleme
-İşlemlerle transformasyon belirleme
Matrislerle belirleme yönteminde glLoadMatrix (), glMultMatrix () OpenGL
fonksiyonları kullanılırken işlemlerle transformasyon belirleme tekniğinde
glRotate(), glTranslate() ,glScale() fonksiyonları kullanılır.
Her iki yöntem aşağıdaki konularda açıklanmaktadır.
Bilgisayar Grafikleri
Matrislerle Transformasyon Belirleme
Matrislerle transformasyon belirleme tekniğinde izlememiz gereken 4
adım vardır. Bunlar :
1-Geçerli matris modu belirlenir
2-Geçerli matris değişime uğratılır
3-Geçerli matris yüklenir
4-Geçerli matris çarpılır
Her adımı tek tek ele alalım.
Bilgisayar Grafikleri
Matrislerle Transformasyon Belirleme-Adım-1
Geçerli matris modu belirlenir
glMatrixMode (mod) fonksiyonu
Ne tür transformasyon matrisinin değişime uğratılacağını
belirler. mod parametresi GL_MODELVIEW , GL_PROJECTION
veya GL_TEXTURE kelimelerinden biri olur.
Bilgisayar Grafikleri
Matrislerle Transformasyon Belirleme-Adım-2
Geçerli matris değişime uğratılır
glLoadMatrix{fd} ( Type *m )
Geçerli matrisin 16 adet değerine(GTM 4x4 olduğu için 16
adet değeri mevcut) , m tarafından belirlenen değerler
atanır.
Not: m 1 boyutlu array olup 16 elemanı vardır
Bilgisayar Grafikleri
Matrislerle Transformasyon Belirleme-Adım-3
Geçerli matris değiştirme- yükleme
glLoadIdentity ( void )
Geçerli değişen matrisi 4x4 birim matrisine set eder.(orj:
Set the currently modifiable matrix to the 4x4 identity
matrix.)
Bilgisayar Grafikleri
Matrislerle Transformasyon Belirleme-Adım-4
Geçerli matris değişimi-çarpma
glMultMatrix{fd} ( Type *m )
m’ işaret ettiği 16 değer ile geçerli matrisi çarpar ve sonucu
yeni geçerli matris olarak kaydeder.
Not: m 1 boyutlu array olup 16 elemanı vardır
Bilgisayar Grafikleri
İşlemlerle Transformasyon Belirleme
OpenGL’da transformasyon modellemek için 3 tür rutin mevcuttur :
yer değiştirme,Ölçekleme,Döndürme.
Yer değiştirme
glTranslate {fd} (TYPE x, TYPE y, TYPE z) : Objeyi verilen x, y, z değerlerine
göre transform eden matris ile geçerli matrisi çarpar.
Ölçekleme
glScale {fd} (TYPE x, TYPE y, TYPE z) : Objeyi verilen x, y, z değerlerine
göre ölçekleyen matris ile geçerli matrisi çarpar
Döndürme
glRotate {fd} (TYPE angle, TYPE x, TYPE y, TYPE z) : Objeyi , orijinden
geçen bir doğru etrafında verilen x, y , z nokta değerlerine kadar saat yönünün
tersi yönünde döndüren matris ile geçerli matrisi çarpar. angle parametresi
döndürme açısını derece cinsinden belirler.
Bilgisayar Grafikleri
Örnek
Aşağıdaki örneği inceleyelim.
Konu : keyfi bir nokta etrafında döndürme işlemi
Soru:
Objeyi orijinden geçen ve diğer noktası (1.0, 2.0, 3.0) da olan bir çizgi ve
(4.0, 5.0, 6.0) noktası etrafında 45.0-derece açıyla döndürünüz.
Çözüm : aşağıdaki işlemler yapılması gerekir:
1-Objey V-vektöründen geçirilir -T(-4.0, -5.0, -6.0)
2-Orijin etrafında q-açıyla döndürülür-R(45.0)
3-Vectör- V den geriye doğru geçirilir-T(4.0, 5.0, 6.0)
buradan M –uygulanacak transformasyon olkam üzere
M = T(V ) R(q ) T(-V )
olur.Program kodu yandaki gibi olur:
glMatrixMode (GL_MODEVIEW);
glLoadIdentity ();
glTranslatef (4.0, 5.0, 6.0);
glRotatef (45.0, 1.0, 2.0, 3.0);
glTranslatef (-4.0, -5.0, -6.0);
Bilgisayar Grafikleri
Transformasyonlarda Dikkat Edilmesi Gereken Hususlar
Transformasyonların sırası :Transformasyon matrislerinin sırası, uygulanan
transformasyonların sırasına terstir. Yani ilk uygulanan transformasyonun
“transformasyon matrisi en son sırada olur”.
Adım adım :
G <= I
G <= GT(4.0, 5.0, 6.0)
G <= GR(45, 1.0, 2.0, 3.0)
G < = GT(-4.0, -5.0, -6.0)
En son şekli : G = T(4.0, 5.0, 6.0) GR(45, 1.0, 2.0, 3.0) GT(-4.0, -5.0, -6.0)
Bilgisayar Grafikleri
Transformasyonlarda Dikkat Edilmesi Gereken Hususlar-1
Matris Çarpımının Değiştirme Özelliği Yoktur : şekillere bakılırsa A işlemi
sonucu ile B işlemi sonucu aynı değildir. Burdan çıkıyorki transformasyon
işlemlerinin sırası önemli ve yer değiştirilemezler.
B-Öcne Yer değiştirme, sonra
da döndürme=>
A-Önce döndürme, sonra da
Yer değiştirme = >
Bilgisayar Grafikleri
Matris Yığınları
OpenGL, matris yığını mekanizmasını transformasyon hiyerarşisini yönetmek için
kullanır. OpenGL 3 adet matris yığını sağlar :
Model-Görüntü (model-view) matris yığını
Projeksiyon (projection) matris yığını
Texture matris yığını
Üst
Alt
Pop • Geçerli matris –herzaman matris
yığınının en üst elemanıdır.
• Geçerli matris ile iş yaparken aslında
matris yığınının en üst elemanı ile iş
yaparız.
• Geçerli matrisi push ve pop işlemleriyle
yönetebiliriz.
Bilgisayar Grafikleri
Matris Yığınlarını Yönetme Fonksiyonları
glPushMatrix ( void ) :Matris yığınına yeni bir eleman ekler
glPopMatrix ( void ) :Matris yığınından en üst elemanı yığından atar.
Matris yığınlarının derinliği OpenGL uyarlamalarına göre değişir
Modelview matris yığınının derinliği her zaman en az 32 dir.
Projeksiyon matris yığınının derinliği her zaman en az 2 dir .
Not: Geçerli yığın glMatrixModel() fonksiyonu ile belirlenir.
Bilgisayar Grafikleri
Uygulamalar-Problem 1
Problem 1:
Güneş ve 1 gezegeni olan basit bir güneş sistemi çiziniz
Güneş kendi ekseni etrafında dönsün (Y ekseni)
Gezegen kendi ekseni etrafında dönsün (Y ekseni)
Gezegen aynı zamanda güneş etrafındaki yörüngesinde dönsün.
Bilgisayar Grafikleri
Problem-1’in Çözümü
Güneş:
Orijindedir ve kendi ekseni etrafında döner (Y ekseni)
M = Ry ()
Gezegen:
1. Kendi ekseni etrafında döner. M1 = Ry ()
2. Yörüngesine göre çevirirsek. M2 = T (x, y, z)
3. Güneş etrafında döner. M3 = Ry ()
M = M3 M2 M1
Bilgisayar Grafikleri
Program Kodu-Sayfa 1
void main (int argc, char** argv)
{
glutInit ( &argc, argv );
glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGB);
glutInitWindowSize (500, 500);
glutCreateWindow ("Composite Modeling Transformation");
init ();
glutDisplayFunc (display);
glutReshapeFunc (reshape);
glutKeyboardFunc (keyboard);
glutMainLoop ();
}
Bilgisayar Grafikleri
Program Kodu-Sayfa 2
void init (void)
{
glViewport(0, 0, 500, 500);
glMatrixMode(GL_PROJECTION);
glLoadIdentity();
gluPerspective(60.0, 1, 1.0, 20.0);
glMatrixMode(GL_MODELVIEW);
glLoadIdentity();
glTranslatef (0.0, 0.0, -5.0); //görüntüleme transformasyonu
glClearColor(0.0, 0.0, 0.0, 0.0);
glShadeModel (GL_FLAT);
}
Bilgisayar Grafikleri
Program Kodu-Sayfa 3
void display(void)
{
glClear(GL_COLOR_BUFFER_BIT);
glColor3f (1.0, 1.0, 1.0);
glPushMatrix();
// güneş çiziliyor
glPushMatrix();
glRotatef ((GLfloat) ang2, 0.0, 1.0, 0.0);
glRotatef (90.0, 1.0, 0.0, 0.0); // yukarı sağa döndürme
glutWireSphere(1.0, 20, 16); // glut rutini
glPopMatrix();
Bilgisayar Grafikleri
Program Kodu-Sayfa 4
// küçük gezegen çizelim
glRotatef ((GLfloat) ang1, 0.0, 1.0, 0.0);
glTranslatef (2.0, 0.0, 0.0);
glRotatef ((GLfloat) ang3, 0.0, 1.0, 0.0);
glRotatef (90.0, 1.0, 0.0, 0.0); // yukarı sağa döndürme
glutWireSphere(0.2, 10, 8); // glut rutini
glPopMatrix();
glutSwapBuffers();
}
Bilgisayar Grafikleri
Program Çalışırken..
Bilgisayar Grafikleri
Uygulamalar-Problem 2
Problem 2:
Eklemli ve 3 segmentten oluşan basit bir robot kolu çiziniz. Kolun
segmentleri miller ile bağlı olsun. Segment uzunlukları aynı ve 2 birim
olsun.
Mil noktaları
Bilgisayar Grafikleri
Problem-2’nin Çözümü-Kırmızı Segment
Kırmızı segment:
1. İlk birimi mil noktasına çevirin.
M1 = T (1, 0, 0)
2. Mil noktası etrafında döndürün.
M2 = Ro ()
3. 2. brim orijine geri çevirilir.
M3 = T (-1, 0, 0)
M = M3 M2 M1
Bilgisayar Grafikleri
Kırmızı Segment- Program Kodu
void display(void)
{
glClear(GL_COLOR_BUFFER_BIT);
glPushMatrix();
// kırmızı kısım çızilir
glTranslatef (-1.0, 0.0, 0.0);
glRotatef (shoulder, 0.0, 0.0, 1.0);
glTranslatef (1.0, 0.0, 0.0);
glPushMatrix();
glScalef (2.0, 0.4, 0.1);
glColor3f (1.0, 0.0, 0.0);
glutSolidCube (1); // glut rutini
glPopMatrix();
Bilgisayar Grafikleri
Problem-2’nin Çözümü-Yeşil Segment
Yeşil segment:
1. İlk birim mil noktasına doğru
çevirilir.
M1 = T (1, 0, 0)
2. Mil noktası etrafında döndür.
M2 = Ro ()
3. Bir birim kırmızı segmentin
kenarına doğru çevirilir.
M3 = T (1, 0, 0)
M = M3 M2 M1
Bilgisayar Grafikleri
Problem-2’nin Çözümü-Sarı Segment
Sarı segment:
1. İlk birim mil noktasına doğru
çevirilir.
M1 = T (1, 0, 0)
2. Mil noktası etrafında döndür.
M2 = Ro ()
3. Bir birim yeşil segmentin kenarına
doğru çevirilir.
M3 = T (1, 0, 0)
M = M3 M2 M1
Bilgisayar Grafikleri
Yeşil ve Sarı Segment- Program Kodu
void display(void)
{
……
// yeşil kısım çizilir
glTranslatef (1.0, 0.0, 0.0);
glRotatef (elbow, 0.0, 0.0, 1.0);
glTranslatef (1.0, 0.0, 0.0);
glPushMatrix();
glScalef (2.0, 0.4, 0.1);
glColor3f (0.0, 1.0, 0.0);
glutSolidCube(1); // glut rutini
glPopMatrix();
Bilgisayar Grafikleri
Program Çalışırken...
Bilgisayar Grafikleri
Alıştırmalar
Not: programı download kısmından bolum4
dizininden indirebilirsiniz
Sailboat programını , matris çarpımı kullanarak aşağıdaki işlemleri
yapacak şekilde değiştiriniz:
Şekli pencerenin ortasına doğru çeviriniz
Yarı boyutuna ölçekleyiniz
Aşağıdaki eksenler etrafında döndürünüz :
X ekseni – fare sol butonu
Y ekseni – fare orta butonu
Z ekseni - fare sağ butonu
Bilgisayar Grafikleri
Alıştırmalar-1
Teapot programını, döndürme-ölçekleme-Yer değiştirme işlemlerini kullanarak
aşağıdaki işlemleri yapacak şekilde değiştiriniz:
Şekli pencerenin dibine doğru çeviriniz
1/3 boyutuna ölçekleyiniz
X ekseni etrafında 120 derece açı ile döndürünüz
Bilgisayar Grafikleri
Glu kütüphanesi :quadric Primitifleri
Quadric primitifler
gluCylinder
gluDisk
gluPartialDisk
gluSphere
Default olarak 0, 0, 0 noktasında görüntülenirler. İstenen konum
koordinatlarına çevirmek programcının görevidir.
Aşağıda her primitif kısaca açıklanmaktadır.
Bilgisayar Grafikleri
gluCylinder
Bir silindir çizer
gluCylinder ( quad, base, top, height, slices, stacks );
quad – quadric objeyi belirler (gluNewQuadric ile oluşturulur)
base – z=0 noktasında silindirin yarıçapını belirtir
top – z=height noktasında silindirin yarıçapını belirtir
height – silindirin yüksekliğini belirtir
slices – z ekseni etrafındaki alt bölümlerin sayısını belirtir
stacks - z ekseni boyunca oluşacak alt bölümlerin sayısını belirtir
Bilgisayar Grafikleri
gluDisk
Bir Disk çizer
gluDisk ( quad, inner, outer, slices, loops );
quad – quadric objeyi belirler (gluNewQuadric ile oluşturulur)
inner – diskin iç yarıçapını belirtir ( 0 da olabilir)
outer – diskin dış yarıçapını belirtir
slices –z ekseni etrafındaki alt bölümlerin sayısını belirtir
loops – orijin etrafındaki eşmerkezli çemberlrin sayısını belirtir
Bilgisayar Grafikleri
gluPartialDisk
Bir diskin yayını çizer
gluPartialDisk ( quad, inner, outer, slices, loops, start, sweep );
quad – quadric objeyi belirler (gluNewQuadric ile oluşturulur)
inner – diskin iç yarıçapını belirtir ( 0 da olabilir)
outer – diskin dış yarıçapını belirtir
slices –z ekseni etrafındaki alt bölümlerin sayısını belirtir
loops – orijin etrafındaki eşmerkezli çemberlrin sayısını belirtir
start – disk parçasının başlangıç açısını belirtir
sweep – disk parçasının çevreleme açısını belirtir
Bilgisayar Grafikleri
gluSphere
Bir küre çizer
gluSphere ( quad, radius, slices, stacks );
quad – quadric objeyi belirler (gluNewQuadric ile oluşturulur)
radius – kürenin yarıçapını berlirtir
slices – z ekseni etrafındaki alt bölümlerin sayısını belirtir
stacks - z ekseni boyunca oluşacak alt bölümlerin sayısını belirtir
Bilgisayar Grafikleri
Bilgisayar Grafikleri
Bölüm 5
Bilgisayar Grafikleri
Bakış Açısı
 Bakış Açısı
– Kesilen alanların çiziminde kullanılan, pencerenin bir
bölgesidir.(the region within the window that will be used
for drawing the clipping area.)
– Default olarak açık olan pencere diktörtgeninin tüm alanı
olarak set edilmiştir.
– Pencere koordinatları cinsinden hesaplanır ve bu
koordinatlar pencerenin alt-sol köşesine göre piksel
pozisyonlarını ekrana yansıtırlar.
Bilgisayar Grafikleri
Bakış Açısı Transformasyonu
Bakış açısı pencere
boyutu kadar
tanımlanmıştır.
Bakış açısı
pencerenin yarı
boyutu kadar
tanımlanmıştır.
h
w
h
w
Bilgisayar Grafikleri
Aspect Ratio
 Dikdörgen için Aspect Ratio eninin boyuna oranıdır :
örnek: Aspect Ratio = en/boy
 Bakış açısının aspect ratio’su görüntüleme
transformasyonunun aynısı olmalıdır, yoksa çıktı
görüntünün biçimi bozulabilir.
Bilgisayar Grafikleri
Bakış Açısı Komutları
 glViewport( x, y, genişlik,yükseklik )
Pencere içine çıktı görüntünün map edileceği bir diktörtgen
tanımlar.
(x, y) bakış açısının alt sol köşesini tanımlar.
(genişlik,yükseklik) bakış açısı dikdörtgeninin boyutunu belirler.
Bilgisayar Grafikleri
Alıştırma-Robot.c programı
 Program kodunu inceleyiniz
– Görüntüleme kısmına glViewport komutunu ekleyiniz
Bilgisayar Grafikleri
Soru
 Bir obje verilmiş olsun ve ben bu objeyi bir bakış açısından
renderlemek istiyorsam hangi bilgilere ihtiyacım var?
– Görüntüleme konumu (viewing position)
– Hangi yöne bakıyorum
– “yukarı” taraf neresi
– Projeksiyon
– Aspect Ratio
– Görüntü alanı (field of view)
– Yakın ve Uzak (Near and Far)
Bilgisayar Grafikleri
Sentetik Kamera Modeli
Fotoğraf
Makinesi Model
Bilgisayar Grafikleri
Transformasyonlar Ve Kamera Benzetmesi
 Görüntüleme transformasyonu
– Kameranın yerleştirilmesi ve odaklanması.
 Modelleme transformasyonu
– Modelin yerleştirilmesi ve hareket ettirilmesi
 Projeksiyon transformasyonu
– Kameranın lensinin ayarları
 Bakış Açısı transformasyonu
– Fiziki fotografın büyültülüp küçültülmesi
Bilgisayar Grafikleri
3D Dünyayı Görüntüleme
Model Bakış yönü
Bakış konumu (göz noktası)
Bilgisayar Grafikleri
Bakış Konumu (view position)
 Çevirme
 Döndürme
x
y
z
x
y
z Kamera
D, Ç
Bilgisayar Grafikleri
OpenGL Kullanırsak...
glMatrixMode (GL_MODEVIEW);
glLoadIdentity ();
glTranslatef (0.0, 0.0, -d);
glRotatef (-90.0, 0.0, 1.0, 0.0);
Bilgisayar Grafikleri
Koordinat Transformasyonu
 Noktayı transform etmek
Bir P noktasına T1 ,T2 , T3 (bu sıra ile) transformasyon dizsini
uygulamak için , aşağıdaki matris oluşturulur :
T = T3T2T1
Sonra P , TP ye transform edilir.
 Koordinat sistemini transform etmek
Bir koordinat sistemine T1 ,T2 , T3 (bu sıra ile) transformasyon
dizsini uygulamak için , aşağıdaki matris oluşturulur :
T = T1T2T3
Sonuç olarak, transform edilmiş koordinat sisteminde tanımlı P
noktasının orijinal sistemdeki koordinatları MP olur.
Bilgisayar Grafikleri
Nereye Bakıyorum ?
Projeksiyon merkezi (center of projection- COP)
Bakış yönü
Bakış-yukarı
Bakış-sağ
Bakış-normal
Bakış konumu (göz noktası)
Bilgisayar Grafikleri
Kameranın Yerleştirilmesi
Bakış-referans noktası
(View-reference point-VRP)
Bakış yönü
Bakış-yukarı vektörü
(View-up vector-VUP)
Bakış-sağ
Bakış-düzlem normal
(View-plane normal-VPN )
n
-n
u
v
Bilgisayar Grafikleri
Kameranın Yerleştirilmesi-1
 Set view reference point (VRP)
Set_view_reference_point (x, y, z)
 Set view plane (VPN)
Set_view_plane_normal (nx, ny, nz)
 Set_view_up (VUP)
Set_view_up (vx, vy, vz)
Bakış-koordinat sistemi (u-v-n sistemi) ve VRP(view
point ref.) ile istenen kamera frame’ını (karesini)
belirleyebiliriz.
Bilgisayar Grafikleri
Neredeyim Ve Nereye Bakıyorum ?
x
y
z
x
y
z
Eyepoint (göz noktası)
(eyex, eyey, eyez)
Model
View-up vectörü
(upx, upy, upz)
Loot at vektörü
(atx, aty, atz)
Bilgisayar Grafikleri
OpenGL Kullanırsak...
 Look-At Fonksiyonu
gluLookAt (eyex, eyey, eyez, atx, aty, atz, upx, upy, upz )
Göz noktası (eyex, eyey, eyez),sahnenin merkezini
tanımlayan referans noktası (centerx, centery, centerz) ve
yukarı vektörünü (upx,upy,upz) taban alarak genel olarak
kullanılan bir görüntüleme matrisi oluşturur.
Bilgisayar Grafikleri
OpenGL Kullanırsak-1
gluLookAt (eyex, eyey, eyez, atx, aty, atz, upx, upy, upz )
Oluşturulan matris negatif Z ekseninde sahnenin merkezini
map edecek (haritalayacak) şekilde düzenlenir. Böylece
tipik projeksiyon matrisi kullanıldığında sahne merkezi
bakış açısının merkezine map edecek şekilde oluşur.
Benzer şekilde görüntüleme düzlemindeki “up vektörü”nün
projeksiyonu positif Y eksenine map edilir ve “bakış açısı
alanında” yukarıyı işaret eder.
Bilgisayar Grafikleri
Alıştırma-Teapot1.c programı
 Teapot1 programı
– Programa gluLookAt() fonksiyonunu ekleyin
– eye, at, ve up parametrelerini (-3, +3) olarak değiştirin
Bilgisayar Grafikleri
Bir Kaç Örnek Program
Bilgisayar Grafikleri
Perspektif Görüntüleme
Model
Bakış Konumu (göz noktası)
Bilgisayar Grafikleri
Paralel Görüntüleme
Bakış Konumu (göz noktası)
Model
Bilgisayar Grafikleri
Ortografik Projeksiyon
Obje vertexlerinin
izdüşümleri sonsuza
kadar mevcuttur.
• Görüntüleme hacmi
dışında kalan
noktalar kesilir
(clipped out ) .
• Mesafe, objenin
görünüşteki boyutunu
değiştirmez.
Kesilen
Kısım
Görüntü
Bilgisayar Grafikleri
3D Dünyayı Görüntüleme
Bakış-sağ
Bakış-yukarı
Bakış-yukarı
Bakış-sağ Aspect Ratio =
Bilgisayar Grafikleri
Perspektif Görüntüleme Hacmi
Yakın-plan
Uzak-plan
Görüntüleme
hacmi
Bilgisayar Grafikleri
Ortografik Görüntüleme Hacmi
Yakın-plan Uzak-plan
Görüntüleme
Hacmi
sol
sağ
üst
Alt
Bilgisayar Grafikleri
Projeksiyon Boru Hattı
Perspektif
Bölünme Model-view Projeksiyon
Bilgisayar Grafikleri
OpenGL’da Projeksiyonlar
 OpenGL, projeksiyon transformasyonlarını tanımlamak
için birtakım API fonksiyonları sağlar
– Ortogonal projeksiyon
– Perspektif projeksiyon
Bilgisayar Grafikleri
Projeksiyon Matrisini Belirtmeyi Unutmayın
 Geçerli matris modunu belirtme
glMatrixMode (mod)
Ne tür transformasyon matrisinin değişime
uğrayacağını belirler.
mod:
GL_MODELVIEW
GL_PROJECTION
Bilgisayar Grafikleri
Ortografik Projeksiyon
Yakın-plan: zNear Uzak-plan: zFar
Görüntüleme
Hacmi
sol
sağ
üst
Bottom
x
y
z
Bilgisayar Grafikleri
Ortografik Projeksiyon Komutları
 glOrtho( left, right, bottom, top, zNear, zFar )
Ortografik görüntüleme hacmi için bir matris oluşturur ve
“Geçerli Matris” ile çarpar.
Bilgisayar Grafikleri
Ortografik Projeksiyon Komutları-1
gluOrtho2D( left, right, bottom, top )
2D koordinatların ekranda gösterilmesi için bir matris oluşturur
ve geçerli matris ile çarpar.
Not: glOrtho() ile aynı ama
zNear = -1.0, zFar = 1.0 değerlerini alır.
Bilgisayar Grafikleri
Örnek
glMatrixMode(GL_PROJECTION)
glLoadIdentity();
gluOrtho2D(0.0, 500.0, 0.0, 500.0);
Bu örnek alt-sol köşesi 2D sisteminin orijininde olan 500x500
boyutunda görüntüleme dikdörtgeni oluşturur.
Bilgisayar Grafikleri
Alıştırma
 Teapot1 programı
– gluOrtho ifadesinin parametrelerini aşağıdaki değerlere göre
değiştirerek programı derleyiniz.
– Sol/Sağ – Alt/Üst (-3, +3)
– Zfar -(9)
Bilgisayar Grafikleri
Perspektif Projeksiyon
Uzak-plan: zFar Yakın-plan: zNear
Görüntüleme
Hacmi
Üst Sol
Sağ Alt
x
y
z
Bilgisayar Grafikleri
Perspektif Projeksiyon-glFrustum komutu
glFrustum( left, right, bottom, top, zNear, zFar )
Perspektif görüntüleme frustum’u için bir matris oluşturur ve
geçerli matrisi onunla çarpar.
Bilgisayar Grafikleri
Örnek
void initOpenGL(void)
{
glMatrixMode (GL_MODELVIEW);
gluLookAt (10.0, 10.0, 5.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
glMatrixMode(GL_PROJECTION);
glFrustum(-0.4, 0.4, -0.4, 0.4, 1.0, 50.0);
glMatrixMode(GL_MODELVIEW);
glEnable(GL_DEPTH_TEST);
}
Bilgisayar Grafikleri
Alıştırma
 teapot1 programına aşağıdakileri
ekleyerek/değiştirerek programı çalıştırınız.
– glFrustum fonksiyonunu ekleyiniz
– Aşağıdaki parametreleri kullanınız
– Sol/Sağ – Alt/Üst (-3, +3)
– zNear (5)
– Zfar (9)
Bilgisayar Grafikleri
Perspektif Projeksiyon-1
Uzak-plan: zNear Yakın-plan: zNear
Görüntüleme
Hacmi
h
w
aspect ratio = w/h
y
z
x
fovy
Bilgisayar Grafikleri
Perspektif Projeksiyon- gluPerspective komutu
gluPerspective( fovy, aspect, zNear, zFar )
Perspektif görüntüleme frustum’u için bir matris oluşturur ve
geçerli matrisi onunla çarpar.
Not: fovy inglizce “field of view”-görüntü/bakış alanı anlamına
gelir. Fovy –kesilen alanın üst ve alt düzlemleri arasındaki bölgeyi
tanımlar. aspect- is the aspect ratio’dur.
Bilgisayar Grafikleri
Alıştırma
 teapot1 programına aşağıdakileri
ekleyerek/değiştirerek programı çalıştırınız
– glPerspective fonksiyonunu ekleyiniz
– Aşağıdaki parametreleri veriniz
– Aspect – (2, 0.5)
– fovy (30, 90)
– Zfar (9)
Bilgisayar Grafikleri
Gizli-Yüzey Kaldırma İşlemi
• Gizli-Yüzey kaldırma
Bakan kişinin görmemesi
gereken yüzeyleri
kaldırmamız gerekir.
Bakış Açısı
Bilgisayar Grafikleri
Gizli-Yüzey Kaldırma İşlemi-1
z1
z2
z-buffer algoritması
- Görüntü-Uzay Kontrolü
- “En kötü ihtimal” karmaşıklığı
,çokgenler sayısı ile orantılıdır
- Çokgenler rasterize edildikçe
bilgiyi tutmak için bir buffera
ihtiyaç duyar ve bu buffere z
buffer denir.
Viewpoint
Bilgisayar Grafikleri
Gizli-Yüzey Kaldırma İşlemi-2
glEnable(GL_DEPTH_TEST)
glDisable(GL_DEPTH_TEST)
z (derinlik) buffer’inin gizli- yüzey kaldırma işlemi için
enable/disable eder.
Bilgisayar Grafikleri
Başlangıç Durumuna Getirmeyi Unutmayın
glutInitDisplayMode(GLUT_DOUBLE|GLUT_RBG|GLUT_DEPTH);
glClear(GL_DEPTH_BUFFER_BIT)
z (derinlik) buffer’ını temizler
Derinlik buffer’ını de temizleyebilirsiniz (color buffer için
yaptığımız gibi
Bilgisayar Grafikleri
Bigisayar Grafiklerinde Projeksiyonlar
 Kullanılan 2 adet ana projeksiyon tipi mevcuttur
– Paralel
– Perspektif
 Genelleştirilmiş projeksiyon oluşturmak için ikisi
birleştirilebilir.
Bilgisayar Grafikleri
Perspektif Projeksiyon-2
Yakın-plan Uzak-plan
Görüntüleme
Hacmi
Bilgisayar Grafikleri
Perspektif Projeksiyon-Özellikleri
 Özellikleri
– Doğal görüntü, grafik renderlemede kullanılır.
– Yakın objeler uzak objelerden daha büyük görünür.
– Uzunlukları veya açıları kaydetmez.
– Perspektif transformasyon geri alınamaz(irreversible)
– Görüntüleme düzlemine paralel olmayan “objenin paralel
çizgileri”- yok olma noktasına yakınsaktır (vanishing
point-yok olma noktası).
Bilgisayar Grafikleri
Perspective Projections
One point Two points Three points
Bilgisayar Grafikleri
Perspektif Projeksiyon-Çeşitleri
 Esal olan eksenler tarafından belirlenen ve projeksiyon
düzlemiyle kesişen üç tip perspektif projeksiyon vardır.
– Tek-nokta perspektif
– Çift-nokta perspektif
– Üç-nokta perspektif
Bilgisayar Grafikleri
Tek-Çift-Üç Nokta Perspektif Projeksiyon
– Tek-nokta
 Bir tek esas eksen projeksiyon düzlemiyle kesişir
 Tek eksen kaybolma noktası
– Çift-nokta
 İki esas eksen projeksiyon düzlemiyle kesişir
 İki eksen kaybolma noktası
– Üç-nokta
 Üç esas eksen projeksiyon düzlemiyle kesişir
 Üç eksen kaybolma noktası
Bilgisayar Grafikleri
Paralel Projeksiyon
Yakın-plan Uzak-plan
Görüntüleme
Hacmi
Bilgisayar Grafikleri
Paralel Projeksiyon-Özellikleri
 Özellikler
– Objeleri paralel çizgiler boyunca projeksiyon
düzlemine aktarır .
– Obje vertex’lerinin izdüşümleri sonsuza kadar uzanır.
– Objelerin birbirine nispi oranlarını kaydeder.
– Hassas uzunluk ve açı ölçüm imkanı sağlar ama
realistik görünüş sağlamaz
Bilgisayar Grafikleri
Paralel Projeksiyon-Çeşitleri
Ortografik Axonometric Oblique
Bilgisayar Grafikleri
Ortografik ve Oblique Paralel Projeksiyon
 İki tip paralel projeksiyon mevcuttur
– Ortografik projeksiyon
 Multiview ortografik projeksiyon
 Axonometric projeksiyon
– Oblique projeksiyon
Bilgisayar Grafikleri
Ortografik ve Axonometrik Paralel Projeksiyon
 Ortografik projeksiyon
– Projeksiyon yönü ,projeksiyon düzlemine diktir.
– Projeksiyon düzlemi esas eksenlerden birine paraleldir.
 Axonometric projeksiyon
– Projeksiyon yönü ,projeksiyon düzlemine diktir.
– Projeksiyon düzlemi esas eksene ortogonal değildir.
– Objenin birden fazla yüzü görüntülenir.
Bilgisayar Grafikleri
Oblique Paralel Projeksiyon
 Oblique projeksiyon
– Projeksiyon yönü, projeksiyon düzlemine ortogonal değildir
Üstten görünüş Yandan görünüş
Bilgisayar Grafikleri
Projeksiyonların Sınıflandırılması- Şema
Bilgisayar Grafikleri
Program-kodu inceleyiniz
gluLookAt
gluPerspective
glFrustum
glOrtho
Bilgisayar Grafikleri
Programlar-kodlarını inceleyiniz
gluLookAt, glFrustum gluLookAt, gluPerspective
gluLookAt, gluPerspective gluLookAt, gluPerspective
Bilgisayar Grafikleri
glut Primitfleri
 glutSolidSphere, glutWireSphere
 glutSolidCube, glutWireCube
 glutSolidCone, glutWireCone
 glutSolidTorus, glutWireTorus
 glutSolidDodecahedron, glutWireDodecahedron
 glutSolidOctahedron, glutWireOctahedron
 glutSolidTetrahedron, glutWireTetrahedron
 glutSolidIcosahedron, glutWireIcosahedron
Bilgisayar Grafikleri
glutSolidSphere, glutWireSphere
Katı veya wireframe(tel çerçeve) küre çizme
void glutSolidSphere(GLdouble radius, GLint slices, GLint stacks);
void glutWireSphere(GLdouble radius, GLint slices, GLint stacks);
radius- küre yarıçapı.
slices –Z ekseni etrafındaki alt bölmelerin sayısı (boylam çizgileri misali).
stacks- Z ekseni boyunca olması istenen alt bölme sayısı (enlem çizgileri
misali).
Bilgisayar Grafikleri
glutSolidCube, glutWireCube
Katı veya wireframe küp çizme
void glutSolidCube(GLdouble size);
void glutWireCube(GLdouble size);
size-her kenarın uzunluğu
Bilgisayar Grafikleri
glutSolidCone, glutWireCone
Katı veya wireframe bir koni çizmek için
void glutSolidCone(GLdouble base, GLdouble height, GLint slices, GLint
stacks);
void glutWireCone(GLdouble base, GLdouble height, GLint slices, GLint
stacks);
base- koni tabanının yarıçapı.
height –koninin yüksekliği.
slices –Z ekseni etrafındaki alt bölmelerin sayısı (boylam çizgileri misali).
stacks- Z ekseni boyunca olması istenen alt bölme sayısı (enlem çizgileri
misali).
Bilgisayar Grafikleri
glutSolidTorus, glutWireTorus
Katı veya wireframe bir simit çizme
void glutSolidTorus(GLdouble innerRadius, GLdouble outerRadius,
GLint nsides, GLint rings);
void glutWireTorus(GLdouble innerRadius, GLdouble outerRadius,
GLint nsides, GLint rings);
innerRadius –simitin iç yarıçapı.
outerRadius –simitin dış yarıçapı.
nsides –her radyal bölme için istenen side sayısı.
rings –radyal bölme sayısı.
Bilgisayar Grafikleri
glutSolidDodecahedron,
glutWireDodecahedron
Katı veya wireframe dodecahedron(12-taraflı düzgün
katı cisim)
void glutSolidDodecahedron(void);
void glutWireDodecahedron(void);
Bilgisayar Grafikleri
glutSolidOctahedron,
glutWireOctahedron
void glutSolidOctahedron(void);
void glutWireOctahedron(void);
Katı veya wireframe octahedron (8-taraflı düzgün
katı cisim)
Bilgisayar Grafikleri
glutSolidTetrahedron,
glutWireTetrahedron
void glutSolidTetrahedron(void);
void glutWireTetrahedron(void);
Katı veya wireframe tetrahedron (4-taraflı
düzgün katı cisim)
Bilgisayar Grafikleri
glutSolidIcosahedron,
glutWireIcosahedron
void glutSolidIcosahedron(void);
void glutWireIcosahedron(void);
Katı veya wireframe icosahedron (20-taraflı
düzgün katı cisim)
Bilgisayar Grafikleri
Ödev
 Aşağıdaki özelliklere sahip OpenGL programı yazınız:
– ortografik projeksiyon, perspektif projeksiyon ve frustum
projeksiyonları arasında seçim imkanı sağlayan bir menü
– Her üç projeksiyonu sağlayan gluLookAt fonksiyonu
– x, y, z değerleri girildiğinde gluLookAt fonksiyonunun
x,y,z “eye position” parametrelerinin değerleri artsın.
– a, b, c değerleri girildiğinde gluLookAt fonksiyonunun
x,y,z “eye position” parametrelerinin değerleri azalsın.
 glut primitiflerini kullanarak ilginç objeler oluşturunuz
Bilgisayar Grafikleri
Bilgisayar Grafikleri
Bölüm 6
Bilgisayar Grafikleri
Işıklandırma (Lighting)
Bu bölümde göreceklerimiz :
1-Gerçek-Dünya ve OpenGL Işıklandırması
2-Basit Bir Örnek: Aydınlatılmış bir küreyi renderleme
3-Işık Kaynaklarını Oluşturma
4-Işıklandırma Modeli Seçimi
5-Madde Özelliklerini Belirleme
Bilgisayar Grafikleri
Giriş
OpenGL, görüntülenen sahnedeki bütün piksellerin renklerini hesaplar. Bu hesaplamanın
bir kısmı sahnede ne tür ışık kullanıldığına ve objelerin bu ışığı nasıl yansıttığı yada
absorbe ettiğine(emdiğine) bağlıdır. Buna örnek olarak bir okyanus düşünün; okyanusun
aydınlık ve güneşli gündeki rengi ile kapalı ve bulutlu havadaki rengi aynı değildir. Güneş
ışığı ve bulutlar faktörü okyanusu açık turkuaz renginde yada koyu gri-yeşil renkte
görmemizi belirler. Çoğu objeler de aydınlatılmadıkça üç boyutlu görünmezler bile. Şekil
6-1 de gösterildiği gibi tamamen aynı iki sahneyi görüyorsunuz (tek küre), birisi
ışıknandırılmış diğeri değil.
Şekil 6-1 :
Aydınlatılmış ve
Aydınlatılmamış
Küreler -
Görüldüğü gibi
aydınlatılmamış
kürenin iki-boyutlu
diskten farkı
yoktur.
Bilgisayar Grafikleri
1-Gerçek-Dünya ve OpenGL Işıklandırması
Fiziki bir yüzeye bakarken gözlerimizin ışığı algılaması göz koni hücrelemizi
tetikleyen foton enerjilerinin dağılımına bağlıdır. Fotonlar ışık kaynağından veya
bileşke ışık kaynaklarından gelir. Bu fotonların bazıları yüzeyler tarafından yansıtılır
bazılarıda yutulurlar. Farklı yüzeyler-farklı özelliklere sahip olabilirler,bazıları parlak
ve ışığı belli bir yönde yansıtırken diğerleri ışığı eşit olarak bütün yönlerde dağıtırlar.
Çoğu yüzeyler bu iki ortamın ortalarında bir özelliğe sahiptirler.
OpenGL ışık ve ışıklandırması sanki ışık kırmızı,yeşil ve mavi komponentlere
bölünmuş gibi bir yaklaşım içindedir. Işık kaynaklarının rengide yaydıkları
kırmızı,yeşil ve mavi ışıkların miktarı olarak karakterize edilirken yüzeyin maddesi
de gelen kırmızı,yeşil ve mavi ışıkların her yönde dağıtılma yüzdesi olarak
karakterize edilir. OpenGL ışıklandırma denklemleri sadece bir yaklaşımdır ama
gayet başarılı çalışırlar. Opengl ışıklandırma modelinde sahneye gelen ışık bir kaç
kapatıp açılabilir ışık kaynaklarından gelir. Bazı ışıklar belli bir yönden gelirke bazı
ışıklar sahne boyunca dağıtılır. Örneğin odadaki ampulü yaktığımızda çoğu ışık
ampulden gelir, ama bir kısmı da bir,iki ,üç yada daha fazla duvarlar arasında
hopladıktan sonra gelir. Bu hoplayan ışığa ambient denir.
Bilgisayar Grafikleri
Gerçek-Dünya ve OpenGL Işıklandırması-1
Son olarak da gelen ışık “genel ambient ışık” olabilir. Bu ışıklar o kadar çok kez
hoplayıp zıplamışlarki gerçek kaynakları belli olmamaktadır.
OpenGL modelinde ancak ışığı yansıtan yada emen yüzeyler olduğunda ışığın bir
etkisi vardır. Her yüzey çeşitli özelliklere sahip maddelerden yapılmış olarak
varsayılmaktadır. Madde kendi ışığını emebilir, gelen ışığı her yönde dağıtabilir,
ışığı belli bir doğrultuda yansıtabilir-mesela ayna veya parlak yüzeyler gibi.
Opengl ışıklandırma modelinde ışıklandırma 4 bağımsız bileşen olarak ele alınır :
yayılan, ambient, diffuse ve specular. Bütün bileşenler ayrı ayrı olarak hesaplanır
ve daha sonra birleştirilir
Bilgisayar Grafikleri
Yayılan, Ambient, Diffuse Specular Işık
Yayılan : en basiti – bir objeden çıkar ve hiç bir ışık kaynağından etkilenmez.
ambient : ortam tarafından o kadar çok kez kırılmış ve dağıtılmış ki asıl ışık
kaynağı belli olmamaktadır – ışık her yönden geliyormuş gibi olur. Bir odada
arkanızda olan ışıklandırmanın çok büyük bir ambient componenti vardır,çünkü
gözlerinize gelen ışık yüzeylerden çok kez çarparak gelmiştir. Projektör ışığında
ise aksine ambient componenti küçüktür;çünkü ışığın çoğu belli bir yöndedir.
Ambient ışık yüzeye vurduğunda tüm yönlerde eşit olarak dağıtılır.
Diffuse : ışık tek yönden gelmektedir, böylece eğer ışık yüzeye direk geliyorsa
daha parlak , yan geliyorsa daha sönük olmaktadır. Belli bir yönden gelen
herhangi bir ışık büyük ihtimalle diffuse componentine sahiptir.
Specular : ışık belli bir yönden gelmektedir ve yüzeyden istenilen yönde
yansımaktadır. Parlak metal veya plastik çok büyük specular komponente
sahiptir. Specular’lık hakkında parlaklık olarak düşünebilirsiniz.
Bilgisayar Grafikleri
Işıklar ve Maddeler için RGB değerleri
Işıklar için belirlenen renk komponentleri bazen maddeleri için farklı anlamlar
taşıyabilir. Işık için rakamlar rengin tam yoğunluğunun yüzdesine tekabul eder.
Eğer bir ışık için R, G ve B değerleri 1.0 ise , ışık mümkün olan en parlak
beyazdır. Eğer değerler 0.5 ise , renk yine beyazdır ama yarım
yoğunlukta,dolayısıyla renk gri olarak ortaya çıkar. Eğer R=G=1 ve B=0 ışık sarı
olur.
Maddeler için ise rakamlar renklerin yansıma oranlarına tekabul eder. Eğer R=1,
G=0.5 ve B=0 ise, madde gelen kırmızı ışığın tümünü ,yeşil ışığın yarısını ve hiç
mavi rengi yansıtmamaktadır. Başka bir deyişle eğer OpenGL (LR, LG, LB) şık
komponentlerine ve madde de (MR, MG, MB) komponetlerine sahip ise göze
gelen ışık (LR*MR, LG*MG, LB*MB) ile verilir..
Benzer olark eğer (R1, G1, B1) ve (R2, G2, B2) gönderen iki ışık kaynağımız
olsa, OpenGL komponentleri toplayarak (R1+R2, G1+G2, B1+B2) sonucunu
verir.
Bilgisayar Grafikleri
2-Basit Bir Örnek: Aydınlatılmış bir küreyi renderleme
aşağıdaki adımlar sahneye ışık eklemek için gereken adımlardır :
a-bütün objelerin her vertexi için normal vektörleri tanımlayın. Bu normaller
objenin ışık kaynağına olan oriyantasyonunu belirler
b-bir yada birden fazla ışık kaynağı oluştur,seç veya yerleştir.
c-Global ambient ışık seviyesini ve bakış noktasının efektif konumunu belirleyen
ışıklandırma modelini seçin veya oluşturun
d-Sahnedeki objeler için madde özelliklerini belirleyin.
Örnek 6-1 bu görevi yerine getirmektedir. Daha önce şekil 6-1 de gösterilen tek
ışık kaynağı ile aydınlatılan küre için program kodu aşağıdadır.
Bilgisayar Grafikleri
Örnek 6-1 aydınlatılmış küre çizimi: Kod
Örnek 6-1 Kod aydınlatılmış küre çizimi:
#include <GL/gl.h>
#include <GL/glu.h>
#include "aux.h"
void myinit(void)
{ GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };
GLfloat mat_shininess[] = { 50.0 };
GLfloat light_position[] = { 1.0, 1.0, 1.0, 0.0 };
glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);
glLightfv(GL_LIGHT0, GL_POSITION, light_position);
glEnable(GL_LIGHTING);
glEnable(GL_LIGHT0);
glDepthFunc(GL_LEQUAL);
glEnable(GL_DEPTH_TEST);
}
void display(void)
{ glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
auxSolidSphere(1.0);
glFlush();
}
Bilgisayar Grafikleri
Örnek 6-1 aydınlatılmış küre çizimi: Kod-1
void myReshape(GLsizei w, GLsizei h)
{
glViewport(0, 0, w, h);
glMatrixMode(GL_PROJECTION);
glLoadIdentity();
if (w <= h)
glOrtho (-1.5, 1.5, -1.5*(GLfloat)h/(GLfloat)w,
1.5*(GLfloat)h/(GLfloat)w, -10.0, 10.0);
else
glOrtho (-1.5*(GLfloat)w/(GLfloat)h,
1.5*(GLfloat)w/(GLfloat)h, -1.5, 1.5, -10.0, 10.0);
glMatrixMode(GL_MODELVIEW);
glLoadIdentity();
}
int main(int argc, char** argv)
{ auxInitDisplayMode (AUX_SINGLE | AUX_RGBA | AUX_DEPTH);
auxInitPosition (0, 0, 500, 500);
auxInitWindow (argv[0]);
myinit();
auxReshapeFunc (myReshape);
auxMainLoop(display); }
Bilgisayar Grafikleri
Örnek 6-1 Açıklamalar
Işıklandırma ile ilgili çağrılar myinit() fonksiyonu içindedir; bu çağrılar aşağıdaki
paragraflarda açıklanmaktadırlar. Not etmek istediğim şey Örnek 6-1 in color-index modunu
değil RGBA renk modunu kullanmaktadır. OpenGL’ın ışıklandırma hesaplamaları her 2
mod için farklıdır ve color-index modun ışıklandırma kabiliyetleri daha kıttır. RGBA modu
ışıklandırma yaparken tercih edilen moddur.
a-Bütün objelerin her vertexi için normal vektörlerin belirlenmesi: OpenGL her vertexin
her ışık kaynağından ne kadar ışık aldığını belirlemek için özel tahsis edilmiş “normal
vektörleri”kullanır. Bu örnekte küre için normaller auxSolidSphere() rutininin bir parçası
olarak belirlenmişlerdir.
b-Bir yada birden fazla ışık kaynağı oluştur,seç veya yerleştir :Örnek 6-1 sadece 1 adet
beyaz ışık kaynağı kullanmaktadır. Kaynağın konumu glLightfv() çağrısıyla
belirlenmektedir. Bu örnek varsayılan renk olan sıfır rengini (GL_LIGHT0) kullanmaktadır
ki bu beyaz renktir; farklı bir renk istiyorsanız glLight*() komutunu kullanmanız gerekir.
Sahnenize en az 8 adet değişik renkli ışık kaynağı dahil edebilirsiniz; bu kaynakların
varsayılan renkleri siyahtır . Işıkları istediğiniz yere koyabilirsiniz , sahne yakınına mesela ki
bu masa lambası gibi olur veya sonsuz uzaklıkta, güneş gibi.
Bilgisayar Grafikleri
Örnek 6-1 Açıklamalar-1
Bunun yanında kaynağın dar,odaklanmış veya geniş ışınlar ütetmesini kontrol edebilirsiniz.
İstediğiniz ışıkların karakteristiklerini belirledikten sonra onları glEnable() komutu ile
açmalısınız. Bir de bu komutu opengl’nin ışıklandırma işlemlerini yapabilmesi için
GL_LIGHTING parametresi ile çağırmalısınız.
c-Işıklandırma modelini seçin : glLightModel*() komutu ışıklandırma modelinin
parametrelerini açıklar. Örnek 6-1 de ışıklandırma modelinin elementi olarak sadece
ambient ışık tanımlanmıştır. Işıklandırma modeli birde sahne görüntüleyinisinin uzaklığını ve
objenin ön ve arka yüzeyleri için hesaplamaların ayrı olup olmayacağını da belirler. Örnek 6-
1 bu iki aspektin default ayarlarını kullanmakta – sonsuz görüntüleyici ve tek taraflı
aydınlatma. Bu örnekte kürenin arka yüzeyi hiçbir zaman görünmediğinden tek taraflı
aydınlatma yeterlidir.
d- Sahnedeki objelerin madde özelliklerini belirleme :objenin madde özellikleri objenin
ışığı nasıl yanstıttığını belirler ve dolayısıyla maddenin neden yapıldığı hakkında fikir verir.
Objenin yüzey maddesi ile ışık arasındak etkileşim karmaşık olduğundan istenilen görüntüyü
elde etmek bir sanattır. Maddenin ambient, diffuse, ve specular renk özellikleri ile nekadar
parlak oldukları ayarlanabilir. Bizim örnekte son iki madde özelliği-madde specular rengi ve
parlaklık belirtilmiştir( glMaterialfv() komutu ile).
Bilgisayar Grafikleri
3-Işık Kaynaklarını Oluşturma
Işık kaynakları renk ,konum ve yön gibi bir takım özelliklere sahiptirler. Bu
bölüm bu özellikleri nasıl yönetileceğini ve çıktı ışığın nasıl olacağını ele
almaktadır. Işık özelliklerinin tümü glLight*() komutu ile belirlenir. Üç argüman
alır.
void glLight{if}[v](GLenum light, GLenum pname, TYPEparam);
light ile belirlenen bir kaynak oluşturur,light burada GL_LIGHT0, GL_LIGHT1,
... , veya GL_LIGHT7 olabilir. Atanacak ışığın özelliği pname ile belirlenir; eğer
vektör versiyonu kullanılıyorsa bu bir pointerdir ama vektör olmayan versiyonu
kullanılıyorsa kendi değeridir.
Bilgisayar Grafikleri
a
Tablo 6-1 : glLight*() ‘ın pname parametresinin varsayılan değerleri
Parametre İsmi Varsayılan Değer Anlamı
GL_AMBIENT (0.0, 0.0, 0.0, 1.0) ambient RGBA ışık yoğunluğu
GL_DIFFUSE (1.0, 1.0, 1.0, 1.0) diffuse RGBA ışık yoğunluğu
GL_SPECULAR (1.0, 1.0, 1.0, 1.0) specular RGBA ışık yoğunluğu
GL_POSITION (0.0, 0.0, 1.0, 0.0) (x, y, z, w) ışık konumu
GL_SPOT_DIRECTION (0.0, 0.0, -1.0) (x, y, z) projektör yönü
GL_SPOT_EXPONENT 0.0 Projektör üssü
GL_SPOT_CUTOFF 180.0 Projektör cutoff açısı
GL_CONSTANT_ATTENUATION 1.0 Sabit attenuation faktör
GL_LINEAR_ATTENUATION 0.0 Linear attenuation faktör
GL_QUADRATIC_ATTENUATION 0.0 quadratik attenuation faktör
Bilgisayar Grafikleri
glLight*() Kullanım Örneği
GLfloat light_ambient[] = { 0.0, 0.0, 0.0, 1.0 };
GLfloat light_diffuse[] = { 1.0, 1.0, 1.0, 1.0 };
GLfloat light_specular[] = { 1.0, 1.0, 1.0, 1.0 };
GLfloat light_position[] = { 1.0, 1.0, 1.0, 0.0 };
glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient);glLightfv(GL_LIGHT0,
GL_DIFFUSE, light_diffuse);
glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular);
glLightfv(GL_LIGHT0, GL_POSITION, light_position);
parametre değerleri için diziler tanımlanmış ve glLightfv() tekrar tekrar farklı
parametreleri set etmek için çağrılmıştır. Bu örnekte ilk üç glLightfv() çağrıları
fazlalıktır çünkü GL_AMBIENT, GL_DIFFUSE, ve GL_SPECULAR
parametreleri için default değerleri atamak için çağrılmışlar.
Bilgisayar Grafikleri
Renk
OpenGL üç farklı, renkle ilgili olan -
GL_AMBIENT, GL_DIFFUSE, ve
GL_SPECULAR parametrelerini
ışık kaynağına verilmesine izin verir.
GL_AMBIENT parametrsi bir ışık
kaynağının sahneye eklediği RGBA
ambient ışığının yoğunluğunu
belirler. Bu değer Örnek 6-1 de
kullanılmıştı. Eğer bu program mavi
ambient ışığını belirtmiş olsaydı
GLfloat light_ambient[] = { 0.0, 0.0,
1.0, 1.0};glLightfv(GL_LIGHT0,
GL_AMBIENT,
light_ambient);sonuç aşağıdaki
resimdeki küre gibi olurdu :
Bilgisayar Grafikleri
Renk-1
GL_DIFFUSE ,bir kaynağın sahneye eklediği diffuse ışığın RGBA rengini
belirler. Default olarak GL_DIFFUSE GL_LIGHT0 için (1.0, 1.0, 1.0, 1.0) dır ki
bu da üstteki resimde gösterildiği gibi açık parlak beyaz ışık oluşturur. Diğer
ışıklar için ise (GL_LIGHT1, ... , GL_LIGHT7) bu değer (0.0, 0.0, 0.0, 0.0)dir.
GL_SPECULAR parametresi objedeki specular parlak noktanın rengini belirler.
Tipik olark gerçek dünya objesi ,cam gibi , üzerinde parlayan ışık specular parlak
nokta olmaktadır ki bu renkde genellikle beyazdır.
Bilgisayar Grafikleri
Birden çok kaynak oluşturma
Daha önce de söylendiği gibi sahnede en az sekiz ışık olabilir (OpenGL
uyarlamalarına göre sayı değişebilir). Işık kaynaklarına başvurmak için şu
sabitler kullanılır : GL_LIGHT0, GL_LIGHT1, GL_LIGHT2, GL_LIGHT3.....
GL_LIGHT7. daha önceki paragraflarda GL_LIGHT0 ile ilgili parametreler set
edilmişti. Eğer ek ışık kaynağı istiyorsanız o ışık kaynağı için parametrelerini
belirlemeniz gerekiyor; bir de şunu aklınızdan çıkarmayınki diğer ışık
kaynaklarının default değerleri GL_LIGHT0 kinde farklıdır.
Aşağıdaki kod parçası beyaz zayıflatılmış bir projektör tanımlamaktadır:
Bilgisayar Grafikleri
Örnek
a
GLfloat light1_ambient[] = { 0.2, 0.2, 0.2, 1.0 };
GLfloat light1_diffuse[] = { 1.0, 1.0, 1.0, 1.0 };
GLfloat light1_specular[] = { 1.0, 1.0, 1.0, 1.0 };
GLfloat light1_position[] = { -2.0, 2.0, 1.0, 1.0 };
GLfloat spot_direction[] = { -1.0, -1.0, 0.0 };
glLightfv(GL_LIGHT1, GL_AMBIENT, light1_ambient);
glLightfv(GL_LIGHT1, GL_DIFFUSE, light1_diffuse);
glLightfv(GL_LIGHT1, GL_SPECULAR, light1_specular);
glLightfv(GL_LIGHT1, GL_POSITION, light1_position);
glLightf(GL_LIGHT1, GL_CONSTANT_ATTENUATION, 1.5);
glLightf(GL_LIGHT1, GL_LINEAR_ATTENUATION, 0.5);
glLightf(GL_LIGHT1, GL_QUADRATIC_ATTENUATION, 0.2);
glLightf(GL_LIGHT1, GL_SPOT_CUTOFF, 45.0);
glLightfv(GL_LIGHT0, GL_SPOT_DIRECTION, spot_direction);
glLightf(GL_LIGHT1, GL_SPOT_EXPONENT, 2.0);
glEnable(GL_LIGHT1);
Eğer bu satırlar Örnek 6-1 eklenirse küre 2 ışık ile aydınlatılmış olur , birisi
normal diğeri ise projektör .
Bilgisayar Grafikleri
Işığın konumunu ve yönünü yönetme
OpenGL ışık konumu ve yönünü normal geometrik primitiflerin konum ve yönünü
yönettiği gibi ele alır. Daha spesifik olarak açıkanacak olursa ışığın konum yada
yönünü belirlemek için glLight*() komutu çağrıldığında konum ve yön geçerli modelview matrisi tarafından transform edilerek dünya koordinatlarında kaydedilir. Bu da
ışığın konum ve yönünü model-view matris yığınının içeriğini değiştirmek suretiyel
manipule edebiliriz demektir (projeksiyon matrisinin ışık konum veya yönü üzerinde bir
etkisi yoktur.) .Bu bölüm aşağıdaki üç çeşit ışıklandırma efektini anlatmaktadır :
-Sabit kalan ışık konumu
-Yerinde duran bir obje etrafında dönen bir ışık
-Bakış noktası ile beraber hareket eden ışık
Bu basit örnekte Örnek 6-1de olduğu gibi ışık kaynağı sabit kalmaktadır. Bu efekti elde
etmek için her tür görüntüleme ve/veya modelleme transformasyonundan sonra ışığın
konumunu set etmelisiniz. Konu ile ilgili kodun myinit() ve myReshape() rutinleri
içindeki görüntüsü aşağıdaki gibi olabilir:
Bilgisayar Grafikleri
Örnek
Görüldüğü gibi ilk önce viewport ve projeksiyon matrisleri oluşturulmuştur.
Daha sonra birim matris modelview matris olarak yüklenmiştir ve ışık konumu
set edilmiştir. Birim matrisi kullanıldığı için ışık konumunun (1.0, 1.0, 1.0) olan
değeri modelview matrisi ile çarpımından etkilenmemiştir. Bu noktadan sonra ne
ışık konumu nede modelview matrisi değişikliğe uğramadığı için ışık (1.0, 1.0,
1.0) noktasına bakmaya devam etmektedir.
glViewport(0, 0, w, h);
glMatrixMode (GL_PROJECTION);
glLoadIdentity();
if (w <= h)
glOrtho (-1.5, 1.5, -1.5*h/w, 1.5*h/w, -10.0,10.0);
else
glOrtho (-1.5*w/h, 1.5*w/h, -1.5, 1.5, -10.0,10.0);
glMatrixMode (GL_MODELVIEW);
glLoadIdentity();
GLfloat light_position[] = { 1.0, 1.0, 1.0, 1.0 };
glLightfv(GL_LIGHT0, GL_POSITION, position);
Bilgisayar Grafikleri
Örnek 1
Şimdide ışığı durağan bir obje etrafında dönecek şekilde ayarlayalım . Bunu
yapmanın bir yolu ışık konumunu modelleme transformasyonundan sonra set
etmektir. Bu işi yapan kod aşağıdaki gibi olabilir:
void display(GLint spin)
{
GLfloat light_position[] = { 0.0, 0.0, 1.5, 1.0 };
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
glPushMatrix();
glTranslatef(0.0, 0.0, -5.0);
glPushMatrix();
glRotated((GLdouble) spin, 1.0, 0.0, 0.0);
glLightfv(GL_LIGHT0, GL_POSITION, light_position);
glPopMatrix();
auxSolidTorus();
glPopMatrix();
glFlush();
}
Bilgisayar Grafikleri
Işığın konumunu ve yönünü yönetme-1
display() komutu sahnenin döndürülen ışık efekti ile yeniden çizilmesini sağlar.
Bu örnekte bakış noktası sabit kaldığından geçerli matris yığında saknalarak
istenilen görüntüleme transformasyonu glTranslatef() komutu ile yüklenir.
matris yığını moelleme transformasyon glRotated() belirtilmeden önce geri
boşaltılır. Böylece ışık konumu yeni döndürülmüş koordinat sisteminde set
edilmiş olur ve ışık kaynağı dönüyormuş gibi bir efekt oluşur.
Bakış noktası ile beraber hareket eden bir ışık kaynağı oluşturmak için ışık
konumunu görüntüleme transformasyonundan önce belirtmemiz gerekmektedir.
Böylece görüntüleme transformasyonu hem ışık ve hemde bakış noktasını aynı
yönde etkilemiş olur. Bu örnek için myinit() fonksiyonunda aşağıdaki
ayarlamalar yapılmalı:
Bilgisayar Grafikleri
Işığın konumunu ve yönünü yönetme-2
a
GLfloat light_position() = { 0.0, 0.0, 1.0, 1.0 };
glViewport(0, 0, w-1, h-1);
glMatrixMode(GL_PROJEKSIYON);
glLoadIdentity();
gluPerspective(40.0, (GLfloat) w/(GLfloat) h, 1.0, 100.0);
glMatrixMode(GL_MODELVIEW);
glLightfv(GL_LIGHT0, GL_POSITION, light_position);
ve sonra sahneyi yeniden çizen display() fonksiyonu aşağıdaki
gibi olabilir :
void display(GLint spin)
{
glClear(GL_COLOR_BUFFER_MASK | GL_DEPTH_BUFFER_MASK);
glPushMatrix();
glTranslatef (0.0, 0.0, -5.0);
glRotatef ((GLfloat) spin, 1.0, 0.0, 0.0);
auxSolidTorus();
glPopMatrix();
glFlush();}
Bilgisayar Grafikleri
Örnek 6-2 : Işığı Modelleme Transformasyonları ile Hareket
Ettirme: Kod
#include <GL/gl.h>
#include <GL/glu.h>
#include "aux.h"
static int spin = 0;
void movelight (AUX_EVENTREC *event)
{ spin = (spin + 30) % 360;}
void myinit (void)
{ glEnable(GL_LIGHTING);
glEnable(GL_LIGHT0);
glDepthFunc(GL_LEQUAL);
glEnable(GL_DEPTH_TEST); }
void display(void)
{ GLfloat position[] = { 0.0, 0.0, 1.5, 1.0 };
glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
glPushMatrix ();
glTranslatef (0.0, 0.0, -5.0);
glPushMatrix ();
glRotated ((GLdouble) spin, 1.0, 0.0, 0.0);
glRotated (0.0, 1.0, 0.0, 0.0);
glLightfv (GL_LIGHT0, GL_POSITION,position);
Bilgisayar Grafikleri
Örnek 6-2 : Işığı Modelleme Transformasyonları ile Hareket
Ettirme: Kod 1
glTranslated (0.0, 0.0, 1.5);
glDisable (GL_LIGHTING);
glColor3f (0.0, 1.0, 1.0);
auxWireCube (0.1);
glEnable (GL_LIGHTING);
glPopMatrix ();
auxSolidTorus (0.275, 0.85);
glPopMatrix ();glFlush (); }
void myReshape(GLsizei w, GLsizei h)
{ glViewport(0, 0, w, h);
glMatrixMode(GL_PROJEKSIYON);
glLoadIdentity();
gluPerspective(40.0, (GLfloat) w/(GLfloat) h, 1.0, 20.0);
glMatrixMode(GL_MODELVIEW); }
int main(int argc, char** argv)
{ auxInitDisplayMode (AUX_SINGLE | AUX_RGBA | AUX_DEPTH);
auxInitPosition (0, 0, 500, 500);
auxInitWindow (argv[0]);
myinit();
auxMouseFunc (AUX_LEFTBUTTON, AUX_MOUSEDOWN, movelight);
auxReshapeFunc (myReshape);
auxMainLoop(display); }
Bilgisayar Grafikleri
4-Işıklandırma Modelini Seçme
OpenGL’in ışıklandırma modeli üç bileşene sahiptir:
•Global ambient ışık yoğunluğu
•Bakış noktası konumu sahneye lokal mi yoksa sonsuz bir uzaklıkta mi olması
gerektiği
•Objenin ön ve arka yüzleri için ışıklandırma hesaplamalarının farklı olup
olmayacağı
Bu bölüm ışıklandırma modelini nasıl belirtildiğini anlatmakatadır. Aynı
zamanda ışıklandırmayı nasıl aktifleştirme – yani OpenGL ‘ e ışıklandırma
hesaplamalarını yapmasını söyleneceğini de incelemektedir.
Bilgisayar Grafikleri
Global Ambient Işık
Daha önce de bahsedildiği gibi her ışık kaynağı
sahneye ambient ışık katabilir. Bunun yanında hiç
bir ışık kaynağına ait olmayan ambient ışık da
olabilir. Böyle bir global ambient ışığın RGBA
yoğunluğunu belirtmek için
GL_LIGHT_MODEL_AMBIENT parametresi
kullanılması :
GLfloat lmodel_ambient[] = { 0.2, 0.2, 0.2, 1.0 };
glLightModelfv(GL_LIGHT_MODEL_AMBIEN
T, lmodel_ambient);
Bu örnekte lmodel_ambient için kullanılan
değerler GL_LIGHT_MODEL_AMBIENT in
varsayılan değerleridir. Bu değerler az bir
miktarda beyaz ambient ışığın oluşmasına sebep
olur . Aşağıdaki şekil değişik global ambient ışık
miktarlarını göstermektedir :
Bilgisayar Grafikleri
Local veya Sonsuz Bakış Noktası
Bakış noktasının konumu specular yansımanın oluşturduğu yansıma noktalarının
hesaplamalarını etkiler. Daha spesifik olacak olursak herhangi bir vertex
üzerindeki parlak noktaların yoğunluğu vertexlerin normalleri, vertexten ışık
kaynağına olan yön ve vertexten bakış noktasına olan yön faktörlerine bağlıdır.
Sonsuz bakış noktasında bakış noktası ve sahnedeki herhangi bir vertex
arasındaki yön sabittir. Local bakış noktası ise daha realistik sonuçlar verir ama
her vertex için yönlerin hesaplaması genel verimi düşürür . Default olarak sonsuz
bakış noktası alınmaktadır. Aşağıdaki kod lokal bakış noktasının nasıl
değiştirileceğini göstermektedir :
glLightModel(GL_LIGHT_MODEL_LOCAL_VIEWER, GL_TRUE);
bu fonksiyon bakış noktasını göz koordinatlatında (0, 0, 0) noktasına yerleştirir.
Sonsuz bakış noktasına geri dönmek için argüman olarak GL_FALSE
verilmelidir .
Bilgisayar Grafikleri
Iki Taraflı Işıklandırma
Işıklandırma hesaplamaları ön-bakışlı veya arka-bakışlı olsun bütün çokgenler için yapılır.
Genel olarak kafada ışıklandırma koşullarını ön-bakışlı çokgenler için belirlediğimiz için
arka-bakışlı çokgenlerin ışıklandırılması iyi yapılamaz ve doğru aydınlatılamazlar. Örnek 6-1
deki kürelerde sadece önyüzler görüldüğü için arka yüzlerinin ne olduğu önemli değildir ,
çünkü hiç bir zaman görüntülenmeyecekleridir.
Ama eğer küreler kesik olsaydı ve iç kısmı görünür olsaydı , belki de kürenin iç kısmının
belirttiğiniz ışıklandırma koşulları çerçevesinde tamamen aydınlatılmasını isteyebilirdiniz;
veya kürenin arka yüzleri için farklı bir madde özellikleri tanımlamak isteyebilirdirniz. Şimdi
bakalım bunların hepsi nasıl yapılır . İki –taraflı ışıklandırmayı aşağıdaki gibi aktif
yaptığımızda : glLightModel(LIGHT_MODEL_TWO_SIDE, GL_TRUE);
OpenGL yüzey normallerini arka-yüz çokgenleri için ters çevirir; tipik olarak bu görünen
arka yüzün yüzey normalleri ile ön-yüzün çokgenleri görüntülüleyiciye bakmaktadır
anlamına gelir. Sonuç. Olarak da bütün çokgenler doğru olarak aydınlatılır.
İki yönlü ışıklandırmayı pasif yapmak için yukarıdaki fonksiyona GL_FALSE argümanını
vermek gerekir. Hangi yüzün OpenGL tarafından ön yüz olarak algılanacağını glFrontFace()
komutu ile belirleyebilirsiniz.
Bilgisayar Grafikleri
Işıklandırmayı Aktifleştirme
OpenGL de ışıklandırma ya aktif halde yada pasif haldedir. Eğer ışıklandırma
aktif değilse , geçerli vertexe geçerli renk map edilir ve normal hesaplamaları,
ışık kaynaları , ışıklandırma modeli ve madde özellikleri işlem görmez.
Işıklandırmayı aktifleştirmek için :
glEnable(GL_LIGHTING); Işıkklandırmayı pasifleştirme için ise glDisable()
GL_LIGHTING argümanı ile çağırılır.
Tamımladığınız ışık kaynaklarını tek tek aktif hale getirmelisiniz. Örnek 6-1
sadece tek ışık kaynağı kullanmaktadır, GL_LIGHT0:
glEnable(GL_LIGHT0);
Bilgisayar Grafikleri
5-Madde Özelliklerini Belirleme
Belli özelliklere sahip ışık kaynakları oluşturmayı ve istenilen ışıklandırma modelini
seçmeyi öğrendiniz. Bu bölüm sahnedeki objelerin madde özelliklerinin belirlenmesini
anlatmaktadır : ambient, diffuse ve specular renkler, parlaklık ve yayılan herhangi bir ışığın
rengi. Çoğu madde özellikleriare konseptüel olarak şimdiye kadar ışık kaynakları
oluştururken kullandıklarımız ile benzer niteliktedirler.Bu özellikleri set etme mekanizması
da benzerdir. Özellikleri set etmek için glMaterial*() fonksiyonu kullanılır.
void glMaterial{if}[v](GLenum face, GLenum pname, TYPE param) : Işıklandırma
hesaplamalarında kullanılaca geçerli madde özelliklerini tanımlar. face parametresi
GL_FRONT, GL_BACK veya GL_FRONT_AND_BACK olabilir ve maddenin objenin
hangi yüzüne uygulanacığını belirler. Set edilecek herhangi bir madde özelliği pname ile
belirlenir ve özellik için istenilne değerler param ile verilir ki burada pram bir pointer
(vektör versiyonu kullanılıyorsa) veya normal değer (vektör olmayan versiyon
kullanılıyorsa ) olabilir. Vektör olmayan versiyonu sadece GL_SHININESS özelliğini set
etmek için kullanılır. pname için olabilecek değerler Tablo 6-2 de ki gibidir.
GL_AMBIENT_AND_DIFFUSE , hem ambient ve hem de diffuse madde renklerini aynı
anda aynı RGBA değerine uygulanmasını sağlar
Bilgisayar Grafikleri
Table 6-2 : glMaterial*() Parametresi pname için varsayılan
değerler
Table 6-2 : glMaterial*() Parametresi pname için default değerler
Parametre İsmi Default Değeri Anlamı
GL_AMBIENT (0.2, 0.2, 0.2, 1.0) Maddenin ambient rengi
GL_DIFFUSE (0.8, 0.8, 0.8, 1.0) Maddenin diffuse rengi
GL_AMBIENT_AND_DIFFUSE Maddenin ambient ve diffuse rengi
GL_SPECULAR (0.0, 0.0, 0.0, 1.0) Maddenin specular rengi
GL_SHININESS 0.0 specular üssü
GL_EMISSION (0.0, 0.0, 0.0, 1.0) Maddenin emissive(yayılımsal) rengi
GL_COLOR_INDEXES (0,1,1) ambient, diffuse ve specular renk
indisleri
Bilgisayar Grafikleri
Madde Özelliklerini Belirleme-1
Yandaki resimde değişik iç ve
dış madde özellikleri ile
çizilmiş şekilleri
görebilirsiniz:
Bilgisayar Grafikleri
Madde Özelliklerini Belirleme-2
Aşağıdaki şekilde birkaç
değişik madde özellikleri
ile çizilmiş aynı objeyi
göstermektedir. Bütün
şekiller için aynı ışık
kaynağı ve ışıklandırma
modeli kullanılmıştır.
Bundan sonraki bölümler
bu resimde yer alan
kürelerin nasıl çizildiklerini
anlatmaktadır. not :
glMaterial*() ile
kullanılan madde
özelliklerinin çoğu (R, G,
B, A) renkleridir.
Bilgisayar Grafikleri
Diffuse ve Ambient Yansıma
glMaterial*() ile set edilmiş GL_DIFFUSE ve GL_AMBIENT parametreleri
obje tarafında yansıtılan diffuse ve ambient ışık rengini etkiler. Diffuse yansıma
,objenin renginin ne olarak algılanacağında büyük rol oynar. Bakış noktasının
konumu diffuse yansımayı hiç bir şekilde etkilemez.
Ambient yansıma ise objenin genel rengini etkler. Diffuse yansıma ,obje direkt
bir aydınlatma ile aydınlatılıyorsa en parlak ve en çok hissediliebilirdir, ambient
yansıma ise en fazla obje direk aydınlatmaya maruz kalmadığında
hissedilebilrdir. Objenin toplam ambient yansımasını global ambient ışık ve özel
ışık kaynaklarından gelen ambient ışık belirler . Diffuse yansımada olduğu gibi
bakış noktasının konumu ambient yansımayı hiç bir şekilde etkilemez.
gerçek-dünya objeleri için diffuse ve ambient yansıma normal olarak aynı
renktedir. Bu nedenle OpenGL her ikisine de aynı değeri atamak için standart bir
yol olarak glMaterial*() fonksiyonunu sunar:
Bilgisayar Grafikleri
Diffuse ve Ambient Yansıma-1
GLfloat mat_amb_diff[] = { 0.1, 0.5, 0.8, 1.0 };
glMaterialfv(GL_FRONT_AND_BACK,
GL_AMBIENT_AND_DIFFUSE , mat_amb_diff);
Bu örnekte , RGBA rengi olan (0.1, 0.5, 0.8, 1.0) – derin bir mavi renktir ve
geçerli ambient ve diffuse yansıma olarak ön-yüz ve arka-yüz çokgenlere
uygulanmıştır.
Üstteki şekilde ilk satırdaki kürelerde ambient yansıma yoktur (0.0, 0.0, 0.0, 0.0)
, ikinci satırdaki kürelerde ise çok fazla vardır (0.7, 0.7, 0.7, 1.0).
Bilgisayar Grafikleri
Specular Yansıma
Objeden olan specular yansıma ,aydınlatılmış noktalar oluşturur. Ambient ve
diffuse yansımadan farklı olarak, görünen specular yansıma miktarı bakış
noktasının konumuna bağlıdır . Bunu anlayabilmek için dışarıda güneş ışığı
altında bir metalik küreye baktığınızı düşünün. Kafanızı hareket ettirdikçe güneş
ışığının oluşturduğu aydınlatılmış noktaların sizinle birlikte harket ettiklerini
göreceksiniz. Kafanızı çok fazla hareket ettirir(döndürür)iseniz, aydınlatılmış
noktaları tamamen kaybeder,kürenin karanlık tarafına bakmakta olursunuz.
OpenGL , aydınlatılmış noktaların specular yansımanın RGBA
rengini(GL_SPECULAR ile) belirleme, aydınlatılmış noktaların büyüklüğü ve
parlaklıklarını (GL_SHININESS ile) ayarlamınızı sağlar. GL_SHININESS [0.0,
128.0] aralığına değerler alabilir; değer ne kadar büyük olursa, aydınlatılmış
noktalar da o kadar küçük ve parlak olurlar.
Bilgisayar Grafikleri
Specular Yansıma-1
Küreler şeklinde , ilk satırdaki kürelerde specular yansıma yoktur. İkinci satırda
ise, GL_SPECULAR ve GL_SHININESS aşağıdaki değerleri almaktadırlar:
GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };
GLfloat low_shininess[] = { 5.0 };
glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
glMaterialfv(GL_FRONT, GL_SHININESS, low_shininess);
üçüncü satırda ise GL_SHININESS parametreler 100.0 yapılmıştır..
Bilgisayar Grafikleri
Madde özelliklerini değiştirme
Örnek 6-1 da tek obje olan kürenin tüm vertisleri için aynı madde özellikleri kullanılmıştır.
Başka bir durumda aynı objenin farklı vertislerine farklı madde özellikleri vermek
isteyebilirsiniz. Örneğin yukarıdaki küreler resmini sonuç veren kod 8 ayrı küre çizmek
zorundadır ve her kürenin madde özellikleri farklıdır. Örnek 6-3 bu kodun display()
rutininin bir parçasını göstermektedir. Örnek 6-3 : Farklı madde özellikleri kullanma:
material.c
GLfloat no_mat[] = { 0.0, 0.0, 0.0, 1.0 };
GLfloat mat_ambient[] = { 0.7, 0.7, 0.7, 1.0 };
GLfloat mat_ambient_color[] = { 0.8, 0.8, 0.2, 1.0 };
GLfloat mat_diffuse[] = { 0.1, 0.5, 0.8, 1.0 };
GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };
GLfloat no_shininess[] = { 0.0 };
GLfloat low_shininess[] = { 5.0 };
GLfloat high_shininess[] = { 100.0 };
GLfloat mat_emission[] = {0.3, 0.2, 0.2, 0.0};
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
/* ilk satır ve ilk sütundeki küreyi çiz * sadece diffuse
yansıma , ambient veya specular yok */
Bilgisayar Grafikleri
Örnek 6.3-Kod
glPushMatrix();
glTranslatef (-3.75, 3.0, 0.0);
glMaterialfv(GL_FRONT, GL_AMBIENT, no_mat);
glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
glMaterialfv(GL_FRONT, GL_SPECULAR, no_mat);
glMaterialfv(GL_FRONT, GL_SHININESS, no_shininess);
glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);
auxSolidSphere();
glPopMatrix();
/* ilk satır ,2.sütundaki küreyi çiz
* diffuse ve specular yansıma; düşük parlaklık, ambient yok
*/
glPushMatrix();
glTranslatef (-1.25, 3.0, 0.0);
glMaterialfv(GL_FRONT, GL_AMBIENT, no_mat);
glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
glMaterialfv(GL_FRONT, GL_SHININESS, low_shininess);
glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);
auxSolidSphere();
glPopMatrix();
Bilgisayar Grafikleri
Örnek 6.3-Kod 1
glPushMatrix();
glTranslatef (1.25, 3.0, 0.0);
glMaterialfv(GL_FRONT, GL_AMBIENT, no_mat);
glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
glMaterialfv(GL_FRONT, GL_SHININESS, high_shininess);
glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);
auxSolidSphere();
glPopMatrix();
/* ilk satır,4 sütundeki küreyi çiz
* diffuse yansıma, yayılma, ambient yok, specular yansıma
yok */
glPushMatrix();
glTranslatef (3.75, 3.0, 0.0);
glMaterialfv(GL_FRONT, GL_AMBIENT, no_mat);
glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
glMaterialfv(GL_FRONT, GL_SPECULAR, no_mat);
glMaterialfv(GL_FRONT, GL_SHININESS, no_shininess);
glMaterialfv(GL_FRONT, GL_EMISSION, mat_emission);
auxSolidSphere();
glPopMatrix();
Bilgisayar Grafikleri
Madde özelliklerini değiştirme-1
görüldüğü gibi glMaterialfv() fonksiyonu istenilen madde özelliklerini set
etmek için tekrar tekrar çağırılmıştır. Bu fonksiyon sadece değişmesi gereken
özellikleri değiştirerek performans sağlar. 1,2 ve 3. küreler aynı ambient
özelliğini kullandıkları için her defasında resetleme olmaz,bu da performans
kazandırır.
maddde özelliklerini değiştirirken performans düşüşünü önlemenin diğer bir yolu
glColorMaterial() fonksiyonunu kullanmak.
void glColorMaterial(GLenum face, GLenum mode);
mode parametresi madde özelliğini belirtitken face de maddenin yüzünü belirtir.
Geçerli renkte yapılan bir değişiklik( glColor*() ile) verilen madde özelliklerine
hemen yansıtılır. face parametresi GL_FRONT, GL_BACK, veya
GL_FRONT_AND_BACK ( default) olabilir. mode parametresi ise
GL_AMBIENT, GL_DIFFUSE, GL_AMBIENT_AND_DIFFUSE (default),
GL_SPECULAR veya GL_EMISSION olabilir.
Bilgisayar Grafikleri
Madde özelliklerini değiştirme-2
glColorMaterial() iki bağımsız değer tanımlar : ilki hangi yüz veya yüzlerin
yenileneceğini belirtir, ikincisi ise o yüzlerin hangi özelliği veya özelliklerinin
yenileneceğini belirtir.
glColorMaterial() fonksiyonunu çağırdıktan sonra l glEnable() fonksiyonu
GL_COLOR_MATERIAL parametresiyle çağırılması gerekir. Bundan sonra da
geçerli rengi glColor*() kullanarak değiştirebilirsiniz :
glColorMaterial(GL_FRONT, GL_DIFFUSE);
glEnable(GL_COLOR_MATERIAL);
glColor3f(0.2, 0.5, 0.8);/* buraya birşeyler çiz
*/glColor3f(0.9, 0.0, 0.2);/* buraya da birşeyler çiz */
glDisable(GL_COLOR_MATERIAL);
Örnek 6-5 glColorMaterial() fonksiyonunu madde parametrelerini değiştirmek için
kullanan interaktif bir programı göstermektedir. Farenin her üç tuşundan harbirine
basılması diffuse yansıma rengini değiştirmektedir.
Bilgisayar Grafikleri
Örnek 6-4 : Işıklandırma Demo programı (delphi)
Örnek 6-4 : Işıklandırma
Demo programı : Bir küre
etrafında dönen kuyruklu
yıldır. Küre normalde
aydınlatılmamıştır, kuyruklu
yıldızda hareket halindeki
bir ışık kaynağıdır. Bu yıldız
,küre etrafında dönerken
kürenin kendi gördüğü
yüzünü
aydınlatmaktadır.Program
kodu için buraya basınız
Bilgisayar Grafikleri
Örnek 6-5 : glColorMaterial() fonksiyonunu kullanımı-Kod
#include <GL/gl.h>
#include <GL/glu.h>
#include "aux.h"
GLfloat diffuseMaterial[4] = { 0.5, 0.5, 0.5, 1.0 };
void myinit(void)
{
GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };
GLfloat ışık_position[] = { 1.0, 1.0, 1.0, 0.0 };
glMaterialfv(GL_FRONT, GL_DIFFUSE, diffuseMaterial);
glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
glMaterialf(GL_FRONT, GL_SHININESS, 25.0);
glIşıkfv(GL_IŞIK0, GL_POSITION, ışık_position);
glEnable(GL_IŞIKING);
glEnable(GL_IŞIK0);
glDepthFunc(GL_LEQUAL);
glEnable(GL_DEPTH_TEST);
glColorMaterial(GL_FRONT, GL_DIFFUSE);
glEnable(GL_COLOR_MATERIAL);
}
Bilgisayar Grafikleri
Örnek 6-5 : glColorMaterial() fonksiyonunu kullanımı-Kod 1
void changeRedDiffuse (AUX_EVENTREC *event)
{
diffuseMaterial[0] += 0.1;
if (diffuseMaterial[0] > 1.0)
diffuseMaterial[0] = 0.0;
glColor4fv(diffuseMaterial);
}
void changeGreenDiffuse (AUX_EVENTREC *event)
{
diffuseMaterial[1] += 0.1;
if (diffuseMaterial[1] > 1.0)
diffuseMaterial[1] = 0.0;
glColor4fv(diffuseMaterial);
}
void changeBlueDiffuse (AUX_EVENTREC *event)
{
diffuseMaterial[2] += 0.1;
if (diffuseMaterial[2] > 1.0)
diffuseMaterial[2] = 0.0;
glColor4fv(diffuseMaterial);
}
Bilgisayar Grafikleri
Örnek 6-5 : glColorMaterial() fonksiyonunu kullanımı-Kod 2
void display(void)
{
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
auxSolidSphere(1.0);
glFlush();
}
void myReshape(GLsizei w, GLsizei h)
{
glViewport(0, 0, w, h);
glMatrixMode(GL_PROJEKSIYON);
glLoadIdentity();
if (w <= h)
glOrtho (-1.5, 1.5, -1.5*(GLfloat)h/(GLfloat)w,
1.5*(GLfloat)h/(GLfloat)w, -10.0, 10.0);
else
glOrtho (-1.5*(GLfloat)w/(GLfloat)h,
1.5*(GLfloat)w/(GLfloat)h, -1.5, 1.5, -10.0,
10.0);
glMatrixMode(GL_MODELVIEW);
glLoadIdentity();
}
Bilgisayar Grafikleri
Örnek 6-5 : glColorMaterial() fonksiyonunu kullanımı-Kod 3
int main(int argc, char** argv)
{
auxInitDisplayMode (AUX_SINGLE | AUX_RGBA | AUX_DEPTH);
auxInitPosition (0, 0, 500, 500);
auxInitWindow (argv[0]);
myinit();
auxMouseFunc(AUX_LEFTBUTTON, AUX_MOUSEDOWN,
changeRedDiffuse);
auxMouseFunc(AUX_MIDDLEBUTTON, AUX_MOUSEDOWN,
changeGreenDiffuse);
auxMouseFunc(AUX_RIGHTBUTTON, AUX_MOUSEDOWN,
changeBlueDiffuse);
auxReshapeFunc(myReshape);
auxMainLoop(display);
}
Bilgisayar Grafikleri
Bilgisayar Grafikleri
Bölüm 7
Bilgisayar Grafikleri
Display Listeleri (Display Listst)
Bu bölümde göreceklerimiz :
1-Display Listesi Kullanım Örneği
2-Display Listeleri -Dizayn Felsefesi
3-Display Listeler Oluşturma Ve Çalıştırma
4-Display Listselerini Kendi İndislerinde Yönetme
Bilgisayar Grafikleri
Giriş
Display listeleri daha sonra çalıştırılmak üzere oluşturlulmuş OpenGL komutları
grubudur. Display listesi çağırıldığında, liste içinde bulunan komutlar
tanımlandıkları sıraya göre çalışmaya başlarlar. Çoğu OpenGL komutları display
listelerinde saklanabilir veya imediate modunda tanımlanabilir(bu modda
tanımlanan komutlar hemen çalıştırılır). Bir programcı olarak immediate-mode
ile display listelerini bir programda karıştırarak kullanmada özgürsünüz.
Şimdiye kadar gördüğünüz program örneklerinin hepsi immediate modunu
kullanmaktadır(bölüm 4 teki Editor programı hariç). Bu bölüm display
listelerinin ne olduğunu ve nerelerde kullanılması gerektiğini ele almaktadır.
Bilgisayar Grafikleri
1- Display Listesi Kullanım Örneği
Display listeleri , OpenGL komutlar kümesinin isimlendirme ve organize etmenin
standart yoludur. Örneğin farzedelim ki 100 adet çizgi segmentini kullanarak bir
daire çizmek istiyoruz. Display listsesi kullanmadan bu kod immediate-modda
aşağıdaki gibi olabilir :
drawCircle()
{
GLint i;
GLfloat cosine, sine;
glBegin(GL_POLYGON);
for(i=0;i<100;i++){
cosine=cos(i*2*PI/100.0);
sine=sin(i*2*PI/100.0);
glVertex2f(cosine,sine);
}
glEnd();
}
Bilgisayar Grafikleri
Display Listesi Kullanım Örneği-1
Bu metod çok verimsizdir çünkü dairenin her renderlenmesinde trigonometrik
hesaplamaların yapılması gerekmektedir. Bunun yerine koordinatları bir tabloya kaydederek
gerektiğinde bu koordinatları tablodan okumak daha verimlidir :
drawCircle()
{ GLint i;
GLfloat cosine, sine;
static GLfloat circoords[100][2];
static GLint inited=0;
if(inited==0){
inited=1;
for(i=0;i<100;i++){
circcoords[i][0]=cos(i*2*PI/100.0);
circcoords[i][1]=sin(i*2*PI/100.0);
}
}
glBegin(GL_POLYGON);
for(i=0;i<100;i++)
glVertex2fv(&circcoords[i][0]);
glEnd();
}
Bilgisayar Grafikleri
Örnek 7-1 : Display Listesi oluşturma
Burada bile iyileştirilmiş metotta bile i değişkeninin test edilmesi ve arttırılmasından
kaybediyoruz. Asıl yapılması gereken şey daireyi bir kere çizip OpenGL’in o daireyi nasıl
çizdiğini hatırlamasını sağlamak. Bu tam olarak display listelerinin amacıdır.
#define MY_CIRCLE_LIST 1
buildCircle()
{
GLint i;
GLfloat cosine, sine;
glNewList(MY_CIRCLE_LIST, GL_COMPILE);
glBegin(GL_POLYGON);
for(i=0;i<100;i++){
cosine=cos(i*2*PI/100.0);
sine=sin(i*2*PI/100.0);
glVertex2f(cosine,sine);
}
glEnd();
glEndList();
}
Bilgisayar Grafikleri
Örnek 7-1 : Display Listesi oluşturma-1
daire çizme kodu glNewList() ve glEndList() ikilisi arasında olmalıdır. Bu bir
display listesi tanımlamaktadır. glNewList() fonksiyonunun MY_CIRCLE_LIST
argümanı display listesini tanımlayan tamsayı indeksidir. Display listesini daha
sonralarda glCallList() komutu ile çağırabilirsiniz:
glCallList(MY_CIRCLE_LIST);
Display listesi sadece OpenGL çağrılarından oluşur. Örnek 7-1 deki cos() ve sin()
C fonksiyonları display listelerinde tutulmazlar. Bunun yerine koordinatlar ve
diğer değişkenlerin (dizi içerikleri gibi) display listesinin derlendiği andaki
değerleri dispalay listesinde tutulurlar. Böyle bir liste oluşturulup derlendikten
sonra değerler değiştirilemez. Mevcut bir listeyi silebilir veya yeni bir liste
tanımlayabilirsiniz ama varolan listeyi değiştiremezsiniz.
Bilgisayar Grafikleri
2- Display Listeleri -Dizayn Felsefesi
OpenGL display listeleri performansın yükseltilmesi için tasarlanmışlardır.
Performansın optimize edilmesi için OpenGL display listeleri dinamik bir
veritabanı olarak değil, daha ziyade bir keş bellek olarak kullanılmaktadır. Başka
bir deyişle , bir kere tanımlanan display listesi bir daha değişikliğe uğratılamaz.
Eğer display listeleri değiştirilebilir olsaydı, veritabanında arama ve bellek
yönetiminin gerekeceğinden performans düşecekti. Display listeleri kullanma en
kötü ihtimalle immediate modda en hızlı çalışmaya eşdeğerdir. Display listeleri
OpenGL rutinlerinin ağ ortamında kullanılmasında performansı arttırırlar,çünkü
display listeleri serverde kalır ve ağ trafiğini düşürürler.
Lokal olarak ise (lokal bilgisayarda) display listelerinin verimi çok çok daha fazla
olabilir çünkü listeler grafik donanımı ile en uyumlu şekle getirilerek saklanırlar.
Örneğin en basitinden glRotate*() komutu eğer display listesinde saklanırsa ,
çok önemli ölçüde verimi arttırabilir çünkü döndürme matrisini oluşturmak için
gereken hesaplamalar basit bir şey değildir (trigonometrik fonksiyon ve
karekökler içerirler).
Bilgisayar Grafikleri
Display Listeleri -Dizayn Felsefesi-1
Display listelerinde ise sadece en son döndürme matrisinin saklanması yeterlidir. Küçük
listeler oluşturulduğunda bazen listeye referans verme, standart programlama yoluyla aynı
işlemi yapan koddan farklı olmayabilir. Bunun için en çok optimizasyon sağladığı bazı
alanlar aşağıda verilmiştir :
Matris işlemleri: çoğu matris işlemleri OpenGL den invers(matrisin tersi) hesabı talebinde
bulunurlar. Hesaplanan matris ve bu matrisin tersi display listeşlerinde saklanabilirler.
Raster bitmaplar ve resimler : Raster verinin sunulduğu şekil grafik donanımı için çok da
ideal sayılmaz.. Display listesi derlendiğinde , OpenGL bu veriyi donanımının sevdiği
şekle dönüştürerek saklayabilir.
Işıklar, madde özellikleri ve ışıklandırma modelleri : Çok kompleks ışıklandırma
şartlarına sahip bir sahne çizerken sahnedeki her obje için farklı bir madde ve madde
özelliği kullanmış olabilirsiniz. Maddeleri belirlemek yavaştır çünkü çok karmaşık
hesaplamalar gerektirmektedir. Eğer madde tanımlamalarını display listelerine koyarsak ,
her maddeler arası geçişte bu hesaplamalara gerek kalmayabilir çünkü sadece
hesaplamaların sonuçları saklanmış olacaktır. Dolayısıyla aydınlatılmış sahnelerin
renderlenmesi daha hızlı yapılmış olacaktır.
Bilgisayar Grafikleri
Display Listeleri -Dizayn Felsefesi-2
Texture’ler(yüzey kaplamaları) : texture’ları tanımlarken onları display
listelerinde tanımlayarak verimi maksimize edebiliriz. Çünkü donanım texture
formatı ile OpenGL texture formatı farklıdır ve görüntülemede bir dönüşümün
yapılması gerekmektedir. Dönüştürülmüş texture’lar listelerde saklanarak verim
arttırılabilir.
Display listelerinin bazı desavantjları da vardır. Örneğin örnek 7-1 deki
buildCircle() fonksiyonu en az 200 floating-point sayıyı tutacak bir hafıza
gerektirir ,diğer tarafta ise immediate modda yazılmış drawCircle() rutininin
obje kodu büyük ihtimalle o gereken hafızadan çok çok daha küçük olabilir.
Display listelerinin bir diğer desavantajı da içeriklerinin değiştirilememesidir.
Performansı optimize etmek için OpenGL display listeleri değiştirilemez ve
içeriği okunamaz .
Bilgisayar Grafikleri
3- Display Listeler Oluşturma
Gaha önce gördüğünüz gibi glNewList() ve glEndList() fonksiyonları display
listesinin tanımını başını ve sonunu belirlerler. Daha sonra bu listeler
glCallList() komutuna gerekli index değerini vererek çağırılırlar. Örnek 7-2 de
display listesi makeList() rutininde oluşturulmuştur. Buradaki display listesi
kırmızı bir üçgen çizecek OpenGL komutlarını içermektedir. Daha sonra
display() rutininde bu display listesi on kere çalıştırılmaktadır. Buna ek olarak
immediate modda bir çizgi çizilmektedir.
Bilgisayar Grafikleri
Örnek 7-2 : Display Liste Kullanımı -Kod
#include <GL/gl.h>
#include <GL/glu.h>
#include "aux.h"
GLuint listName = 1;
void myinit (void)
{glNewList (listName, GL_COMPILE);
glColor3f(1.0, 0.0, 0.0);
glBegin (GL_TRIANGLES);
glVertex2f (0.0, 0.0);
glVertex2f (1.0, 0.0);
glVertex2f (0.0, 1.0);
glEnd ();
glTranslatef (1.5, 0.0, 0.0);
glEndList ();
glShadeModel (GL_FLAT); }
void drawLine (void)
{ glBegin (GL_LINES);
glVertex2f (0.0, 0.5);
glVertex2f (15.0, 0.5);
glEnd ();
}
Bilgisayar Grafikleri
Örnek 7-2 : Display Liste Kullanımı –Kod 1
void display(void)
{
GLuint i;
glClear (GL_COLOR_BUFFER_BIT);
glColor3f(0.0, 1.0, 0.0);
for (i = 0; i < 10; i++)
glCallList (listName);
drawLine ();
glFlush ();
}
void myReshape(GLsizei w, GLsizei h)
{
glViewport(0, 0, w, h);
glMatrixMode(GL_PROJECTION);
glLoadIdentity();
if (w <= h)
gluOrtho2D (0.0, 2.0, -0.5 * (GLfloat) h/(GLfloat) w,
1.5 * (GLfloat) h/(GLfloat) w);
else
gluOrtho2D (0.0, 2.0 * (GLfloat) w/(GLfloat) h, -0.5,
1.5);
Bilgisayar Grafikleri
Örnek 7-2 : Display Liste Kullanımı –Kod 2
glMatrixMode(GL_MODELVIEW);
glLoadIdentity();
}
int main(int argc, char** argv)
{
auxInitDisplayMode (AUX_SINGLE | AUX_RGBA);
auxInitPosition (0, 0, 400, 50);
auxInitWindow (argv[0]);
myinit ();
auxReshapeFunc (myReshape);
auxMainLoop(display);
}
Display list içinde bulunan glTranslatef() rutini bir sonraki çizilecek objenin konumunu
değiştirmektedir. Eğer bu komutu çağırmazsak display listesinin iki kere çağırılması şekli
değiştirmez, yeni üçgen eskisi üzerinden aynen çizilir. İmmediat modda çağırılan
drawLine() rutini de kendinden önce gelen glTranslatef() çağrısından etkilenir. Eğer
display listesine transformasyon komutlarını dahil ediyorsanız , bu komutların daha sonraki
etkilerini dikkate almayı unutmayın.
Bilgisayar Grafikleri
Display Listeler Oluşturma -1
Her glNewList() komutunu bir glEndList() takip etmelidir ve eğer yeni bir
liste gerekiyorsa bu komuttan sonra tanımlanmalıdır. glEndList() komutunu
listeyi başlatmadan önce çağırmak GL_INVALID_OPERATION hatasını
oluşturur.
void glNewList (GLuint list, GLenum mode);
Display listenin başlangıcını belirtir. Bundan sonra gelen OpenGL rutinleri (l
glEndList() komutundan önce olanlar) display listesinde saklanır(bazı özel
OpenGL rutinleri hariç. Bu özel rutinler liste oluşturulmasında çalışan
rutinlerdir.) list parametresi oluşturulacak listeyi belirler. mode parametresinin
alabilieceği değerleri ise GL_COMPILE ve GL_COMPILE_AND_EXECUTE
dir. Listede takib eden komutların listeye yerleştirildikleri şekilde çalışmalarını
istemiyorsanız GL_COMPILE parmetresini kullanın; diğer durumlarda ise
GL_COMPILE_AND_EXECUTE kullanılır.
void glEndList (void) :display listin sonunu gösterir.
Bilgisayar Grafikleri
Display Listelerde Ne Tutulur?
Display listesini kurarken başlangıçta sadece kullanılan ifadelerin değerleri
listede yer alır. Örneğin bir dizideki değerler daha sonra değişiyorsa , display-list
değerleri değişmez. Aşağıdaki kod parçasında , display list, geçerli rengi siyah
(0.0, 0.0, 0.0)yapan bir komut içermektedir. Daha sonra color_vector’ün
değerinin kırmızı (1.0, 0.0, 0.0) olarak değişmesi display listesini etkilemez
çünkü liste sadece ilk oluşturma zamanındaki değerleri içerir.
GLfloat color_vector[3]={0.0,0.0,0.0};
glNewList(1,GL_COMPILE);
glColor3fv(color_vector);
glEndList();
color_vector[0]=1.0;
Bilgisayar Grafikleri
Display Listelerde Ne Tutulur? -1
Genel olarak referans olarak parametre geçenler ve değer döndüren fonksiyonlar
listede tutulamazlar çünkü liste ,değişkenlerin tanımlandıkları sınırların
dışarısında çağırılmış olabilir. Eğer liste oluştururken böye komutlar çağırılmış
ise bu komutlar immediate modda çalıştırılırlar ve listeye dahil edilmezler.
Aşağıda display listelerinde saklanamayan opengl komutları verilmiştir. Bu
komutların bazılarını daha görmedik ,komut açıklamaları için OpenGL
referansına bakınız :
glDeleteLists() glIsEnabled()
glFeedbackBuffer() glIsList()
glFinish() glPixelStore()
glFlush() glReadPixels()
glGenLists() glRenderMode()
glGet*() glSelectBuffer()
Bilgisayar Grafikleri
Display Listelerini Çalıştırma
display listesini oluşturduktan sonra glCallList() komutu ile listeyi
çalıştırabilirsiniz. Doğal olarak display listesini döngüye sokablir,immediate mod
çağrıları ile karıştırarak kullanabilirsiniz.
void glCallList (GLuint list);
list parametresi ile belirlenen dispalay listesini çalıştırır. Listedeki komutlar, nasıl
kaydedildiyseler aynı şakilde (aynı sırada) çalıştırılırlar eğer liste tanımlı değil ise
hiç bir şey olmuyor.
Display listesi, OpenGL durum değişkenlerini değiştiren çağrılar da
içerebildiğinden liste çalışırken bu değişkenler de değişir. OpenGL durum
değişkenlerinde yapılan değişiklikler , liste çalışmayı tamamladıysa bile aynen
kalır. Örnek 7-2 de, listenin çalışma esnasında geçerli renk ve geçerli matris
değişkenlerinde yapılan değişiklikler liste çalışmayı bitirdikten sonra bile Örnek
7-3’te gösterildiği gibi etkilerini sürdürürler:
Bilgisayar Grafikleri
Örnek 7-3 : Display Listenin Çalışmayı Bitirdikten Sonra Durum
Değişkenlerinin Etkileri Örneği
Bazen bu değişikliklerin kalması istenir ama bazende listeyi çalıştırmadan önceki
durum daha sonra yeniden geri getirilmek üzere kayd edilmek istenir. Bunun için
glPushAttrib() komutunu bir grup durum değişkenlerini kaydetmek için ve
glPopAttrib() komutunu kaydedilen değişkenlerin geri yüklenmesi için
kullanabilirisiniz. Geçerli matrisi kaydetmek ve geri yüklemek için daha önce de
söylendiği gibi glPushMatrix() ve glPopMatrix() komutları kullanılır.Örnek 7-
3 te durum değişkenleri kaydedilmek istendiği takdirde aşağıdaki kod
kullanılabilir :
glNewList(listIndex,GL_COMPILE);
glColor3f(1.0, 0.0, 0.0);
glBegin(GL_POLYGON);
glVertex2f(0.0,0.0);
glVertex2f(1.0,0.0);
glVertex2f(0.0,1.0);
glEnd();
glTranslatef(1.5,0.0,0.0);
glEndList();
Bilgisayar Grafikleri
Örnek 7-4 : Display Listesinde Durum değişkenlerini geri yükleme
glNewList(listIndex,GL_COMPILE);
glPushMatrix();
glPushAttrib(GL_CURRENT_BIT);
glColor3f(1.0, 0.0, 0.0);
glBegin(GL_POLYGON);
glVertex2f(0.0,0.0);
glVertex2f(1.0,0.0);
glVertex2f(0.0,1.0);
glEnd();
glTranslatef(1.5,0.0,0.0);
glPopAttrib();
glPopMatrix();
glEndList();
Bilgisayar Grafikleri
Hiyerarşik Display Listeler
glNewList() ve glEndList() çifti arasında glCallList()glCallList() çağrısı
yaparak liste içinden çalıştırılan listeler , başka bir deyişle hiyerarşik display
listeler oluşturabilirsiniz. Hiyerarşik display listeler, bileşenlerden oluşan objeler
kullanılırken ve özellikle bazı bileşenlerin birden fazla kez kullanılması gerektiği
durumlarda çok yararlıdırar. Örneğin aşağıdaki kod, bir bisikleti renderlemek için
kullanılan ve bisikletin parçalarını renderlemek için diğer display listelerini
çağıran program örneği:
sonsuz özyinelemeden kaçınmak için içiçe çağırma seviyesi(bütün OpenGL
uyarlamalaı için) en az 64 olarak belirlenmiştir.
glNewList(listIndex,GL_COMPILE);
glCallList(handlebars);
glCallList(frame);
glTranslatef(1.0,0.0,0.0);
glCallList(wheel);
glTranslatef(3.0,0.0,0.0);
glCallList(wheel);
glEndList();
Bilgisayar Grafikleri
4- Display Listselerini Kendi İndislerinde Yönetme
Şimdiya kadar display-liste indeksi olarak pozitif tamsayıları kullanıyorduk.
Gerçek hayatta bu tehlikeli olabilir çünkü kazara kullanımda olan indeksi seçerek
varolan display listesinin üstüne yazarak listenin kaybolmasına sebep olabilir.
Kaza ile silmelerden kaçınmak için glGenLists() komutunu kullanılmayan bir
indeks seçmek için ve glIsList() komutunu da verilen indeksin kullanımda olup
olmadığını öğrenmek için kulanın. Bir liste veya liste aralığını glDeleteLists()
komutu yardımıyla silebilirsiniz.
GLuint glGenLists(GLsizei range);
Daha önce kullanılmamış display-list indislerini bulur. range parametresi kaç
adet indis istendiğini belirler. Döndürülen tam sayı, sürekli v boşta olan display
listesi indisleri bloğunun başlangıç konumunu ifade eder. Döndürülen indislerin
hepsi kullanılmış ve boş olarak işaretlenir , dolayısıyla bir sonraki glGenLists()
çağrıları aynı indisleri döndürmezler(ta ki silinene kadar). Eğer istenilen sayıda
indis mevcut değil ise sıfır döndürür.
Bilgisayar Grafikleri
Display Listselerini Kendi İndislerinde Yönetme-1
GLboolean glIsList(GLuint list);
list kullanılmış ise TRUE ,değilse FALSE döndürür.
Aşağıdaki örnekte tek indis istenmektedir ve eğer o indis kullanılabilir ise yeni
display listesinde kullanılmaktadır :
listIndex=glGenLists(1);if(listIndex!=0) {
glNewList(listIndex,GL_COMPILE);
...
glEndList();
}
Bilgisayar Grafikleri
Örnek 7-5-Bölüm 4-Geometrik Objeler Ve Transformason’te
gösterilen Editor Delphi programının Display Listesi kullandığı
parçası
Örnekte çizilecek her bir geometrik obje tek tek Display listesi içerisine konulmuştur. Bu
işlemi ListPrep ; fonksiyonu yapmaktadır.
Procedure TfrmMain.ListPrep;
begin
glNewList(DRAWCUBE, GL_COMPILE);
glBegin(GL_POLYGON);
glNormal3f(0.5, 0.5, 1.0);
glVertex3f(1.0, 1.0, 1.0);
glVertex3f(0.0, 1.0, 1.0);
glVertex3f(0.0, 0.0, 1.0);
glVertex3f(1.0, 0.0, 1.0);
glEnd;
Bilgisayar Grafikleri
Örnek 7-5-Kod 1
glBegin(GL_POLYGON);
glNormal3f(0.5, 0.5, 0.0);
glVertex3f(1.0, 1.0, 0.0);
glVertex3f(1.0, 0.0, 0.0);
glVertex3f(0.0, 0.0, 0.0);
glVertex3f(0.0, 1.0, 0.0);
glEnd;
glBegin(GL_POLYGON);
glNormal3f(0.0, 0.5, 0.5);
glVertex3f(0.0, 1.0, 1.0);
glVertex3f(0.0, 1.0, 0.0);
glVertex3f(0.0, 0.0, 0.0);
glVertex3f(0.0, 0.0, 1.0);
glEnd;
Bilgisayar Grafikleri
Örnek 7-5-Kod 2
glBegin(GL_POLYGON);
glNormal3f(1.0, 0.5, 0.5);
glVertex3f(1.0, 1.0, 1.0);
glVertex3f(1.0, 0.0, 1.0);
glVertex3f(1.0, 0.0, 0.0);
glVertex3f(1.0, 1.0, 0.0);
glEnd;
glBegin(GL_POLYGON);
glNormal3f(0.5, 1.0, 0.5);
glVertex3f(0.0, 1.0, 0.0);
glVertex3f(0.0, 1.0, 1.0);
glVertex3f(1.0, 1.0, 1.0);
glVertex3f(1.0, 1.0, 0.0);
glEnd;
Bilgisayar Grafikleri
Örnek 7-5-Kod 3
glBegin(GL_POLYGON);
glNormal3f(0.5, 0.0, 0.5);
glVertex3f(0.0, 0.0, 0.0);
glVertex3f(1.0, 0.0, 0.0);
glVertex3f(1.0, 0.0, 1.0);
glVertex3f(0.0, 0.0, 1.0);
glEnd;
glEndList;
glNewList(DRAWSPHERE, GL_COMPILE);
glTranslatef (0.5, 0.5, 0.5);
gluSphere(Quadric, 0.5, 50, 50);
glTranslatef (-0.5, -0.5, -0.5);
glEndList;
Bilgisayar Grafikleri
Örnek 7-5-Kod 4
glNewList(DRAWCYLINDER, GL_COMPILE);
glTranslatef (0.5, 0.5, 0.0);
gluCylinder (Quadric, 0.5, 0.5, 1.0, 50, 50);
glTranslatef (-0.5, -0.5, 0.0);
glEndList;
glNewList(MARKER, GL_COMPILE);
glBegin(GL_POLYGON);
glNormal3f(-0.025, -0.025, 0.025);
glVertex3f(0.025, 0.025, 0.025);
glVertex3f(-0.025, 0.025, 0.025);
glVertex3f(-0.025, -0.025, 0.025);
glVertex3f(0.025, -0.025, 0.025);
glEnd;
Bilgisayar Grafikleri
Örnek 7-5-Kod 5
glBegin(GL_POLYGON);
glNormal3f(-0.025, -0.025, 0.025);
glVertex3f(0.025, 0.025, -0.025);
glVertex3f(0.025, -0.025, -0.025);
glVertex3f(-0.025, -0.025, -0.025);
glVertex3f(-0.025, 0.025, -0.025);
glEnd;
glBegin(GL_POLYGON);
glNormal3f(-0.025, -0.025, 0.025);
glVertex3f(-0.025, 0.025, 0.025);
glVertex3f(-0.025, 0.025, -0.025);
glVertex3f(-0.025, -0.025, -0.025);
glVertex3f(-0.025, -0.025, 0.025);
glEnd;
Bilgisayar Grafikleri
Örnek 7-5-Kod 6
glBegin(GL_POLYGON);
glNormal3f(0.025, -0.025, 0.025);
glVertex3f(0.025, 0.025, 0.025);
glVertex3f(0.025, -0.025, 0.025);
glVertex3f(0.025, -0.025, -0.025);
glVertex3f(0.025, 0.025, -0.025);
glEnd;
glBegin(GL_POLYGON);
glNormal3f(-0.025, 0.025, -0.025);
glVertex3f(-0.025, 0.025, -0.025);
glVertex3f(-0.025, 0.025, 0.025);
glVertex3f(0.025, 0.025, 0.025);
glVertex3f(0.025, 0.025, -0.025);
glEnd;
Bilgisayar Grafikleri
Örnek 7-5-Kod 7
glBegin(GL_POLYGON);
glNormal3f(-0.025, -0.025, -0.025);
glVertex3f(-0.025, -0.025, -0.025);
glVertex3f(0.025, -0.025, -0.025);
glVertex3f(0.025, -0.025, 0.025);
glVertex3f(-0.025, -0.025, 0.025);
glEnd;
glEndList;
end;
Bilgisayar Grafikleri
Örnek 7-5-Ekrana Çizim Fonksiyonu
procedure TfrmMain.DrawScene (mode : GLEnum);
var
i : GLInt;
begin
glClearColor (R, G, B, 1.0);
glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
glLoadIdentity;
glTranslatef(0.0, 0.0, -32.0);
glRotatef(AngX, 1.0, 0.0, 0.0);
glRotatef(AngY, 0.0, 1.0, 0.0);
glRotatef(AngZ, 0.0, 0.0, 1.0);
glTranslatef(AddX, AddY, AddZ);
If (mode <> GL_SELECT) and flgGrid then Grid;
If flgAxes then Axes (mode);
If flgSquare then Square (mode);
glPushAttrib (GL_ALL_ATTRIB_BITS );
glDisable (GL_LIGHT1);
Bilgisayar Grafikleri
Örnek 7-5-Ekrana Çizim Fonksiyonu-1
For i := 1 to objectcount do begin
glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, @objects[i].color);
glPushMatrix;
glTranslatef (objects[i].x, objects[i].y, objects[i].z);
glScalef (objects[i].l, objects[i].k, objects[i].h);
glRotatef (objects[i].RotX, 1.0, 0.0, 0.0);
glRotatef (objects[i].RotY, 0.0, 1.0, 0.0);
glRotatef (objects[i].RotZ, 0.0, 0.0, 1.0);
If mode = GL_SELECT then glLoadName (i + startObjects);
case objects [i].kind of
Cube : glCallList (DRAWCUBE);// listeye çağrıda bulunuluyor
Sphere : glCallList (DRAWSPHERE);// listeye çağrıda bulunuluyor
Cylinder : glCallList (DRAWCYLINDER);// listeye çağrıda bulunuluyor
end; {case}
If i = MarkerObject then MarkerCube (i, mode);
glPopMatrix;
end;
Bilgisayar Grafikleri
Bilgisayar Grafikleri
Bölüm 8
Bilgisayar Grafikleri
Seçme ve Geribesleme Teknikleri (Select & Feedback Technics)
Bu bölümde göreceklerimiz :
1-Seçme
2-Geribesleme
Bilgisayar Grafikleri
Giriş
Bazı grafik uygulamalaı sadece iki ve üç boyutlu objelerin statik bir görüntüsünü
çizerler. Bazı uygulamalar da kullanaıcıya ekranda objeler tanımlama, hareket
ettirme, değiştirme, silme gibi özellikler de tanır. OpenGL tam olarak bu tür
interaktif uygulamaları için dizayn edilmiştir. Ekrana çizlen objeler tipik olarak
çok fazla döndürme, yerdeğiştirme ve perspektif transformasyonlara maruz
kaldığından bizim için kullanıcının üç boyutlu sahnade tam olarak hangi objeyi
seçmek istediğini belirlemek çok güçtür. Bize yardımcı olmak için OpenGL
“Seçme” mekanizmasını sunar. Bu mekanzima otomatik olarak bize pencerenin
belirli bölgesinde hangi objelerin çizildiğini söyler. Seçme tam olarak OpenGL’in
bir işlem modudur; geribesleme ise başka bir böyle moddur. Geribesleme
modunda , grafik donanımımızı ve OpenGL’i herzamanki rendering hesaplamalar
yapmak için kullanırız. Yani bu modda , hesaplanan sonuçların görüntüyü ekrana
çizilmesinde kullanmak yerine ,OpenGL bu sonuçları bize döndürür (veya
geribesleme yapar).
Bilgisayar Grafikleri
Giriş
Örneğin eğer 3-boyutlu bir objeyi ekrana değilde bir çiziciye göndermek
istiyorsanız , parçaları geribesleme modunda çizmeniz gerekecek,daha sonrada
çizim direktiflerini toplayarak bu direktifleri çizicinin anlayabileceği komutlara
dönüştürmeniz gerekecektir.
Seçme ve geribesleme modlarında , rendering moddan farklı olarak çizim
bilgileri framebuffer’a değilde uygulamaya geri döndürülmektedir. Böylece ,
OpenGL seçme veya geribesleme modunda iken ekran donmuş olarak kalır –
çizim olmaz .
Bilgisayar Grafikleri
Seçme
OpenGL'in seçme mekanizmasını kullanmayı planlıyorsanız , sahnenizi önce
framebuffer’a çizerek daha sonra seçme moduna girmeniz gerekir ve sahneyi
yeniden çizmeniz gerekir. Seçme modunda iken framebuffer’in içeriği değşmez
ta ki seçme modundan çıkılana kadar. Seçme modundan çıkıldığında OpenGL ,
görüntüleme hacmi ile kesişen primitiflerin listesini döndürür(görüntüleme hacmi
geçerli modelview and projeksiyon matrisleri ve herhangi tanımlanan
kesme(clipping planes) düzlemleri tarafından belirlenir. ) Görüntüleme hacmi ile
kesişen her primitif bir “seçme hit”’e sebep olur. Burada hit-kelimesi inglizce
isabetli vuruş manasına gelmektedir. Primitifler listesi tamsayı-değerli isimler
dizisi ve ilgili veri-hit kayıtları şeklinde döndürülür. Bu isimler-isim yığınında
tutulurlar. İsim yığını ,seçme modunda iken primitif çizimleri için gereken
komutlar çağırıldığında oluşturulur. Böylelikle isimler listesi döndürüldüğünde ,
bu listeyi kullanıcıların ekranda hangi primitifleri seçmiş olabileceğini belirlerken
kullanırız.
Bilgisayar Grafikleri
Temel Adımlar
Seçme mekanizmasını kullanmak için aşağıdaki adımları takip etmelisiniz :
 glSelectBuffer() komutu ile hit kayıtlarının döndürüleceği bir dizi tanımlanır.
 GL_SELECT parametresini glRenderMode() fonksiyonu ile kullanarak
seçme moduna girilmesi sağlanır
 glInitNames() ve glPushName() fonksiyonları ile isim yığınları başlangıç
duruma getirilir.
 Seçme için istediğimiz görüntüleme hacmi belirlenir.
 Primitif çizim komutları ve isimler yığınını yönetecek komutlar verilmeli. Her
primitife uygun bir isim verilmeli.
 Seçme modundan çıkarak geri döndürülen seçme verisini (hit kayıtları)
işlemek.
Aşağıdaki paragraflar glSelectBuffer() ve glRenderMode() komutlarını
anlatmaktadır. Bir sonraki bölümde isimler yığınını yönetmek için gerek
fonksiyonlar anlatılacaktır.
Bilgisayar Grafikleri
Temel Adımlar-1
void glSelectBuffer(GLsizei size, GLuint *buffer);
Geri döndürülen seçme verisi için bir dizi tanımlar. buffer argümanı işaretsiz
tamsayılar dizisine bir pointerdir,bilgiler bu diziye konur, size dizide tutulabilen
maksimum değer sayısını belirler. glSelectBuffer() fonksiyonu seçme moduna
girilmeden önce çağırılmalı.
GLint glRenderMode(GLenum mode);
Uygulamanın rendering, seçme veya geribesleme modunda olduğunu belirler.
mode argümanı GL_RENDER ( default), GL_SELECT, veya GL_FEEDBACK
olabilir. Uygulama , glRenderMode() fonksiyonu değişik bir argüman ile
çağırılana dek verilen modda kalır. Seçme moduna girmeden önce seçme dizisini
belirlemek için glSelectBuffer() fonksiyonu çağırılmalı. Benzer olarak
geribesleme moduna girmeden önce, glFeedbackBuffer() komutu geribesleme
dizisini belirtmek için çağırılmalı.
Bilgisayar Grafikleri
İsimler Yığınını Oluşturmak
Bir önceki kısımda bahsi geçtiği gibi isimler yığını ,bize döndürülen seçme
bilgisi için bir veri tabanı oluşturur. İsimler yığınını oluşturmak için ilk önce
glInitNames() fonksiyonu ile zemin hazırlanması lazım. Bu işlem basit olarak
yığını sıfırlar ve sonra biz çağırdığımız çizim komutlarına uygun olarak tamsayı
isimlerimizi bu yığına ekleriz. Tahmin edebileceğiniz gibi yığını yönetme
komutları bize yığına isim ekleme (glPushName()),yığından isim çıkarma
(glPopName()) ve yığının en üstündeki elemanını bir başka bir eleman ile
değiştirme (glLoadName()) gibi işlemleri yapabilmemizi sağlar. Örnek 8-1 buna
dair bir önrek sunmaktadır.
Bilgisayar Grafikleri
Örnek 8-1 : isimler yığınını oluşturma
glInitNames();
glPushName(-1);
glPushMatrix(); /* geçerli transformasyon durumunu kaydet
*/
/* istediğiniz görüntüleme hacmini burada oluşturun */
glLoadName(1);
drawSomeObject();
glLoadName(2);
drawAnotherObject();
glLoadName(3);
drawYetAnotherObject();
drawJustOneMoreObject();
glPopMatrix (); /* bir önceki transformasyon durumunu
geri yükle*/
Bilgisayar Grafikleri
İsimler Yığınını Oluşturmak-1
Bu örnekte ilk iki çizilecek objenin kendi isimleri vardır , üçüncü ve dördüncü
objeler ise ortak bir isim kullanmaktadırlar. Bu ayarlamada eğer 3. ve 4.
objelerden biri veya her ikisi seçme hit’e sebep olursa, sadece bir tek hit kaydı
döndürülür.
void glInitNames(void);
isimler yığını siler(tamamen boşaltır)
void glPushName(GLuint name);
name ile belirtilen ismi yığına atar. Dolmuş bir yığına isim eklemek
GL_STACK_OVERFLOW hatasını oluşturur. İsim yığınlarının derinliği
OpenGL uyarlamalarında değişik olabilir ama en azında 64 ismi alabilecek
kapasitede olmalıdırlar. İsim yığınının derinliğini öğrenebilmek için
glGetIntegerv() fonksiyonunu GL_NAME_STACK_DEPTH parametresi ile
çağırmalısınız.
Bilgisayar Grafikleri
İsimler Yığınını Oluşturmak-2
void glPopName(void);
İsimler yığınının en üstündeki elemanı çıkar. Boş bir yığına uygulana bu
fonksiyon GL_STACK_UNDERFLOW hatasını oluşturur.
void glLoadName(GLuint name);
isimler yığınının en üst elemanını name ile belirtilen eleman ile değiştir. Eğer
yığın boş ise ki glInitNames() fonksiyonundan sonra bu doğrudur,
glLoadName() GL_INVALID_OPERATION hatasını oluşturur. Bu hatadan
kaçınmak için eğer yığın başlangıçta boş ise en azından glPushName()
fonksiyonu bir kere çağırılmalı ve daha sonra glLoadName() fonksiyonu
çağırılmalıdır.
Eğer seçme modunda değilseniz glPushName(), glPopName() ve
glLoadName() çağrılarına görmezlikten gelinir ve işlenmezler
Bilgisayar Grafikleri
Hit Kayıtları
Seçme modunda , görüntüleme hacmi ile kesişen primitifler bir “seçme hit” oluşturur(hitisabetli vuruş demektir). Eğer yığın yönetme fonksiyonları çağırılmış veya
glRenderMode() çalıştırılmış ise, OpenGL hit kaydını seçme dizisine yazar. Bu süreçle
aynı ismi paylaşan objeler –örneğin , birden fazla primitiften oluşan objeler – her primitif
için ayrı hit değil,aynı isimleri taşıyan bütün primitifler için tek hit kaydı oluşturur. Hit
kayıtlarının diziye yazılmaları glRenderMode() fonksiyonu çağırılana kadar garanti
değildir,bazı hit kayıtları kaybolabilir.
Primitifler gibi glRasterPos() tarafından oluşturulan geçerli koordinatlar da seçme hit’i
oluşturabilir. Her hit kaydı 4 bileşenden oluşur :
Hit oluştuğu anda, isimler yığınındaki isimlerin numaraları
Görüntüleme hacmi ile kesişen bütün primitiflerin bütün vertisleninin pencere
koordinatları cinsinden minimum ve maksimum z-değerleri. [0,1] aralığında olan bu iki
değerlerden her biri 232-1 ile çarpılarak en yakın işaretsiz tam sayıya dönüştürülür.
Hit anında ,isimler yığınının en alttaki elemanı en başta olacak şekilde tüm içeriği.
Bilgisayar Grafikleri
Hit Kayıtları-1
Seçme moduna girdiğimiz anda , OpenGL , seçme dizisine bir pointer atar. Hit
kaydının diziye her yazılışında , pointer da buna göre dğişmektedir. Eğer yazılan
hit kaydı , glSelectBuffer() fonksiyonunun size argümanı ile belirtilen sayıdan
aşarsa , OpenGL yazabildiği kadar hit kayıtlarını yazar ve overflow flagını set
eder. Seçme modundan glRenderMode() fonksiyonu ile çıkıldığında bu komut
yazılan hit kayıtlarının sayısını döndürür, isimler yığınınını temizler,overflow
flagını resetler ve yığın pointerini resetler. Eğer overflow flagı set edilmiş ise -1
değeri döndürülür.
Bilgisayar Grafikleri
Seçme Örneği
Örnek 8-2 , Seçme modunda
üçgenler çizilmekte ve uygun hit
kayıtları işlenmeketedir. İlk üçgen
hit üretmekte,ikinci üçgen
üretmemekte, 3. ve 4. üçgenler de
tek bir hit üretmektedirler.
Rutinler üçgen çizimi için -
drawTriangle() ve görüntüleme
hacmini belirten kabloçerçeve
çizimek için -drawViewVolume()
. processHits() rutini seçme
dizisini yazdırmaktadır. Son
olarak selectObjects()
fonksiyonu,hit kayıtları
oluşturmak için üçgenleri seçme
modunda çizmektedir.
Bilgisayar Grafikleri
Seçme Örneği-Kod
#include <GL/gl.h>
#include <GL/glu.h>
#include "aux.h"
void drawTriangle (GLfloat x1, GLfloat y1, GLfloat x2,
GLfloat y2, GLfloat x3, GLfloat y3, GLfloat z)
{
glBegin (GL_TRIANGLES);
glVertex3f (x1, y1, z);
glVertex3f (x2, y2, z);
glVertex3f (x3, y3, z);
glEnd ();
}
void drawViewVolume (GLfloat x1, GLfloat x2, GLfloat y1,
GLfloat y2, GLfloat z1, GLfloat z2)
{ glColor3f (1.0, 1.0, 1.0);
glBegin (GL_LINE_LOOP);
glVertex3f (x1, y1, -z1);
glVertex3f (x2, y1, -z1);
glVertex3f (x2, y2, -z1);
glVertex3f (x1, y2, -z1);
glEnd ();
Bilgisayar Grafikleri
Seçme Örneği-Kod-1
glBegin (GL_LINE_LOOP);
glVertex3f (x1, y1, -z2);
glVertex3f (x2, y1, -z2);
glVertex3f (x2, y2, -z2);
glVertex3f (x1, y2, -z2);
glEnd ();
glBegin (GL_LINES);
glVertex3f (x1, y1, -z1);
glVertex3f (x1, y1, -z2);
glVertex3f (x1, y2, -z1);
glVertex3f (x1, y2, -z2);
glVertex3f (x2, y1, -z1);
glVertex3f (x2, y1, -z2);
glVertex3f (x2, y2, -z1);
glVertex3f (x2, y2, -z2);
glEnd ();
}
Bilgisayar Grafikleri
Seçme Örneği-Kod-2
void drawScene (void)
{
glMatrixMode (GL_PROJCTION);
glLoadIdentity ();
gluPerspective (40.0, 4.0/3.0, 0.01, 100.0);
glMatrixMode (GL_MODELVIEW);
glLoadIdentity ();
gluLookAt (7.5, 7.5, 12.5, 2.5, 2.5, -5.0, 0.0, 1.0,
0.0);
glColor3f (0.0, 1.0, 0.0);
drawTriangle (2.0, 2.0, 3.0, 2.0, 2.5, 3.0, -5.0);
glColor3f (1.0, 0.0, 0.0);
drawTriangle (2.0, 7.0, 3.0, 7.0, 2.5, 8.0, -5.0);
glColor3f (1.0, 1.0, 0.0);
drawTriangle (2.0, 2.0, 3.0, 2.0, 2.5, 3.0, 0.0);
drawTriangle (2.0, 2.0, 3.0, 2.0, 2.5, 3.0, -10.0);
drawViewVolume (0.0, 5.0, 0.0, 5.0, 0.0, 10.0);
}
Bilgisayar Grafikleri
Seçme Örneği-Kod-3
void processHits (GLint hits, GLuint buffer[])
{
unsigned int i, j;
GLuint names, *ptr;
printf ("hits = %d\n", hits);
ptr = (GLuint *) buffer;
for (i = 0; i < hits; i++) {
names = *ptr;
printf(" number of names for hit = %d\n", names);
ptr++;
printf (" z1 is %u;", *ptr); ptr++;
printf (" z2 is %u\n", *ptr); ptr++;
printf (" the name is ");
for (j = 0; j < names; j++) {
printf ("%d ", *ptr); ptr++;
}
printf ("\n");
}
}
#define BUFSIZE 512
Bilgisayar Grafikleri
Seçme Örneği-Kod-4
void selectObjects(void)
{ GLuint selectBuf[BUFSIZE];
GLint hits, viewport[4];
glSelectBuffer (BUFSIZE, selectBuf);
(void) glRenderMode (GL_SELECT);
glInitNames();
glPushName(-1);glPushMatrix ();
glMatrixMode (GL_PROJCTION);
glLoadIdentity ();
glOrtho (0.0, 5.0, 0.0, 5.0, 0.0, 10.0);
glMatrixMode (GL_MODELVIEW);
glLoadIdentity ();
glLoadName(1);
drawTriangle (2.0, 2.0, 3.0, 2.0, 2.5, 3.0, -5.0);
glLoadName(2);
drawTriangle (2.0, 7.0, 3.0, 7.0, 2.5, 8.0, -5.0);
glLoadName(3);
drawTriangle (2.0, 2.0, 3.0, 2.0, 2.5, 3.0, 0.0);
drawTriangle (2.0, 2.0, 3.0, 2.0, 2.5, 3.0, -10.0);
glPopMatrix ();glFlush ();
hits = glRenderMode (GL_RENDER);
processHits (hits, selectBuf);
}
Bilgisayar Grafikleri
Seçme Örneği-Kod-5
void myinit (void)
{
glDepthFunc(GL_LEQUAL);
glEnable(GL_DEPTH_TEST);
glShadeModel(GL_FLAT);
}
void display(void)
{
glClearColor (0.0, 0.0, 0.0, 0.0);
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
drawScene ();
selectObjects ();
glFlush();
}
int main(int argc, char** argv)
{
auxInitDisplayMode (AUX_SINGLE | AUX_RGBA | AUX_DEPTH);
auxInitPosition (0, 0, 200, 200);
auxInitWindow (argv[0]);
myinit ();
auxMainLoop(display);}
Bilgisayar Grafikleri
Select Programı: Delphi Versiyonu
Delphi versiyonu
için buraya basınız!
Bilgisayar Grafikleri
Geribesleme
Geribesleme ,seçme modu gibidir ama farkı şu: seçmede pikseller üretilirken
geribeslemede üretilmez,sadece ekran dondurulur,çizim olmaz. Çizim yerine
primitiflerin renderlenme biligileri uygulamaya geri gönderilir. Seçme ve
geribesleme modları arasındak ana fark da ne tür bilginin
döndürüldüğüdür.Seçme modunda atanmış isimler tamsayılar dizisine
döndürülür. Geribesleme modunda ise , transform olmuş primitifler hakkında
bilgi kayan noktalı sayılar dizisine döndürülür. Geri döndürülüne değerler ne tür
primitifinin (nokta, çizgi, çokgen,resim veya bitmap) ,vertex,renk ve diğer
primitif bilgilerini belirten token’lardan oluşur. Geribesleme modu
glRenderMode() fonksiyonunu GL_FEEDBACK parametresi ile çağırılarak
başlangıç duruma getirilmiş olur.
Bilgisayar Grafikleri
Geribesleme-1
Geribesleme moduna girme ve çıkma adımları :
Geribesleme bilgisini tutacak dizi glFeedbackBuffer() fonksiyonu ile belirlenir.
Fonksiyon argümanları ne tür veri ve diziye ne kadar yazılacağını belirlerler.
glRenderMode() fonksiyonunu GL_FEEDBACK argümanı ile çağırarak
geribesleme moduna giriniz. Bu noktadan sonra geribesleme modundan çıkılana
kadar , primitifler piksel üretmek için rasterize edilmezler ve framebuffer’in içeriği
değişmez.
Primitiflerinizi çiziniz.
 glRenderMode() fonksiyonunu GL_RENDER argümanı ile çağırarak
geribesleme modundan normal çizim moduna dönebilirsiniz. glRenderMode()
fonksiyonu taatından döndürülen tamsayı, geribesleme dizisinde tutulan değerlerin
sayısını ifade eder.
Geribesleme dizisindeki bilgileri analiz edin.
Bilgisayar Grafikleri
Geribesleme-2
void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer);
Geribesleme verisi için bir buffer tahsis eder: buffer verinin tutulduğu diziye bir
pointerdir. size argümanı dizide tutulabilecek maksimum değer sayısını ifade
eder. type argümanı geribesleme dizisindeki her vertex için döndürülen bilginin
tipini belirler; bu argümanın alabileceği değerler ve anlamları Tablo 8-1 deki
gibidir . glFeedbackBuffer() fonksiyonu geribesleme moduna girilmeden önce
çağırılmalıdır. Tabloda ki k değeri color-index modu için 1 ve RGBA modu için
ise 4 tür.
Bilgisayar Grafikleri
Tablo 8-1
Tablo 8-1 : glFeedbackBuffer() fonksiyonunun type argumanı
Argüman tipi Koordinatlar Renk Texture Toplam Değer
GL_2D x, y - - 2
GL_3D x, y, z - - 3
GL_3D_COLOR x, y, z k - 3 + k
GL_3D_COLOR_TEXTURE x, y, z k 4 7 + k
GL_4D_COLOR_TEXTURE x, y, z, w k 4 8 + k
Bilgisayar Grafikleri
Geribesleme Dizisi
Geribesleme modunda ,rasterize edilecek her primitif ( glDrawPixels() veya
glCopyPixels() fonksiyonlarına yapılan her çağırı) bir değerler bloğu oluşturur ve
bu değerler geribesleme dizisine kopyalanır. Değer sayısı glFeedbackBuffer()
fonksiyonunun type argümanı ile belirlenir(tablo 8-1 de gösterildiği gibi) .
Çizmekte olduğunuz primitif tipine uygun bir değer seçmelisiniz : GL_2D veya
GL_3D aydınlatılmamış iki veya üç-boyutlu primitifler için, GL_3D_COLOR
aydınlatılmış üç-boyutlu primitifler için ve GL_3D_COLOR_TEXTURE veya
GL_4D_COLOR_TEXTURE aydınlatılmış, texture uygulanmış , 3 veya 4-
boyutlu primitifler için.
Geribesleme değerlerinin her bloğu primitif tipini belirleyen bir kod ile başlar,
sonraki bilgiler ise primitif vertislerini tanımlayan bilgiler ve ve bunlarla ilgili
veri gelir. Tablo 8-2 geribesleme dizisinin sentaksını göstermektedir; döndürülen
her vertex ile ilgili verilerin tipleri Tablo 8-1 de açıklanmıştı . Geribesleme
tarafından döndürülen x, y, z koordinatları pencere koordinatlarındadır; eğer w de
döndürüldüyle,clip(kesme) koordinatlarındadır
Bilgisayar Grafikleri
Tablo 8-2
Tablo 8-2 : Geribesleme Dizi Sentaksı
Primitif
Tipi
Kod İlgili Veri
Nokta GL_POINT_TOKEN vertex
Çizgi GL_LINE_TOKEN veya GL_LINE_RESET_TOKEN vertex vertex
Çokgen GL_POLYGON_TOKEN n vertex vertex ...
vertex
Bitmap GL_BITMAP_TOKEN vertex
Pixel
Dörtgeni
GL_DRAW_PIXEL_TOKEN veya
GL_COPY_PIXEL_TOKEN
vertex
Passthrough
GL_PASS_THROUGH_TOKE N Kayan noktalı sayı
Bilgisayar Grafikleri
Geribesleme Örneği
Örnek 8-3 geribesleme modunun kullanımını göstermektedir. Bu
program normal renderleme modunda aydınlatılmış üç boyutlu bir sahne
çizmektedir . Daha sonra geribesleme moduna girilerek sahne yeniden
çizilmektedir. Program aydınlatılmış, texture’suz ve 3-boyutlu bir obje
çizdiğinden , geribesleme verisinin tipi GL_3D_COLOR olur. RGBA
modu kullanıldığından , clip (kesme)yapılmamış her vertex
geribesleme bufferı için yedi değer üretir: x, y, z, r, g, b ve a.
Bilgisayar Grafikleri
Geribesleme Örneği-1
Programın Delphi Versiyonu için buraya tıklayınız!
Bilgisayar Grafikleri
Geribesleme Örneği-Kod
#include <GL/gl.h>
#include <GL/glu.h>
#include "aux.h"
void myinit(void)
{ glEnable(GL_LIGHTING);
glEnable(GL_LIGHT0);}
void drawGeometry (GLenum mode)
{ glBegin (GL_LINE_STRIP);
glNormal3f (0.0, 0.0, 1.0);
glVertex3f (30.0, 30.0, 0.0);
glVertex3f (50.0, 60.0, 0.0);
glVertex3f (70.0, 40.0, 0.0);
glEnd ();
if (mode == GL_FEEDBACK)
glPassThrough (1.0);
glBegin (GL_POINTS);
glVertex3f (-100.0, -100.0, -100.0);
glEnd ();
if (mode == GL_FEEDBACK)
glPassThrough (2.0);
Bilgisayar Grafikleri
Geribesleme Örneği-Kod-1
glBegin (GL_POINTS);
glNormal3f (0.0, 0.0, 1.0);
glVertex3f (50.0, 50.0, 0.0);
glEnd ();
}
void print3DcolorVertex (GLint size, GLint *count,
GLfloat *buffer)
{
int i;
printf (" ");
for (i = 0; i < 7; i++) {
printf ("%4.2f ", buffer[size-(*count)]);
*count = *count - 1;
}
printf ("\n");}
void printBuffer(GLint size, GLfloat *buffer)
{ GLint count;
GLfloat token;
count = size;
while (count) {
token = buffer[size-count]; count--;
Bilgisayar Grafikleri
Geribesleme Örneği-Kod-2
if (token == GL_PASS_THROUGH_TOKEN) {
printf ("GL_PASS_THROUGH_TOKEN\n");
printf (" %4.2f\n", buffer[size-count]);
count--;
}
else if (token == GL_POINT_TOKEN) {
printf ("GL_POINT_TOKEN\n");
print3DcolorVertex (size, &count, buffer);
}
else if (token == GL_LINE_TOKEN) {
printf ("GL_LINE_TOKEN\n");
print3DcolorVertex (size, &count, buffer);
print3DcolorVertex (size, &count, buffer);
}
else if (token == GL_LINE_RESET_TOKEN) {
printf ("GL_LINE_RESET_TOKEN\n");
print3DcolorVertex (size, &count, buffer);
print3DcolorVertex (size, &count, buffer);
}
}
}
Bilgisayar Grafikleri
Geribesleme Örneği-Kod-3
void display(void)
{
GLfloat feedBuffer[1024];
GLint size;
glMatrixMode (GL_PROJCTION);
glLoadIdentity ();
glOrtho (0.0, 100.0, 0.0, 100.0, 0.0, 1.0);
glClearColor (0.0, 0.0, 0.0, 0.0);
glClear(GL_COLOR_BUFFER_BIT);
drawGeometry (GL_RENDER);
glFeedbackBuffer (1024, GL_3D_COLOR, feedBuffer);
(void) glRenderMode (GL_FEEDBACK);
drawGeometry (GL_FEEDBACK);
size = glRenderMode (GL_RENDER);
printBuffer (size, feedBuffer);
}
Bilgisayar Grafikleri
Geribesleme Örneği-Kod-4
int main(int argc, char** argv)
{
auxInitDisplayMode (AUX_SINGLE | AUX_RGBA);
auxInitPosition (0, 0, 100, 100);
auxInitWindow (argv[0]);
myinit ();
auxMainLoop(display);
}
Running this program generates the following output:
GL_LINE_RESET_TOKEN
30.00 30.00 0.00 0.84 0.84 0.84 1.00
50.00 60.00 0.00 0.84 0.84 0.84 1.00
GL_LINE_TOKEN
50.00 60.00 0.00 0.84 0.84 0.84 1.00
70.00 40.00 0.00 0.84 0.84 0.84 1.00
GL_PASS_THROUGH_TOKEN
1.00
GL_PASS_THROUGH_TOKEN
2.00
GL_POINT_TOKEN
Bilgisayar Grafikleri
Geribesleme Örneği-Kod-5
50.00 50.00 0.00 0.84 0.84 0.84 1.00
Thus, the line strip drawn with these commands results in two
primitives:
glBegin(GL_LINE_STRIP);
glNormal3f (0.0, 0.0, 1.0);
glVertex3f (30.0, 30.0, 0.0);
glVertex3f (50.0, 60.0, 0.0);
glVertex3f (70.0, 40.0, 0.0);
glEnd();
Bilgisayar Grafikleri
Bilgisayar Grafikleri
Bölüm 9
Bilgisayar Grafikleri
Delphi Ve OpenGL Programlama
Bu bölümün amacı İnprise firmasının Delphi programlama dilini
kullanarak OpenGL programlarının nasıl yazılacağını anlatmaktır.
Delphi ve OpenGL
Delphi’de OpenGL programlamasına başlamak için bir kaç şeye ihtiyaç
duyarız. Bunlardan ilki opengl.pas dosyasıdır. Bu dosya Delphi’nin
kurulum dizinindeki \Lib altdizininde bulunmaktadır. Bu dosya, opengl’in
Delphi object pascal dilinde çevirilmiş temel kütüphanesidir. Bunun
yanında da GLU,GLUT ve GLAUX gibi yardımcı kütüphaneleri de
mevcuttur. Eğer sisteminizde opengl.pas dosyası mevcut değilse, windows
işletim sistemiyle beraber gelen opengl.dll dosyası programa linklenerek
de program yazılabilir.
Bilgisayar Grafikleri
Basit Primitflerden Objelere
Opengl sadece şu primitifleri destekler : nokta, çizgi ve çokgenler. Üst düzey
yüzeylerin (küre gibi) primitif olararak çizmek mümkün değildir. Ama çokgen
kullanılarak bu iş görülebilir. Obje çizimi pascal programlamasına çok benzer.
Her blok begin ... end çiftiyel çevirilmeli veya Opengl açısından söyleceyecek
olursak glBegin() ve glEnd() fonksiyonları kullanılır.Aşağıdaki koda bir göz atın:
const S=1.0; D=5.0;
...
glBegin(GL_TRIANGLES);
glVertex3f( -S, 0, D); glVertex3f(S, 0, D);
glVertex3f(0, S, D);
glEnd;
Bu basit bir üçgendir. Bakış noktanızdan 5 birim uzakta, 1 birim boyunda ve 2
birim genişliğinde bir üçgen.
Bilgisayar Grafikleri
Basit Primitflerden Objelere-Örnek 1-Üçgen Objesi
Her OpenGL programında , işletim sistemine özel , çıktı cihazlarını hazır hale
getiren bir kod mevcuttur. Eğer Win32 kullanıyorsak piksel formatı ,
renderleme konteksti gibi ayarları yapmalıyız(set etmeliyiz.). Eğer pek fazla
sistem programcılığından anlamıyorsanız aşağıdaki kodu şablon olarak
kullanabilirsiniz.
unit Tri;//Tri.pas dosyası
interface
uses
OpenGL, Windows, Messages, SysUtils, Classes, Graphics,
Controls, Forms, Dialogs,
StdCtrls, ExtCtrls, ComCtrls;
type
TForm1 = class(TForm)
procedure FormCreate(Sender: TObject);
procedure FormPaint(Sender: TObject);
private
procedure Draw; //Draws an OpenGL scene on request
public
end;
Bilgisayar Grafikleri
Örnek 1-Üçgen Objesi-1
var
Form1: TForm1;
implementation
{$R *.DFM}
procedure setupPixelFormat(DC:HDC);
const
pfd:TPIXELFORMATDESCRIPTOR = (
nSize:sizeof(TPIXELFORMATDESCRIPTOR);// boyut
nVersion:1; // versiyon
dwFlags:PFD_SUPPORT_OPENGL or PFD_DRAW_TO_WINDOW or
PFD_DOUBLEBUFFER; // support double-buffering
iPixelType:PFD_TYPE_RGBA; // renk tipi
cColorBits:24; // seçilen renk derinliği
cRedBits:0; cRedShift:0; // renk bitleri(yoksay)
cGreenBits:0; cGreenShift:0;
cBlueBits:0; cBlueShift:0;
cAlphaBits:0; cAlphaShift:0; // alfa buffer yok
cAccumBits: 0;
cAccumRedBits: 0; // accumulation buffer yok,
cAccumGreenBits: 0; // accum bitleri (yoksay)
Bilgisayar Grafikleri
Örnek 1-Üçgen Objesi-2
cAccumBlueBits: 0;
cAccumAlphaBits: 0;
cDepthBits:16; // depth buffer
cStencilBits:0; // stencil buffer yok
cAuxBuffers:0; // auxiliary buffers yok
iLayerType:PFD_MAIN_PLANE; // ana katman
bReserved: 0;
dwLayerMask: 0;
dwVisibleMask: 0;
dwDamageMask: 0; //visible, damage masks
);
var pixelFormat:integer;
begin
pixelFormat := ChoosePixelFormat(DC, @pfd);
if (pixelFormat = 0) then
exit;
if (SetPixelFormat(DC, pixelFormat, @pfd) <> TRUE)
then
exit;
end;
Bilgisayar Grafikleri
Örnek 1-Üçgen Objesi-3
procedure GLInit;
begin
// görüntüleme projeksiyonunu set ettik
glMatrixMode(GL_PROJECTION);
glFrustum(-0.1, 0.1, -0.1, 0.1, 0.3, 25.0);
// görüntüleyicyi yerleştirme
glMatrixMode(GL_MODELVIEW);
glEnable(GL_DEPTH_TEST);
end;
procedure TForm1.FormCreate(Sender: TObject);
var DC:HDC;
RC:HGLRC;
i:integer;
begin
DC:=GetDC(Handle);//Burada herhangi bir window
//kontrolü olabilir
SetupPixelFormat(DC);
RC:=wglCreateContext(DC);
wglMakeCurrent(DC, RC);//Opengl penceresini aktif yap
GLInit; //OpenGL’i hazır duruma getir
end;
Bilgisayar Grafikleri
Örnek 1-Üçgen Objesi-4
procedure TForm1.Draw;
const S=1.0; D=5.0;
begin
glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
glLoadIdentity;
glTranslatef(0.0, 0.0, -12.0);
glBegin(GL_TRIANGLES);
glVertex3f( -S, 0, D); glVertex3f(S, 0, D);
glVertex3f(0, S, D);
glEnd;
SwapBuffers(wglGetCurrentDC);
end;
procedure TForm1.FormPaint(Sender: TObject);
begin
Draw;
end;
end.
Bilgisayar Grafikleri
Örnek 1-Üçgen Objesi-.dfm dosyası
//Tri.dfm dosyası içeriği
object Form1: TForm1
BorderStyle = bsDialog
Caption = 'BASIC OpenGL
Program'
ClientHeight = 318
ClientWidth = 373
OnCreate = FormCreate
OnPaint = FormPaint
end
Bilgisayar Grafikleri
Kilit Fonksiyon : FormCreate()
Delphide opengl uygulaması yazarken butün opengl başlatama fonksiyonları
programın onCreate olayında çağırılmalı, dolayısıyla büyün başlatma
fonksiyonlarına çağırı TForm.FormCreate(...) fonksiyonu içinden yapılır.
Yukarıdaki örnekten de gördüğünüz gibi :
begin
DC:=GetDC(Handle);//Burada herhangi bir window
//kontrolü olabilir
SetupPixelFormat(DC);
RC:=wglCreateContext(DC);
wglMakeCurrent(DC, RC);//Opengl penceresini aktif
yap
GLInit; //OpenGL’i hazır duruma getir
end;
Burada GetDC,SetPixelFormat,wglCreateContext,wglMakeCurrent ve GLInit
fonksiyonları başlatma fonksiyonlarıdır.
Bilgisayar Grafikleri
TForm.FormPaint(...) Fonksiyonunun Kullanımı
Bir delphi opengl programındaki bütün çizimler (yani bütün çizim işlemleri)
TForm.FormPaint(...) fonksiyonu içinde olmalıdır. Bu fonksiyon delphi
programının onPaint olayına tekabul eder. Programdaki objeler çizildikten sonra
da en son olarak aşağıdaki fonksiyon çağırılır :
procedure TMain.FormDestroy(Sender: TObject);
begin
wglMakeCurrent(0, 0);
wglDeleteContext(hrc);
ReleaseDC(Handle, DC);
end;
Bilgisayar Grafikleri
Delphi Component Kullanımı
Yukarıdaki üçgen örneğinde kullandığımız opengl hazır hale getirme rutinlerinin
karmaşıklığından kurtulmak ve bütün başlatma rutinlerini bir arada yönetebilmek
için Jason Allen’in yazdığı glWater (delphigl.cfxweb.net)delphi bileşenini
kullanmak yararlı olur. Komponenti downloads kısmından indirebilirsiniz.
Bu komponenti basitçe formun üzerine atarak object inspector’dan özelliklerini
ayarlayabilirsiniz. Aşağıda, bu komponenti kullanan bir örnek verilmektedir.
Bilgisayar Grafikleri
glWater Komponentinin Kullanımı
unit frmMain;
interface
uses
Windows, Messages, SysUtils, Classes, Graphics, Controls,
Forms, Dialogs,
GLWindow, ExtCtrls, OpenGL, RenderThread, StdCtrls, glAux;
type
TForm1 = class(TForm)
Panel1: TPanel;
Label1: TLabel;
RadioButton1: TRadioButton;
RadioButton2: TRadioButton;
glWindow1: TglWindow;
Timer1: TTimer;
glWindow2: TglWindow;
glWindow3: TglWindow;
glWindow4: TglWindow;
procedure FormCreate(Sender: TObject);
procedure Timer1Timer(Sender: TObject);
procedure RadioButton1Click(Sender: TObject);
Bilgisayar Grafikleri
glWater Komponentinin Kullanımı-1
procedure RadioButton2Click(Sender: TObject);
procedure FormClose(Sender: TObject; var Action:
TCloseAction);
procedure glWindow1Draw(Sender: TObject);
procedure glWindow2Draw(Sender: TObject);
procedure glWindow3Draw(Sender: TObject);
procedure glWindow4Draw(Sender: TObject);
private
public
renderThread : TGLThread;
procedure DrawAll();
end;
var
Form1: TForm1;
rot : Integer;
implementation
{$R *.DFM}
Bilgisayar Grafikleri
glWater Komponentinin Kullanımı-2
procedure TForm1.FormCreate(Sender: TObject);
begin
renderThread := TglThread.Create(False);
renderThread.Suspend;
end;
procedure TForm1.DrawAll;
begin
glWindow1.ReDraw;
glWindow2.ReDraw;
glWindow3.ReDraw;
glWindow4.ReDraw;
end;
procedure TForm1.Timer1Timer(Sender: TObject);
begin
DrawAll();
end;
Bilgisayar Grafikleri
glWater Komponentinin Kullanımı-3
procedure TForm1.RadioButton1Click(Sender: TObject);
begin
timer1.Enabled := True;
renderThread.Suspend;
end;
procedure TForm1.RadioButton2Click(Sender: TObject);
begin
timer1.Enabled := False;
renderThread.Resume;
end;
procedure TForm1.FormClose(Sender: TObject; var Action:
TCloseAction);
begin
// OpenGL kanalını durdur
renderThread.Suspend;
renderThread.Free;
Application.Terminate;
end;
Bilgisayar Grafikleri
glWater Komponentinin Kullanımı-4
procedure TForm1.glWindow1Draw(Sender: TObject);
begin
// renk ve derinlik bufferlarını silme
glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
glLoadIdentity();
glMatrixMode(GL_MODELVIEW);
glTranslatef(0.0, 0.0, -4.0);
glRotatef(rot, 1.0, 1.0, 1.0);
glColor3f(0.0, 0.0, 1.0);
auxWireCube(2.0);
Inc(rot);
end;
procedure TForm1.glWindow2Draw(Sender: TObject);
begin
// renk ve derinlik bufferlarını silme
glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
glLoadIdentity();
Bilgisayar Grafikleri
glWater Komponentinin Kullanımı-5
glMatrixMode(GL_MODELVIEW);
glTranslatef(0.0, 0.0, -4.0);
glRotatef(rot, 1.0, 1.0, 1.0);
glColor3f(0.0, 1.0, 0.0);
auxWireSphere(1.0);
end;
procedure TForm1.glWindow3Draw(Sender: TObject);
begin
// renk ve derinlik bufferlarını silme
glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
glLoadIdentity();
glMatrixMode(GL_MODELVIEW);
glTranslatef(0.0, 0.0, -15.0);
glRotatef(rot, 1.0, 1.0, 1.0);
glColor3f(1.0, 0.0, 0.0);
auxWireTorus(1.0, 5.0);
end;
Bilgisayar Grafikleri
glWater Komponentinin Kullanımı-6
procedure TForm1.glWindow4Draw(Sender: TObject);
begin
// renk ve derinlik bufferlarını silme
glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
glLoadIdentity();
glMatrixMode(GL_MODELVIEW);
glTranslatef(0.0, 0.0, -10.0);
glRotatef(rot, 1.0, 1.0, 1.0);
glColor3f(1.0, 1.0, 1.0);
auxWireCylinder(1.0, 5.0);
end;
end.
Bilgisayar Grafikleri
glWater Komponentinin Kullanımı-Program Çalışırken...
Bilgisayarlı Grafik Dersi
Son
Giriş
Makine Öğrenmesi Dersi
1
1
Makine Ögrenmesi
1. hafta
  Temel Terimler
  Danışmanlı – Danışmansız Öğrenme
  Veri Hazırlama
  Çapraz Geçerlik
  Aşırı Eğitim
2
Makine Ögrenmesi Nedir?
Makine Öğrenmesi, verilen bir problemi
probleme ait ortamdan edinilen veriye göre
modelleyen bilgisayar algoritmalarının genel
adıdır. Yoğun çalışılan bir konu olduğu için
önerilmiş birçok yaklaşım ve algoritma
mevcuttur. Bu yaklaşımların bir kısmı tahmin
(prediction) ve kestirim (estimation) bir kısmı
da sınıflandırma (classification) yapabilme
yeteneğine sahiptir.
2
3
Makine Öğrenmesi Yöntemleri
Önerilmiş birçok makine öğrenmesi yöntemi
mevcuttur. Bunlar probleme yaklaşımlara göre
farklılık gösterebilir ve bu yüzden farklı
problemlerde farklı başarılara sahip olabilirler.
4
Makine Ögrenmesi Terimleri
  Tahmin (prediction): Veriden öğrenen
modellerde sistem çıkışının nicel olması
durumunda kullanılan yöntemlerin ürettiği
değerlerdir.
  Sınıflandırma (classification): Giriş verisine ait
çıkışların nitel olduğu durumlarda kullanılan
yöntemlerin her veri örneğinin hangi sınıfa ait
olduğunu belirlemesidir.
3
5
Tahmin ve Kestirim
İstatistikte rasgele bir değişkenin bilinmeyen
bir değerinin belirlenmesi için tahmin
(prediction), bilinmeyen bir sabitin belirlenmesi
içinse kestirim (estimation) kavramından
bahsedilir. Çok yakın anlamları dolayısıyla bu
iki terim literatürde çoğunlukla karıştırılarak
aynı şeyi ifade etmede kullanılır.
6
Tahmin ve Kestirim
Örneğin sağda veri noktaları
için bir doğrusal eğri fonksiyonu tespit edilmiştir. Herhangi bir x değerine karşılık
gelen y değerini belirlemekte
“tahmin”, tahmini yapmamıza yardımcı olan eğrinin
(eğim ve sapma değeri gibi)
parametrelerinin belirlenmesinde ise “kestirim” terimleri
tercih edilmelidir.
4
7
Bir Kestirim Örneği
Bir probleme ilişkin olarak sağdaki
veri kümesi veriliyor. Amaç bir x
girdisine karşı bir y değerini
üretmektir. Buna göre veri üzerinde
doğru ilişkiyi bulan öyle bir f :X Y
fonksiyonu tanımlanmalıdır ki en
küçük hatayı üretsin.
Bu basit problemde y=3*x çözümü
kolayca görünmektedir.
X Y
43 129
38 114
31 93
27 81
24 72
19 57
10 30
8 24
5 15
3 9
8
Bir Tahmin Örneği
Bulunan y=3*x çözümüne ilişkin
olarak eğer x=50 değeri için y değeri
istenirse kestirilen denklem yardımı
ile y=150 tahmin değerini kolayca
hesaplamak mümkün olur.
X Y
43 129
38 114
31 93
27 81
24 72
19 57
10 30
8 24
5 15
3 9
5
9
Sınıflandırma
Amaç probleme ait tüm
uzayın belirli sayıda sınıfa
bölünmesidir. Sağdaki resimde her renk bir sınıfı
göstermektedir. Sınıflandırma teknikleri sayesinde hiçbir veri örneğinin
olmadığı bölgeler de
renklendirilebilir.
10
Bir Sınıflandırma Örneği
Sağdaki veri kümesinde amaç X
girdisine karşı Y etiket (label)
değerini üretmektir. Öyle bir f :X Y
sınıflandırma fonksiyonu tanımlanmalıdır ki en az hata ile sınıflandırma
yapılabilsin.
X Y
47 1
39 1
33 1
27 1
20 1
19 0
13 0
9 0
5 0
2 0



≥
<
=
,1 20
,0 20
X
X
Y
6
11
Makine Öğrenmesi Terimleri
Makine Öğrenmesi yöntemleri verinin yapısına
göre ikiye ayrılır.
  Danışmanlı (supervised) Öğrenme: Veri,
etkiye tepki prensibiyle çalışan sistemlerden
alınır ve giriş-çıkış düzeninde organize edilir.
  Danışmansız (unsupervised) Öğrenme: Sınıf
bilgisi olmayan veya verilmeyen veri içerisindeki
grupları keşfetmeyi hedefler.
12
Takviyeli Öğrenme
Bazen öğretici, sisteme beklenen sonucu tam
söyleyemez. Ama sistemin ürettiği sonuç için
“doğru/yanlış” şeklinde fikir belirtir. Bu
öğrenme şekli de takviyeli (reinforcement)
öğrenme adıyla anılır.
Boltzmann makinesi, LVQ ve genetik algoritma
örnek olarak sayılabilir.
7
13
Makine Ögrenmesi Terimleri
Sınıflandırma ve tahmin yöntemlerine
danışmanlı öğrenme yöntemleri de denilebilir.
Kümeleme (clustering) yöntemleri ise
danışmansız öğrenme yöntemleri olarak
anılırlar.
Peki Kümeleme nedir?
14
Kümeleme
Danışmansız öğrenmeyi baz alan Kümelemede
amaç veri kümesi içerisindeki veri örneklerini
sadece özellik (feature) vektörlerine göre
gruplamaktır. Bunun için örneklerin birbirine
benzerliği gözetilir. Kümeleme literatüründe
benzerlik terimi uzaklık terimiyle zıt anlamda
kullanılmaktadır.
8
15
Kümeleme
Birbirine benzer olan örnekler aynı kümeye ve
biribirinden uzak olan örnekler farklı kümelere
yerleştirilmeye çalışılır. Küme sayısı genellikle
dışarıdan verilir.
16
Danışmanlı Kümeleme
Sınıf bilgisinden bağımsız olarak veri içerisinde
bilgi keşfi sınıflandırma için destekleyici bir
etkiye sahip olabilir. Sınıflandırma öncesi verinin
kümelenmesi (supervised clustering), genellikle
sınıflandırma başarısını yükseltmektedir.
Kümeleme Danışmanlı Kümeleme
9
17
Notasyonlar
Çalışmalarda
  İstenen sınıflar için D ,
  Tahmin çıkışları için Y ,
  Giriş verisi için X ,
  Girişin her bir özelliği için Xj ,
  Veri içerisindeki her bir örnek için xi
,
  Giriş veri kümesinin tamamı için X
notasyonları tercih edilmektedir.
18
Öğrenme Zamanlaması
  Çevrimiçi (online) öğrenme: Gerçek zamanlı
olarak çalışan sistemlerde öğrenme
aşamasının çalışma anında da sürdürülmesi
gerekiyorsa kullanılır.
  Çevrimdışı (offline) öğrenme: Uygulama
sistemi henüz çalışmaz iken eğitim
gerçekleştirilir, eğitilmiş yöntem sisteme
yüklenir ve sistem çalıştırılır.
10
19
Öğrenme Kuralları
Veriden eğitim için önerilen her algoritma farklı
bir öğrenme kuralı olsa da genel eğilim
algoritmaları ortak özelliklerine göre gruplamak
yönündedir. Öğrenme algoritmaları dört grupta
toplanabilir:
  Hebb
  Delta
  Hopfield
  Kohonen
20
Hebb Öğrenme Kuralı
1949’da geliştirilen ilk öğrenme kuralıdır. “Bir
hücre, bağlı olduğu diğer hücreleri etkiler”
prensibine dayalıdır. Bu öğrenme kuralı
geliştirilerek farklı öğrenme kuralları
geliştirilmiştir.
11
21
Delta Öğrenme Kuralı
Beklenen sonuç ve hesaplanan sonuç arasındaki
karesel fark, sistemin hatasıdır. Bu hatayı
indirgemek için hücreler arasındaki bağlantılar
sürekli değiştirilir. Çok katmanlı algılayıcı ağlar
bu kurala göre eğitilirler.
22
Hopfield Öğrenme Kuralı
Beklenen sonuç ile hesaplanan sonuç aynı ise
hücreler arası bağlar belirli bir oranda
güçlendirilir, aksi durumda bağlar zayıflatılır.
Recurrent ve Elman ağları bu kural ile eğitilirler.
12
23
Kohonen Öğrenme Kuralı
Bu danışmansız modelde hücreler yarış
halindedir. En büyük sonucu üreten hücre yarışı
kazanır. Kazanan hücrenin ve komşularının
bağları güçlendirilir. ART (Adaptive Resonance
Theory) ve Kohonen tarafından geliştirilen SOM
(Self Organizing Map) ağları örnek olarak
verilebilir.
24
Veri Hazırlama
Sınıflandırma veya tahmin için problem uzayını
tam olarak temsil edebilen veri kümesi
hazırlamak gerekmektedir.
13
25
Veri Hazırlama
Çözüm için hazırlanan veri, hem eğitim hem de
başarı ölçümünde kullanıldığı için genellikle
ikiye ayrılır.
26
Sınıflandırma Geçerliği
Veriye dayalı olarak eğitim yapılmasının temel
amacı eğitilen sistemin benzer konuda hiç
bilinmeyen bir örneğe mantıklı bir cevap
üretebilmesidir. Eldeki sınırlı veri kullanılarak
sistemin hem eğitilmesi hem de başarısının
tarafsız bir şekilde ölçülebilmesi gerekmektedir.
Bunun için çapraz geçerlik (cross validation)
adıyla anılan yöntemler kullanılmalıdır.
14
27
Çapraz Geçerlik
(Cross Validation)
Bu temel prensibe dayanarak önerilmiş birkaç
geçerlik yöntemi vardır. Ama hepsinde temel
mantık aynıdır. Sistemin başarısını ölçebilmek
için mevcut veri kümesi ikiye bölünür. Birisi
eğitim için (train set) diğeri de sistemin hiç
görmediği olası örnekleri temsilen (test set)
kullanılır. Sistem, seçilen eğitim algoritması ile
eğitim kümesini öğrenir. Eğitilen sistemin
başarısı daha sonra test kümesi üzerinde
hesaplanır.
28
Çapraz Geçerlik Yöntemleri
Üç tip çapraz geçerlik yöntemi önerilmiştir:
  Rasgele örnekleme
  K parçalı
  Birini hariç tut
15
29
Rasgele Örneklemeli Geçerlik
Rasgele örneklemede
kümeler rasgele seçilir. Optimum başarı
için birkaç kez tekrarlanır. Çapraz geçerlik
içerisinde en yüksek
başarıyı sağlayan
yöntemdir.
30
K Parçalı ve Birini Hariç Tut
K parçalıda veri, K
adet kümeye ayrılır.
Birisi test kümesi için
ve diğer K-1 küme
birleştirilip eğitim
kümesi için seçilir. Bu
işlem kümeler değiştirilerek K kez tekrarlanır. Genel başarı
için K adet başarı değerinin ortalaması
alınır. Birini hariç tut yöntemi ise N adet örnek
içeren veri için N parçalı çapraz geçerliktir.
16
31
Aşırı Eğitim (Overfitting)
Veri ile iterasyonal eğitim yapan modellerin
hepsinde öğrenme sürecinin zamanı gelince
durdurulması gerekir. Eğitim durdurulmazsa
öğrenilmesi gereken veri içerisindeki tüm
örnekler sistem tarafından ezberlenir ve
bilinmeyen örnekleri tahmin yeteneği azalır.
Aşırı eğitim (overfitting) denilen bu istenmeyen
durum makine öğrenmesinin temel amacı olan
genelleştirme kavramına zarar verir.
32
Eğitim Süresi
Eğitimin ne zaman durdurulması gerektiği
kullanılan algoritmaya bağlıdır. Erken durdurma
yapılırsa sistem veriyi tam öğrenemediği için
başarı düşecektir. Aşırı eğitimde de modelin
genelleştirme yeteneği zarar göreceği için
benzer şekilde başarı kötü yönde etkilenecektir.
1
1
Makine Ögrenmesi
2. hafta
  Uzaklığa dayalı gruplandırma
  K-means kümeleme
  K-NN sınıflayıcı
2
Uzaklığa dayalı gruplandırma
Makine öğrenmesinde amaç birbirine en çok
benzeyen veri noktalarını aynı grup içerisinde
birarada tutmaktır. Benzerlik kavramı çoğu kez
uzaklığın tersiyle ifade edilir. Farklı hesaplara
dayanan birçok sınıflandırma veya kümeleme
algoritmalarından bazıları uzaklık ölçütü ile
gruplandırma yapar.
2
3
Benzerlik
4
Benzerlik vs. Uzaklık
Uzaklık için en çok kullanılan ölçüt Öklit
(Euclidean distance) uzaklığıdır. İki nokta (n
boyutlu) arasındaki uzaklık şöyle
hesaplanır:
Benzerlik ise genellikle uzaklığın tersidir.
2 2
2 2
2
1 1
( ) ( ) ... ( )
ab n n
d = a −b = a − b + a − b + + a − b
a b
sab
+ −
=
1
1
3
5
Benzerlik vs. Uzaklık
Fakat uzaklık hesabı için Öklit dışında
önerilmiş Mahalanobis, Manhattan ve
Chebyshev gibi farklı birçok ölçüt
bulunmaktadır. Benzerlik ölçütü de her
zaman uzaklık ile ilişkili olmak zorunda
değildir. Literatürde uzaklığa dayalı,
olasılıksal ve özellik tabanlı gibi farklı
temellere dayanan birçok benzerlik ölçütü
önerilmiştir.
6
Uzaklığa dayalı kümeleme
Kümeleme, sınıf bilgisi içermeyen veri
içerisinde benzerliği yüksek noktaları
gruplama işlemidir. Bu tanımdaki “benzerliği
yüksek” terimini “benzersizliği düşük”
şeklinde değiştirebiliriz. Böylece benzersizlik
için uzaklık ölçütü kullanılabilir.
Uzaklığı kullanarak kümeleme yapan en
popüler ve çoğunlukla en başarılı yöntem Kmeans algoritmasıdır.
4
7
K Ortalamalar (K-means)
Veri içerisinden rasgele
seçilen K adet noktaya
küme merkezi gözüyle
bakılır. Tüm veri
noktaları bu küme
merkezlerine
uzaklıklarına göre
gruplanır. Her
gruplamadan sonra
küme merkezleri tekrar
hesaplanır.
8
K Ortalamalar (K-means)
Her gruplama ve küme merkezinin tekrar
hesabı işlemi bir iterasyon içerisinde
gerçekleştirilir. Algoritmanın kaç iterasyon
yapacağı çoğu kez J maliyet fonksiyonu ile
tespit edilir.
Maliyet fonksiyonu tüm küme merkezlerinin en
uygun konumda olduğu durumda minimum
değerde olmalıdır.
∑ ∑ =






= −
K
i k
k i
J x c
1
2
5
9
K-means Algoritması
1. Rasgele K adet küme merkezi belirle.
2. Her veri noktasını en yakın küme
merkezine göre bir gruba yerleştir.
3. Her gruba atanan tüm veri noktalarının
ortalamasını alarak küme merkezini
güncelle.
4. Grup üyelerinde değişim olmayana kadar 2.
adıma git. Bazen değişim, sıfıra yakın bir değerde uzun
zaman sürebilir. O zaman maliyet fonksiyonu belirli bir
değere düşünce veya toplam iterasyon sayısı belirli bir
değere ulaşınca algoritma durdurulur.
10
K-means Dezavantajları
  Rasgele noktalar ile başladığından elde edilen
her sonuç kararlı değildir.
  Küme sayısı birçok kümeleme algoritmasında
olduğu gibi dışarıdan istenilir.
  Konkav (konvex olmayan) küme şekillerinde
başarılı değildir.
  Keskin kümeleme yapar. Ama uygulamada
gruplar genelde içiçedir (overlapping).
  Aykırı değerlere (outlier) karşı hassastır.
6
11
MATLAB Uygulaması
X = [rand(20,2)+0.3*ones(20,2); rand(20,2)-0.3*ones(20,2)];
opts = statset('maxiter',1);
C = X(1:2,:);
plot(X(:,1), X(:,2), 'k.', 'MarkerSize', 12);
hold on;
plot(C(:,1), C(:,2), 'kx', 'MarkerSize', 12, 'LineWidth', 2);
axis([-1.1 2.1 -1.1 2.1]);
for i=1:5
pause;
hold off;
[idx,C] = kmeans(X,2,'Options',opts,'start',C);
plot(X(idx==1,1), X(idx==1,2), 'r.', 'MarkerSize', 12);
hold on;
plot(X(idx==2,1), X(idx==2,2), 'b.', 'MarkerSize', 12);
plot(C(:,1), C(:,2), 'kx', 'MarkerSize', 12, 'LineWidth', 2);
axis([-1.1 2.1 -1.1 2.1]);
legend('Cluster 1', 'Cluster 2', 'Centroids', 'Location', 'NW');
end
12
ÖDEVLER
  Agglomerative
  Divisive
  BIRCH
  STING
  Chameleon
  OPTICS
  CURE
  DBSCAN
  CLARANS
7
13
Uzaklığa dayalı sınıflandırma
Sınıflandırma, veri içerisindeki noktaları
hem özellik uzayındaki hem de sınıf
bilgisindeki benzerliklere göre gruplama
işlemidir. Daha önce bahsedildiği gibi
yüksek benzerlik terimi düşük uzaklık
olarak kullanılmaktadır. Veri noktaları
arasındaki uzaklıkları kullanarak sınıflandırma yapan en popüler yöntem K en
yakın komşu (K-NN) yöntemidir.
14
K en yakın komşu (K-NN)
Bir a noktasının sınıfını belirlemek için
veride bulunan tüm xi noktaları kullanılır. K
değeri, bilinmeyen noktaya en yakın kaç
adet sınıflı noktanın kullanılacağını belirler.
Örneğin 1-NN için hedef sınıf, bilinmeyen
noktaya en yakın sınıflı veri noktası
tarafından belirlenir. 3-NN için hedef sınıf
ise bilinmeyen noktaya en yakın 3 adet
sınıflı noktadan çoğunluğu sağlayan sınıf
olmalıdır.
8
15
K en yakın komşu (K-NN)
Farklı K değerleri için
16
K-NN Algoritması
  K değeri dışarıdan istenir.
  Sınıfı bilinmeyen noktaya sınıflı veri
noktalarının uzaklıkları hesaplanır. Genelde
Öklit uzaklığı kullanılır.
  Hesaplanan uzaklıklar sıralanır. En küçük
uzaklığa sahip (en yakın) K adet sınıflı veri
noktası tespit edilir.
  Seçilen K adet sınıflı veri noktası içerisinde
çoğunluğa sahip sınıf belirlenir. Bu sınıf,
bilinmeyen nokta için kestirim sonucudur.
9
17
K-NN Dezavatajları
  Bellek tabanlı bir sınıflayıcıdır. Sınıflı veri
noktaları sürekli hafızada tutulmalıdır. Veri
kümesi çok büyük olduğunda hesaplama
süresi de kötüleşir.
  Hesaplamaya tüm özellikler katıldığı için
gereksiz veya ilgisiz özellikler sınıflandırmayı
kötü yönde etkileyebilir.
  Sınıflandırma başarısı açısından genellikle
yapay sinir ağları gibi gelişmiş sınıflandırma
tekniklerinin gerisinde kalır.
18
MATLAB Uygulaması
Rasgele üretilen X, D eğitim matrisleri
yardımıyla rasgele oluşturulan A matrisindeki
örneklerin sınıflarını (Y) bulmak istiyoruz.
X=rand(10,2);
D=fix(2*rand(10,1));
A=rand(5,2);
10
19
MATLAB Uygulaması
%%K=1 için uygulama sonucu
Y=knnclassify(A,X,D,1);
figure; plot(X(D==1,1),X(D==1,2),'r.');
hold on; plot(X(D==0,1),X(D==0,2),'b.');
plot(A(Y==1,1),A(Y==1,2),'ro');
plot(A(Y==0,1),A(Y==0,2),'bo');
axis([-0.1 1.1, -0.1 1.1]);
20
MATLAB Uygulaması
%%K=3 için uygulama sonucu
Y=knnclassify(A,X,D,3);
figure; plot(X(D==1,1),X(D==1,2),'r.');
hold on; plot(X(D==0,1),X(D==0,2),'b.');
plot(A(Y==1,1),A(Y==1,2),'ro');
plot(A(Y==0,1),A(Y==0,2),'bo');
axis([-0.1 1.1, -0.1 1.1]);
11
21
ÖDEV
Herhangi bir sınıflandırma örneğini K-NN ile
sınıflandırmada aşağıdaki uzaklık ölçütlerini
karşılaştırınız.
  Euclid
  Manhattan
  Chebyshev
  Mahalanobis
1
1
Makine Ögrenmesi
3. hafta
  Entropi
  Karar Ağaçları (Desicion Trees)
  ID3
  C4.5
  Sınıflandırma ve Regresyon Ağaçları (CART)
2
Karar Ağacı Nedir?
Temel fikir, giriş verisinin bir kümeleme algoritması yardımıyla tekrar tekrar gruplara bölünmesine dayanır.
Grubun tüm elemanları aynı sınıf etiketine sahip
olana kadar kümeleme işlemi derinlemesine
devam eder.
2
3
Karar Ağacı Nedir?
Hava
Nem
Evet
Rüzgar
Güneşli
Bulutlu
Yağmurlu
Evet
Hayır Evet
Hayır
Yüksek Normal Kuvvetli Hafif
4
Karar Ağacı Tipleri
Entropiye dayalı sınıflandırma ağaçları (ID3,
C4.5) ve Regresyon ağaçları (CART) olmak
üzere iki kategoride birçok algoritma
önerilmiştir.
Önce entropiye dayalı karar ağaçlarını
inceleyeceğiz. Bu algoritmaları iyi anlayabilmek
için önce entropiyi iyi bilmek gerekmektedir.
3
5
Entropi, Belirsizlik ve
Enformasyon
Rassal bir değişkenin belirsizlik ölçütü olarak
bilinen Entropi, bir süreç için tüm örnekler
tarafından içerilen enformasyonun beklenen
değeridir. Enformasyon ise rassal bir olayın
gerçekleşmesine ilişkin bir bilgi ölçütüdür. Eşit
olasılıklı durumlar yüksek belirsizliği temsil eder.
Shannon’a göre bir sistemdeki durum
değiştiğinde entropideki değişim kazanılan
enformasyonu tanımlar. Buna göre maksimum
belirsizlik durumundaki değişim muhtemelen
maksimum enformasyonu sağlayacaktır.
6
Enformasyon
Aslında zıt şeyleri temsil etmelerine rağmen
Shannon’a göre maksimum belirsizlik maksimum enformasyon sağladığı için Enformasyon
ve Belirsizlik terimleri benzerdir. Enformasyon
(self-information) formülü aşağıdaki gibidir.
Shannon, bilgiyi bitlerle temsil ettiği için
logaritmayı iki tabanında kullanmıştır.
log ( )
( )
1
( ) log P x
P x
I x = = −
4
7
Entropi
Shannon’a göre entropi, iletilen bir mesajın
taşıdığı enformasyonun beklenen değeridir.
Shannon Entropisi (H) adıyla anılan terim,
tüm ai durumlarına ait Pi olasılıklarına bağlı
bir değerdir.
∑ ∑
∑
= =
≤ ≤
= = −
= =
n
i
i i
n
i i
i
i n
i i
P P
P x
P x
H X E I X P x I x
1
2
1
2
1
log
( )
1
( )log
( ) ( ( )) ( ). ( )
8
Entropi
Bir paranın havaya atılması olayı, rassal X sürecini temsil etsin. Yazı ve tura gelme olasılıkları eşit olduğu için X sürecinin entropisi aşağıdaki gibidir.
Entropisi 1 olan para atma olayı (X) gerçekleştiğinde 1 bitlik bilgi kazanılacaktır.
5.0( log 5.0 5.0 log )5.0 1
( ) log
2 2
2
1
2
= − + =
= −∑
i=
i i H X p p
5
9
Karar Ağacında Entropi
Karar ağaçları çok boyutlu (özellikli) veriyi
belirlenmiş özellik üzerindeki bir şart ile
parçalara böler. Her seferinde verinin hangi
özelliği üzerinde hangi şarta göre işlem
yapacağına karar vermek çok büyük bir kombinasyonun çözümüyle mümkündür. 5 özellik ve
20 örneğe sahip bir veride 106 dan fazla sayıda
farklı karar ağacı oluşturulabilir. Bu sebeple her
parçalanmanın metodolojik olması gerekir.
10
Karar Ağacında Entropi
Quinlan’e göre veri, bir özelliğe göre bölündüğünde elde edilen her bir veri kümesinin belirsizliği minimum ve dolayısıyla bilgi kazancı maksimum ise en iyi seçim yapılmış demektir. Buna
göre önerdiği ilk algoritma ID3’te tek tek özellik
vektörleri incelenir ve en yüksek bilgi kazancına
sahip özellik, ağaçta dallanma yapmak için
tercih edilir.
6
11
ID3 Algoritması
Sadece kategorik veri ile çalışan bir yöntemdir.
Her iterasyonun ilk adımında veri örneklerine ait
sınıf bilgilerini taşıyan vektörün entropisi belirlenir. Daha sonra özellik vektörlerinin sınıfa bağımlı entropileri hesaplanarak ilk adımda hesaplanan entropiden çıkartılır. Bu şekilde elde edilen değer ilgili özellik vektörüne ait kazanç değeridir. En büyük kazanca sahip özellik vektörü
ağacın o iterasyonda belirlenen dallanmasını
gerçekleştirir.
12
ID3 Örneği
B D F
B D E
B C F
A C E
V1 V2 S 2 özellik vektörü (V1 ve
V2) ile S sınıf vektörüne
sahip 4 örnekli veri kümesi
verilmiştir. ID3 algoritması
ile ilk dallanma hangi özellik üzerinde gerçekleşir ?
H(S) - H(V1,S)
H(S) - H(V2,S)
7
13
ID3 Örneği
B D F
B D E
B C F
A C E
V1 V2 S
Sınıf Entropisi
1
2
1
log
2
1
2
1
log
2
1
( )
2 2  =





H S = − +
V1 Entropisi
0,9183 0,6887
4
3
0
3
2
log
3
2
3
1
log
3
1
4
3
0
4
1
( )
4
3
( )
4
1
( )1
2 2
= + =






= − +
H V = H A + H B
V2 Entropisi
1
2
1
2
1
( )
2
1
( )
2
1
H(V )2 = H C + H D = + = V1 seçilir...
14
C4.5 Algoritması
ID3 algoritmasının nümerik özellik içeren veriye
uygulanabilen şeklidir. ID3’ten tek farkı nümerik
özelliklerin kategorik hale getirilebilmesini sağlayan bir eşikleme yöntemini içermesidir. Temel
mantık nümerik özellik vektöründeki tüm değerler ikili olarak ele alınarak ortalamaları eşik olarak denenir. Hangi eşik değeriyle bilgi kazanımı
en iyi ise o değer seçilir. Seçilen eşiğe göre
özellik vektörü kategorize edilir ve ID3
uygulanır.
8
15
Kayıp Veri
Eğer veride bazı örneklerin bazı özellikleri
kayıpsa izlenecek iki yol vardır:
  Kayıp özelliklere sahip örnek veriden tamamen
çıkartılır.
  Kayıp verilerle çalışabilecek şekilde algoritma
düzenlenir.
Eğer kayıplı örneklerin sayısı birinci seçenek
uygulanamayacak kadar çoksa ikinci seçenek
uygulanmalıdır.
16
Kayıp Veri
Kayıp bilgiye sahip özellik vektörü için
kazanç hesaplanırken kayıplı örnekler hariç
tutularak bilgi kazancı normal şekilde
hesaplanır ve daha sonra F katsayısıyla
çarpılır. F, kayıpsız verinin tamamına
oranıdır.
IG(X ) = F.(H(X ) − H(V, X ))
9
17
Kayıp Veri
Kayıp bilgiye sahip özellik vektörü içinde en
sık tekrarlanan değerin, kayıp bilgi yerine
yazılması da önerilen yöntemlerden birisidir.
18
Ezber (Overfitting)
Tüm makine öğrenmesi yöntemlerinde
verinin ana hatlarının modellenmesi esas
alındığı için öğrenme modelinde ezberden
(overfitting) kaçınılmalıdır. Tüm karar
ağaçları önlem alınmazsa ezber yapar. Bu
yüzden ağaç oluşturulurken veya
oluşturulduktan sonra budama yapılmalıdır.
10
19
Ağaç Budama
Budama, sınıflandırmaya katkısı olmayan
bölümlerin karar ağacından çıkarılması
işlemidir. Bu sayede karar ağacı hem sade
hem de anlaşılabilir hale gelir. İki çeşit
budama yöntemi vardır;
  ön budama
  sonradan budama
20
Ön Budama
Ön budama işlemi ağaç oluşturulurken
yapılır. Bölünen nitelikler, değerleri belli bir
eşik değerinin (hata toleransının) üstünde
değilse o noktada ağaç bölümleme işlemi
durdurulur ve o an elde bulunan kümedeki
baskın sınıf etiketi, yaprak olarak
oluşturulur.
11
21
Sonradan Budama
Sonradan budama işlemi, ağaç oluşturulduktan sonra devreye girer. Alt ağaçları silerek
yaprak oluşturma, alt ağaçları yükseltme, dal
kesme şeklinde yapılabilir.
22
Ağaç Budama
Hava
Nem
Evet
15
Rüzgar
Güneşli
Bulutlu
Yağmurlu
Evet
20
Evet
15
Hayır
35
Hayır
25
Yüksek Normal Kuvvetli Hafif
Hata toleransı %33 seçilirse “Nem” düğümünün alt dallarındaki “Evet”
oranı %30’dur. Bu yüzden “Nem” düğümü budanıp yerine “Hayır” yaprağı
konur.
12
23
Ağaç Budama
Hava
Evet
Rüzgar
Güneşli
Bulutlu
Yağmurlu
Evet
Hayır
Hayır
Kuvvetli Hafif
24
Sınıflandırma ve Regresyon
Ağaçları (CART)
CART karar ağaçlarının temel prensibi herbir
düğümde ağacı iki dala ayırmasıdır. En çok
bilinen iki algoritması:
  Twoing algoritması
  Gini algoritması
13
25
ÖDEVLER
Aşağıdaki CART algoritmalarını MATLAB’de
hazırlayınız.
  Twoing
  Gini
1
1
VERİ MADENCİLİĞİ
Farklı Sınıflandırma Yöntemleri
Yrd. Doç. Dr. Şule Gündüz Öğüdücü
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 2
Konular
 Sınıflandırma yöntemleri
 Örnek tabanlı yöntemler
 k-En Yakın Komşu Yöntemi
 Genetik Algoritmalar
 Destek Vektör Makineleri
 Bulanık Küme Sınıflandırıcılar
 Öngörü
 Eğri Uydurma
 Model Değerlendirme
 Öğrenme, sınama, geçerleme kümelerini oluşturma
 Sınıflandırıcıları birleştirme
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 3
Örnek Tabanlı Yöntemler
 Örnek tabanlı sınıflandırma:
 Öğrenme kümesi saklanır
 Sınıflandırılacak yeni bir örnek geldiğinde
öğrenme kümesi sınıf etiketini öngörmek için
kullanılır (tembel (lazy) yöntemler)
 Yöntemler
 k-en yakın komşu yöntemi
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 4
Örnek Tabanlı Yöntemler
Nit1 ……... NitN Sınıf
A
B
B
C
A
C
B
Öğrenme Kümesi
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 5
En Yakın Komşu Yöntemi
 Temel yaklaşım: Sınıflandırılmak istenen örneğe en yakın örnekleri
bul.
Örnek: ördek gibi yürüyor, ördek gibi bağırıyor
=> büyük olasılıkla ördek
Öğrenme
Örnekleri
Sınama
Örneği
Uzaklık
hesapla
en yakın k adet
örnek seç
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 6
En Yakın Komşu Sınıflandırıcı
 Bütün örnekler n-boyutlu uzayda
bir noktaya karşı düşürülür
 Nesneler arasındaki uzaklık
(Öklid uzaklığı)
 Öğrenilen fonksiyon ayrık değerli
veya gerçel değerli olabilir
 Ayrık değerli fonksiyonlarda kkomşu algoritması Xq örneğine
en yakın k öğrenme örneğinde
en çok görülen sınıf değerini
verir
 Sürekli değerli fonksiyonlarda en
yakın k öğrenme örneğinin
ortalaması alınır
2
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 7
K-En Yakın Komşu Yöntemi
 Xq örneği 1-en yakın
komşuya göre pozitif
olarak, 5-en yakın
komşuya göre negatif
olarak sınıflandırılır
.
_
+
_ xq
+
_ _
+
_
_
+
.
. .
. .
 Voronoi diyagramları:
Her öğrenme örneğini
çevreleyen dışbükey
çokgenlerden oluşan
karar yüzeyi
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 8
K-En Yakın Komşu Yöntemi
 Uzaklık-ağırlıklı k-en yakın komşu algoritması
 Öğrenme kümesindeki örneklere (xi
), sınıflandırılmak
istenen örneğe (xq) olan uzaklıklarına göre ağırlıklar
verilmesi
 yakın örneklerin ağırlığı daha fazla
 k-en yakın komşunun ortalaması alındığı için gürültülü
veriden az etkileniyor
 İlgisiz nitelikler uzaklığı etkileyebilir
 bu nitelikler uzaklık hesaplarken kullanılmayabilir
w d xq x
i
≡ 1 2 ( ,)
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 9
Konular
 Sınıflandırma yöntemleri
 Örnek tabanlı yöntemler
 k-En Yakın Komşu Yöntemi
 Genetik Algoritmalar
 Destek Vektör Makineleri
 Bulanık Küme Sınıflandırıcılar
 Öngörü
 Eğri Uydurma
 Model Değerlendirme
 Öğrenme, sınama, geçerleme kümelerini oluşturma
 Sınıflandırıcıları birleştirme
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 10
Genetik Algoritmalar
 Optimizasyon amaçlı
 Bir başlangıç çözümü öneriyor, tekrarlanan her ara
adımda daha iyi çözüm üretmeye çalışıyor.
 Doğal evrime ve en iyi olanın yaşamını sürdürmesine
dayanıyor
 Çözümü birey olarak sunuyor.
 Birey: I=I1,I2,…,In – Ij kullanılan alfabenin bir karakteri
 gen: Ij
 Toplum: Bireylerden oluşan küme
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 11
Genetik Algoritmalar
 Genetik Algoritmalar (GA) 5 parçadan oluşuyor:
 Bireylerden oluşan bir başlangıç kümesi, P
 Çaprazlama (Crossover): Bir anne babadan yeni
bireyler üretmek için yapılan işlem
 Mutasyon: Bir bireyi rastgele değiştirme
 Uygunluk (fitness): En iyi bireyleri belirleme
 Çaprazlama ve mutasyon tekniklerini uygulayan
ve uygunluk fonksiyonuna göre toplum içindeki
en iyi bireyleri seçen algoritma
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 12
Çaprazlama Örnekleri
111 111
000 000
Parents Children
111 000
000 111
a) Single Crossover
111 111
Parents Children
111 000
000
a) Single Crossover
111 111
000 000
Parents
a) Multiple Crossover
000
Children
111 000
00 000 111
11
00
11
3
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 13
Genetik Algoritma
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 14
GA – Avantajlar, Dezavantajlar
 Avantaj
 Paralel çalışabilir
 NP karmaşık problem çözümlerine uygun
 Dezavantaj
 Son kullanıcının modeli anlaması güç
 Problemi GA ile çözmeye uygun hale getirmek
zor
 Uygunluk fonksiyonunu belirlemek zor
 Çaprazlama ve mutasyon tekniklerini belirlemek
zor
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 15
Konular
 Sınıflandırma yöntemleri
 Örnek tabanlı yöntemler
 k-En Yakın Komşu Yöntemi
 Genetik Algoritmalar
 Destek Vektör Makineleri
 Bulanık Küme Sınıflandırıcılar
 Öngörü
 Eğri Uydurma
 Model Değerlendirme
 Öğrenme, sınama, geçerleme kümelerini oluşturma
 Sınıflandırıcıları birleştirme
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 16
Destek Vektör Makineleri
 Hem doğrusal olarak ayırt edilebilen hem de
edilemeyen veri kümesini sınıflandırabilir
 Doğrusal olmayan bir eşlem ile n boyutlu veri kümesi
m > n olacak şekilde m boyutlu yeni bir veri kümesine
dönüştürülür
 Yüksek boyutta doğrusal sınıflandırma işlemi yapılır
 Uygun bir dönüşüm ile her zaman veri bir hiper düzlem
ile iki sınıfa ayrılabilir
 Hiper düzleme en yakın öğrenme verileri destek
vektörleri olarak adlandırılır
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 17
Destek Vektör Makineleri
 Destek Vektör Makineleri (Support Vector Machines
SVM): Veriyi ayıracak doğrusal bir sınır
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 18
Destek Vektör Makineleri
 Bir çözüm
B1
4
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 19
Destek Vektör Makineleri
 Başka bir çözüm
B2
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 20
Destek Vektör Makineleri
 Diğer çözümler
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 21
Destek Vektör Makineleri
 Hangisi daha iyi? B1 mi, B2 mi?
 Daha iyi nasıl tanımlanır?
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 22
Destek Vektör Makineleri
 Farklı sınıftan örnekler arasındaki uzaklığı enbüyüten hiper
düzlemi bul => B1, B2’den daha iyi
B1
B2
b11
b12
b21
b22
margin
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 23
Destek Vektör Makineleri
(w·x1)+b=yi
=+1
(w·x2)+b=yi
=-1
=>w·(x1-x2)=2
=> w · (x1-x2)= 2
||w|| ||w||
w• x + b = −1 r r
w• x + b = +1 r r
w• x + b = 0 r r
yi
=+1
yi
=-1
x2
x1
.
w
(w·x) + b ≥ +1, yi
=+1
(w·x) + b ≤ -1, yi
=-1
=>yi
(w·x + b) ≥ +1
H H2
H1
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 24
Destek Vektör Makineleri
 enbüyük olması isteniyor
 yi
(w·x + b) ≥ +1 olacak şekilde enküçük olmalı
 kısıtlı eniyileme (constraint optimization) problem
 Problem
2
||w||2
||w||2
2
∑ [ ] =
= − ⋅ + −
N
i
Lp w i yi i b 1
2
( ) 1
2
1 α w x
α1…αN bulunması
Σαi - ½ΣΣαi
αj
yi
yj
xi
Txj en büyük olacak
kısıtlar:
(1) Σαi
yi = 0
(2) αi ≥ 0, ∀αi
5
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 25
Eniyileme Problemi Çözümü
 Çözüm
 Sınıflandırma fonksiyonu
 f(x) = 1 ise x pozitif olarak, diğer durumlarda
negatif olarak sınıflandırılıyor.
w =Σαi
yi
xi b= yk- wTxk ∀ xk , αk≠ 0
f(x) = Σαi
yi
xi
Tx + b
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 26
Destek Vektör Makineleri
 Öğrenme kümesi doğrusal olarak ayrılamıyor
 ξi değişkenleri ekleniyor
ξi
ξi
(w·x) + b ≥ +1- ξi
, yi
=+1
(w·x) + b ≤ -1- ξi
, yi
=-1
=>yi
(w·x + b) ≥ +1- ξi
ξi ≥ 0, ∀i
 Problem:
α1…αN bulunması
Σαi - ½ΣΣαi
αj
yi
yj
xi
Txj en büyük olacak
kısıtlar:
(1) Σαi
yi = 0
(2) 0 ≤ αi ≤ C, ∀αi
k N
i
Lp w C i ⎟
⎠
⎞ ⎜
⎝
⎛ = − ∑=1
2
2
1 ξ
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 27
Eniyileme Problemi Çözümü
 Çözüm
 Sınıflandırma fonksiyonu
w =Σαi
yi
xi
b= yk(1- ξk) – wTxk, k = argmax αk
f(x) = Σαi
yi
xi
Tx + b
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 28
DVM Uygulamaları
 Boser, Guyon ve Vapnik tarafından 1992 yılında
önerildi. 1990’ların sonlarına doğru yaygın
olarak kullanılmaya başlandı
 DVM için en yaygın eniyileme algoritmaları SMO
[Platt ’99] ve SVMlight [Joachims’ 99]
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 29
Konular
 Sınıflandırma yöntemleri
 Örnek tabanlı yöntemler
 k-En Yakın Komşu Yöntemi
 Genetik Algoritmalar
 Destek Vektör Makineleri
 Bulanık Küme Sınıflandırıcılar
 Öngörü
 Eğri Uydurma
 Model Değerlendirme
 Öğrenme, sınama, geçerleme kümelerini oluşturma
 Sınıflandırıcıları birleştirme
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 30
Bulanık Küme
Sınıflandırıcılar
 Bulanık mantık 0.0 ve 1.0 arasında gerçel
değerler kullanarak üyelik dereceleri hesaplar
 Nitelik değerleri bulanık değerlere
dönüştürülür
 Kurallar kümesi oluşturulur
 Yeni bir örneği sınıflandırmak için birden fazla
kural kullanılır
 Her kuraldan gelen sonuç toplanır
6
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 31
Konular
 Sınıflandırma yöntemleri
 Örnek tabanlı yöntemler
 k-En Yakın Komşu Yöntemi
 Genetik Algoritmalar
 Destek Vektör Makineleri
 Bulanık Küme Sınıflandırıcılar
 Öngörü
 Eğri Uydurma
 Model Değerlendirme
 Öğrenme, sınama, geçerleme kümelerini oluşturma
 Sınıflandırıcıları birleştirme
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 32
Öngörü
 Sınıflandırma problemleriyle aynı yaklaşım
 model oluştur
 bilinmeyen değeri hesaplamak için modeli kullan
 eğri uydurma
 doğrusal
 doğrusal olmayan
 Sınıflandırma ayrık değerli
 Öngörü sürekli değerli
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 33
Eğri Uydurma
 Doğrusal eğri uydurma:
 en basit eğri uydurma yöntemi
 veri doğrusal bir eğri ile modellenir.
 veri kümesindeki niteliklerin doğrusal fonksiyonu
 öğrenme kümesindeki yi sınıfından bir xi örneği için çıkış
 karesel hatayı enküçültecek ağırlıkları bulma
k k y = w + w a + w a +...+ w a 0 1 1 2 2
∑=
= + + + + =
k
j
i i i k ik j ij y w x w x w x w x w x 0
0 0 1 1 2 2 ...
2
1 0
∑ ∑ = = ⎟
⎟
⎠
⎞
⎜
⎜
⎝
⎛ −
n
i
k
j
i j ij y w x
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 34
Konular
 Sınıflandırma yöntemleri
 Model Değerlendirme
 Hata oranı
 Anma
 Kesinlik
 F-ölçütü
 ROC eğrileri
 Öğrenme, sınama, geçerleme kümelerini oluşturma
 Sınıflandırıcıları birleştirme
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 35
Sınıflandırma Modelini Değerlendirme
 Model başarımını değerlendirme ölçütleri
nelerdir?
 Hata oranı
 Anma
 Kesinlik
 F-ölçütü
 Farklı modellerin başarımı nasıl karşılaştırılır?
 ROC
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 36
Sınıflandırma Hatası
 Sınıflandırma yöntemlerinin hatalarını ölçme
 başarı: örnek doğru sınıfa atandı
 hata: örnek yanlış sınıfa atandı
 hata oranı: hata sayısının toplam örnek sayısına
bölünmesi
 Hata oranı sınama kümesi kullanılarak
hesaplanır
7
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 37
Model Başarımını Değerlendirme
 Model başarımını değerlendirme ölçütleri
 modelin ne kadar doğru sınıflandırma yaptığını ölçer
 hız, ölçeklenebilirlik gibi özellikleri değerlendirmez
 Karışıklık matrisi:
Sınıf =-1 c d
Sınıf =1 a b
Sınıf=1 Sınıf=-1
DOĞRU
SINIF
ÖNGÖRÜLEN SINIF
a: TP (true positive)
b: FN (false negative)
c: FP (false positive)
d: TN (true negative)
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 38
Model Başarımını Değerlendirme: Doğruluk
 Modelin başarımı:
d
(TN)
c
(FP)
-1
b
(FN)
a
(TP)
+1
+1 -1
DOĞRU
SINIF
ÖNGÖRÜLEN SINIF
TP TN FP FN
FN FP
a b c d
b c Hata Orani
TP TN FP FN
TP TN
a b c d
a d Dogruluk
+ + +
+ = + + +
+ =
+ + +
+ = + + +
+ =
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 39
Örnek
 Hangi sınıflandırıcı daha iyi?
 B ve C, A’dan daha iyi bir sınıflandırıcı
 B, C’den daha iyi bir sınıflandırıcı mı?
FP=25 TN=25
TP=25 FN=25
Sınıflandırıcı A
FP=25 TN=25
TP=50 FN=0
Sınıflandırıcı B
FP=0 TN=50
TP=25 FN=25
Sınıflandırıcı C
Doğruluk=%50 Doğruluk=%75 Doğruluk=%75
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 40
Model Başarımını Değerlendirme: Kesinlik
d
(TN)
c
(FP)
-1
b
(FN)
a
(TP)
+1
+1 -1
DOĞRU
SINIF
ÖNGÖRÜLEN SINIF
Kesinlik =
Doğru sınıflandırılmış pozitif örnek sayısı
Pozitif sınıflandırılmış örneklerin sayısı
= TP
TP + FP
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 41
Model Başarımını Değerlendirme: Anma
d
(TN)
c
(FP)
-1
b
(FN)
a
(TP)
+1
+1 -1
DOĞRU
SINIF
ÖNGÖRÜLEN SINIF
Anma =
Doğru sınıflandırılmış pozitif örnek sayısı
Pozitif örneklerin sayısı
= TP
TP + FN
Doğru pozitif oranı
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 42
Anma / Kesinlik
 A modeli B modelinden daha iyi anma ve
kesinlik değerine sahipse A modeli daha iyi bir
sınıflandırıcıdır.
 Kesinlik ve anma arasında ters orantı var.
kesinlik
anma
8
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 43
Sınıflandırıcıları Karşılaştırma
 Doğruluk en basit ölçüt
 Kesinlik ve anma daha iyi ölçme sağlıyor
 Model A’nın kesinliği model B’den daha iyi ancak
model B’nin anma değeri model A’dan daha iyi
olabilir.
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 44
Model Başarımını Değerlendirme: F-ölçütü
 F-ölçütü: Anma ve kesinliğin harmonik
ortalamasını alır.
F-ölçütü =
2 * kesinlik * anma
kesinlik + anma
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 45
ROC (Receiver Operating Characteristic)
 İşaret işlemede bir sezicinin, gürültülü bir kanalda
doğru algılama oranının yanlış alarm oranına karşı
çizdirilen grafiği (algılayıcı işletim eğrisi)
 Farklı sınıflandırıcıları karşılaştırmak için ROC eğrileri
 Doğru pozitif (TPR - y ekseni) oranının yanlış pozitif
(FPR – x ekseni) oranına karşı çizdirilen grafiği
 TPR = TP / (TP + FN)
 FPR = FP / (TN + FP)
 ROC üzerindeki her nokta bir sınıflandırıcının
oluşturduğu bir modele karşı düşer
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 46
ROC Eğrisi
 iki sınıftan oluşan tek boyutlu bir veri kümesi (positive – negative)
 x > t için her örnek pozitif olarak sınıflandırılıyor
t eşik değeri için:
TPR=0.5, FNR=0.5, FPR=0.12, FNR=0.88
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 47
ROC Eğrisi
(FPR,TPR)
 (0,0): Bütün örneklerin
negatif sınıflandırılması
 (1,1): Bütün örneklerin
pozitif sınıflandırılması
 (0,1): ideal durum
 Çapraz çizgi:
 Rastlantısal tahmin
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 48
ROC Eğrilerinin Kullanılması
 Farklı modelleri
karşılaştırmak için
 M1 veya M2 birbirlerine
üstünlük sağlamıyor
 küçük FPR değerleri için
M1 daha iyi
 büyük FPR değerleri için
M2 daha iyi
 ROC eğrisi altında kalan
alan
 ideal = 1
 Rastlantısal tahmin=0.5
9
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 49
ROC Eğrisinin Çizilmesi
 Her örnek için P(+|A)
olasılığı hesaplanır
 P(+|A) değeri azalarak
sıralanır
 Her farklı P(+|A) değeri
için bir eşik değeri
uygulanır
 Her eşik değeri için TP,
FP, TN, FN hesaplanır
10 0.25 +
9 0.43 -
8 0.53 +
7 0.76 -
6 0.85 +
5 0.85 -
4 0.85 -
3 0.87 -
2 0.93 +
1 0.95 +
Örnek P(+|A) Sınıf
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 50
ROC Eğrisinin Çizilmesi Class + - + - - - + - + +
0.25 0.43 0.53 0.76 0.85 0.85 0.85 0.87 0.93 0.95 1.00
TP 5 4 4 3 3 3 3 2 2 1 0
FP 5 5 4 4 3 2 1 1 0 0 0
TN 0 0 1 1 2 3 4 4 5 5 5
FN 0 1 1 2 2 2 2 3 3 4 5
TPR 1 0.8 0.8 0.6 0.6 0.6 0.6 0.4 0.4 0.2 0
FPR 1 1 0.8 0.8 0.6 0.4 0.2 0.2 0 0 0
ROC Eğrisi:
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 51
Model Parametrelerini Belirleme
 Sınama kümesi sınıflandırıcı oluşturmak için kullanılmaz
 Bazı sınıflandırıcılar modeli iki aşamada oluşturur
 modeli oluştur
 parametreleri ayarla
 Sınama kümesi parametreleri ayarlamak için
kullanılmaz
 Uygun yöntem üç veri kümesi kullanma: öğrenme,
geçerleme, sınama
 geçerleme kümesi parametre ayarlamaları için kullanılır
 model oluşturulduktan sonra öğrenme ve geçerleme
kümesi son modeli oluşturmak için kullanılabilir
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 52
Sınıflandırma: Öğrenme, Geçerleme, Sınama
Veri
Sınıflandırma
Y N
Sınıflar
Öğrenme kümesi
Geçerleme Kümesi
+
+
-
-
+
Model Oluşturma
Değerlendirme
+
-
+
-
S Son model ınama Kümesi
+
-
+
-
hata oranı
Model
Oluşturma
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 53
Model Başarımını Tahmin Etme
 Örnek: Doğruluğu %25 olan bir modelin gerçek
başarımı ne kadardır?
 Sınama kümesinin büyüklüğüne bağlı
 Sınıflandırma (hileli) yazı tura atmaya benziyor
 tura doğru sınıflandırma (başarı), yazı yanlış
sınıflandırma (başarısızlık)
 İstatistikte birbirinden bağımsız olayların başarı ya da
başarısızlıkla sonuçlanmaları Bernoulli dağılımı ile
modellenir.
 Gerçek başarı oranını belirlemek için istatistikte güven
aralıkları tanımlanmıştır.
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 54
Güven Aralığı
 p belli bir güvenle belli bir aralıkta bulunmaktadır.
 Örnek: N=1000 olayda S=750 başarı sağlanmış.
 Tahmin edilen başarı oranı: 75%
 Gerçek başarıya ne kadar yakın
 %80 güven ile p∈[73,2 - 76,7]
 Örnek: N=100 olayda S=75 başarı sağlanmış.
 Tahmin edilen başarı oranı: 75%
 Gerçek başarıya ne kadar yakın
 %80 güven ile p∈[69,1 - 80,1]
10
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 55
Ortalama Değer ve Varyans
 Başarı oranı p olan bir Bernoulli dağılımının ortalama
değeri ve varyansı: p, p (1–p)
 N kere tekrarlanan bir deneyin beklenen başarı oranı
f=S/N
 Büyük N değerleri için, f normal dağılım
 f için ortalama değer ve varyans: p, p (1–p)/N
 Ortalama değeri 0 ve varyansı 1 olan X rastlantı
değişkeninin %c güven aralığı :
Pr[–z ≤ X ≤ z]=c
 Simetrik bir dağılım için:
Pr[–z ≤ X ≤ z]=1 – 2*Pr [X ≥ z]
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 56
Güven Sınırları
 Ortalama değeri 0 ve varyansı 1 olan bir normal
dağılımın güven sınırları
 Pr[–1,65 ≤ X ≤ 1,65]=90%
 f’in ortalama değerinin 0, varyansının 1 olacak şekilde
dönüştürülmesi gerekir.
40% 0.25
20% 0.84
10% 1.28
5% 1.65
2.33
2.58
3.09
z
1%
0.5%
0.1%
Pr[X ≥ z]
–1 0 1 1.65
–1 0 1 1.65
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 57
Dönüşüm
 f’in ortalama değerinin 0, varyansının 1 olacak şekilde
dönüştürülmesi için
 Güven aralığı
 p’nin değeri
p p N
f p
(1− )/
−
z c p p N
f p z =⎥
⎦
⎤ ⎢
⎣
⎡ ≤ −
− − ≤
(1 )/
Pr
⎟
⎠
⎞ ⎜
⎝
⎛ + ⎟
⎟
⎠
⎞
⎜
⎜
⎝
⎛ = + ± − + N
z
N
z
N
f
N
f z N
z p f
2
2
2 2 2
1
2 4
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 58
Örnek
 f = 75%, N = 1000, c = 80% (z = 1.28):
p ∈ [0,732 – 0,767]
 f = 75%, N = 100, c = 80% (z = 1.28):
p ∈ [0,691 – 0,801]
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 59
Konular
 Sınıflandırma yöntemleri
 Model Değerlendirme
 Öğrenme, sınama, geçerleme kümelerini
oluşturma
 holdout
 k-kat çapraz geçerleme
 Bootstrap
 Sınıflandırıcıları birleştirme
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 60
Verinin Dengesiz Dağılımı
 Küçük veya dengesiz veri kümeleri için örnekler
tanımlayıcı olmayabilir
 Veri içinde bazı sınıflardan çok az örnek olabilir
 tıbbi veriler: %90 sağlıklı, %10 hastalık
 elektronik ticaret: %99 alışveriş yapmamış, %1 alışveriş
yapmış
 güvenlik: %99 sahtekarlık yapmamış, %1 sahtekarlık
yapmış
 Örnek: Sınıf1: 9990 örnek, Sınıf2: 10 örnek
 bütün örnekleri sınıf1’e atayan bir sınıflandırıcının hata
oranı: 9990 / 10000= %99,9
 hata oranı yanıltıcı bir ölçüt olabilir
11
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 61
Dengeli Dağılım Nasıl Sağlanır?
 Veri kümesinde iki sınıf varsa
 iki sınıfın eşit dağıldığı bir veri kümesi oluştur
 Az örneği olan sınıftan istenen sayıda rasgele
örnekler seç
 Çok örneği olan sınıftan aynı sayıda örnekleri
ekle
 Veri kümesinde iki sınıftan fazla sınıf varsa
 Öğrenme ve sınama kümesini farklı sınıflardan
aynı sayıda örnek olacak şekilde oluştur
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 62
Örnek
¾ holdout
¾ repeated holdout
¾ k-fold cross validation
¾ bootstrapping
Model
Tid Nit1 Nit2 Nit3 Sınıf
1 1 Büyük 125K 0
2 0 Orta 100K 0
3 0 Küçük 70K 0
4 1 Orta 120K 0
5 0 Büyük 95K 1
6 0 Orta 60K 0
7 1 Büyük 220K 0
8 0 Küçük 85K 1
9 0 Orta 75K 0
10 0 Küçük 90K 1 10
Tid Nit1 Nit2 Nit3 Sınıf
11 0 Küçük 55K ?
12 1 Orta 80K ?
13 1 Büyük 110K ?
14 0 Küçük 95K ?
15 0 Büyük 67K ? 10
Sınama
Kümesi
Öğrenme
Algoritması
Öğrenme
Kümesi Uygulama
Öğrenme
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 63
Büyük Veri Kümelerinde Değerlendirme
 Veri dağılımı dengeli ise: Veri kümesindeki
örnek sayısı ve her sınıfa ait örnek sayısı fazla
ise basit bir değerlendirme yeterli
 holdout yöntemi: Belli sayıda örnek sınama için
ayrılır, geriye kalan örnekler öğrenme için
kullanılır
 genelde veri kümesinin 2/3’ü öğrenme, 1/3’i sınama
kümesi olarak ayrılır
 öğrenme kümesi kullanılarak model oluşturulur
ve sınama kümesi kullanılarak model
değerlendirilir
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 64
Tekrarlı Holdout Yöntemini
 Veri kümesini farklı altkümelere bölerek holdout
yöntemini tekrarlama
 Her eğitme işleminde veri kümesinin belli bir
bölümü öğrenme kümesi olarak rasgele ayrılır
 Modelin hata oranı, işlemler sonunda elde edilen
modellerin hata oranlarının ortalaması
 Problem: Farklı eğitme işlemlerindeki sınama
kümeleri örtüşebilir
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 65
k-Kat Çapraz Geçerleme
 Veri kümesi eşit boyutta k adet farklı gruba ayrılır.
 Bir grup sınama, diğerleri öğrenme için ayrılır.
 Her grup bir kere sınama kümesi olacak şekilde
deneyler k kere tekrarlanır.
Sınama
Kümesi
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 66
Biri Hariç Çapraz Geçerleme
 k-kat çapraz geçerlemenin özel hali
 k sayısı veri kümesindeki örnek sayısına (N) eşit
 Model N-1 örnek üzerinde eğitilir, dışarıda bırakılan 1
örnek üzerinde sınanır
 Bu işlem her örnek 1 kez sınama için kullanılacak
şekilde tekrarlanır
 model N kez eğitilir
 Model başarımı denemelerin başarımının ortalaması
 Verinin en etkin şekilde kullanımı
12
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 67
Bootstrap Yöntemi
 Veri kümesinden yerine koyma yöntemi ile örnekler
seçilerek öğrenme kümesi oluşturulur
 N örnekten oluşan veri kümesinden yerine koyarak N
örnek seçilir
 Bu küme öğrenme kümesi olarak kullanılır
 Öğrenme kümesinde yer almayan örnekler sınama kümesi olarak kullanılır
Örnek 1
Örnek 2
Örnek 3
Örnek 4
Örnek 5
Örnek 1
Örnek 1
Örnek 3
Örnek 3
Örnek 5
Örnek 2
Örnek 4
Veri Öğrenme Kümesi(1)
Sınama Kümesi(1)
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 68
0.632 bootstrap
 N örnekten oluşan bir veri kümesinde bir örneğin
seçilmeme olasılığı:
 Sınama kümesinde yer alma olasılığı:
 Öğrenme kümesi veri kümesindeki örneklerin
%63,2’sinden oluşuyor
N
1 1−
0.368 1 1 1 ⎟ ≈ = ⎠
⎞ ⎜
⎝
⎛ − − e N
N
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 69
Bootstrap Yönteminde Model Hatasını
Belirleme
 Model başarımını sadece sınama kümesi kullanarak
belirleme kötümser bir yaklaşım
 model örneklerin sadece ~%63’lük bölümüyle eğitiliyor
 Model başarımı hem öğrenme kümesindeki hem de
sınama kümesindeki başarım ile değerlendirilir
hata = 0,632 hata(sınama) + 0,368 hata(öğrenme)
 İşlem birkaç kez tekrarlanarak hatanın ortalaması
alınır.
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 70
Konular
 Sınıflandırma yöntemleri
 Model Değerlendirme
 Öğrenme, sınama, geçerleme kümelerini
oluşturma
 Sınıflandırıcıları birleştirme
 Bagging
 Boosting
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 71
Model Başarımını Artırma
 Bir grup sınıflandırıcı kullanma
 Bagging
 Boosting
Veri
Sınıflandırıcı(1)
Sınıflandırıcı(2)
Sınıflandırıcı(3)
Sınıflandırıcı(k)
:
Model
Yeni
Veri
Öğrenme K.(1)
Öğrenme K.(2)
Öğrenme K.(3)
Öğrenme K.(k)
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 72
Bagging
 N örnekten oluşan bir veri kümesinde bootstrap
yöntemi ile T örnek seç
 Bu işlemi k öğrenme kümesi oluşturmak üzere tekrarla
 Aynı sınıflandırma algoritmasını k öğrenme kümesi
üzerinde kullanarak k adet sınıflandırıcı oluştur
 Yeni bir örneği sınıflandırmak için her sınıflandırıcının
sonucunu öğren
 Yeni örnek en çok hangi sınıfa atanmışsa o sınıfın
etiketiyle etiketlendir.
13
http://www.ninova.itu.edu.tr/EgitimDetay.aspx?eId=195/ 73
Boosting
 Öğrenme kümesindeki her örneğin bir ağırlığı
var
 Her öğrenme işleminden sonra, her sınıflandırıcı
için yapılan sınıflandırma hatasına bağlı olarak
örneklerin ağırlığı güncelleniyor
 Yeni bir örneği sınıflandırmak için her
sınıflandırıcının doğruluğuna bağlı olarak
ağırlıklı ortalaması alınıyor.
Yrd. Doç. Dr. Umut ORHAN 1
Makine Öğrenmesi
1. hafta
 Temel Terimler
 Danışmanlı – Danışmansız Öğrenme
 Veri Hazırlama
 Çapraz Geçerlik
 Aşırı Eğitim
Yrd. Doç. Dr. Umut ORHAN 2
Makine Ögrenmesi Nedir?
Makine Öğrenmesi, verilen bir problemi
probleme ait ortamdan edinilen veriye göre
modelleyen bilgisayar algoritmalarının genel
adıdır. Yoğun çalışılan bir konu olduğu için
önerilmiş birçok yaklaşım ve algoritma
mevcuttur. Bu yaklaşımların bir kısmı tahmin
(prediction) ve kestirim (estimation) bir kısmı da
sınıflandırma (classification) yapabilme
yeteneğine sahiptir.
Yrd. Doç. Dr. Umut ORHAN 3
Makine Öğrenmesi Yöntemleri
Önerilmiş birçok makine öğrenmesi yöntemi
mevcuttur. Bunlar probleme yaklaşımlara göre
farklılık gösterebilir ve bu yüzden farklı
problemlerde farklı başarılara sahip olabilirler.
Yrd. Doç. Dr. Umut ORHAN 4
Makine Ögrenmesi Terimleri
 Tahmin (prediction): Veriden öğrenen
modellerde sistem çıkışının nicel olması
durumunda kullanılan yöntemlerin ürettiği
değerlerdir.
 Sınıflandırma (classification): Giriş verisine ait
çıkışların nitel olduğu durumlarda kullanılan
yöntemlerin her veri örneğinin hangi sınıfa ait
olduğunu belirlemesidir.
Yrd. Doç. Dr. Umut ORHAN 5
Tahmin ve Kestirim
İstatistikte rasgele bir değişkenin bilinmeyen
bir değerinin belirlenmesi için tahmin
(prediction), bilinmeyen bir sabitin belirlenmesi
içinse kestirim (estimation) kavramından
bahsedilir. Çok yakın anlamları dolayısıyla bu
iki terim literatürde çoğunlukla karıştırılarak
aynı şeyi ifade etmede kullanılır.
Yrd. Doç. Dr. Umut ORHAN
6
Tahmin ve Kestirim
Örneğin sağda veri noktaları
için bir doğrusal eğri fonksiyonu tespit edilmiştir. Herhangi bir x değerine karşılık
gelen
y değerini belirlemekte
“tahmin”, tahmini yapmamı
-
za yardımcı olan eğrinin
(eğim ve sapma değeri gibi)
parametrelerinin belirlenme
-
sinde ise “kestirim” terimleri
tercih edilmelidir.
Yrd. Doç. Dr. Umut ORHAN 7
Bir Kestirim Örneği
Bir probleme ilişkin olarak sağdaki
veri kümesi veriliyor. Amaç bir x
girdisine karşı bir y değerini
üretmektir. Buna göre veri üzerinde
doğru ilişkiyi bulan öyle bir f :X"Y
fonksiyonu tanımlanmalıdır ki en
küçük hatayı üretsin.
Bu basit problemde y=3*x çözümü
kolayca görünmektedir.
X Y
3 9
5 15
8 24
10 30
19 57
24 72
27 81
31 93
38 114
43 129
Yrd. Doç. Dr. Umut ORHAN 8
Bir Tahmin Örneği
Bulunan y=3*x çözümüne ilişkin
olarak eğer x=50 değeri için y değeri
istenirse kestirilen denklem yardımı
ile y=150 tahmin değerini kolayca
hesaplamak mümkün olur.
X Y
3 9
5 15
8 24
10 30
19 57
24 72
27 81
31 93
38 114
43 129
Yrd. Doç. Dr. Umut ORHAN
9
Sınıflandırma
Amaç probleme ait tüm
uzayın belirli sayıda sınıfa
bölünmesidir. Sağdaki re
-
simde her renk bir sınıfı
göstermektedir. Sınıflan
-
dırma teknikleri sayesin
-
de hiçbir veri örneğinin
olmadığı bölgeler de
renklendirilebilir.
Yrd. Doç. Dr. Umut ORHAN 10
Bir Sınıflandırma Örneği
Sağdaki veri kümesinde amaç X
girdisine karşı Y etiket (label)
değerini üretmektir. Öyle bir f :X"Y
sınıflandırma fonksiyonu tanımlanmalıdır ki en az hata ile sınıflandırma
yapılabilsin.
X Y
2 0
5 0
9 0
13 0
19 0
20 1
27 1
33 1
39 1
47 1






1, 20
0, 20
X
X
Y
Yrd. Doç. Dr. Umut ORHAN 11
Makine Öğrenmesi Terimleri
Makine Öğrenmesi yöntemleri verinin yapısına
göre ikiye ayrılır.
 Danışmanlı (supervised) Öğrenme: Veri, etkiye
tepki prensibiyle çalışan sistemlerden alınır ve
giriş-çıkış düzeninde organize edilir.
 Danışmansız (unsupervised) Öğrenme: Sınıf
bilgisi olmayan veya verilmeyen veri içerisindeki
grupları keşfetmeyi hedefler.
Yrd. Doç. Dr. Umut ORHAN 12
Takviyeli Öğrenme
Bazen öğretici, sisteme beklenen sonucu tam
söyleyemez. Ama sistemin ürettiği sonuç için
“doğru/yanlış” şeklinde fikir belirtir. Bu öğrenme
şekli de takviyeli (reinforcement) öğrenme
adıyla anılır.
Boltzmann makinesi, LVQ ve genetik algoritma
örnek olarak sayılabilir.
Yrd. Doç. Dr. Umut ORHAN 13
Makine Ögrenmesi Terimleri
Sınıflandırma ve tahmin yöntemlerine
danışmanlı öğrenme yöntemleri de denilebilir.
Kümeleme (clustering) yöntemleri ise
danışmansız öğrenme yöntemleri olarak anılırlar.
Peki Kümeleme nedir?
Yrd. Doç. Dr. Umut ORHAN 14
Kümeleme
Danışmansız öğrenmeyi baz alan Kümelemede
amaç veri kümesi içerisindeki veri örneklerini
sadece özellik (feature) vektörlerine göre
gruplamaktır. Bunun için örneklerin birbirine
benzerliği gözetilir. Kümeleme literatüründe
benzerlik terimi uzaklık terimiyle zıt anlamda
kullanılmaktadır.
Yrd. Doç. Dr. Umut ORHAN 15
Kümeleme
Birbirine benzer olan örnekler aynı kümeye ve
biribirinden uzak olan örnekler farklı kümelere
yerleştirilmeye çalışılır. Küme sayısı genellikle
dışarıdan verilir.
Yrd. Doç. Dr. Umut ORHAN 16
Danışmanlı Kümeleme
Sınıf bilgisinden bağımsız olarak veri içerisinde
bilgi keşfi sınıflandırma için destekleyici bir
etkiye sahip olabilir. Sınıflandırma öncesi verinin
kümelenmesi (supervised clustering), genellikle
sınıflandırma başarısını yükseltmektedir.
Kümeleme Danışmanlı Kümeleme
Yrd. Doç. Dr. Umut ORHAN 17
Notasyonlar
Çalışmalarda
 İstenen sınıflar için D ,
 Tahmin çıkışları için Y ,
 Giriş verisi için X ,
 Girişin her bir özelliği için Xj ,
 Veri içerisindeki her bir örnek için xi
,
 Giriş veri kümesinin tamamı için X
notasyonları tercih edilmektedir.
Yrd. Doç. Dr. Umut ORHAN 18
Öğrenme Zamanlaması
 Çevrimiçi (online) öğrenme: Gerçek zamanlı
olarak çalışan sistemlerde öğrenme
aşamasının çalışma anında da sürdürülmesi
gerekiyorsa kullanılır.
 Çevrimdışı (offline) öğrenme: Uygulama
sistemi henüz çalışmaz iken eğitim
gerçekleştirilir, eğitilmiş yöntem sisteme
yüklenir ve sistem çalıştırılır.
Yrd. Doç. Dr. Umut ORHAN 19
Öğrenme Kuralları
Veriden eğitim için önerilen her algoritma farklı
bir öğrenme kuralı olsa da genel eğilim
algoritmaları ortak özelliklerine göre gruplamak
yönündedir. Öğrenme algoritmaları dört grupta
toplanabilir:
 Hebb
 Delta
 Hopfield
 Kohonen
Yrd. Doç. Dr. Umut ORHAN 20
Hebb Öğrenme Kuralı
1949’da geliştirilen ilk öğrenme kuralıdır. “Bir
hücre, bağlı olduğu diğer hücreleri etkiler”
prensibine dayalıdır. Bu öğrenme kuralı
geliştirilerek farklı öğrenme kuralları
geliştirilmiştir.
Yrd. Doç. Dr. Umut ORHAN 21
Delta Öğrenme Kuralı
Beklenen sonuç ve hesaplanan sonuç arasındaki
karesel fark, sistemin hatasıdır. Bu hatayı
indirgemek için hücreler arasındaki bağlantılar
sürekli değiştirilir. Çok katmanlı algılayıcı ağlar
bu kurala göre eğitilirler.
Yrd. Doç. Dr. Umut ORHAN 22
Hopfield Öğrenme Kuralı
Beklenen sonuç ile hesaplanan sonuç aynı ise
hücreler arası bağlar belirli bir oranda
güçlendirilir, aksi durumda bağlar zayıflatılır.
Recurrent ve Elman ağları bu kural ile eğitilirler.
Yrd. Doç. Dr. Umut ORHAN 23
Kohonen Öğrenme Kuralı
Bu danışmansız modelde hücreler yarış
halindedir. En büyük sonucu üreten hücre yarışı
kazanır. Kazanan hücrenin ve komşularının
bağları güçlendirilir. ART (Adaptive Resonance
Theory) ve Kohonen tarafından geliştirilen SOM
(Self Organizing Map) ağları örnek olarak
verilebilir.
Yrd. Doç. Dr. Umut ORHAN 24
Veri Hazırlama
Sınıflandırma veya tahmin için problem uzayını
tam olarak temsil edebilen veri kümesi
hazırlamak gerekmektedir.
Yrd. Doç. Dr. Umut ORHAN 25
Veri Hazırlama
Çözüm için hazırlanan veri, hem eğitim hem de
başarı ölçümünde kullanıldığı için genellikle ikiye
ayrılır.
Yrd. Doç. Dr. Umut ORHAN 26
Sınıflandırma Geçerliği
Veriye dayalı olarak eğitim yapılmasının temel
amacı eğitilen sistemin benzer konuda hiç
bilinmeyen bir örneğe mantıklı bir cevap
üretebilmesidir. Eldeki sınırlı veri kullanılarak
sistemin hem eğitilmesi hem de başarısının
tarafsız bir şekilde ölçülebilmesi gerekmektedir.
Bunun için çapraz geçerlik (cross validation)
adıyla anılan yöntemler kullanılmalıdır.
Yrd. Doç. Dr. Umut ORHAN 27
Çapraz Geçerlik
(Cross Validation)
Bu temel prensibe dayanarak önerilmiş birkaç
geçerlik yöntemi vardır. Ama hepsinde temel
mantık aynıdır. Sistemin başarısını ölçebilmek
için mevcut veri kümesi ikiye bölünür. Birisi
eğitim için (train set) diğeri de sistemin hiç
görmediği olası örnekleri temsilen (test set)
kullanılır. Sistem, seçilen eğitim algoritması ile
eğitim kümesini öğrenir. Eğitilen sistemin
başarısı daha sonra test kümesi üzerinde
hesaplanır.
Yrd. Doç. Dr. Umut ORHAN 28
Çapraz Geçerlik Yöntemleri
Üç tip çapraz geçerlik yöntemi önerilmiştir:
 Rasgele örnekleme
 K parçalı
 Birini hariç tut
Yrd. Doç. Dr. Umut ORHAN 29
Rasgele Örneklemeli Geçerlik
Rasgele örneklemede
kümeler rasgele seçilir. Optimum başarı
için birkaç kez tekrarlanır. Çapraz geçerlik
içerisinde en yüksek
başarıyı sağlayan
yöntemdir.
Yrd. Doç. Dr. Umut ORHAN 30
K Parçalı
K parçalıda veri,
K
adet kümeye ayrılır.
Birisi test kümesi için
ve diğer
K1 küme
birleştirilip eğitim
kümesi için seçilir. Bu
işlem kümeler değiş
-
tirilerek
K kez tekrar
-
lanır. Genel başarı
için
K adet başarı de
-
ğerinin ortalaması
alınır.
Yrd. Doç. Dr. Umut ORHAN 31
Birini Hariç Tut
Birini hariç tut yöntemi ile K parçalı geçerlik
yöntemleri çok benzerdir. N adet örnek içeren
veri kümesi için kullanılan birini hariç tut
yöntemi K=N için K parçalı çapraz geçerlik gibi
uygulanır.
Yrd. Doç. Dr. Umut ORHAN 32
Aşırı Eğitim (Overfitting)
Veri ile iterasyonal eğitim yapan modellerin
hepsinde öğrenme sürecinin zamanı gelince
durdurulması gerekir. Eğitim durdurulmazsa
öğrenilmesi gereken veri içerisindeki tüm
örnekler sistem tarafından ezberlenir ve
bilinmeyen örnekleri tahmin yeteneği azalır. Aşırı
eğitim (overfitting) denilen bu istenmeyen
durum makine öğrenmesinin temel amacı olan
genelleştirme kavramına zarar verir.
Yrd. Doç. Dr. Umut ORHAN 33
Eğitim Süresi
Eğitimin ne zaman durdurulması gerektiği
kullanılan algoritmaya bağlıdır. Erken durdurma
yapılırsa sistem veriyi tam öğrenemediği için
başarı düşecektir. Aşırı eğitimde de modelin
genelleştirme yeteneği zarar göreceği için
benzer şekilde başarı kötü yönde etkilenecektir.
Yrd. Doç. Dr. Umut ORHAN 1
Makine Öğrenmesi
2. hafta
 Uzaklığa dayalı gruplandırma
 K-means kümeleme
 K-NN sınıflayıcı
Yrd. Doç. Dr. Umut ORHAN 2
Uzaklığa dayalı gruplandırma
Makine öğrenmesinde amaç birbirine en çok
benzeyen veri noktalarını aynı grup içerisinde
birarada tutmaktır. Benzerlik kavramı çoğu kez
uzaklığın tersiyle ifade edilir. Farklı hesaplara
dayanan birçok sınıflandırma veya kümeleme
algoritmalarından bazıları uzaklık ölçütü ile
gruplandırma yapar.
Yrd. Doç. Dr. Umut ORHAN 3
Benzerlik
Yrd. Doç. Dr. Umut ORHAN 4
Benzerlik vs. Uzaklık
Uzaklık için en çok kullanılan ölçüt Öklit
(Euclidean distance) uzaklığıdır. İki nokta (n
boyutlu) arasındaki uzaklık şöyle hesaplanır:
Benzerlik ise genellikle uzaklığın tersidir.
2 2
2 2
2
1 1
( ) ( ) ... ( ) dab  a b  a b  a b   an
bn
a b
sab
 

1
1
Yrd. Doç. Dr. Umut ORHAN 5
Benzerlik vs. Uzaklık
Fakat uzaklık hesabı için Öklit dışında
önerilmiş Mahalanobis, Manhattan ve
Chebyshev gibi farklı birçok ölçüt
bulunmaktadır. Benzerlik ölçütü de her
zaman uzaklık ile ilişkili olmak zorunda
değildir. Literatürde uzaklığa dayalı,
olasılıksal ve özellik tabanlı gibi farklı
temellere dayanan birçok benzerlik ölçütü
önerilmiştir.
Yrd. Doç. Dr. Umut ORHAN 6
Uzaklığa dayalı kümeleme
Kümeleme, sınıf bilgisi içermeyen veri
içerisinde benzerliği yüksek noktaları
gruplama işlemidir. Bu tanımdaki “benzerliği
yüksek” terimini “benzersizliği düşük”
şeklinde değiştirebiliriz. Böylece benzersizlik
için uzaklık ölçütü kullanılabilir.
Uzaklığı kullanarak kümeleme yapan en
popüler ve çoğunlukla en başarılı yöntem Kmeans algoritmasıdır.
Yrd. Doç. Dr. Umut ORHAN 7
K Ortalamalar (K-means)
Veri içerisinden rasgele
seçilen K adet noktaya
küme merkezi gözüyle
bakılır. Tüm veri
noktaları bu küme
merkezlerine
uzaklıklarına göre
gruplanır. Her
gruplamadan sonra
küme merkezleri tekrar
hesaplanır.
Yrd. Doç. Dr. Umut ORHAN 8
K Ortalamalar (K-means)
Her gruplama ve küme merkezinin tekrar
hesabı işlemi bir iterasyon içerisinde
gerçekleştirilir. Algoritmanın kaç iterasyon
yapacağı çoğu kez J maliyet fonksiyonu ile
tespit edilir.
Maliyet fonksiyonu tüm küme merkezlerinin en
uygun konumda olduğu durumda minimum
değerde olmalıdır.
 






 
K
i k
k i
J x c
1
2
Yrd. Doç. Dr. Umut ORHAN 9
K-means Algoritması
1. Rasgele K adet küme merkezi belirle.
2. Her veri noktasını en yakın küme merkezine
göre bir gruba yerleştir.
3. Her gruba atanan tüm veri noktalarının
ortalamasını alarak küme merkezini
güncelle.
4. Grup üyelerinde değişim olmayana kadar 2.
adıma git. Bazen değişim, sıfıra yakın bir değerde uzun
zaman sürebilir. O zaman maliyet fonksiyonu belirli bir
değere düşünce veya toplam iterasyon sayısı belirli bir
değere ulaşınca algoritma durdurulur.
Yrd. Doç. Dr. Umut ORHAN 10
K-means Dezavantajları
 Rasgele noktalar ile başladığından elde edilen
her sonuç kararlı değildir.
 Küme sayısı birçok kümeleme algoritmasında
olduğu gibi dışarıdan istenilir.
 Konkav (konvex olmayan) küme şekillerinde
başarılı değildir.
 Keskin kümeleme yapar. Ama uygulamada
gruplar genelde içiçedir (overlapping).
 Aykırı değerlere (outlier) karşı hassastır.
Yrd. Doç. Dr. Umut ORHAN 11
MATLAB Uygulaması
X = [rand(20,2)+0.3*ones(20,2); rand(20,2)-0.3*ones(20,2)];
opts = statset('maxiter',1);
C = X(1:2,:);
plot(X(:,1), X(:,2), 'k.', 'MarkerSize', 12);
hold on;
plot(C(:,1), C(:,2), 'kx', 'MarkerSize', 12, 'LineWidth', 2);
axis([-1.1 2.1 -1.1 2.1]);
for i=1:5
pause;
hold off;
[idx,C] = kmeans(X,2,'Options',opts,'start',C);
plot(X(idx==1,1), X(idx==1,2), 'r.', 'MarkerSize', 12);
hold on;
plot(X(idx==2,1), X(idx==2,2), 'b.', 'MarkerSize', 12);
plot(C(:,1), C(:,2), 'kx', 'MarkerSize', 12, 'LineWidth', 2);
axis([-1.1 2.1 -1.1 2.1]);
legend('Cluster 1', 'Cluster 2', 'Centroids', 'Location', 'NW');
end
Yrd. Doç. Dr. Umut ORHAN 12
ÖDEVLER
 Agglomerative
 Divisive
 BIRCH
 STING
 Chameleon
 OPTICS
 CURE
 DBSCAN
 CLARANS
Yrd. Doç. Dr. Umut ORHAN 13
Uzaklığa dayalı sınıflandırma
Sınıflandırma, veri içerisindeki noktaları
hem özellik uzayındaki hem de sınıf
bilgisindeki benzerliklere göre gruplama
işlemidir. Daha önce bahsedildiği gibi
yüksek benzerlik terimi düşük uzaklık
olarak kullanılmaktadır. Veri noktaları
arasındaki uzaklıkları kullanarak sınıflandırma yapan en popüler yöntem K en
yakın komşu (K-NN) yöntemidir.
Yrd. Doç. Dr. Umut ORHAN 14
K en yakın komşu (K-NN)
Bir a noktasının sınıfını belirlemek için
veride bulunan tüm xi noktaları kullanılır. K
değeri, bilinmeyen noktaya en yakın kaç
adet sınıflı noktanın kullanılacağını belirler.
Örneğin 1-NN için hedef sınıf, bilinmeyen
noktaya en yakın sınıflı veri noktası
tarafından belirlenir. 3-NN için hedef sınıf
ise bilinmeyen noktaya en yakın 3 adet
sınıflı noktadan çoğunluğu sağlayan sınıf
olmalıdır.
Yrd. Doç. Dr. Umut ORHAN 15
K en yakın komşu (K-NN)
Farklı K değerleri için
Yrd. Doç. Dr. Umut ORHAN 16
K-NN Algoritması
 K değeri dışarıdan istenir.
 Sınıfı bilinmeyen noktaya sınıflı veri
noktalarının uzaklıkları hesaplanır. Genelde
Öklit uzaklığı kullanılır.
 Hesaplanan uzaklıklar sıralanır. En küçük
uzaklığa sahip (en yakın) K adet sınıflı veri
noktası tespit edilir.
 Seçilen K adet sınıflı veri noktası içerisinde
çoğunluğa sahip sınıf belirlenir. Bu sınıf,
bilinmeyen nokta için kestirim sonucudur.
Yrd. Doç. Dr. Umut ORHAN 17
K-NN Dezavatajları
 Bellek tabanlı bir sınıflayıcıdır. Sınıflı veri
noktaları sürekli hafızada tutulmalıdır. Veri
kümesi çok büyük olduğunda hesaplama
süresi de kötüleşir.
 Hesaplamaya tüm özellikler katıldığı için
gereksiz veya ilgisiz özellikler sınıflandırmayı
kötü yönde etkileyebilir.
 Sınıflandırma başarısı açısından genellikle
yapay sinir ağları gibi gelişmiş sınıflandırma
tekniklerinin gerisinde kalır.
Yrd. Doç. Dr. Umut ORHAN 18
MATLAB Uygulaması
Rasgele üretilen X, D eğitim matrisleri
yardımıyla rasgele oluşturulan A matrisindeki
örneklerin sınıflarını (Y) bulmak istiyoruz.
X=rand(10,2);
D=fix(2*rand(10,1));
A=rand(5,2);
Yrd. Doç. Dr. Umut ORHAN 19
MATLAB Uygulaması
%%K=1 için uygulama sonucu
Y=knnclassify(A,X,D,1);
figure; plot(X(D==1,1),X(D==1,2),'r.');
hold on; plot(X(D==0,1),X(D==0,2),'b.');
plot(A(Y==1,1),A(Y==1,2),'ro');
plot(A(Y==0,1),A(Y==0,2),'bo');
axis([-0.1 1.1, -0.1 1.1]);
Yrd. Doç. Dr. Umut ORHAN 20
MATLAB Uygulaması
%%K=3 için uygulama sonucu
Y=knnclassify(A,X,D,3);
figure; plot(X(D==1,1),X(D==1,2),'r.');
hold on; plot(X(D==0,1),X(D==0,2),'b.');
plot(A(Y==1,1),A(Y==1,2),'ro');
plot(A(Y==0,1),A(Y==0,2),'bo');
axis([-0.1 1.1, -0.1 1.1]);
Yrd. Doç. Dr. Umut ORHAN 21
ÖDEV
Herhangi bir sınıflandırma örneğini K-NN ile
sınıflandırmada aşağıdaki uzaklık ölçütlerini
karşılaştırınız.
 Euclid
 Manhattan
 Chebyshev
 Mahalanobis
Yrd. Doç. Dr. Umut ORHAN 1
Makine Öğrenmesi
3. hafta
 Entropi
 Karar Ağaçları (Desicion Trees)
 ID3
 C4.5
 Sınıflandırma ve Regresyon Ağaçları (CART)
Yrd. Doç. Dr. Umut ORHAN 2
Karar Ağacı Nedir?
Temel fikir, giriş verisinin bir kümeleme
algoritması yardımıyla tekrar tekrar gruplara
bölünmesine dayanır. Grubun tüm elemanları
aynı sınıf etiketine sahip olana kadar kümeleme
işlemi derinlemesine devam eder.
Yrd. Doç. Dr. Umut ORHAN 3
Karar Ağacı Nedir?
Hava
Nem
Evet
Rüzgar
Güneşli
Bulutlu
Yağmurlu
Evet
Hayır Evet
Hayır
Yüksek Normal Kuvvetli Hafif
Yrd. Doç. Dr. Umut ORHAN 4
Karar Ağacı Tipleri
Entropiye dayalı sınıflandırma ağaçları (ID3,
C4.5) ve Regresyon ağaçları (CART) olmak
üzere iki kategoride birçok algoritma
önerilmiştir.
Önce entropiye dayalı karar ağaçlarını
inceleyeceğiz. Bu algoritmaları iyi anlayabilmek
için önce entropiyi iyi bilmek gerekmektedir.
Yrd. Doç. Dr. Umut ORHAN 5
Entropi, Belirsizlik ve
Enformasyon
Rassal bir değişkenin belirsizlik ölçütü olarak bilinen Entropi, bir süreç için tüm örnekler tarafından içerilen enformasyonun beklenen değeridir.
Enformasyon ise rassal bir olayın gerçekleşmesine ilişkin bir bilgi ölçütüdür. Eşit olasılıklı durumlar yüksek belirsizliği temsil eder. Shannon’a göre
bir sistemdeki durum değiştiğinde entropideki
değişim kazanılan enformasyonu tanımlar. Buna
göre maksimum belirsizlik durumundaki değişim
muhtemelen maksimum enformasyonu
sağlayacaktır.
Yrd. Doç. Dr. Umut ORHAN 6
Enformasyon
Aslında zıt şeyleri temsil etmelerine rağmen
Shannon’a göre maksimum belirsizlik maksimum
enformasyon sağladığı için Enformasyon ve
Belirsizlik terimleri benzerdir. Enformasyon (selfinformation) formülü aşağıdaki gibidir. Shannon
bilgiyi bitlerle temsil ettiği için logartimayı iki
tabanında kullanımıştır.
log ( )
( )
1
( ) log P x
P x
I x   
Yrd. Doç. Dr. Umut ORHAN 7
Entropi
Shannon’a göre entropi, iletilen bir mesajın
taşıdığı enformasyonun beklenen değeridir.
Shannon Entropisi (H) adıyla anılan terim, tüm
ai durumlarına ait Pi olasılıklarına bağlı bir
değerdir.
 

 
 
  
 
n
i
i i
n
i i
i
i n
i i
P P
P x
P x
H X E I X P x I x
1
2
1
2
1
log
( )
1
( )log
( ) ( ( ) ) ( ) . ( )
Yrd. Doç. Dr. Umut ORHAN 8
Entropi
Bir paranın havaya atılması olayı, rassal X sürecini temsil etsin. Yazı ve tura gelme olasılıkları
eşit olduğu için X sürecinin entropisi aşağıdaki
gibidir.
Entropisi 1 olan para atma olayı (X) gerçekleştiğinde 1 bitlik bilgi kazanılacaktır.
(0.5log 0.5 0.5log 0.5) 1
( ) log
2 2
2
1
2
   
 
i
H X pi
pi
Yrd. Doç. Dr. Umut ORHAN 9
Karar Ağacında Entropi
Karar ağaçları çok boyutlu (özellikli) veriyi belirlenmiş özellik üzerindeki bir şart ile parçalara
böler. Her seferinde verinin hangi özelliği üzerinde hangi şarta göre işlem yapacağına karar
vermek çok büyük bir kombinasyonun çözümüyle mümkündür. 5 özellik ve 20 örneğe sahip bir
veride 106 dan fazla sayıda farklı karar ağacı
oluşturulabilir. Bu sebeple her parçalanmanın
metodolojik olması gerekir.
Yrd. Doç. Dr. Umut ORHAN 10
Karar Ağacında Entropi
Quinlan’e göre veri, bir özelliğe göre bölündüğünde elde edilen her bir veri kümesinin belirsizliği minimum ve dolayısıyla bilgi kazancı maksimum ise en iyi seçim yapılmış demektir. Buna
göre önerdiği ilk algoritma ID3’te tek tek özellik
vektörleri incelenir ve en yüksek bilgi kazancına
sahip özellik, ağaçta dallanma yapmak için
tercih edilir.
Yrd. Doç. Dr. Umut ORHAN 11
ID3 Algoritması
Sadece kategorik veri ile çalışan bir yöntemdir.
Her iterasyonun ilk adımında veri örneklerine ait
sınıf bilgilerini taşıyan vektörün entropisi belirlenir. Daha sonra özellik vektörlerinin sınıfa bağımlı entropileri hesaplanarak ilk adımda hesaplanan entropiden çıkartılır. Bu şekilde elde edilen değer ilgili özellik vektörüne ait kazanç değeridir. En büyük kazanca sahip özellik vektörü
ağacın o iterasyonda belirlenen dallanmasını
gerçekleştirir.
Yrd. Doç. Dr. Umut ORHAN 12
ID3 Örneği
V1 V2 S
A C E
B C F
B D E
B D F
2 özellik vektörü (V1 ve
V2) ile S sınıf vektörüne
sahip 4 örnekli veri kümesi
verilmiştir. ID3 algoritması
ile ilk dallanma hangi
özellik üzerinde gerçekleşir
?
H(S) - H(V1,S)
H(S) - H(V2,S)
Yrd. Doç. Dr. Umut ORHAN 13
ID3 Örneği
V1 V2 S
A C E
B C F
B D E
B D F
Sınıf Entropisi
1
2
1
log
2
1
2
1
log
2
1
( )
2 2
 





H S   
V1 Entropisi
0,9183 0,6887
4
3
0
3
2
log
3
2
3
1
log
3
1
4
3
0
4
1
( )
4
3
( )
4
1
( 1)
2 2
  






  
H V  H A  H B
V2 Entropisi
1
2
1
2
1
( )
2
1
( )
2
1
H(V 2)  H C  H D    V1 seçilir...
Yrd. Doç. Dr. Umut ORHAN 14
C4.5 Algoritması
ID3 algoritmasının nümerik özellik içeren veriye
uygulanabilen şeklidir. ID3’ten tek farkı nümerik
özelliklerin kategorik hale getirilebilmesini sağlayan bir eşikleme yöntemini içermesidir. Temel
mantık nümerik özellik vektöründeki tüm değerler ikili olarak ele alınarak ortalamaları eşik olarak denenir. Hangi eşik değeriyle bilgi kazanımı
en iyi ise o değer seçilir. Seçilen eşiğe göre özellik vektörü kategorize edilir ve ID3 uygulanır.
Yrd. Doç. Dr. Umut ORHAN 15
Kayıp Veri
Eğer veride bazı örneklerin bazı özellikleri
kayıpsa izlenecek iki yol vardır:
 Kayıp özelliklere sahip örnek veriden tamamen
çıkartılır.
 Kayıp verilerle çalışabilecek şekilde algoritma
düzenlenir.
Eğer kayıplı örneklerin sayısı birinci seçenek
uygulanamayacak kadar çoksa ikinci seçenek
uygulanmalıdır.
Yrd. Doç. Dr. Umut ORHAN 16
Kayıp Veri
Kayıp bilgiye sahip özellik vektörü için kazanç
hesaplanırken kayıplı örnekler hariç tutularak
bilgi kazancı normal şekilde hesaplanır ve daha
sonra F katsayısıyla çarpılır. F, kayıpsız verinin
tamamına oranıdır.
IG(X)  F. (H(X)  H(V, X) )
Yrd. Doç. Dr. Umut ORHAN 17
Kayıp Veri
Kayıp bilgiye sahip özellik vektörü içinde en sık
tekrarlanan değerin kayıp bilgi yerine yazılması da önerilen yöntemlerdendir.
Yrd. Doç. Dr. Umut ORHAN 18
Ezber (Overfitting)
Tüm makine öğrenmesi yöntemlerinde verinin
ana hatlarının modellenmesi esas alındığı için
öğrenme modelinde ezberden (overfitting) kaçınılmalıdır. Tüm karar ağaçları önlem alınmazsa ezber yapar. Bu yüzden ağaç oluşturulurken veya oluşturulduktan sonra budama
yapılmalıdır.
Yrd. Doç. Dr. Umut ORHAN 19
Ağaç Budama
Budama, sınıflandırmaya katkısı olmayan bölümlerin karar ağacından çıkarılması işlemidir.
Bu sayede karar ağacı hem sade hem de anlaşılabilir hale gelir. İki çeşit budama yöntemi
vardır;
 ön budama
 sonradan budama
Yrd. Doç. Dr. Umut ORHAN 20
Ön Budama
Ön budama işlemi ağaç oluşturulurken yapılır.
Bölünen nitelikler, değerleri belli bir eşik değerinin (hata toleransının) üstünde değilse o
noktada ağaç bölümleme işlemi durdurulur ve
o an elde bulunan kümedeki baskın sınıf etiketi, yaprak olarak oluşturulur.
Yrd. Doç. Dr. Umut ORHAN 21
Sonradan Budama
Sonradan budama işlemi ağaç oluşturulduktan
sonra devreye girer. Alt ağaçları silerek yaprak
oluşturma, alt ağaçları yükseltme, dal kesme
şeklinde yapılabilir.
Yrd. Doç. Dr. Umut ORHAN 22
Ağaç Budama
Hava
Nem
Evet
15
Rüzgar
Güneşli
Bulutlu
Yağmurlu
Evet
20
Evet
15
Hayır
35
Hayır
25
Yüksek Normal Kuvvetli Hafif
Hata toleransı %33 seçilirse “Nem” düğümünün alt dallarındaki “Evet”
oranı %30’dur. Bu yüzden “Nem” düğümü budanıp yerine “Hayır” yaprağı
konur.
Yrd. Doç. Dr. Umut ORHAN 23
Ağaç Budama
Hava
Evet
Rüzgar
Güneşli
Bulutlu
Yağmurlu
Evet
Hayır
Hayır
Kuvvetli Hafif
Yrd. Doç. Dr. Umut ORHAN 24
Sınıflandırma ve Regresyon
Ağaçları (CART)
CART karar ağaçlarının temel prensibi herbir
düğümde ağacı iki dala ayırmasıdır. En çok
bilinen iki algoritması:
 Twoing algoritması
 Gini algoritması
Yrd. Doç. Dr. Umut ORHAN 25
ÖDEVLER
Aşağıdaki CART algoritmalarını MATLAB’de
hazırlayınız.
 Twoing
 Gini
Yrd. Doç. Dr. Umut ORHAN 1
Makine Öğrenmesi
4. hafta
 Olasılık ve Koşullu Olasılık
 Bayes Teoremi
 Naïve Bayes Sınıflayıcı
Yrd. Doç. Dr. Umut ORHAN 2
Olasılık
Olasılık ifadesinin birçok kullanım şekli vardır.
Rasgele bir A olayının herhangi bir olaydan
bağımsız olarak gerçekleşme ihtimalini ifade
etmek için P(A) notasyonu kullanılır. A olayının
olasılığı olarak bilinen bu ifade “önsel” (prior),
“koşulsuz” (unconditional) veya “marjinal”
(marginal) olasılık isimleriyle kullanılabilir.
Yrd. Doç. Dr. Umut ORHAN 3
Örnek
Bir para atma olayının iki kez tekrarlanması
durumunda ardarda iki defa da tura gelme
ihtimalini bulalım.
4
1
2
1
2
1
P(A B)  P(A)P(B)   
Yrd. Doç. Dr. Umut ORHAN 4
Koşullu Olasılık
Rasgele bir A olayının, farklı bir rasgele B
olayına bağlı gerçekleşmesi ihtimalini ifade
etmek için önsel olasılıklar yeterli olmaz. Bu
yüzden “koşullu” (conditional) veya “sonsal”
(posterior) olasılık olarak isimlendirilen P(A|B)
notasyonu kullanılır. Bilinen bir B olayına göre
A olayının koşullu olasılığı şöyle gösterilir.
( )
( )
( | )
P B
P A B
P A B


Yrd. Doç. Dr. Umut ORHAN 5
Koşullu Olasılık
( )
( )
( | )
P B
P A B
P A B


A B
A B
c
AB
Yrd. Doç. Dr. Umut ORHAN 6
Örnek
Elimizde bulunan iki kavanozdan birincisinde 3
mavi ve 4 sarı, ikincisinde 5 mavi 2 sarı top
olsun. Bu durumda rasgele seçilen bir
kavanozdan mavi top çekme olasılığı nedir?
A: Birinci kavanozu seçme durumu
B: İkinci kavanozu seçme durumu
C: Mavi top seçme durumu
7
4
7
5
2
1
7
3
2
1
P(C)  P(A)P(C | A)  P(B)P(C | B)   
Yrd. Doç. Dr. Umut ORHAN 7
Bayes Teoremi
Birbirinden bağımsız ve rasgele iki olayın (A ve
B) birbiri ardı sıra gerçekleştiği durumlarda bu
iki olaydan birinin gerçekleşmesi durumunda
ikinci olayın gerçekleşme olasılığı P(A,B) veya
P(B,A) yada ifadesi ile gösterilebilir.
Değişme özelliği sayesinde aşağıdaki çarpım
kuralı iki farklı ifade ile yazılabilir.
( ) ( | ) ( )
( ) ( | ) ( )
P A B P B A P A
P A B P A B P B
 
 
P(AB)
Yrd. Doç. Dr. Umut ORHAN 8
Bayes Teoremi
Bayes teoremi (kuralı veya kanunu) stokastik
(rassal) bir sürece bağlı olarak ortaya çıkan
rasgele bir A olayı ile diğer bir rasgele B olayı
için koşullu olasılıklar ve marjinal olasılıklar
arasındaki ilişkiyi tanımlar. Bu ilişkiyi ilk kez
Thomas Bayes (1702-1761) ortaya atmış ve
aşağıdaki eşitliği önermiştir.
( )
( | ) ( )
( | )
P B
P B A P A
P A B 
Yrd. Doç. Dr. Umut ORHAN 9
Örnek
İki sınıflı (kanser ve kanser değil) bir tıbbi teşhis
problemini ele alalım. Tüm popülasyonun %0.8’nin
kanser olduğunu varsayalım. Ayrıca kişilere + (pozitif)
ve - (negatif) olmak üzere iki sonucu olan bir
laboratuvar testi uygulanmış olsun. Test, hastalığın var
olduğu durumların %98’inde +, olmadığı durumların
ise %97’sinde - sonuçlar üretiyorsa;
( | ) 0.02 ( | ) 0.97
( | ) 0.98 ( | ) 0.03
( ) 0.008 ( ) 0.992
    
    
  
P kanser P kanser
P kanser P kanser
P kanser P kanser
Yrd. Doç. Dr. Umut ORHAN 10
Örnek
Bu olasılıklara göre labortuvar sonucu + olan ve
kanser şüphesiyle gelen bir kişinin kanser olup
olmadığı Bayes Teoremine göre hesaplanırsa aşağıdaki
sonuçlar elde edilir;
olduğu için kanser değildir
0.7915
( ) 0.0376
0.03 0.992 ( | )
0.2085
( ) 0.0376
0.98 0.008 ( | )

 

  

 

 
P
P kanser
P
P kanser P(kanser| )  P(kanser| ) !
Yrd. Doç. Dr. Umut ORHAN 11
Naïve Bayes Sınıflayıcı
Bayes Teoremi sınıflandırma amaçlı kullanılırken en
yüksek olasılıklı durum hedef sınıf olarak seçilir.
Fakat girdi vektörlerinin (v) birden çok olduğu
durumlarda Bayes formülü farklı bir forma dönüşür.
Birçok özelliğin kesişimi görünümündeki veri örneği
için hedef sınıf tahmininde tüm özellikler için koşullu
olasılıkların çarpımı hesaplanmalıdır.
S argmaxP(s | v) j
s S
hedef
j




n
i
n j i j
P v v v s P v s
1
1 2
( , ,..., | ) ( | )
Yrd. Doç. Dr. Umut ORHAN 12
Naïve Bayes Sınıflayıcı
Naïve Bayes Sınıflayıcı ile Bayes Teoremi hesaplarında
dikkat edilmesi gereken en önemli fark sınıflayıcıların
olasılık değerinden ziyade hedef sınıfı bulmaya
odaklanmasıdır. Bu yüzden paydada bulunan değer,
tüm hedef sınıflara ait olasılık hesaplarında ortak
olduğundan ihmal edilebilir. O zaman hedef sınıf
bulurken dikkat edeceğimiz formül;








 
 
n
i
j i j
s S
hedef S P s P v s
j 1
argmax ( ) ( | )
Yrd. Doç. Dr. Umut ORHAN 13
Naïve Bayes Sınıflayıcı
Bu yüzden Bayes Teoreminde bulunan sınıf
olasılıkları toplamı 1 olmak zorunda iken Naïve
Bayes Sınıflayıcı ile bulunan değerlerin toplamı
(ihmal edilen paydadan dolayı) 1 olamaz. Buna
göre Bayes Teoremi ile bir durumun olası
sonuçlarının olasılıkları bulunurken Naïve Bayes
ile normalizasyonsuz olasılıklar üzerinden
sınıflandırma yapılabilir.
Yrd. Doç. Dr. Umut ORHAN 14
Örnek
v1 v2 v3 v4 Sınıf
Yes No No Yes B
Yes No No No B
No Yes Yes No M
No No Yes Yes M
Yes No No Yes B
Yes No No No M
Yes Yes Yes No M
Yes Yes No Yes M
No No No Yes B
No No Yes No M
Yandaki veri kümesi
için sırasıyla gelen
<Yes, No, Yes, Yes>
örneğinin sınıfını
bulalım.
Yrd. Doç. Dr. Umut ORHAN 15
Örnek
160
9
4
3
4
1
1
4
3
5
2
( | , , , )
1 2 3 4
 





P S  b v v v v 
P(Yes, No, Yes, Yes | S) = ?
Sonuçlara göre hedef sınıf “b” bulunur.
30
1
3
1
3
2
2
1
2
1
5
3
( | , , , )
1 2 3 4
 





P S  m v v v v 
V1 V2 V3 V4 Sınıf
Yes No Yes Yes B
Yes No No No B
Yes No No Yes B
No No No Yes B
No Yes Yes No M
No No Yes Yes M
Yes No No No M
Yes Yes Yes No M
Yes Yes No Yes M
No No Yes No M
Yrd. Doç. Dr. Umut ORHAN 16
Nümerik Değerler
Bayes Teoremi yalnızca kategorik veri özelliklerinde kullanılabilmektedir. Nümerik değerlere
sahip özelliklere uygulayabilmek için ilgili özellik uzayında örneklerin Gauss (normal) Dağılımına sahip olduğu varsayılır. Aranan olasılık
değeri, özellik vektörünün ortalaması μ ve
standart sapması σ değerine bağlı aşağıdaki
dağılım formülü ile hesaplanır.
2
2
1
2
2
1
( )





 





v
P v e
Yrd. Doç. Dr. Umut ORHAN 17
Örnek
V1= Evet, V2 = Evet,
V3= Hayır, V4= Hayır,
Yaş= 45 için
Cinsiyet = ?
Yaş özelliği nümeriktir.
Normal dağılıma sahip
olduğu varsayılarak
olasılıkları hesaplanır.
V1 V2 V3 V4 Yaş Cinsiyet
Evet Hayır Evet Hayır 38 k
Evet Evet Evet Hayır 40 k
Evet Evet Evet Hayır 41 k
Hayır Hayır Hayır Hayır 55 k
Hayır Evet Hayır Hayır 27 e
Evet Evet Evet Evet 30 e
Evet Hayır Evet Evet 35 e
Hayır Hayır Hayır Hayır 42 e
Evet Hayır Hayır Hayır 43 e
Evet Hayır Hayır Hayır 45 e
Yrd. Doç. Dr. Umut ORHAN 18
Örnek
P(Yaş | Cinsiyet=k) için μ=43.5 ve σ=7.77
P(Yaş | Cinsiyet=e) için μ=37 ve σ=7.46
Normal dağılıma göre;
P(Yaş=45 | Cinsiyet=k) = 0.0504 ~ 5/100
P(Yaş=45 | Cinsiyet=e) = 0.0301 ~ 3/100
bulunur.
Yaş Cinsiyet
38 k
40 k
41 k
55 k
27 e
30 e
35 e
42 e
43 e
45 e
Yrd. Doç. Dr. Umut ORHAN 19
Örnek
0.0018
100
3
3
2
3
2
3
1
3
2
5
3
( | , , , , )
1 2 3 4
 





P C  e v v v v Yaş 
P (C | Evet,Evet,Hayır,Hayır,45) = ?
Sonuçlara göre hedef sınıf “k” bulunur.
v1 v2 v3 v4 Yaş C
Evet Hayır Evet Hayır 38 k
Evet Evet Evet Hayır 40 k
Evet Evet Evet Hayır 41 k
Hayır Hayır Hayır Hayır 55 k
Hayır Evet Hayır Hayır 27 e
Evet Evet Evet Evet 30 e
Evet Hayır Evet Evet 35 e
Hayır Hayır Hayır Hayır 42 e
Evet Hayır Hayır Hayır 43 e
Evet Hayır Hayır Hayır 45 e
0.0019
100
5
1
4
1
2
1
4
3
5
2
( | , , , , )
1 2 3 4
 





P C  k v v v v Yaş 
Yrd. Doç. Dr. Umut ORHAN 20
Sıfır Olasılık Sorunu
Bayes formülü, özelliklere ait koşullu olasılıkların çarpımı şeklinde düzenlenirken bir özellik
vektöründe çözümü aranan değere rastlanmaması durumunda genel sonucu etkileyecek bir
sıfır olasılık üretilir. Diğer özellik olasılıklarının
büyük olduğu durumlarda sıfır olasılıklı özellik
genel sonucu etkiler. Bunu engellemek için
olasılıklar sıfır olamayacak şekilde tekrar
organize edilir.
Yrd. Doç. Dr. Umut ORHAN 21
ÖDEV
Aşağıdaki yöntemleri MATLAB’de hazırlayınız.
 Lojistik Regresyon
 EM (Expectation Maximization)
Yrd. Doç. Dr. Umut ORHAN 1
Makine Öğrenmesi
5. hafta
 Doğrusal Regresyon
 Çoklu Doğrusal Regresyon
 En küçük kareler yöntemi
Yrd. Doç. Dr. Umut ORHAN 2
Doğrusal Regresyon
Doğrusal regresyonun temelinde bir özellik vektörüne ait giriş değişkeninin ağırlık kazanmasıyla bir hedef değişkeni belirli bir hata ile ürettiği
varsayılır. Bu varsayım aşağıdaki eşitlik ile temsil edilir.
W ağırlıkları, X verinin özellik vektörünü, E hatayı ve Y
değişkeni de hedef değişkeni temsil etmektedir.
Y  W0
W1
X  E
Yrd. Doç. Dr. Umut ORHAN 3
Doğrusal Regresyon
Her veri örneği aslında bir doğru denklemine E
hatası oranında uzaktır. Bu hata değerleri çok
küçük olduğu varsayımı ile çözüm sırasında
ihmal edilirler. X ve Y vektörlerini içeren veri
kümesi kullanılarak W ağırlık vektörünün tespiti
regresyon analizinin temel amacını oluşturur.
Yrd. Doç. Dr. Umut ORHAN 4
Örnek
X Y
2743 21,4
3518 15,2
1855 38,9
5214 12,7
4341 17,8
0
5
10
15
20
25
30
35
40
45
0 1000 2000 3000 4000 5000 6000
Yrd. Doç. Dr. Umut ORHAN 5
Örnek
X Y
2743 21,4
3518 15,2
1855 38,9
5214 12,7
4341 17,8
0
5
10
15
20
25
30
35
40
45
0 1000 2000 3000 4000 5000 6000
Y = 45.11- 0.007 X
MSE = 24.07
Yrd. Doç. Dr. Umut ORHAN 6
Çoklu Doğrusal Regresyon
Doğrusal regresyonun M boyutlu bir veri kümesine uygulanabilen şeklidir. Tüm giriş değişkenlerinin ağırlıklı toplamının hedef değişkeni belirli
bir hata ile ürettiği varsayılır.
Wj ağırlıkları, Xj verinin özellik vektörlerini, E hatayı ve Y değişkeni
de hedef değişkeni temsil etmektedir.
Y W W X E
M
j
  j j

1
0
Yrd. Doç. Dr. Umut ORHAN 7
Çoklu Doğrusal Regresyon
Veri örnekleri M+1 boyutlu bir hiper-düzlem
denklemine, ihmal edilebilecek kadar küçük E
hatası oranında uzaktır. Amaç, doğrusal regresyondaki gibi W ağırlık vektörünün tespit edilmesine dayanır.
Hem basit doğrusal hem de çoklu doğrusal regresyonun en temel çözümü en küçük kareler
yöntemine (least squares) dayanır.
Yrd. Doç. Dr. Umut ORHAN 8
En Küçük Kareler (Least Squares)
En küçük kareler yöntemiyle çözülebilen bu
denklemlerin matematiksel çözümü aşağıdaki
gibi ifade edilebilir.
N değeri verideki toplam örnek sayısını, i indisi her bir örneğin
verideki sırasını ve j indisi de verinin boyutlarını temsil eder.




  N
i
i j
N
i
i j i
j
j
j
x
x d
X
X D
W
1
2
1
2
W X X X D
T
-1 T

Yrd. Doç. Dr. Umut ORHAN 9
En Küçük Kareler (Least Squares)
En küçük kareler yönteminin temel prensibi aşağıdaki gibi ifade edilen ortalama karesel hatanın
(MSE) minimize edilmesidir.
Bu eşitlikle ifade edilen ei hataları olabilecek en
küçük değerlere sahiptir ve doğrusal bir çözüm
ile tahmin edilemez kabul edilirler.
     








 
N
i
M
j
i j ij
N
i
i
d w x
N
e
N 1
2
1 1
1 2
1
Yrd. Doç. Dr. Umut ORHAN 10
Eşikleme ve Yarışmalı
Sınıflandırma
Tahmin ve kestirim yöntemlerinin başarıları MSE
ölçütü yardımıyla karşılaştırılır. Regresyon gibi
tahminlemede kullanılan bir çözümleyicinin
sınıflandırma yapabilmesi için ise hesaplanan
sonuçlar üzerinde bir eşikleme yapılmalıdır. İki
sınıflı sistemlerde etiketler için 0 ve 1 değerleri
seçilirse eşik değeri de 0.5 olmalıdır. Çok sınıflı
sistemlerde ise yarışma usulü sonuç tayin edilir.
Yrd. Doç. Dr. Umut ORHAN 11
Sınıflandırma Örneği
X1 X2 X3 X4 Y
5.1 3.5 1.4 0.2 A
4.9 3 1.4 0.2 A
7 3.2 4.7 1.4 B
6.4 3.2 4.5 1.5 B
6.3 3.3 6 2.5 C
5.8 2.7 5.1 1.9 C
Kümeleme ve sınıflandırma
için sık kullanılan İRİS veri
kümesinden bir kesit
alınmıştır. Veri, giriş için 4
özellik vektörüne sahip X
değişkenini, hedef içinse 3
sınıf değeri taşıyan Y
değişkenini bulundurur.
Sınıflandırma yapılacağı için
Y değikeni üç ayrı lojik
değişkene dönüşmelidir.
Yrd. Doç. Dr. Umut ORHAN 12
Sınıflandırma Örneği
Y Y1 Y2 Y3
A 1 0 0
A 1 0 0
B 0 1 0
B 0 1 0
C 0 0 1
C 0 0 1
Sınıflandırma sistemlerinin
en kolay öğrendiği hedefler
0 ve 1 olmak üzere ikili sınıf
bilgileridir. Tahmin sistemi
gerçel sayılar üretir. Bu
yüzden tek çıkışlı sistemde
0.5 eşikleme kullanılarak
yuvarlama yapılır ve çok
çıkışlı sistemlerde ise
değişkenlerden hangisi
büyükse o kazandı denilir.
Yrd. Doç. Dr. Umut ORHAN 13
Sınıflandırma Örneği
Çoklu doğrusal regresyon çözümü ile aşağıdaki 3
denklem bulunur;
Bulunan ortalama karesel hatalar;
Y1
için MSE=0.030, Y2
için MSE=0.301,
Y3
için MSE=0.014
3 1 2 3 4
2 1 2 3 4
1 1 2 3 4
3.2 1.1 1 0.3 5 0.9 8 0.9 2
3.4 0.8 2 0.2 0.0 4 0.5 2
1.2 0.2 9 0.1 6 1.0 2 1.4 3
Y X X X X
Y X X X X
Y X X X X
    
     
    
Yrd. Doç. Dr. Umut ORHAN 14
Sınıflandırma Örneği
Ȳ1 Ȳ2 Ȳ3
0.98 0.06 -0.04
1.00 -0.01 0
-0.06 1.19 -0.13
0.11 0.63 0.25
-0.02 0.07 0.95
-0.02 0.05 0.96
Burada Ȳ değikenleri regresyon denklemleriyle hesaplanan
değerleri gösterir. İlk iki örnekte en büyük değer Ȳ1
, sonraki
iki örnekte Ȳ2 ve son iki örnekte Ȳ3 değişkeni kazanan sınıfı
temsil eder. Y değişkenleri sırasıyla A, B ve C sınıflarını
temsil eder. Buna göre 6
örneğin tümü de doğru
sınıflandırılmıştır.
Yrd. Doç. Dr. Umut ORHAN 15
Doğrusal Olmayan Regresyon
Doğrusal olmayan regresyon modelleri de aynı
doğrusal modeller gibi basit bir denklemle
gösterilebilirler. Doğrusal olmayan regresyon
modellerinde bu denklemdeki parametre sayısı
verideki değişken sayısıyla doğrudan ilişkili
olmayabilir. Doğrusal olmayan regresyon
modellerinin parametre tahminleri için önerilen
birçok yöntem vardır. Bunlardan en çok
bilinenleri en küçük kareler, en çok olabilirlik
(maximum likelihood) ve gauss-newton
yöntemleridir.
Yrd. Doç. Dr. Umut ORHAN 16
ÖDEV
Doğrusal olmayan regresyon modellerinin
parametre tahminleri için kullanılan aşağıdaki iki
yöntemi araştırınız.
 Maximum Likelihood
 Gauss-Newton
Yrd. Doç. Dr. Umut ORHAN 1
Makine Öğrenmesi
6. hafta
 Yapay Sinir Ağlarına Giriş
 Tek katmanlı YSA’lar
 Algılayıcı (Perceptron)
 Adaline (Adaptive Linear Element)
Yrd. Doç. Dr. Umut ORHAN 2
Biyolojik Sinir Hücresi
Biyolojik sinirler dört ana
bölümden oluşmaktadır. Bunlar:
 Dendrit,
 Akson,
 Çekirdek,
 Bağlantılar.
Yrd. Doç. Dr. Umut ORHAN 3
Biyolojik Sinir Hücresi
 Dendrit: Bağlı olduğu yerlerden
gelen işaretleri çekirdeğe iletir.
 Çekirdek: Dendritten gelen
işaretleri bir araya toplar ve
aksona iletir.
 Akson: Toplanan bu işaretleri
işleyerek nöronun diğer ucunda
bulunan bağlantılara gönderilir.
 Bağlantılar: Üretilen bu işareti
diğer nöronlara iletir.
Yrd. Doç. Dr. Umut ORHAN 4
Yapay Sinir Hücresi

 
M
i
i
wi
net b x
1
y  f (net)

xn
x2
x1
f (net)
net y
w1
w2
wn
b
Yrd. Doç. Dr. Umut ORHAN 5
Tek Katmanlı Yapay Sinir Ağı
Tek katmanlı ileri beslemeli ağlar her biri belli ağırlıklarla
tüm girişlere bağlı olan bir veya daha fazla çıkış nöronuna
sahiptir. Şekilde gösterildiği gibi en basit ağ, iki giriş ve bir
çıkıştan oluşur. Nöronun girişi, giriş değişkenlerinin ağırlıklı
toplamına sapma (b) değerinin eklenmesiyle hesaplanır.
Ağın çıkışı, hesaplanan toplamın bir f fonksiyonu olan çıkış
nöronunun aktivasyonuyla aşağıdaki gibi hesaplanır.






 
i
i i
y f b w x
y
+1
x2
x1
w1
w2
b
xM
wM
Yrd. Doç. Dr. Umut ORHAN 6
Aktivasyon Fonksiyonu
Tek katmanlı ağlarda f aktivasyon fonksiyonu
doğrusaldır. Biyolojik hücrelerdeki gibi hesaplanan
toplam değerin belirli bir eşik değerinden büyük
olması durumunda çıkış aktive edilir. Diğer
durumlarda çıkış pasiftir. Bu iki değer bazı
çalışmalarda 0 ve 1 iken bazılarında -1 ve 1
değerlerini alır.






0
1 0
( )
net
f net
Yrd. Doç. Dr. Umut ORHAN 7
Öğrenme Kuralı
İki öğrenme kuralını konuşacağız: 1958’de
Rosenblatt tarafından önerilen Algılayıcı
(perceptron) kuralı ve 1960’da Widrow ve Hoff’un
önerdiği Adaline (Delta veya LMS kuralı). Her iki
yöntem de birbirine çok benzer. Her ağırlık için eski
değere bir düzeltme eklenerek yeni bir değer
hesaplanır.
w (t 1) w (t) w (t), i
 
i
  i
Yrd. Doç. Dr. Umut ORHAN 8
Genel Algoritma
Hem algılayıcı hem de adaline için algoritma
adımları şöyledir:
1. Bağlantılar için rasgele ağırlıklarla başla.
2. Eğitim kümesinden bir örnek seç (x örneğin
girişi ve d örneğin sınıfı).
3. Çıkışı (y) hesapla. Eğer y ≠ d ise, tüm wi
bağlantı ağırlıklarını öğrenme kuralının bulduğu
Δwi değerine göre değiştir.
4. 2. adıma git.
Yrd. Doç. Dr. Umut ORHAN 9
Algılayıcı (Perceptron)
Aktivasyon fonksiyonu için bir eşik (θ) değeri
kullanılır. Hesaplanan ‘net’ değeri θ değerinden
büyükse çıkış aktive edilir.






0
1
( )
net 
f net 
x
M
x2
x1
f (net)
net y
w1
w2
wM
θ
...
b
Yrd. Doç. Dr. Umut ORHAN 10
Algılayıcı (Perceptron)
Ağın bulduğu çıkış değeri gerçek değere
uymuyorsa (mutlak hata 1 ise) Δwi
(t) değerleri
aşağıdaki gibi hesaplanır.
burada η öğrenme katsayısı değeri özenle seçilmiş
bir sabittir.
 
( ) ( )
( ) ( ) ( )
( ) ( ) ( ) 1,0,1
b t e t
w t e t x t
e t d t y t
i i


 
 
   
Yrd. Doç. Dr. Umut ORHAN 11
Örnek
X ve D verisine göre algılayıcı eğitimi sonucu
ağırlıkları bulalım.
Varsayımsal başlangıç değerleri şöyle olsun.







0
1
D







2
1
w   1







0 1
1 0
X
b  0
  0.5
Yrd. Doç. Dr. Umut ORHAN 12
Örnek
İki boyutlu veri kümemizde 2 örnek mevcuttur.
Buna göre sırayla ileri beslemeleri hesaplayalım.
İlk veri örneği doğru sonuç üretti. Ağırlıklar
güncellenmez.
 
 
0.5
1
0
2
1
0
1
0 1
1 0
2
1
2
1
2
1

 









b
w
w
d
d
x
x
(1) 1 0
0 1*1 0*2 1
1 1,1 1 1,2 2
  
   
  
y f e
net b x w x w
Yrd. Doç. Dr. Umut ORHAN 13
Örnek
İkinci örneğimizin sonucunu hesaplayalım.
Yanlış sonuç ürettiği için ağırlıklar güncellenir.
 
 
0.5
1
0.5
1.5
1
0
1
0 1
1 0
2
1
2
1
2
1

 
 








b
w
w
d
d
x
x
(2) 1 1
0 0*1 1*2 2
2
2 2,1 1 2,2 2
   
   
  
y f e
net b x w x w
2 0.5*1 1.5
1 0.5*0 1
0 0.5 0.5
2
1
  
  
   
w
w
b
Yrd. Doç. Dr. Umut ORHAN 14
Adaline (Adaptive Linear Element)
Eşik değeri, aktivasyon fonksiyonuna giren toplama
eklenir. Hesaplanan net değeri sıfırdan büyükse
çıkış aktive edilir.

x
M
x2
x1
f (net)
net y
w1
w2
wM
b
...






0
1 0
( )
net
f net
Yrd. Doç. Dr. Umut ORHAN 15
Adaline (Adaptive Linear Element)
Widrow ve Hoff tarafından geliştirilen “en
küçük ortalama kare” (LMS) yöntemiyle eğim
azaltmayı hedefleyen öğrenme algoritmasıdır.
Karesel hatalar toplamının minimum olmasına
dayanır. Ağırlıkları güncellemek için aşağıdaki
temel denklem kullanılır:
burada ifadesi eğim vektörüdür.
   ( )
2
1
( 1) ( )
2
w t w t E e t
i
 
i
  
  ( )
2
 E e t
Yrd. Doç. Dr. Umut ORHAN 16
Adaline (Adaptive Linear Element)
Eğim vektörünün hesaplanması için aşağıdaki
denklem kullanılabilir:
Bu açılım önceki denklemde yerine konulursa
ağırlık güncelleme denklemi şu şekli alır:
  ( ) 2 ( ) ( )
2
E e t x t e t    i
w (t 1) w (t) x (t)e(t) i
 
i
 i
Yrd. Doç. Dr. Umut ORHAN 17
Adaline (Adaptive Linear Element)
Bulunan ağırlık güncelleme denklemi aslında
algılayıcı ile aynıdır. Tek fark algılayıcıda hata
hesaplanırken aktivasyon fonksiyonun çıkışı ile
istenen hedef farkı alınırken adaline için
aktivasyon fonksiyonunun girişi olan “net”
değeri ile istenen hedef farkı hesaplanır.
 
e t d t x w b
e t d t f x w b
adaline i i
perceptron i i
  
  


( ) ( )
( ) ( )
Yrd. Doç. Dr. Umut ORHAN 18
Örnek
Önceki örneğimizin 2. iterasyonunu Adaline için
tekrarlayalım.
İkinci veri örneği yanlış sonuç üretti. Ağırlıklar
güncellenmelidir.
 
 
0.5
1
1
1
1
0
1
0 1
1 0
2
1
2
1
2
1

 
 








b
w
w
d
d
x
x
1 0 2 2
0 0*1 1*2 2
2
2
    
   
y e
net
2 2*0.5*1 1
1 2*0.5*0 1
0 2*0.5 1
2
1
  
  
   
w
w
b
Yrd. Doç. Dr. Umut ORHAN 19
ÖDEV
Algılayıcı ve Adaline için hazırlanmış
MATLAB kodları ile önceki derslerde verilen
sentetik veri kümeleri analiz edilecek ve bu
analizlerde üç farklı çapraz geçerlik
yöntemi kullanılacaktır.
Yrd. Doç. Dr. Umut ORHAN 1
Makine Öğrenmesi
7. hafta
 Çok Katmanlı Algılayıcı (MLP) Ağı
 Geri-yayılım Algoritması
 Eğitimi Durdurma Kriteri
Yrd. Doç. Dr. Umut ORHAN 2
Çok Katmanlı Algılayıcı Ağı
Algılayıcı ve Adaline yöntemleri doğrusal
olmayan çözümler üretemediği için hem mimari
hem de eğitim algoritması açısından
iyileştirilmiş Çok Katmanlı Algılayıcı (MLP) ağı
önerilmiştir. Mimari açıdan doğrusal olmayan
aktivasyon fonksiyonuna sahip birçok nöronun
birbirine hiyerarşik olarak bağlandığı bir yapıya
sahip olan MLP, Algılayıcı ve Adaline
yöntemlerinin avantajları yanı sıra geri-yayılım
adındaki öğrenme sistemini kullanmaktadır.
Yrd. Doç. Dr. Umut ORHAN 3
MLP Mimarisi
MLP ağlarında kullanılan bir
nöronun genel yapısı.
x
1
x
2
x
3
y*
ara
katman
çıkış
katmanı
giriş
katmanı
Bir MLP ağının genel mimarisi.
y
+1
x2
x1
w1
w2
b
xn
wn
Σ
net
f
Yrd. Doç. Dr. Umut ORHAN 4
Aktivasyon Fonksiyonu
Genel kavram olarak aktivasyon fonksiyonu,
bir değişkeni farklı bir boyuta taşıyan doğrusal
veya doğrusal olmayan bir fonksiyondur.
Türevinin kolay alınabilmesi eğitim hızını
arttırır. Sıklıkla kullanılan üç aktivasyon
fonksiyonu vardır: Sigmoid, Hiperbolik Tanjant
ve Adım Basamak.
Yrd. Doç. Dr. Umut ORHAN 5
Aktivasyon Fonksiyonu
Sigmoid
Adım basamak
Hiperbolik tanjant
net
e
y



1
1
net
net
e
e
y 2
2
1
1







 


1 0
1 0
net
net
y
Yrd. Doç. Dr. Umut ORHAN 6
Geri-yayılım (Backpropagation)
Tüm ağırlık değerleri, eğim azaltma (gradient
descent) denilen bir yöntemin hata
fonksiyonunu minimize etmesiyle bulunur.
Hesaplanan hata, nöronun çıkışından girişine
doğru giderken aktivasyon fonksiyonunun
türevine maruz kalır. Fonksiyonun türevine
uygulanan hata değeri tüm ağırlıklara, giriş
değerleri oranında dağıtılır.
Yrd. Doç. Dr. Umut ORHAN 7
Geri-yayılım (Backpropagation)
Aktivasyon fonksiyonu olarak sigmoid kullanılırsa;
 
   i
i
j
j
ij
i
i
j
ij j
ij
j
j j
j
j
x
net
y
e
w
net
net
y
y
E
w
E
w
E e d y








  




























 


  
    

 
2 2
2
1
2
1
       ij j j j i j j j i
w   e 1 y y x e 1 y y x
Yrd. Doç. Dr. Umut ORHAN 8
Geri-yayılım (Backpropagation)
Aşağıdaki ifadenin doğruluğunu
için ispatlayınız.
  j j j i
ij
e y y x
w
E
 


  1
net j
e
y



1
1
Yrd. Doç. Dr. Umut ORHAN 9
Geri-yayılım (Backpropagation)
Eğim azaltma ile sistem adım adım hedefe
yaklaşırken bazen yerel minimum değerleri
yüzünden adım miktarı sıfıra gider ve mutlak
hedefe ulaşılamaz. Bunun için eğim azaltma
yönteminin önceki adımlardaki değişim
değerlerinin belirli oranda ( ) katkısını sağlayan
momentum etkisi kullanılır.
( 1) w (t)
w
E
w t
ij
ij
ij  


    

Yrd. Doç. Dr. Umut ORHAN 10
Örnek
Tek ara (gizli) katmanında 2 nöronu olan bir
MLP ağ için iki giriş tek çıkışlı XOR problemini
çözelim.
w11
w22
w21
w12
x1
x2
y
a1
a2
η = 0.5
α = 0.1
w11= 1
w12= -2
w21= -1
w22= 2
a1 = 3
a2 = -3
Yrd. Doç. Dr. Umut ORHAN 11
Eğitimi Durdurma Kriteri
MLP ağının eğitiminin ne zaman durması
gerektiğini belirleyecek bir kriter olmazsa aşırı
eğitim (overfittig) kaçınılmazdır. Çapraz
geçerliğe göre bölünen verinin bir altkümesi
olan eğitim kümesi bir daha ikiye bölünür. Bu
parçalardan birisi eğitimde ağırlıkların
güncellenmesi için kullanılırken diğer parça
(validation set) üzerinde eğitimin başarısı
hesaplanır. Başarının keskin düşüşü
gözlenirse eğitim durdurulur.
Yrd. Doç. Dr. Umut ORHAN 12
Eğitimi Durdurma Kriteri
Yrd. Doç. Dr. Umut ORHAN 13
Matlab Uygulaması - NNTool
Makine Öğrenmesi - 3
(Machine Learning) Bölüm 18
Öbekleme (clustering)
Öbekleme (clustering)
Öbekleme (clustering)
• Bir öbek içindeki mesafeler az olmalı
• Öbekler arası mesafeler fazla olmalı
• Yine bir uzaklık ölçütü kullanmalıyız.
K-ortalama (K-means) öbekleme
K-means algoritması
K-means örneği
K-means örneği
K-means örneği
K-means örneği
K-means örneği
K-means örneği
K-means örneği
K-means örneği
K-means örneği
K-means örneği
REGRESYON ANAL REGRESYON ANAL
İ
Z
İ
Bilgisayar destekli istatistiki y Bilgisayar destekli istatistiki y
öntemler ntemler
Nevzat ADA Nevzat ADA
0830120007 0830120007
Do
ç.Dr. Serdar CARUS .Dr. Serdar CARUS
Üzerinde durulan de zerinde durulan de
ğişkenlerden birinin kenlerden birinin
ba
ğımlı (y), di (y), di
ğerinin (x) ba erinin (x) ba
ğımsız olmas z olması
durumunda y durumunda y
’nin
x
’in bir fonksiyonu bir fonksiyonu
olarak ifade edilen ili olarak ifade edilen ili
şkiye regresyon regresyon
denir.
Ba
ğımlı de
ğişken ile bir veya daha ken ile bir veya daha
çok
ba
ğımsız de
ğişken aras ken arasındaki ili ndaki ili
şkiyi
incelemek amac incelemek amacıyla kullan yla kullanılan bir analiz lan bir analiz
y
öntemine de ntemine de regresyon analizi regresyon analizi denir.
Regresyon analizi, de Regresyon analizi, de
ğişkenler aras kenler arasındaki
neden
-sonu
ç ili
şkisini bulmam kisini bulmamıza imkan za imkan
veren bir analiz y veren bir analiz y
öntemidir. ntemidir.
Regresyon analizi ile ba Regresyon analizi ile ba
ğımlı ve ba
ğımsız
de
ğişkenler aras kenler arasında bir ili nda bir ili
şki var m ki var mıdır?
E
ğer bir ili er bir ili
şki varsa bu ili ki varsa bu ili
şkinin g kinin g
ü
c
ü
nedir? De nedir? De
ğişkenler aras kenler arasında ne t nda ne t
ür bir
ili
şki vard ki vardır? Ba
ğımlı de
ğişkene ait kene ait
ileriye d ileriye d
ö
n
ük de
ğerleri tahmin etmek erleri tahmin etmek
m
ümk
ün m
ü
d
ür ve nas r ve nasıl tahmin l tahmin
edilmelidir? Belirli ko edilmelidir? Belirli ko
şulların kontrol n kontrol
edilmesi durumunda edilmesi durumunda
özel bir de zel bir de
ğişken
veya de veya de
ğişkenler grubunun di kenler grubunun di
ğer
de
ğişken veya de ken veya de
ğişkenler
üzerindeki zerindeki
etkisi nedir ve nas etkisi nedir ve nasıl de
ğişir? gibi ir? gibi
sorulara cevap aranmaya sorulara cevap aranmaya
çalışılır.
Regresyon ba Regresyon ba
şlıca 2
’ye ayrılır:
1)Tek De
ğ
i
şkenli Regresyon Analizi; kenli Regresyon Analizi; Tek
de
ğişkenli regresyon analizi bir ba kenli regresyon analizi bir ba
ğımlı
de
ğişken ve bir ba ken ve bir ba
ğımsız de
ğişken
arasındaki ili ndaki ili
şkiyi inceler. Tek de kiyi inceler. Tek de
ğişkenli
regresyon analizi ile ba regresyon analizi ile ba
ğımlı ve ba
ğımsız
de
ğişkenler aras kenler arasındaki do ndaki do
ğrusal ili rusal ili
şkiyi
temsil eden bir do temsil eden bir do
ğrunun denklemi form runun denklemi form
üle
edilir. edilir.
2)
Çok De
ğ
i
şkenli Regresyon Analizi; kenli Regresyon Analizi;
İ
çinde bir adet ba inde bir adet ba
ğımlı de
ğişken ve birden ken ve birden
fazla ba fazla ba
ğımsız de
ğişkenin bulundu kenin bulundu
ğu
regresyon modelleri regresyon modelleri
çok de
ğişkenli
regresyon analizi olarak bilinir. regresyon analizi olarak bilinir.
İki de
ğişken aras ken arasında
ç
e
şitli ili itli ili
şkiler
Regresyon do Regresyon doğrusal regresyon modeli rusal regresyon modeli ve
doğrusal olmayan regresyon modeli rusal olmayan regresyon modeli
olmak üzere 2 çeşittir.
Doğrusal regresyon modeli: rusal regresyon modeli:
yi=α+βxi
xi:bağımsız değişkeni,
α:doğrunun y eksenini kesti runun y eksenini kestiği değer olarak er olarak
başlangıç değerini,
β:x’deki 1 birim de 1 birim değişmeye kar meye karşılık y’deki
değişim miktar im miktarını gösterir. sterir.
PARAMETRE TAHM PARAMETRE TAHM
İ
N
İ
yi
=
α
+
β
xi
β parametresinin tahmin edicisi b; parametresinin tahmin edicisi b;
REGRESYON KATSAYISININ REGRESYON KATSAYISININ
ÖNEM TEST NEM TEST
İ VE G
ÜVEN
SINIRLARI SINIRLARI
Regresyon katsay Regresyon katsayısının
önem testi ve nem testi ve
g
üven sınırlarının tahmininde t n tahmininde t
da
ğılışı kullanılır ve t da r ve t da
ğılışı ile
yapılan test tahminlerdeki benzer lan test tahminlerdeki benzer
işlem prosed lem prosed
ü
r
ü burada da takip burada da takip
edilir. edilir.
ÖNEM TEST NEM TESTİ
GÜVEN SINIRLARI VEN SINIRLARI
Örnek: Bebekler rnek: Bebekler üzerinde yap zerinde yapılan bir lan bir çalışmada,
bebeklerin ya bebeklerin yaş(ay olarak) ve a (ay olarak) ve ağırlıkları
aşağıdaki gibi bulunmu daki gibi bulunmuştur.
a) Ağırlığın yaşa göre ilişkisini ifade eden kisini ifade eden
regresyon denklemini bulunuz? regresyon denklemini bulunuz?
b) Bebeklerin do Bebeklerin doğum ve 4. ay a um ve 4. ay ağırlığının
bulunuz? bulunuz?
c) Regresyon katsay Regresyon katsayısı b’nin 0’dan büyüklüğünü
tespit ediniz? tespit ediniz?
d) b’nin güven sınırlarını tahminleyiniz? (1 tahminleyiniz? (1-
α=0.95)
Yaş(xi) 1 2 3 4 5 6 7
Ağırlık(yi
)
3.5 4.0 5.0 - 5.2 5.8 6.
5



Do
ğrusal olamayan regresyon rusal olamayan regresyon
modelleri modelleri
Örnek:
Bir bakteri k Bir bakteri k
ült
ü
r
ünde, k
ült
ür
ekiminden 6 dakika sonra ekiminden 6 dakika sonra
ölçülen kloni sayısı (Y)
a
ş
a
ğıda tabloda verilmi da tabloda verilmi
ştir.
a)verilere, Y= a)verilere, Y=ab
x
formunda, en k formunda, en küçük
kareler e kareler e
şitli
ğini kurunuz. ini kurunuz.
b)denklemden elde b)denklemden elde
edece
ğiniz Y de iniz Y de
ğerlerini erlerini
ger
çek de
ğerler ile erler ile
kar
şıla
ş
tırınız. c)X=7 iken z. c)X=7 iken
Y de
ğerini bulunuz? erini bulunuz?
Dakika(X) Dakika(X) Kloni
say.(Y) say.(Y)
0 32
1 47
2 65
3 92
4 132
5 190
6 275

c) X=7 i c) X=7 için y=32.21*1.4277=384.32 in y=32.21*1.4277=384.32 dir.
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
1
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
2
Gleri Yön (Düz) KinematiÂi
Bir robot ana çerçevesinden araç çerçevesine doÂru
birbirine prizmatik veya döner eklemlerle baÂlanmÍó seri
uzuvlardan oluóur. Gki uzuv arasÍndaki ilióki bir homojen
dönüóüm matrisiyle açÍklanÍr. Eklem dönüóüm matrislerinin ard
arda çarpÍlmasÍyla ana çerçeve ile araç çerçeve arasÍndaki ilióki
tanÍmlanÍr. Bu ilióki manipülatörün araç çerçevesinin konumunu
ve yönelimini ana çerçeveye göre belirtir.
 Ísaca ileri yön kinematiÂi eklem deÂókenleri ile uç iólevcisinin
konumu ve yönelimini ana çerçeveye göre hesaplar diyebiliriz.
Her bir ekleme bir koordinat sistemi yerleótirilse komóu iki
eklem arasÍndaki ilióki bir T
i
i
 1
dönüóüm matrisiyle elde edilir.
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
3
T T T T
N
N N
1 1
2
0
1
0
.......
 

Glk ekleme ait dönüóüm matrisi ilk eklem ile ana çerçeve
arasÍndaki iliókiyi tanÍmlarken, son ekleme ait dönüóüm matrisi uç
ólevcisi ile son eklem arasÍndaki iliókiyi ifade eder. Arka arkaya
Íralanan bu eklem dönmüóüm matrisleriyle ana çerçeve ile araç
çerçevesi arasÍndaki ilióki tanÍmlanÍr. Bu iliókiye de ileri kinematik
denir. Ana çerçeve ile araç çerçevesi arasÍndaki ilióki
óeklinde tanÍmlanÍr.
Eklem DeÂókenlerinin Belirlenmesi
RobotlarÍn eklem deÂókenlerinin belirlenmesi için birçok
kinematik yöntem belirlenmiótir. Kinematik problemler kartezyen üç
boyutlu ve kartonom dört boyutlu olmak üzere iki farklÍ uzayda
gerçekleótirilir. Kartezyen uzayda üstel yöntem, Pieper-Roth yöntemi
ve Denativ-Hartenberg yöntemi kullanÍÍr. Ancak en fazla tercih
edilen yöntem Denativ-Hartenberg yöntemidir.
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
4
ai 1
Di 1
i
d
Ti 1
Denativ-Hartenberg Yöntemi
Bu yöntemde dört ana deÂóken kullanÍlarak robot kinematiÂi
³ÍkarÍÍr.
iki komóu eksen arasÍndaki eksen açÍÍ
üst üste çÍkan baÂlar arasÍndaki eklem
kaymasÍ(kaçÍklÍÂÍ)
ve iki komóu uzuv arasÍndaki eklem açÍÍ
Bu dört deÂókende D-H DeÂókenidir.
Bu deÂókenler
iki eksen arasÍndaki uzuv uzunluÂu
‘dir.
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
5
1. Öncelikle eklem eksenleri dönme veya kayma yönleri belirlenir ve
bu eksene paralel bir doÂru çizilir
2. Bu iólem gerçekleótirilirken eklem eksenleri, döner eksenler için
dönme yönü Z, prizmatik eklemler için kayma yönü Z ekseni
olarak belirlenir.
3. Z eksenine dik ve kol boyunca olan baÂ (uzuv) uzunluÂu X ekseni
olarak kabul edilir.
4. Z ve X eksenleri belirlendikten sonra saÂ el kuralÍna göre Y ekseni
bulunur.
5. EÂer arka arkaya gelen 2 eklemin dönme veya kayma yönleri aynÍ
ise Z ekseni belirlendikten sonra kol boyunca X ekseni belirlenir.
Son olarak saÂ el kuralÍna göre Y ekseni belirlenir.
6. 0 ve 1. eksenler üst üste kabul edilebilir.
7. Bir seri robotun eklemine koordinat sistemleri yerleótirilirken 1.
eksenin dönme yönü Z ekseni olarak belirlendikten sonra
genellikle bu eksene X eksenince döndürüldüÂünde komóu iki Z
ekseni çakÍóacak óekilde bir X ekseni yerleótirilir.
Eksenler aóÂÍdaki hususlar dikkate alÍnarak yerleótirilir.
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
6
Bu deÂókenleri belirlemek için öncelikli olarak óekilden
görüldüÂü gibi robotun dönme eksenleri belirlenir ve dönme
eksenleri uzuvlardan bir fazla olacak óekilde numaralandÍÍÍr.
Daha sonra bu eksenlerin her birine bir koordinat sistemi
yerleótirilir ve uzuv dönme ekseni aóÂÍdaki óekilde görüldüÂü
gibi koordinat sisteminin Z ekseni olarak kabul edilir.
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
7
Xi 1
Zi 1 Zi
i 1
a
óÂÍdaki óekildeki gibi yönünde uzanan ile
eksenleri arasÍndaki dik uzaklÍÂa uzuv uzunluÂu denir.
Zi
Xi 1 Xi
i
d
óÂÍdaki óekildeki gibi yönünde uzanan ile
eksenleri arasÍndaki dik uzaklÍÂa eklem kaçÍklÍÂÍ denir.
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
8
Zi 1
Zi
Xi
Di 1
óÂÍdaki óekildeki gibi ekseni ile ekseni arasÍndaki
boyunca ölçülen açÍya eksen açÍÍ denir.
Xi 1
Xi
Zi
Ti
óÂÍdaki óekildeki gibi ekseni ile ekseni arasÍndaki
boyunca ölçülen açÍya eklem açÍÍ denir.
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
9
i 1
a
Di 1 Ti 1
i 1
d
Koordinat sistemleri eklemlere yerleótirildikten sonra D-H
deÂókenleri bulunur ve aóÂÍdaki tabloya yazÍÍr. Robotun
hareket etmesiyle deÂómeyen parametreler uzuv uzunluklarÍ ve
eksen açÍlarÍÍr. DeÂóen parametreler ise eklem döner ise
eklem açÍÍ eÂer eklem prizmatik ise eklem kaçÍklÍÂÍÍr.
»
»
»
»
¼
º
«
«
«
«
¬
ª
   
 


       
       
 
   
 
0 0 0 1
sin sin cos sin cos cos
sin cos cos cos sin sin
cos sin 0
( ) ( ) ( ) ( )
1 1 1 1
1 1 1 1
1
1 1
1
i i i i i i i
i i i i i i i
i i i
x i x i Z i Z i
i
i
d
d
a
T R D a R D d
T D T D D D
T D T D D D
T T
D T
Her bir ekleme ait genel
dönüóüm matrisi
buradan elde edilir.
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
10
Gleri Kinematik Problemlerinin Çözümünde KullanÍlan YaklaóÍmlar
Geometrik YaklaóÍm
Bu yaklaóÍm manipülatör duruóuna baÂÍ olarak oluóan geometrik
óekilden yararlanÍr.
Cebirsel YaklaóÍm
Bu yaklaóÍm manipülatörün parametreleri ve eklem deÂókenleri
arasÍndaki cebirsel iliókilerden yararlanÍr
Dönüóüm matrislerin çarpÍlmasÍyla uç iólevcisinin konumunu ve
yönelimini içeren ve eklem deÂókenlerinin birer fonksiyonu olan
genel bir dönüóüm matrisi elde edilir. Bu matriste 9 adet dönme
(r11,r
12,r13, r
21,r
22,r23, r
31,r
32 ve r33) ve 3 adet de konum (px
, py ve pz
)
belirten toplam 12 elemanÍ bulunur
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
11
Gki boyutlu düzlemde hareket eden robot kolunun geometrik
yaklaóÍm kullanÍlarak ileri yön kinematiÂinin bulunmasÍ
Öncelikle robotun iki boyutlu
düzlemde aldÍÂÍȱóekil çizilerek
uç iólevcisini ifade eden P
noktasÍÍn konumu bulunur.
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
12

  
 
  
 1 1 2 1 2 3 1 2 3 Px
l cosT  
 l cos T  
T  
 l cos T  
T  
T

  
 
  
 1 1 2 1 2 3 1 2 3 Py
l sinT  
 l sin T  
T  
 l sin T  
T  
T
P noktasÍÍn X Eksenindeki izdüóümü
P noktasÍÍn Y Eksenindeki izdüóümü
AynÍ kolun ileri yön kinematiÂini D-H yöntemi ile bulalÍm.
Öncelikle kolun baólangÍç deÂerlerine göre eklemlere koordinat
sistemleri yerleótirilir.
Gkinci adÍmda dönme eklemlerine Z eksenleri yerleótirilir.
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
13
Üçüncü adÍmda Z eksenine dik ve uzuv boyunca
uzanan X eksenleri yerleótirilir.
Dördüncü adÍmda SaÂ El kuralÍna göre Y eksenleri yerleótirilir.
Son adÍmda da Koordinat sistemleri eklemlere yerleótirildikten
sonra D-H deÂókenleri belirlenir ve tabloya eklenir.
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
14
, , ,
0,1 2 3 Z4 Z Z Z ve
0 1 2 3 D ,D ,D ve D
Öncelikle D-H deÂókenlerinden sabit olan parametreler belirlenir.
eksenlerinin dönme yönleri aynÍ olduÂundan
açÍlarÍ 0 ‘dÍr. Z0
ile Z1 arasÍnda X1 boyunca uzanan
herhangi bir baÂ uzunluÂu olmadÍÂÍndan a0=0
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
15
Elde edilen tabloya göre her ekleme ait deÂókenleri aóÂÍdaki genel
matriste yerine koyarak dönüóüm matrislerini bulalÍm.
»
»
»
»
¼
º
«
«
«
«
¬
ª
   
 

       
       
 
 
0 0 0 1
sin sin cos sin cos cos
sin cos cos cos sin sin
cos sin 0
1 1 1 1
1 1 1 1
1
1
i i i i i i i
i i i i i i i
i i i
i
i
d
d
a
T
T D T D D D
T D T D D D
T T
Birinci eklem için dönüóüm matrisi
»
»
»
»
¼
º
«
«
«
«
¬
ª  

»
»
»
»
¼
º
«
«
«
«
¬
ª
   
 

0 0 0 1
0 0 0 0
sin cos 0 0
cos sin 0 0
0 0 0 1
sin sin cos sin cos cos
sin cos cos cos sin sin
cos sin 0
1 1
1 1
1 0 1 0 0 0 1
1 0 1 0 0 0 1
1 1 0
0
1
T T
T T
T D T D D D
T D T D D D
T T
d
d
a
T
Gkinci eklem için dönüóüm matrisi
»
»
»
»
¼
º
«
«
«
«
¬
ª  

»
»
»
»
¼
º
«
«
«
«
¬
ª
   
 

0 0 0 1
0 0 0 0
sin cos 0 0
cos sin 0
0 0 0 1
sin sin cos sin cos cos
sin cos cos cos sin sin
cos sin 0
2 2
2 2 1
2 1 2 1 1 1 2
2 1 2 1 1 1 2
2 2 1
1
2
T T
T T
T D T D D D
T D T D D D
T T
l
d
d
a
T
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
16
Üçüncü eklem için dönüóüm matrisi
»
»
»
»
¼
º
«
«
«
«
¬
ª  

»
»
»
»
¼
º
«
«
«
«
¬
ª
   
 

0 0 0 1
0 0 0 0
sin cos 0 0
cos sin 0
0 0 0 1
sin sin cos sin cos cos
sin cos cos cos sin sin
cos sin 0
3 3
3 3 2
3 2 3 2 2 2 3
3 2 3 2 2 2 3
3 3 2
2
3
T T
T T
T D T D D D
T D T D D D
T T
l
d
d
a
T
Dördüncü eklem için dönüóüm matrisi
»
»
»
»
¼
º
«
«
«
«
¬
ª

»
»
»
»
¼
º
«
«
«
«
¬
ª  

»
»
»
»
¼
º
«
«
«
«
¬
ª
   
 

0 0 0 1
0 0 1 0
0 1 0 0
1 0 0
0 0 0 1
0 0 0 0
sin cos 0 0
cos sin 0
0 0 0 1
sin sin cos sin cos cos
sin cos cos cos sin sin
cos sin 0
3
4 4
4 4 3
4 2 4 3 3 3 4
4 2 4 3 3 3 4
4 4 3
3
4
l l
d
d
a
T
T T
T T
T D T D D D
T D T D D D
T T
76
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
17
Elde edilen dört ekleme ait dönüóüm matrisleri
birbirleriyle çarpÍlarak manipülatöre ait dönüóüm
matrisi elde edilir.
»
»
»
»
¼
º
«
«
«
«
¬
ª
»
»
»
»
¼
º
«
«
«
«
¬
ª  
»
»
»
»
¼
º
«
«
«
«
¬
ª  
»
»
»
»
¼
º
«
«
«
«
¬
ª  


0 0 0 1
0 0 1 0
0 1 0 0
1 0 0
.
0 0 0 1
0 0 0 0
sin cos 0 0
cos sin 0
.
0 0 0 1
0 0 0 0
sin cos 0 0
cos sin 0
.
0 0 0 1
0 0 0 0
sin cos 0 0
cos sin 0 0 3
3 3
3 3 2
2 2
2 2 1
1 1
1 1
3
4
2
3
1
2
0
1
0
4
l l l
T T T T T
T T
T T
T T
T T
T T
T T

  
 
  
 
  
 
  
 
 
  
 
  
  
 
  

  
 
  
 
  
 
  
 
 
  
 
  
  
 
  
»
»
»
»
¼
º
«
«
«
«
¬
ª
 
 
 
 
   
  
  
  
  
  
  

 
   
    
  
  
  
    
  
  
  


0 0 0 1
0 0 1 0
0
0
1 2 3 1 2 3 1 2 3 1 2 3 3 1 2 3 1 2 3 2 1 2 1 1
1 2 3 1 2 3 1 2 3 1 2 3 3 1 2 3 1 2 3 2 1 2 1 1
T T T T T T T T T T T T T T T T T T T T T
T T T T T T T T T T T T T T T T T T T T T
s c c s c c s s l s c c s l s l s
c c s s s c c s l c c s s l c l c

  
 
  
 3 1 2 3 2 1 2 1 1 Px l cos T  
T  
T  
 l cos T  
T  
 l cosT

  
 
  
 3 1 2 3 2 1 2 1 1 Py l sin T  
T  
T  
 l sin T  
T  
 l sinT
elde edilen dönüóüm matrisinin konum vektöründen
Denklemleri elde edilir.
c
T1  
T2
 
cT3   s
T1  
T2
 
sT3 cos
  
, T1  
T2  
T3
s
T1  
T2
 
cT3  
 c
T1  
T 2
 
sT3 
  
 1 2 3
sin T  
T  
T
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
18
Robotlarda KullanÍlan Bilek Düzenleóimleri
Endüstriyel robotlarda Euler ve eklem kaçÍklÍklÍ bilek olmak üzere iki
tip bilek düzenleóimi kullanÍÍr. Euler bilekli düzenleóimde üç eksen bir
noktada kesióirken eklem kaçÍklÍklÍ bilekte eklemlerin kesiómesi eklem
kaymasÍ ve uzuv uzunluklarÍ ile engellenir.
Euler Bileklik Düzenleóimin Gleri Yön KinematiÂi
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
19
Öncelikle D-H DeÂókenlerine ait tablo oluóturulur
Bu tabloya göre de bilek düzenleóimine ait ileri yön kinematiÂine
ait dönüóüm matrisi bulunur.
»
»
»
»
¼
º
«
«
«
«
¬
ª
 
 
   
  
       

»
»
»
»
¼
º
«
«
«
«
¬
ª
   
 
»
»
»
»
¼
º
«
«
«
«
¬
ª
 
 
»
»
»
»
¼
º
«
«
«
«
¬
ª  

0 0 0 1
0
0
0
0 0 0 1
0 0
0 0 1 0
0 0
0 0 0 1
0 0
0 0 1 0
0 0
0 0 0 1
0 0 1 0
0 0
0 0
0
j k j k j
i j k i k i j k i k i j
i j k i k i j k i k i j
k k
k k
j j
j j
i
i i
k
s c s s s
s c c c s s c s c c s s
c c c s s c c s s c c s
s c
c s
s c
c s
s c
c s
T
T T T T T
T T T T T T T T T T T T
T T T T T T T T T T T T
T T
T T
T T
T T
T T
T T
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
20
Eklem KaçÍklÍÍklÍ Bileklik Düzenleóiminin Gleri Yön KinematiÂi
Öncelikle D-H DeÂókenlerine ait tablo oluóturulur
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
21
Bu tabloya göre de bilek düzenleóimine ait ileri yön kinematiÂine
ait dönüóüm matrisi bulunur.

  
 
  

  
 
  

  
 »
»
»
»
¼
º
«
«
«
«
¬
ª
 
 
   
      
           


»
»
»
»
¼
º
«
«
«
«
¬
ª
   
 
»
»
»
»
¼
º
«
«
«
«
¬
ª
 
 
»
»
»
»
¼
º
«
«
«
«
¬
ª  

0 0 0 1
0 0 0 1
0 0
0 0 1
0 0
0 0 0 1
0 0
0 0 1 0
0
0 0 0 1
0 0 1 0
0 0
0 0
0
j k j k j j
i j k i k i j k i k i j i j i
i j k i k i j k i k i j i j i
k k
k k
j j
j j
i
i i
k
s c s s s d c
s c c c s s c s c c s s d s s a s
c c c s s c c s s c c s d c s a c
s c
d
c s
s c
c s a
s c
c s
T
T T T T T T
T T T T T T T T T T T T T T T
T T T T T T T T T T T T T T T
T T
T T
T T
T T
T T
T T
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
22
AltÍ Serbestlik Derecesine Sahip Robotun Gler Yön KinematiÂi
Endüstriyel robotlara Euler veya eklem kaçÍklÍklÍ bilek eklendiÂinde 6
serbestlik dereceli robotlar elde edilir. Euler bileklikli robotlar
endüstride hafif yüklerde tercih edilirken, eklem kaçÍklÍklÍ robotlar
ÂÍr yüklerin kaldÍÍlmasÍ gibi iólemlerde tercih edilir.
Scara diye tanÍmlanan altÍ serbestlik dereceli robotun ileri yön
kinematiÂini bulalÍm
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
23
Öncelikle koordinat sistemlerini her bir ekleme
yerleótirelim ve ardÍndan D-H parametrelerine ait
tabloyu oluóturalÍm.
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
24
Her ekleme ait dönüóüm matrisleri bulunur
»
»
»
»
¼
º
«
«
«
«
¬
ª  

0 0 0 1
0 0 1
sin cos 0 0
cos sin 0 0
1
1 1
1 1
0
1
h
T
T T
T T
»
»
»
»
¼
º
«
«
«
«
¬
ª  

0 0 0 1
0 0 1 0
sin cos 0 0
cos sin 0
2 2
2 2 1
1
2
T T
T T l
T
»
»
»
»
¼
º
«
«
«
«
¬
ª
   
 

0 0 0 1
0 0 1
0 1 0 0
1 0 0
3
2
2
3
d
l
T
»
»
»
»
¼
º
«
«
«
«
¬
ª  

0 0 0 1
0 0 1
sin cos 0 0
cos sin 0 0
4
4 4
4 4
3
4
d
T
T T
T T
»
»
»
»
¼
º
«
«
«
«
¬
ª
   
 

0 0 0 1
sin cos 0 0
0 0 1 0
cos sin 0 0
5 5
5 5
4
5
T T
T T
T
»
»
»
»
¼
º
«
«
«
«
¬
ª
 
 

0 0 0 1
sin cos 0 0
0 0 1 0
cos sin 0 0
6 6
6 6
5
6
T T
T T
T
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
25
T T T T T T T
5
6
4
5
3
4
2
3
1
2
0
1
0
6


 
  
 
  
  
 
 
  
 
  
  

 
  
 
  
  
 
 
  
 
  
  
«
«
«
«
¬
ª
 
   
    
  
  

 
 
 
   
    


0
5 6
1 2 4 1 2 4 5 6 1 2 4 1 2 4 6
1 2 4 1 2 4 5 6 1 2 4 1 2 4 6
0
6
T T
T T T T T T T T T T T T T T T
T T T T T T T T T T T T T T T
s c
s c c s c c s c c s s
c c s s c c c c s s s
T

 
  
 
  
  
 
 
  
 
  
  

 
  
 
  
  
 
 
  
 
  
  
0
5 6
1 2 4 1 2 4 5 6 1 2 4 1 2 4 6
1 2 4 1 2 4 5 6 1 2 4 1 2 4 6
T T
T T T T T T T T T T T T T T T
T T T T T T T T T T T T T T T
s c
s c c s c s s c c s c
c c s s c s c c s s c
 
   
    
    
  
  

   
  
  
    
    


 
  
 
  
  

 
  
 
  
  

  

  
»
»
»
»
¼
º
   
 
 

 
 

 
   
    

   
  
  

0 1
1 3 4
2 1 2 1 1
2 1 2 1 1
6
1 2 4 1 2 4 5
1 2 4 1 2 4 5
h d d
l s l s
l c l c
c
s c c s s
c c s s s
T T T
T T T
T
T T T T T T T
T T T T T T T
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
26
Ters Kinematik
Robotun uç iólevcisinin ana çerçeveye göre konumu ve yönelimi
verildiÂinde manipülatörün bu konuma ve yönelime gelebilmesi için
gerekli eklem deÂókenlerinin bulunmasÍÍr.
Baóka bir deÂóle de uç iólevcisinin konum ve yönelimini
kartezyen koordinat sisteminden eklem koordinat sistemine
dönüótürme iólemi olarak da tanÍmlayabiliriz.
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
27
Ters kinematik aóÂÍdaki nedenlerden dolayÍ çözülmesi oldukça
zor olan problemler içerir.
•Analitik olarak karmaóÍk, doÂrusal olmayan denklemler içerir.
•Eklemlerin yapÍÍna baÂÍÍr. EÂer robot prizmatik eklemlerden
oluóuyorsa ters kinematik problemin çözümü kolaylaóÍrken,
robottaki döner eklem sayÍÍ arttÍkça problemin çözümü de o
derece zorlaómaktadÍr.
•Her zaman matematiksel çözüm fiziksek çözümü temsil etmez.
Birinci óekilde matematiksel çözümle fiziksel çözüm örtüóürken
ikinci óekilde örtüómez
arctan2( , ) pz T  k arctan2( , )
z T k   p
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
28
2 64 6

•AynÍ uç iólevci düzenleóimi için birden fazla çözüm olabilir. Ters
kinematik çözüm sayÍÍ robotun serbestlik derecesinin yanÍnda
aynÍ zamanda eklem deÂókenlerine de baÂÍÍr. Her bir eklemde
uzuv uzunluÂu ve eklem kaçÍklÍÂÍÍn olmasÍ çözüm sayÍÍÍn
artmasÍna neden olur. ÖrneÂin 6R robotta her bir eklem için en
azÍndan bir uzuv uzunluÂu ve eklem kaçÍklÍÂÍ olduÂundan ters
kinematik çözüm sayÍÍ
YalnÍz bu çözümlerin bir kÍsmÍ gerçek bir kÍsmÍ ise sanaldÍr. Dönel
eklemlerden oluóan robotlarda fiziksel çözüm sayÍÍn fazla olmasÍ,
üç boyutlu uzayda bir noktaya birkaç óekilde ulaóma imkânÍ saÂlar.
ÖrneÂi PUMA robotunun aynÍ noktaya dört farklÍ óekilde
erióebildiÂimi gösterir.
‘dür.
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
29
Ters Kinematik Problemlerine Analitik Çözüm YaklaóÍÍ
Craig tarafÍndan tanÍmlanan altÍ serbestlik derecesine sahip bir
robotun ileri yön kinematiÂi aóÂÍdaki gibi yazÍÍr.
T T T T T T T
5
6
4
5
3
4
2
3
1
2
0
1
0
6
> T@ T I
  0
1
1 0
1 OlduÂundan yukarÍdaki denklem daha basit bir
ifadeyle elde edilebilir.
> T @ T T T T T T
5
6
4
5
3
4
2
3
1
2
0
6
1 0
1
 
> T T @ T T T T T
5
6
4
5
3
4
2
3
0
6
1 1
2
0
1
 
> T T T @ T T T T
5
6
4
5
3
4
0
6
1 2
3
1
2
0
1
 
> T T T T @ T T T
5
6
4
5
0
6
1 3
4
2
3
1
2
0
1
 
> T T T T T @ T T
5
6
0
6
1 4
5
3
4
2
3
1
2
0
1
 
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
30
cos a ise arctan 2
 1 a ,a 
2
T T r  

  
2
sinT a ise T arctan 2 a,r 1  a
cosT a ve sinT b ise T arctan2
b,a 
a sinT  
 b cosT 0 ise
T arctan 2
 b,a 
 veya T arctan 2
b, a 
a sinT  
 b cosT c ise
arctan 2
  
 a,b arctan 2
 a b c ,c 
2 2 2
T  
 T r  
  
Ters kinematik çözüm gerçekleótirilirken kullanÍlan bazÍ
trigonometrik eóitlikler.
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
31
Örnek
»
»
»
»
¼
º
«
«
«
«
¬
ª  

0 0 0 1
0 0 1 0
sin cos 0 0
cos sin 0 0
1 1
1 1
0
1
T T
T T
T
»
»
»
»
¼
º
«
«
«
«
¬
ª  

0 0 0 1
0 0 1 0
sin cos 0 0
cos sin 0
2 2
2 2 1
1
2
T T
T T l
T
»
»
»
»
¼
º
«
«
«
«
¬
ª

0 0 0 1
0 0 1 0
0 1 0 0
1 0 0 2
2
3
l
T
T T T T
2
3
1
2
0
1
0
3

> @
1 0
1
 
T
> T @ T > T @ T T T
2
3
1
2
0
1
1 0
1
0
3
1 0
1
   

Gleri yön kinematiÂine ait dönüóüm matrisinin her iki tarafÍÍ
ile çarpalÍm.
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
32
> T @ T I
  0
1
1 0
1
> T @ T T T
2
3
1
2
0
3
1 0
1
 
BilindiÂi gibi olduÂundan denklem aóÂÍdaki gibi olur.
»
¼
º
«
¬
ª  

 
0 0 0 1
1
0 0
1
0
0 1 1
1
R R P
T
T T
»
»
»
¼
º
«
«
«
¬
ª  

0 0 1
sin cos 0
cos sin 0
1 1
1 1
0
1 T T
T T
R
»
»
»
¼
º
«
«
«
¬
ª
 
0 0 1
sin cos 0
cos sin 0
1 1
1 1
0
1 T T
T T
T R
T
0
1
»
»
»
¼
º
«
«
«
¬
ª

»
»
»
¼
º
«
«
«
¬
ª
»
»
»
¼
º
«
«
«
¬
ª
   
0
0
0
0
0
0
0 0 1
sin cos 0
cos sin 0
1 1
1 1
1
0 0
1 T T
T T
R P
T
Dönüóüm matrisinin konum vektörü sÍÍr olduÂundan
»
»
»
»
¼
º
«
«
«
«
¬
ª
 

 
0 0 0 1
0 0 1 0
sin cos 0 0
cos sin 0 0
1 1
1 1
0 1
1
T T
T T
T
elde edilir.
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
33
Bu matrisi T
0
3
ileri kinematiÂi temsil eden matrisle çarpalÍm
»
»
»
»
¼
º
«
«
«
«
¬
ª

0 0 0 1
31 32 33
21 22 23
11 12 13
0
3
z
y
x
r r r p
r r r p
r r r p
T
»
»
»
»
¼
º
«
«
«
«
¬
ª
»
»
»
»
¼
º
«
«
«
«
¬
ª
 

 
0 0 0 1 0 0 0 1
0 0 1 0
sin cos 0 0
cos sin 0 0
31 32 33
21 22 23
11 12 13
1 1
1 1
0
3
0 1
1
z
y
x
r r r p
r r r p
r r r p
T T
T T
T T
»
»
»
»
¼
º
«
«
«
«
¬
ª
   
    
    
    

 
 
 
 


0 0 0 1
sin cos sin cos sin cos sin cos
cos sin cos sin cos sin cos sin
31 32 33
1 11 1 21 1 12 1 22 1 13 1 23 1 1
1 11 1 21 1 12 1 22 1 13 1 23 1 1
z
x x
x y
r r r p
r r r r r r p p
r r r r r r p p
T T T T T T T T
T T T T T T T T
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
34
> T @ T
0
3
1 0
1
 
T T
2
3
1
2
»
»
»
»
¼
º
«
«
«
«
¬
ª    


»
»
»
»
¼
º
«
«
«
«
¬
ª
»
»
»
»
¼
º
«
«
«
«
¬
ª  

0 0 0 1
0 0 1 0
sin cos 0 cos
cos sin 0 cos
0 0 0 1
0 0 1 0
0 1 0 0
1 0 0
0 0 0 1
0 0 1 0
sin cos 0 0
cos sin 0
2 2 2 2
2 2 2 2 2 1
2 2
2 2 1
2
3
1
2
T T T
T T T
T T
T T
l
l l l l
T T
ÇarpÍÍÍ bulduk. kimdide
çarpÍÍÍ bulalÍm ve iki sonucu birbirine eóitleyelim.
»
»
»
»
¼
º
«
«
«
«
¬
ª    


»
»
»
»
¼
º
«
«
«
«
¬
ª
   
    
    
    

 
 
 
 

0 0 0 1
0 0 1 0
sin cos 0 cos
cos sin 0 cos
0 0 0 1
sin cos sin cos sin cos sin cos
cos sin cos sin cos sin cos sin
2 2 2 2
2 2 2 2 1
31 32 33
1 11 1 21 1 12 1 22 1 13 1 23 1 1
1 11 1 21 1 12 1 22 1 13 1 23 1 1
T T T
T T T
T T T T T T T T
T T T T T T T T
l
l l
r r r p
r r r r r r p p
r r r r r r p p
z
x x
x y
Bulunur.
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
35
1 11 1 21 2
cosT r  
 sinT r cosT
1 11 1 21 2  sinT r  
 cosT r sinT
r31 0
1 12 1 22 2
cosT r  
sinT r  sinT
1 12 1 22 2  sinT r  
 cosT r cosT
r32 0
cosT1
r13  
 sinT1
r23 0
sin 3 cos 0   T1
r  
 T1
r23
1 r33
1 1 2 2 1
cos P sin P l cos l T x  
 T y T  

1 1 2 2   sinT Px  
 cosT Py l sinT
1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.
12. Pz 0
óitlikleri elde edilir.
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
36
Ters kinematik çözümün tamamÍ mümkünse kol uzunluklarÍ
cinsinden elde edilmelidir. Bu nedenle 10. ve 11. denklemlerin
her iki tarafÍÍn karesini alÍp alt alta toplayalÍm.

  
2
2 2
2
2
2 1 2 2 1
2 2
2
2
1
2 2 2
1
2
1
2 2
1
2
2
2 2
2
2
1
2 2 2
1
2
2 1 2 2 1
2 2
2
2
1
2 2
1
2
cos sin sin cos cos 2 cos sin
sin cos sin
cos sin cos 2 cos
T T T T T T T
T T T
T T T T
P P P P l l l l l
P P l
P P l l l l
x y x y
x y
x y
 
 
 
 
 
 

 
   

 
 
 

2 2
x Py P ve 2
2
ó l
itliÂin sol tarafÍÍ , saÂ tarafÍÍ da parantezine alalÍm.

  
 
  
 
  
2
2 1 2 2 1
2
2
2 2
2
2
1
2
1
2 2 2
1 1
2
cos sin P sin cos P l cos sin 2l l cos l T  
 T x  
 T  
 T y T  
 T  
 T  


cos sin  
 1
2
1 1
2
T  
 T ‘dir.
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
37
2
1 2 2 1
2
2
2 2
P P l 2l l cos l
x  
 y
 
T  

Bu durumda denklemi yeniden yazarsak
olur.
Buradan ¸
¸
¹
·
¨
¨
©
§  
    


1 2
2
1
2
2
2 2
2
2
( )
cos
l l
P P l l
x y
T bulunur.
Bunu cos a ise arctan 2
 1 a ,a 
2
T T r   denklemine uyarlarsak
¸
¸
¸
¹
·
¨
¨
¨
©
§
¸
¸
¹
·
¨
¨
©
§  
    

¸
¸
¹
·
¨
¨
©
§  
    

r  
1 2
2
1
2
2
2 2
2
1 2
2
1
2
2
2 2
2
2
( )
,
2
( )
arctan 2 1
l l
P P l l
l l
P P l l
x y x y
T bulunur.
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
38
1 1 2 2 1
cos P sin P l cos l T x  
 T y T  

Bu ifadeyi de a sinT  
 bcosT c ‘e uyarlarsak
P a P b l l c x

,
y

,
2
cosT2  
 1 Olur.
arctan 2
  
 a,b arctan 2
 a b c ,c 
2 2 2
T rT  
  

  
 
  
 
  
¸
¹
·
¨
©
§ r  
    
 2 2  
 1
2
2 2 1
2
1
arctan 2 P ,P arctan 2 P P l cos l , l cos l T y x T y x T T elde edilir.
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
39
,
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
40
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
41
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
42
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
43
Eksen
no
Eksen
açÕVÕ
(z’ler
arasÕ)
Di
Eklem
uzunlu÷u
(z’ler
arasÕ)
ai
Eklem
kaçÕklÕ÷Õ
(x’ler
arasÕ)
di
Eklem
açÕVÕ
(Z’etra
IÕnda)
Ti
1
(0-1)
0 a1 d1 T1
2
(1-2)
S
(1800
)
a2 0 T2
3
(2-3)
0 0 d3 0
4
(3-4)
0 0 d4 T4
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
44
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
45
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
46
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
47
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
48
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
49
TEMEL ROBOTúK Ders sorumlusu: Yrd.Doç.Dr.Hilmi KUùÇU
50
1
YAPAY SİNİR AĞLARI
3.1.Yapay Sinir Ağlarının Genel Tanımı
3.2. Yapay Sinir Ağlarının Görevi
3.3. Yapay Sinir Ağlarının Genel Özellikleri
3.4. Yapay Sinir Ağları İle Neler Yapılabilir?
3.5. Yapay Sinir Ağlarının Tarihçesi
3.6. Yapay Sinir Ağlarının Yapısı ve Temel Elemanları
3.7. Yapay Sinir Ağı Modelleri
3.8. Eğiticili YSA Modeli
3.9. Eğiticisiz YSA Modeli
2
3. YAPAY SİNİR AĞLARI
3.1.Yapay Sinir Ağlarının Genel Tanımı
Yapay sinir ağları, insan beyninin özelliklerinden olan öğrenme yolu ile yeni bilgiler
türetebilme, yeni bilgiler oluşturabilme ve keşfedebilme gibi yetenekleri herhangi bir yardım almadan
otomatik olarak gerçekleştirmek amacı ile geliştirilen bilgisayar sistemleridir. Bu yetenekleri
geleneksel programlama yöntemleri ile gerçekleştirmek oldukça zor veya mümkün değildir. O
nedenle, yapay sinir ağlarının, programlanması çok zor veya mümkün olmayan olaylar için
geliştirilmiş adaptif bilgi işleme ile ilgilenen bir bilgisayar bilim dalı olduğu söylenebilir.
3.2. Yapay Sinir Ağlarının Görevi
Yapay sinir ağları, insanlar tarafından gerçekleştirilmiş örnekleri (gerçek beyin fonksiyonlarının
ürünü olan örnekleri) kullanarak olayları öğrenebilen, çevreden gelen olaylara karşı nasıl tepkiler
üretileceğini belirleyebilen bilgisayar sistemleridir. İnsan beyninin fonksiyonel özelliklerine benzer
şekilde,
• öğrenme
• ilişkilendirme
• sınıflandırma
• genelleme
• özellik belirleme
• optimizasyon
gibi konularda başarılı bir şekilde uygulanmaktadırlar. Örneklerden elde ettikleri bilgiler ile kendi
deneyimlerini oluşturur ve daha sonra, benzer konularda benzer kararları verirler.
Yapay sinir ağları günümüzde bir çok probleme çözüm üretebilecek yeteneğe sahiptir. Değişik
şekillerde tanımlanmaktadır. Tanımların ortak bir kaç noktası vardır. Bunların en başında yapay sinir
ağlarının birbirine hiyerarşik olarak bağlı ve paralel olarak çalışabilen yapay hücrelerden oluşmaları
gelmektedir. Proses elemanları da denilen bu hücrelerin birbirlerine bağlandıkları ve her bağlantının
bir değerinin olduğu kabul edilmektedir. Bilginin öğrenme yolu ile elde edildiği ve proses
elamanlarının bağlantı değerlerinde saklandığı dolayısıyla dağıtık bir hafızanın söz konusu olduğu da
ortak noktaları oluşturmaktadır. Proses elemanlarının birbirleri ile bağlanmaları sonucu oluşan ağa
yapay sinir ağı denmektedir. Bu ağın oluşturulması biyolojik sinir sistemi hakkındaki bulgulara
dayanmaktadır.
3
Şekil 3.1. Bir yapay sinir ağı örneği
Teknik olarak da, bir yapay sinir ağının en temel görevi, kendisine gösterilen bir girdi setine
karşılık gelebilecek bir çıktı seti belirlemektir. Bunu yapabilmesi için ağ, ilgili olayın örnekleri ile
eğitilerek (öğrenme) genelleme yapabilecek yeteneğe kavuşturulur. Bu genelleme ile benzer olaylara
karşılık gelen çıktı setleri belirlenir.
Ağı oluşturan proses elemanları, bunların bilgileri işleme yetenekleri, birbirleri ile
bağlantılarının şekilleri değişik modelleri oluşturmaktadır. Bu modeller ile ilgili bilgiler ileride
ayrıntılı olarak açıklanacaktır. Bu bölümde yapay sinir ağları konusunda genel bilgiler verilmeye
çalışılacaktır.
Yapay sinir ağları aynı zamanda, "bağlantılı ağlar (connectionist networks)", "paralel dağıtılmış
ağlar (parallel distributed networks)", "nuromorfık sistemler (neuromorfic systems)" olarak da
adlandırılmaktadır. Yapay sinir ağları bilgisayar bilimine de bazı yenilikler getirmiştir. Algoritmik
olmayan, adaptif, paralel programlama, dağıtılmış programlama vb. gibi tekniklerinin gelişmesine
katkıda bulunmuşlardır. Bilgisayarlarında öğrenebileceğini göstermişlerdir. Özellikle olaylar hakkında
bilgilerin olmadığı fakat örneklerin bulunduğu durumlarda çok etkin olarak kullanılabilecek bir karar
verme aracı ve hesaplama yöntemi olarak görülebilir.
3.3. Yapay Sinir Ağlarının Genel Özellikleri
Yapay sinir ağlarının karakteristik özellikleri uygulanan ağ modeline göre değişmektedir. İlgili
modeller anlatılırken her modelin özellikleri ayrıntılı olarak anlatılacaktır. Burada bütün modeller için
geçerli olan genel karakteristik özellikler verilmiştir. Bunlar aşağıdaki gibi sıralanabilir:
• Yapay sinir ağları makine öğrenmesi gerçekleştirirler. Yapay sinir ağlarının temel işlevi
bilgisayarların öğrenmesini sağlamaktır. Olayları öğrenerek benzer olaylar karşısında benzer
kararlar vermeye çalışırlar.
4
• Programları çalışma stili bilinen programlama yöntemlerine benzememektedirler.
Geleneksel programlama ve yapay zekâ yöntemlerinin uygulandığı bilgi işleme yöntemlerinden
tamamen farklı bir bilgi işleme yöntemi vardır.
• Bilginin saklanması: Yapay sinir ağlarında bilgi ağın bağlantılarının değerleri ile ölçülmekte
ve bağlantılarda saklanmaktadır. Diğer programlarda olduğu gibi veriler bir veri tabanında veya
programın içinde gömülü değildir. Bilgiler ağın üzerinde saklı olup ortaya çıkartılması ve
yorumlanması zordur.
• Yapay sinir ağları örnekleri kullanarak öğrenirler. Yapay sinir ağlarının olayları
öğrenebilmesi için o olay ile ilgili örneklerin belirlenmesi gerekmektedir. Örnekleri kullanarak
ilgili olay hakkında genelleme yapabilecek yeteneğe kavuşturulurlar (adaptif öğrenme). Örnek
bulunamıyorsa ve yok ise yapay sinir ağının eğitilmesi mümkün değildir. Örnekler ise
gerçekleşmiş olan olaylardır. Mesela bir doktor hastasına bazı sorular sorar ve aldığı cevaplara
göre teşhis ederek ilaç yazar. Sorulan sorular ve verilen cevaplar ile konulan teşhis bir örnek
olarak nitelendirilir. Bir doktorun belirli bir zaman içinde hastaları ile yaptığı görüşmeler ve
koyduğu teşhisler not edilerek örnek olarak alınırsa yapay sinir ağı benzer hastalıklara benzer
teşhisi koyabilir. Elde edilen örneklerin olayı tamamı ile gösterebilmesi çok önemlidir. Ağa olay
bütün yönleri ile gösterilemez ve ilgili örnekler sunulmaz ise başarılı sonuçlar elde edilemez. Bu
ağın sorunlu olduğundan değil olayın ağa iyi gösterilemediğindendir. O nedenle örneklerin
oluşturulması ve toplanması yapay sinir ağı biliminde özel bir öneme sahiptir.
• Yapay sinir ağlarının güvenle çalıştırılabilmesi için önce eğitilmeleri ve performanslarının
test edilmesi gerekmektedir. Yapay sinir ağlarının eğitilmesi demek, mevcut örneklerin tek tek
ağa gösterilmesi ve ağın kendi mekanizmalarını çalıştırarak örnekteki olaylar arasındaki
ilişkileri belirlemesidir. Bu konu kitabın değişik bölümlerinde ayrıntılı olarak anlatılacaktır. Her
ağı eğitmek için elde bulunan örnekler iki ayrı sete bölünürler. Birincisi ağı eğitmek için (eğitim
seti) diğeri ise ağın performansını sınamak için (test seti) kullanılır. Her ağ önce eğitim seti ile
eğitilir. Ağ bütün örneklere doğru cevaplar vermeye başlayınca eğitim işi tamamlanmış kabul
edilir. Daha sonra ağın hiç görmediği test setindeki örnekler ağa gösterilerek ağın verdiği
cevaplara bakılır. Eğer ağ hiç görmediği örneklere kabul edilebilir bir doğrulukta cevap veriyor
ise o zaman ağın performansı iyi kabul edilir ve ağ kullanıma alınarak gerekirse çevrimiçi (online) kullanılır. Eğer ağın performansı yetersiz olursa o zaman yeniden eğitmek veya yeni
örnekler ile eğitmek gibi bir çözüme gidilir. Bu işlem ağın performansı kabul edilebilir bir
düzeye gelinceye kadar devam eder.
• Görülmemiş örnekler hakkında bilgi üretebilirler. Ağ kendisine gösterilen örneklerden
genellemeler yaparak görmediği örnekler hakkında bilgiler üretebilirler.
• Algılamaya yönelik olaylarda kullanılabilirler. Ağlar daha çok algılamaya yönelik bilgileri
işlemede kullanılırlar. Bu konuda başarılı oldukları yapılan uygulamalarda görülmektedir.
5
Bilgiye dayalı çözümlerde uzman sistemler kullanılmaktadır. Bazı durumlarda yapay sinir ağı
ve uzman sistemleri birleştirmek daha başarılı sistemler oluşturmaya neden olmaktadır.
• Şekil (örüntü) ilişkilendirme ve sınıflandırma yapabilirler. Genel olarak ağların çoğunun
amacı kendisine örnekler halinde verilen örüntülerin kendisi veya diğerleri ile
ilişkilendirilmesidir. Diğer bir amaç ise sınıflandırma yapmaktır. Verilen örneklerin
kümelendirilmesi ve belirli sınıflara ayrıştırılarak daha sonra gelen bir örneğin hangi sınıfa
gireceğine karar vermesi hedeflenmektedir.
• Örüntü tamamlama gerçekleştirebilirler. Bazı durumlarda ağa eksik bilgileri içeren bir
örüntü (pattern), veya bir şekil verilir. Ağın bu eksik bilgileri bulması istenir. Örneğim yırtık bir
resmin kime ait olduğunu belirlemesi ve tam resmi vermesi gibi bir sorumluluk ağdan
istenebilmektedir. Bu tür olaylarda yapay sinir ağlarının çok etkin çözümler ürettiği
bilinmektedir.
• Kendi kendini organize etme ve öğrenebilme yetenekleri vardır. Yapay sinir ağlarının
örnekler ile kendisine gösterilen yeni durumlara adapte olması ve sürekli yeni olayları
öğrenebilmesi mümkündür.
• Eksik bilgi ile çalışabilmektedirler. Yapay sinir ağları kendileri eğitildikten sonra eksik
bilgiler ile çalışabilir ve gelen yeni örneklerde eksik bilgi olmasına rağmen sonuç üretebilirler.
Eksik bilgiler ile de çalışmaya devam ederler. Hâlbuki geleneksel sistemler bilgi eksik olunca
çalışmazlar. Burada bir noktaya dikkatleri çekmekte fayda vardır. Yapay sinir ağlarının eksik
bilgiler ile çalışması performanslarının düşeceği anlamına gelmez. Performansın düşmesi eksik
olan bilginin önemine bağlıdır. Hangi bilginin önemli olduğunu ağ (network) kendisi eğitim
sırasında öğrenmektedir. Kullanıcıların bu konuda bir fikri yoktur. Ağın performansı düşük
olunca, kayıp olan bilginin önemli olduğu kararma varılır. Eğer ağın performansı düşmez ise
eksik olan bilginin önemli olmadığı anlaşılır.
• Hata toleransına sahiptirler. Yapay sinir ağlarının eksik bilgilerle çalışabilme yetenekleri
hatalara karşı toleranslı olmalarını sağlamaktadır. Ağın bazı hücrelerinin bozulması ve
çalışamaz duruma düşmesi halinde ağ çalışmaya devam eder. Ağın bozuk olan hücrelerinin
sorumluluklarının önemine göre ağın performansında düşmeler görülebilir. Hangi hücrelerin sorumluluklarının önemli olduğuna da yine ağ eğitim esnasında kendisi karar verir. Bunu kullanıcı
bilmemektedir. Ağın bilgisinin yorumlanamamasının sebebi de budur.
• Belirsiz, tam olmayan bilgileri işleyebilmektedirler. Yapay sinir ağlarının belirsiz bilgileri
işleyebilme yetenekleri vardır. Olayları öğrendikten sonra belirsizlikler altında ağlar
öğrendikleri olaylar ile ilgili ilişkileri kurarak kararlar verebilirler.
• Dereceli bozulma (Graceful degradation) gösterirler. Yapay sinir ağlarının hatalara karşı
toleranslı olmaları bozulmalarının da dereceli (göreceli) olmasına neden olmaktadır. Bir ağ
(network) zaman içerisinde yavaş yavaş ve zarif bir şekilde bozulur. Bu eksik olan bilgiden veya
6
hücrelerin bozulmasından kaynaklanır. Ağlar, herhangi bir problem ortaya çıktığında hemen
anında bozulmazlar.
• Dağıtık belleğe sahiptirler. Yapay sinir ağlarında bilgi ağa yayılmış durumdadır. Hücrelerin
birbirleri ile bağlantılarının değerleri ağın bilgisini gösterir. Tek bir bağlantının bir anlamı
yoktur. Daha önce belirtildiği gibi ağın bilgilerinin açıklanamamasının sebeplerinden birisi de
budur. Bu ağlarda, ağın tamamı öğrendiği olayın bütününü karakterize etmektedir. O nedenle
bilgiler ağa dağıtılmış durumdadır. Bu ise dağıtık bir belleğin doğmasına neden olmaktadır.
• Sadece nümerik bilgiler ile çalışabilmektedirler. Yapay sinir ağları sadece nümerik bilgiler
ile çalışırlar. Sembolik ifadeler ile gösterilen bilgilerin nümerik gösterime çevrilmeleri
gerekmektedir. Bunun nasıl yapıldığı daha sonra açıklanacaktır. Sembolik bilgilerin nümerik
değerler ile ifade edilmesinde bilgilerin yorumlanmasını ve kararların (üretilen çözümlerin)
açıklanmasını zorlaştırmaktadır.
Yukarıda belirtilen özelliklere ek olarak geliştirilmiş olan her modelin kendisine özgü özellikleri
olabilmektedir. Bunlar ilgili bölümlerde açıklanmaktadır...
Burada açıklanan özellikler dikkatlice incelenirse aslında yapay sinir ağlarının bilgisayar
bilimine oldukça avantajlı katkılarının olduğu görülebilir. Geleneksel bilgisayar yazılım teknolojisi ile
çözülemeyen birçok problemin yapay sinir ağları ile çözülebileceği görülebilir. Mesela yapay sinir
ağları, eksik, normal olmayan, belirsiz bilgileri işleyebilen en güçlü problem çözme tekniğidir denilse
yanlış olmaz. Belirsiz bilgileri işlemede bulanık önermeler mantığı (fuzzy logic) gibi teknikler olsa
bile eksik bilgi ile çalışabilen teknikler bulmak çok zordur.
3.4. Yapay Sinir Ağları İle Neler Yapılabilir?
Yapay sinir ağları günümüzde geliştirilmiş en güncel ve en mükemmel örüntü tanıyıcı ve
sınıflandırıcılardan sayılabilirler; bu ağları bu kadar güncel yapan da, yukarıda belirtildiği gibi, eksik
bilgiler ile çalışabilme ve normal olmayan verileri işleyebilme yetenekleridir. Özellikle çok sayıda
veriyi işleme gerektiren (radar verileri gibi) işlerde çok avantajlı sonuçlar üretebilmektedirler.
Günümüzde birçok problem aslında şekil tanıma problemi haline getirilmekte ve ondan sonra
çözülmektedir. Bu nedenle, yapay sinir ağlarının kullanılabileceği birçok alan vardır. Endüstriyel ve
sosyal hayatta görülen binlerce örnek ile başarılı oldukları gösterilmiştir. Fakat her problemi yapay sinir ağı ile çözmek mantıklı olmayabilir. Eğer herhangi bir problemin çözümü için yeterli etkinlikte ve
verimlilikte çözüm yöntemi söz konusu ise yapay sinir ağının kullanılmasının bir anlamı yoktur. İlgili
olay hakkında örneklerin olmayışı da (bulunamayışı da) bu ağları kullanmamak için önemli bir
nedendir. Bir problemin yapay sinir ağı ile çözülmesi için şu şartlardan birini sağlanması gerekir.
• Sadece yapay sinir ağları ile problemlere pratik çözümler üretebilme durumunun söz konusu
olması gerekir.
7
• Başka çözüm yolları olmasına rağmen yapay sinir ağlarının daha kolay ve daha etkin çözümler
üretilebilmesinin sağlanması gerekir.
Başarılı uygulamalar incelendiğinde yapay sinir ağlarının, doğrusal olmayan, çok boyutlu,
gürültülü, karmaşık, kesin olmayan, eksik, kusurlu, hata olasılığı yüksek sensor verilerinin olması ve
problemin çözümü için özellikle bir matematik modelin ve algoritmanın bulunmaması hallerinde
yaygın olarak kullanıldıkları görülmektedir. Bu amaçla geliştirilmiş ağlar genel olarak şu
fonksiyonları yerine getirmektedir:
• Probabilistik fonksiyon kestirimleri
• Sınıflandırma
• Îlişkilendirme veya örüntü eşleştirme
• Zaman serileri analizleri
• Sinyal filtreleme
• Veri sıkıştırma
• Örüntü tanıma
• Doğrusal olmayan sinyal işleme
• Doğrusal olmayan sistem modelleme
• Optimizasyon
• Zeki ve doğrusal olmayan kontrol
Yukarıda listelenen konularda teorik uygulamaların ötesinde günlük hayatta kullanılan finansal
konulardan mühendisliğe ve tıp bilimine kadar birçok uygulamadan bahsetmek mümkündür.
Bunlardan bazıları ise şöyle sıralanabilir:
• Veri madenciliği
• Optik karakter tanıma ve çek okuma
• Bankalardan kredi isteyen müracaatları değerlendirme
• Ürünün pazardaki performansının tahmin etme
• Kredi kartı hilelerini saptama
• Zeki araçlar ve robotlar için optimum rota belirleme
• Güvenlik sistemlerinde konuşma ve parmak izi tanıma
• Robot hareket mekanizmalarının kontrol edilmesi
• Mekanik parçaların ömürlerinin ve kırılmalarının tahmin edilmesi
• Kalite kontrolü
• İş çizelgelim ve iş sıralaması
• İletişim kanallarındaki geçersiz ekoların filtrelenmesi
8
• İletişim kanallarındaki trafik yoğunluğunu kontrol etme ve anahtarlama
• Radar ve sonar sinyalleri sınıflandırma
• Üretim planlama ve çizelgeleme
• Kan hücreleri reaksiyonları ve kan analizlerini sınıflandırma
• Kanserin saptanması ve kalp krizlerinin tedavisi
• Beyin modellenmesi çalışmaları
Bunların çoğaltılması mümkündür. Yukarıdakiler yalnızca genel olarak hangi alanlarda
kullanılacaklarına göstermek amacıyla verilmiştir; yoksa hemen hemen her alanda örneklerini görmek
mümkündür. Çünkü gerçek hayatta kullanılan sistemlerin çoğu doğrusal olmayan modellemeler
gerektirmektedir. Bu ise geleneksel yöntemler ile çözüm üretilmesini zorlaştırmakta bazen de
imkânsızlaştırmaktadır.
3.5. Yapay Sinir Ağlarının Tarihçesi
İnsanoğlu tarih boyunca sürekli insan beyninin nasıl çalıştığını merak etmiştir. Bilgisayarların
doğmasında aslında bu merakın bir neticesidir. İlk hesap makinelerinden günümüzdeki çok karmaşık
bilgisayar sistemlerine geçişin temelinde bu merak ve arayışın rolünü unutmamak gerekmektedir.
Gelişmelere bakarak gelecekte daha karmaşık sistemlerin çıkacağını da kestirmek zor değildir.
Bilgisayarlar başlangıçta sadece aritmetik işlemler yapmak amacı ile geliştirilmiş iken, bugün olayları
öğrenmeleri ve çevre şartlarına göre karar vermeleri istenmektedir. Gelecekte insanoğlunun gerçekleştirdiği çok yüksek oranda beyin gücü gerektiren işleri yapmalarının bekleneceğini kestirmek zor
değildir. Yapay sinir ağları günümüzde bu gelişmeyi tetikleyen bilim dallarından birisidir. Gelecekte
de yine en önemli bilim dallarından birisi olacaktır.
Yapay sinir ağlarının tarihsel gelişimine bakıldığında ise 1970 yılının bir dönüm noktası olduğu
görülmektedir. Bu tarihten önce birçok araştırmanın yapıldığı ve 1969 yılında XOR probleminin
çözülememesi nedeni ile araştırmaların durduğu görülmektedir. 1970 yılından sonra sınırlı sayıda
araştırmacının çalışmalarını sürdürmeleri ve XOR problemini çözmeleri sonucunda yapay sinir
ağlarına olan ilgi yeniden alevlenmiştir. İzleyen 10 yıl içinde birbirinden farklı 30 civarından yeni
model geliştirildi. Aynı zamanda çalışmalar laboratuarlardan çıkarak günlük hayatta kullanılan
sistemler haline geldi. Bu çalışmalar hem yapay zekâ hem de donanım teknolojisindeki gelişmeler ile
de desteklenmiştir. Artık bilgisayarlarında öğrenebileceğini herkes kabul etmekte ve bu teknolojiden
faydalanmak istemektedir.
3.6. Yapay Sinir Ağlarının Yapısı Ve Temel Elemanları
Sinir sistemi birbiri ile iletişim halinde olan sinir hücrelerinden oluşmaktadır. Aşağıda bir sinir
hücresinin yapısı açıklanmıştır.
9
a) Biyolojik Sinir Hücreleri
Biyolojik sinir ağları beynimizde bulunan birçok sayıda sinir hücresinin bir koleksiyonudur. Bir
sinir ağı milyarlarca sinir hücresinin bir araya gelmesi ile oluşmaktadır.
Sinir hücreleri birbirleri ile bağlanarak fonksiyonlarını yerine getirirler. Beynimizde 1010 adet
sinir hücresi ve bunlarında 6x10' ten fazla sayıda bağlantısının olduğu söylenmektedir. İnsan beyni,
çok hızlı çalışabilen mükemmel bir bilgisayar gibi görülebilir. Bir grup insan resmi içinden tanıdık bir
resmi 100-200 ms gibi kısa bir sürede fark edebilir. Hâlbuki geleneksel bilgisayarların böyle bir
tanıma işlemini yapması çok daha uzun zamanlar alabilir. Bugün insan beyinin kapasitesinin çok
küçük bir oranında kapasiteye sahip ve çalışabilen bir makine yapılsa olağanüstü bilgi işleme ve
kontrol edebilme mekanizmaları geliştirmek ve mükemmel sonuçlar elde etmek mümkün olabilir.
Biyolojik sinir ağlarının performansları küçümsenemeyecek kadar yüksek ve karmaşık olayları
işleyebilecek yetenektedir. Yapay sinir ağları ile bu yeteneğin bilgisayara kazandırılması
amaçlanmaktadır.
Biyolojik sinir ağları insan beyninin çalışmasını sağlayan en temel taşlardan birisidir. İnsanın
bütün davranışlarını ve çevresini anlamasını sağlarlar. Biyolojik sinir ağları beş duyu organından
gelen bilgiler ışığında geliştirdiği algılama ve anlama mekanizmalarını çalıştırarak olaylar arasındaki
ilişkileri öğrenir.
Şekil 3.2. Bir biyolojik sinir hücresinin yapısı
Şekil 3.2'de gösterildiği gibi temel bir biyolojik sinir hücresi sinapsler, soma, 0x01 ı ve
dentritlerden oluşmaktadır. Sinapslar sinir hücreleri arasındaki bağlantılar olarak görülebilir. Bunlar
fiziksel bağlantılar olmayıp bir hücreden diğerine elektrik sinyallerinin geçmesini sağlayan
boşluklardır. Bu sinyaller somaya giderler. Soma bunları işleme tabi tutar, sinir hücresi kendi elektrik
sinyalini oluşturur ve axon aracılığı ile dendritlere gönderir. Dendritler ise bu sinyalleri sinapslara
göndererek diğer hücrelere gönderilir. İki hücrenin birbirleri ile bilgi alış verişi snaptik bağlantılarda
neurotransmitterler yolu ile sağlanmaktadır. Şekildeki axon uçlarının her birisi başka bir hücre ile
birleşmektedir. Verilen özellikte milyarlarca sinir hücresi bir araya gelerek sinir sistemini oluşturmaktadır. Yapay sinir ağları biyolojik hücrelerin bu özelliklerinden yararlanarak geliştirilmiştir.
10
b) Yapay Sinir Hücresi (Proses Elemanı)
Biyolojik sinir ağlarının sinir hücreleri olduğu gibi yapay sinir ağlarının da yapay sinir hücreleri
vardır. Yapay sinir hücreleri mühendislik biliminde proses elamanları olarak da adlandırılmaktadır.
Her proses elemanının 5 temel elemanı vardır (bkz. Şekil-3.3). Bunlar:
Şekil 3.3. Yapay sinir hücrelerinin yapısı
• Girdiler: Bir yapay sinir hücresine (proses elemanına) dış dünyadan bilgilerdir. Bunlar ağm
öğrenmesi istenen örnekler tarafından belirlenir. Yapay sinir hücresine dış dünyadan olduğu gibi
başka hücrelerden veya kendi kendisinden de bilgiler gelebilir.
• Ağırlıklar: Ağırlıklar bir yapay hücreye gelen bilginin önemini ve hücre üzerindeki etkisini
gösterir. Şekildeki Ağırlık 1, Girdi l' in hücre üzerindeki etkisini göstermektedir. Ağırlıkların
büyük yada küçük olması önemli veya önemsiz olduğu anlamına gelmez. Bir ağırlığın değerinin
sıfır olması o ağ için en önemli olay olabilir. Eksi değerler önemsiz demek değildir. O nedenle
artı veya eksi olması etkisinin pozitif veya negatif olduğunu gösterir. Sıfır olması ise herhangi
bir etkinin olmadığını gösterir. Ağırlıklar değişken veya sabit değerler olabilirler.
• Toplama fonksiyonu: Bu fonksiyon, bir hücreye gelen net girdiyi hesaplar. Bunun için değişik
fonksiyonlar kullanılmaktadır. En yaygın olanı ağırlıklı toplamı bulmaktır. Burada her gelen
girdi değeri kendi ağırlığı ile çarpılarak toplanır. Böylece ağa gelen net girdi bulunmuş olur. Bu
şu şekilde formülize edilmektedir.
Burada G girdileri, A ise ağırlıkları, n ise bir hücreye gelen toplam girdi (proses elemanı)
sayısını göstermektedir. Yalnız yapay sinir ağlarında daima bu formülün kullanılması şart
değildir. Uygulanan yapay sinir ağı modellerinden bazıları kullanılacak toplama fonksiyonunu
belirleyebilmektedir. Literatürde yapılan araştırmalarda toplama fonksiyonu olarak değişik
11
formüllerin kullanıldığı görülmektedir. Tablo-3.1'de değişik toplama fonksiyonlarına örnekler
verilmektedir. Görüldüğü gibi, bazı durumlarda gelen girdilerin değeri dikkate alınırken bazı
durumlarda ise gelen girdilerin sayısı önemli olabilmektedir. Bir problem için en uygun toplama
fonksiyonunu belirlemek için bulunmuş bir formül yoktur. Genellikle deneme yanılma yolu ile
toplama fonksiyonu belirlenmektedir. Bir yapay sinir ağında bulunan proses elemanlarının
tamamının aynı toplama fonksiyonuna sahip olmaları gerekmez. Her proses elemanı bağımsız
olarak farklı bir toplama fonksiyonuna sahip olabilecekleri gibi hepsi aynı proses elemanına
sahip olabilir. Hatta ağın bazı proses elemanları grup halinde aynı toplama fonksiyonuna sahip
olabilir. Diğerleri ise farklı fonksiyonlar kullanabilirler. Bu tamamen tasarımcının kendi
öngörüsüne dayanarak verdiği karara bağlıdır.
Tablo 3.1. Toplama fonksiyonu örnekleri
• Aktivasyon fonksiyonu: Bu fonksiyon, hücreye gelen net girdiyi işleyerek hücrenin bu girdiye
karşılık üreteceği çıktıyı belirler. Toplama fonksiyonunda olduğu gibi aktivasyon fonksiyonu
olarak da çıktıyı hesaplamak içinde değişik formüller kullanılmaktadır. Bazı modeller (mesela
çok katmanlı algılayıcı) bu fonksiyonun türevinin alınabilir bir fonksiyon olmasını şart
koşmaktadır. Toplama fonksiyonunda olduğu gibi aktivasyon fonksiyonunda da ağın proses
elemanlarının hepsinin aynı fonksiyonu kullanması gerekmez. Bazı elemanlar aynı fonksiyonu
diğerleri farklı fonksiyonları kullanabilirler. Bir problem için en uygun fonksiyonda yine
tasarımcının denemeleri sonucunda belirleyebileceği bir durumdur. Uygun fonksiyonu gösteren
bir formül bulunmuş değildir.
12
Günümüzde en yaygın olarak kullanılan Çok Katmanlı Algılayıcı modelinde Genel olarak
aktivasyon fonksiyonu olarak sigmoid fonksiyonu kullanılmaktadır. Bu fonksiyon şu formül ile
gösterilmektedir.
Burada NET proses elemanına gelen NET girdi değerini göstermektedir. Bu değer toplama
fonksiyonu kullanılarak belirlenmektedir.
Şekil 3.4. Sigmoid fonksiyonunun şekilsel gösterimi
Sigmoid fonksiyonu şekilsel olarak da Şekil-3.4'te gösterilmiştir. Aktivasyon fonksiyonu olarak
kullanılacak olan diğer fonksiyonlara örnekler ise Tablo-3.2'de verilmiştir:
Tablo 3.2. Akvitasyon fonksiyonu örnekleri
13
• Hücrenin çıktısı: Aktivasyon fonksiyonu tarafından belirlenen çıktı değeridir. Üretilen çıktı dış
dünyaya veya başka bir hücreye gönderilir. Hücre kendi çıktısını kendisine girdi olarak da
gönderebilir. Bir proses elemanının birden fazla çıktısı olmasına rağmen sadece bir çıktısı
olmaktadır. Ağ şeklinde gösterildiğinde bir proses elemanının birden faza çıktısı varmış gibi
görülmektedir. Bu sadece gösterim amacıyladır. Aslında bir proses elemanından çıkan tek bir
çıktı değeri vardır. Aynı değer birden fazla proses elemanına girdi olarak gitmektedir.
Örnek: Yapay sinir hücresinin çalışma prensibi.
Şekil 3.5. Bir yapay sinir hücresinin çalışması örneği
Hücreye gelen NET bilgi, ağırlıklı toplam alınarak şu şekilde hesaplanır.

Hücrenin sigmoid fonksiyonuna göre çıktısı (Ç) hesap edilir ise;

Bir ağdaki bütün proses elemanlarının çıktılarının bu şekilde hesaplanması sonucu ağın girdilere
karşılık çıktıları nasıl ürettiği görülür.
c) Yapay Sinir Ağının Yapısı
Daha önce belirtildiği gibi, yapay sinir hücreleri bir araya gelerek yapay sinir ağını oluştururlar.
Sinir hücrelerinin bir araya gelmesi rasgele olmaz. Genel olarak hücreler 3 katman halinde ve her
katman içinde paralel olarak bir araya gelerek ağı oluştururlar. Bu katmanlar:
 Girdi katmanı: Bu katmandaki proses elemanları dış dünyadan bilgileri alarak ara katmanlara
transfer etmekle sorumludurlar. Bazı ağlarda girdi katmanında herhangi bir bilgi işleme olmaz.
14
 Ara katmanlar: Girdi katmanından gelen bilgiler işlenerek çıktı katmanına gönderirler. Bu
bilgilerin işlenmesi ara katmanlarda gerçekleştirilir. Bir ağ için birden fazla ara katmanı olabilir.
 Çıktı katmanı: Bu katmandaki proses elemanları ara katmandan gelen bilgileri işleyerek ağın
girdi katmanından sunulan girdi seti (örnek) için üretmesi gereken çıktıyı üretirler. Üretilen çıktı
dış dünyaya gönderilir.
Şekil 3.6. Bir yapay sinir ağı örneği
Bu üç katmanın her birinde bulunan proses elemanları ve katmanlar arası ilişkileri şematik
olarak Şekil-3.6'da gösterilmektedir. Şekildeki yuvarlak şekiller proses elemanlarını göstermektedir.
Her katmanda birbirine paralel elemanlar söz konusudur. Proses elemanlarını birbirlerine bağlayan
çizgiler ise ağın bağlantılarını göstermektedir. Proses elemanları ve bağlantıları bir yapay sinir ağını
oluştururlar. Bu bağlantıların ağırlık değerleri öğrenme sırasında belirlenmektedir.
Şekil 3.7. Yapay sinir ağı girdi, çıktı ilişkisi
15
Bir YSA, herhangi bir girdi vektörünü çıktı vektörüne nasıl dönüştüğü konusunda bir bilgi
vermez. Mühendislik açısından bakıldığında yapay sinir ağları “kara kutu” gibi görülebilirler. Diğer
bir deyişle, YSA’nın sonuçları nasıl oluşturduğunu açıklama yeteneği yoktur.
d) Yapay Sinir Ağlarında Öğrenme, Adaptif Öğrenme ve Test Etme
Yukarıda belirtildiği gibi yapay sinir ağlarında proses elemanlarının bağlantılarının ağırlık
değerlerinin belirlenmesi işlemine "ağın eğitilmesi" denir. Başlangıçta bu ağırlık değerleri rasgele
olarak atanır. Yapay sinir ağları kendilerine örnekler gösterildikçe bu ağırlık değerlerini değiştirirler.
Amaç ağa gösterilen örnekler için doğru çıktıları üretecek ağırlık değerlerini bulmaktır. Örnekler ağa
defalarca gösterilerek en doğru ağırlık değerleri bulunmaya çalışılır. Ağın doğru ağırlık değerlerine
ulaşması örneklerin temsil ettiği olay hakkında genellemeler yapabilme yeteneğine kavuşması
demektir. Bu genelleştirme özelliğine kavuşması işlemine ağın öğrenmesi denir. Ağırlıkların
değerlerinin değişmesi belirli kurallara göre yürütülmektedir. Bu kurallara öğrenme kuralları denir.
Daha önce belirtildiği gibi, Kullanılan öğrenme stratejisine göre değişik öğrenme kuralları
geliştirilmiştir. İlerideki bölümlerde değişik modelleri anlatırken her model için geliştirilmiş olan
öğrenme kuralları ayrıntılı olarak anlatılacaktır.
Yapay sinir ağlarında öğrenme olayının iki aşaması vardır. Birinci aşamada ağa gösterilen örnek
için ağın üreteceği çıktı belirlenir. Bu çıktı değerinin doğruluk derecesine göre ikinci aşamada ağın
bağlantılarının sahip olduğu ağırlıklar değiştirilir. Ağın çıktısının belirlenmesi ve ağırlıkların
değiştirilmesi öğrenme kuralına bağlı olarak farklı şekillerde olmaktadır.
Ağın eğitimi tamamlandıktan sonra öğrenip öğrenmediğini (performansını) ölçmek için yapılan
denemelere ise ağın test edilmesi denmektedir. Test etmek için ağın öğrenme sırasında görmediği
örnekler kullanılır. Test etme sırasında ağın ağırlık değerleri değiştirilmez. Test örnekleri ağa
gösterilir. Ağ eğitim sırasında belirlenen bağlantı ağırlıklarını kullanarak görmediği bu örnekleri için
çıktılar üretir. Elde edilen çıktıların doğruluk değerleri ağın öğrenmesi hakkında bilgiler verir.
Sonuçlar ne kadar iyi olursa eğitimin performansı da o kadar iyi demektir. Eğitimde kullanılan örnek
setine eğitim seti, test için kullanılan sete ise test seti adı verilmektedir. Yapay sinir ağlarının bu
şekilde bilinen örneklerden belirli bilgileri çıkartarak bilinmeyen örnekler hakkında yorumlar
yapabilme (genelleme yapabilme) yeteneğine Adaptif öğrenme denir.
e) Yapay Sinir Ağlarından En Çok Kullanılan Modeller
Bir yapay sinir ağında proses elemanlarının bağlanması sonucu oluşan topoloji, proses
elemanlarının sahip oldukları toplama ve aktivasyon fonksiyonları, öğrenme stratejisi ve kullanılan
öğrenme kuralı ağın modelini belirlemektedir. Günümüzde çok sayıda model geliştirilmiştir. Bunların
en yaygın olarak kullanılanları ve pratik hayatta uygulananları şunlardır.
• Algılayıcılar
16
• Çok katmanlı algılayıcılar (hatayı geriye yayma modelleri)
• Vektör Kuantizasyon modelleri (LVQ)
• Kendi kendini organize eden model (SOM)
• Adaptif Rezonans Teorisi modelleri (ART)
• Hopfield ağları
• Counterpropagation ağı
• Neocognitron ağı
• Boltzman makinesi
• Probabilistic ağlar (PNN)
• Elman ağı
• Radyal temelli ağlar (RBN)
3.7. Yapay Sinir Ağı Modelleri
Yapay sinir ağlarının ilk modelleri, tek katmanlı algılayıcı, Perseptron, ve
ADALINE/MADALINE yapılarıdır. Bu modeller daha sonra geliştirilen modeller için temel
oluşturmaktadır.
a) Tek Katmanlı Algılayıcılar (TKA)
Tek katmanlı yapay sinir ağları sadece girdi ve çıktı katmanlarından oluşur. Her ağın bir veya
daha fazla girdisi ve çıktısı (Ç) vardır. Çıktı üniteleri bütün girdi ünitelerine (X) bağlanmaktadır. Her
bağlantının bir ağırlığı vardır (W). En basit şekliyle tek katmanlı bir ağa örnek vermek gerekirse, Şekil
3.8’deki ağ iki girdisi ve bir çıktıdan oluşmaktadır. Bu ağlarda proses elemanlarının değerlerinin ve
dolayısıyla ağın çıktısının sıfır olmasını önleyen birde eşik değeri (O) vardır. Eşik değerinin girdisi
daima l’dir.
Şekil 3.8. İki girdi ve bir çıktıdan oluşan en basit TKA model
Ağın çıktısı ağırlıklandırılmış girdi değerlerinin eşik değeri ile toplanması sonucu bulunur. Bu
girdi değeri bir aktivasyon fonksiyondan geçirilerek ağın çıktısı hesaplanır. Bu, şu şekilde formülize
edilmektedir.
17
Tek katmanlı algılayıcılarda çıktı fonksiyonu doğrusal fonksiyondur. Yani ağa gösterilen
örnekler iki sınıf arasında paylaştırılarak iki sınıfı birbirinden ayıran doğru bulunmaya çalışılır. Onun
için eşik değer fonksiyonu kullanılmaktadır. Burada ağın çıktısı 1 veya -1 değerlerini almaktadır. 1 ve
-1 sınıfları temsil etmektedir. Eğer ağın çıktısı 1 ise birinci sınıfta -1 ise ikinci sınıfta kabul
edilmektedir (Bazı araştırıcılar sınıfları 1 veya 0 olarak da gösterilmektedir). Felsefede bir değişiklik
yoktur.
Bu formül incelendiğinde ağa gelen toplam girdinin pozitif olması durumunda ağa sunulan
örnek 1 sınıfına negatif olması durumunda ise -1 sınıfına ait demektir. Sıfır olması durumu ise
tasarımcının kabulüne kalmıştır. Yukarıdaki formülde -1 sınıfına konulmuştur. Dikkat edilirse, iki
sınıfı ayıran bir doğrudur.
Şekil 3.9. Ağırlıkların ve sınıf ayracı olan doğrunun geometrik gösterimi
Sınıf ayracı da denilen bu doğru şu şekilde tanımlanmaktadır.
W1 .Xl + W2 .X2 + Φ =0
Buradan X2 = - ( W1 / W2 ) X1 - Φ / W2 olur.
Benzer şekilde, X1 = - ( W2 / W1 ) X2 - Φ / W2 olarak hesaplanır.
Bu iki formülden hareketle sınıfın ayracı doğrusu çizilebilir. Bu doğrunun geometrik gösterimi
ise Şekil 3.9.'da verilmiştir.
Bu ağlarda öğrenmeden kasıt ağın sınıf ayracı doğrusunun pozisyonunu her iki grubu en iyi
şekilde ayıracak şekilde belirlemektir. Bunun için ağırlık değerlerinin değiştirilmesi gerekmektedir.
Yani t zaman biriminde ağırlık değerleri ∆W kadar değiştirilir ise;
18
Wj (t+l)=Wi (t)+ ∆ Wi(t)
olacaktır. Öğrenme sırasında bu değişim her iterasyonda gerçekleştirilerek sınıf ayracının en doğru
pozisyonu bulunmaya çalışılır. Ağırlıkların değiştirilmesi doğrunun eğimini değiştirmek anlamına
gelmektedir. Bu yeterli olmayabilir. Eşik değerinin de değiştirilmesi gerekir. Bu, doğrunun sınıflar
arası kaymasına yardımcı olmaktadır. Böylece aktivasyon fonksiyonun konumu belirlenmektedir. Bu
durum da t anında eşik değerinin de;
Φ (t+l) = Φ (t)+ ∆Φ (t)
şeklinde değiştirilmesi demektir. Öğrenme sırasında ağırlıklarda olduğu gibi eşik değeri de her
iterasyonda ∆Φ kadar değiştirilmektedir.
Tek katmanlı algılayıcılarda önemli görülen iki modelden bahsedilebilir. Bunlardan birisi
algılayıcı (perseptron) modeli, diğeri ise Adaline/Madaline ünitesidir.
b) Basit Algılayıcı Modeli (Perseptron)
İlk defa 1958 yılında Rosenblat tarafından örüntü (şekil) sınıflandırma amacı ile geliştirilmiştir.
Basit Algılayıcıların Yapısı: Perseptron bir sinir hücresinin birden fazla girdiyi alarak bir çıktı
üretmesi prensibine dayanmaktadır. Ağın çıktısı bir veya sıfırdan oluşan mantıksal (boolean) değerdir.
Çıktının değerinin hesaplanmasında eşik değer fonksiyonu kullanılır. Perseptron un yapısı Şekil 3.10.’
da gösterildiği gibidir:
Şekil 3.10. Bir basit algılayıcı yapısı
Şekilden de görüldüğü gibi, perseptron eğitilebilen tek bir yapay sinir hücresinden (proses
elemanından) oluşur. Eğitilebilirden kasıt ağırlıkların (W) değiştirilebilir olması demektir. Girdiler
proses elemanına gösterilirler. Her girdi setine karşılık gelen çıktı değerleri de ağa gösterilir. Daha
sonra öğrenme kuralına göre ağın çıktı değeri hesaplanır. Eğer ağın çıktısı olması gereken çıktıdan
farklı ise ağırlıklar ve eşik değerleri değiştirilir. Değişikliğin nasıl yapılacağını ise öğrenme kuralı
belirler. Girdilere karşılık gelene çıktı değerleri bir veya sıfırdan oluşmaktadır.
Yukarıda belirtildiği gibi eşik değeri, aktivasyon fonksiyonunun konumunu belirlemek için
kullanılır. Şekil 3.11. eşik değerinin sıfır ve "a" pozitif değerleri alması durumunda aktivasyon
fonksiyonunun konumunu göstermektedir.
19
Şekil 3.11. Eşik değerinin aktivasyon fonksiyonunun konumuna etkisi
Basit Algılayıcı Öğrenme Kuralı: Basit algılayıcıların öğrenme kuralı adım adım aşağıda
açıklanmıştır:
Adım,l: Ağa girdi setini ve ona karşılık olarak beklenen çıktı gösterilir (X,B). Burada birden fazla
girdi değeri olabilir. Yani X= ( xl, x2, x3...xN ) demektir. Çıktı değeri ise 1 ve 0 değerlerinden birisini
alır.
Adım 2: Perseptron ünitesine gelen net girdi şu şekilde hesaplanır:
Adım 3: Perseptron ünitesinin çıktısı hesaplanır. Net girdinin eşik değerinden büyük veya küçük
olmasına göre çıktı değeri 0 ve 1 değerlerinden birisini alır. Yani;
Eğer gerçekleşen çıktı ile beklenen çıktı aynı olursa ağırlıklarda herhangi bir değişiklik olmaz. Ağ,
beklenmeyen bir çıktı üretmiş ise o zaman iki durum söz konusudur:
a) Ağın beklenen çıktısı 0 değeridir. Fakat NET girdi eşik değerinin üstündedir. Yani
ağın gerçekleşen çıktısı 1 değeridir. Bu durumda ağırlık değerleri azaltılmaktadır.
Ağırlıkların değişim oranı girdi değerlerinin belirli bir oranı kadardır. Yani vektörel
olarak;
Wn = Wo-λX
olur. Burada λ öğrenme katsayısıdır. Ağırlıkların değişim miktarlarını belirlemekte
ve sabit bir değer olarak alınmaktadır.
20
b) Beklenen çıktının 1 olması ve ağın gerçek çıktısının 0 olması durumudur. Yani net
girdi eşik değerinin altındadır. Bu durumda ağırlıkların değerinin artırılması
gerekmektedir. Yani vektörel olarak
Wn = Wo +λX
olacaktır.
Adım 4: Yukarıdaki adımları bütün girdi setindeki örnekler için doğru sınıflandırmalar yapılıncaya
kadar ilk üç adımdaki işlemler tekrarlanır.
Örnek:
1. örnek: X1= (xl, x2)= (1,0),B1= 1
2. örnek: X2= (x1,x2)= (0,1), B2=0
Ağırlıklar: W = (wl, w2)= (1,2)
Eşik değeri: Ф= -1
Öğrenme katsayısı: λ =0.5
1. iterasyon da 1. örnek ağa gösterilir. Bu durumda,
Basit algılayıcının NET girdisi;
NET= wl*xl +w2*x2 = 1*1+2*0= 1
NET > Ф olduğundan Gerçekleşen çıktı, Ç= 1 olacaktır. Ç=B1 olduğundan ağırlıklar değiştirilmez.
Böylece öğrenmede birinci iterasyon tamamlanmış olur.
İkinci örnek ağa gösterilerek aynı işlemler tekrarlanır. Bu ikinci iterasyon demektir. Burada birinci
iterasyonda değiştirilen (bu örnekte olmamıştır) ağırlık ve eşik değerleri kullanılır.
2. iterasyon- 2. örnek ağa gösterilir.
Bu durumda algılayıcının NET girdisi,
NET= wl*xl +w2*x2 = 1*0+2*1= 2
NET > Ф olduğundan Gerçekleşen çıktı, Ç= 1 olacaktır. Ç≠B2 olduğundan ağırlıklar,
Wn = Wo- λX
formülü kullanılarak değiştirilir. Ağırlıkların değerleri belirlenir. Sonuçta yeni değerler şöyle elde
edilir.
wl= w1 – λX1
wl= 1-0.5* 0=1
w2= w2 - λX2
w2=2-0.5* 1 = 1.5
3. iterasyon 1. örnek tekrar gösterilirse
21
Benzer şekilde;
NET= wl*xl +w2*x2 = 1*1+1.5*0= 1
NET > Ф olduğundan Gerçekleşen çıktı Ç1= 1 olacaktır. Çl=Bl olduğundan ağırlıklar değiştirilmez
4. iterasyon 2. örnek tekrar gösterilirse
NET= wl*xl +w2*x2 = 1*0+1.5*1= 1.5 olarak hesaplanır.
NET > Ф olduğundan Gerçekleşen çıktı Çl= 1 olacaktır. Beklenen çıktıdan farklı olduğundan
ağırlıklar;
Wn = Wo- λX
formülü kullanılarak değiştirilir ve şu sonuçlar elde edilir. Burada bir önceki iterasyonlarda
değiştirilen ağırlıkların kullanıldığına dikkat ediniz.
w1= w\ - λ xl
w1= 1-0.5*0=1
w2= w2 - λ x2
w2=1.5-0.5* 1 = 1
5. iterasyon 1. örnek tekrar gösterilirse
NET= wl*xl +w2*x2 = 1*1+1*0= 1 olur.
NET > Ф olduğundan Gerçekleşen çıktı Ç1= 1 olacaktır. Çl=Bl olduğundan ağırlıklar değiştirilmez.
6. iterasyon 2. örnek tekrar gösterilirse
NET= wl*xl +w2*x2 = 1*0+1*1= 1 olur.
NET > Ф olduğundan Gerçekleşen çıktı Çl= 1 olacaktır. Beklenen çıktıdan farklı olduğundan
ağırlıklar;
Wn = Wo-λX
formülü ile yeni ağırlıklar şöyle bulunur.
wl=wl-λxl wl= 1-0.5*0=1
w2= w2-λx2 w2= 1- 0.5 * 1 = 0.5
7. iterasyon 1. örnek tekrar gösterilirse
NET= wl*xl +w2*x2 = 1*1+0.5*0= 1 olur.
NET > Ф olduğundan Gerçekleşen çıktı Ç1= 1 olacaktır. Çl=Bl olduğundan ağırlıklar değiştirilmez.
8. iterasyon 2. örnek tekrar gösterilirse
NET= wl*xl +w2*x2 = 1*0+0.5*1= 0.5 olur.
NET >Ф olduğundan gerçekleşen çıktı Çl= 1 olacaktır.Beklenen çıktıdan farklı olduğundan ağırlıklar;
Wn = Wo-λX
formülü ağırlıklar şu değerleri alır.
22
wl= w1 – λ x1
wl= 1-0.5* 0=1
w2= w2 – λ x2
w2= 0.5- 0.5 * 1 = 0
9. iterasyon 1. örnek tekrar gösterilirse
NET= wl*xl +w2*r2 = 1*1+0*0= 1 olur.
NET > Ф olduğundan Gerçekleşen çıktı Çl= 1 olacaktır. Çl=Bl olduğundan ağırlıklar değiştirilmez.
10. iterasyon 2. örnek tekrar gösterilirse
NET= wl1*xl +w2*x2 = 1*0+0.0*1= 0 olur.
NET > Ф olduğundan Gerçekleşen çıktı Ç1= 1 olacaktır. Beklenen çıktıdan farklı olduğundan
ağırlıklar;
Wn = Wo- λ X
formülü kullanılarak değiştirilir ve sonuçta şu değerler oluşur.
wl= w1 - λ x1
wl= 1-0.5* 0=1
w2= w2 - λ x2
w2= 0- 0.5 * 1 = -0.5
11. iterasyon 1. örnek tekrar gösterilirse
NET= wl*xl +w2*x2 = 1*1+ (-0.5)*0= 1 olur.
NET > Ф olduğundan Gerçekleşen çıktı Çl= 1 olacaktır. Çl=Bl olduğundan ağırlıklar değiştirilmez.
12. iterasyon 2. örnek tekrar gösterilirse
NET= wl*xl +w2*x2 = l*0+(-0.5)*l= -0.5 olur.
NET > Ф olduğundan Gerçekleşen çıktı Çl= 1 olacaktır. Beklenen çıktıdan farklı olduğundan benzer
şekilde ağırlıklar;
Wn = Wo- λ X
formülü kullanılarak şu şekilde değiştirilir.
wl= w1 - λ xl
wl= 1-0.5* 0=1
w2= w2 - λ x2
w2=-0.5-0.5* 1=-1
13. iterasyon 1. örnek tekrar gösterilirse
NET= wl*xl +w2*x2 = 1*1+ (-1)*0= 1 olur.
NET > Ф olduğundan Gerçekleşen çıktı Çl= 1 olacaktır. Çl=Bl olduğundan ağırlıklar değiştirilmez
23
14. iterasyon 2. örnek tekrar gösterilirse
NET= wl*xl +w2*x2 = l*0+(-l)*l= -1 olur.
NET = Ф olduğundan Gerçekleşen çıktı Çl= 0 olacaktır. Çl=Bl olduğundan ağırlıklar değiştirilmez.
Bundan sonra her iki örnekte doğru olarak sınıflandırılır. Öğrenme sonunda ağırlıklar:
w1 = 1
w2 = -l
değerlerini alınca örnekler doğru sınıflandırılabilir demektir. Bu ağırlık değerleri kullanılarak ile iki
örnek tekrar ağa tekrar gösterilirse, ağın çıktıları şöyle olur:
1. örnek için: NET= wl*xl +w2*x2 = 1*1+ (-1)*0= 1 > Ф Çl= 1 =Bl
2. örnek için: NET= wl*xl +w2*x2 = l*0+(-l)*l= -1= Ф Ç2= 0 = B2
Görüldüğü gibi her iki örnek içinde ağ tarafından doğru sınıflandırma yapılmaktadır. O nedenle, ağ
öğrenmeyi tamamlamıştır denilebilir.
Tek katmanlı algılayıcının en önemli problemi doğrusal olmayan problemlerin çözülmesinde
başarılı olmamasıdır. Daha önce belirtildiği gibi, bilinen ZOR problemine çözüm üretemediği için
uzun süre yapay sinir ağları araştırmalarının sekteye uğramasına neden olmuştur. Daha sonra çok
katmanlı algılayıcıların (backpropogation metodunun) bulunması ile bu sorun çözülmüştür. İleride bu
konuda daha ayrıntılı bir örnek irdelenecektir.
Tek katmanlı algılayıcının diğer bir problemi ise ağın her iterasyonda ağırlıklarını değiştirdikçe
öğrendiklerini unutması olasılığıdır. Bir girdi seti ağırlıkları artırdıkça diğeri azaltmaktadır. Bu sorun
çoğu zaman içerisinde ağırlıkların bulunması ile çözülebilmededir. Fakat eğitim zamanının uzamasına
neden olmaktadır.
c) ADALINE Modeli
ADALİNE widrow ve Hoff [2] tarafından 1959 yılında geliştirilmiş olup adaptif doğrusal
eleman (Adaptif Linear Element) ağının kısaltılmış şeklidir. Genel olarak ADALİNE bir proses
elemanından (Adaline ünitesi) oluşan bir ağdır.
Bu ağ en küçük ortalamaların karesi (least mean sguare) yöntemine dayanmaktadır. Öğrenme
kuralına delta kuralı da denmektedir. Öğrenme kuralı, ağın çıktısının beklenen çıktı değerine göre
hatasını enazlayacak şekilde ağın ağırlıklarının değiştirilmesi prensibine dayanır. ADALİNE
ünitesinin yapısı Şekil 3.12.'de verilmiştir. ADALINE’ nin yapısının tek katmanlı algılayıcıya
benzediğine dikkat ediniz. Aradaki fark öğrenme kuralında görülmektedir.
24
Şekil 3.12. Adaline ünitesi
Şekilden de görüldüğü gibi bir ADALİNE ünitesi şu notasyon ile gösterilmektedir: N adet
girdiler: XI, X2, X3, ........ XN
Her girdinin ADALİNE elemanı üzerinde etkisinin gösteren ağırlıklar: Wl, W2,W3, ... WN,
ADALİNE biriminin çıktısının sıfırdan farklı bir değer olmasını sağlayan eşik değer: Ø
Adaline Öğrenme Kuralı: ADALİNE ünitesi en küçük kareler yöntemini kullanarak öğrenme
gerçekleştirir. Perseptron algoritmasına çok benzemektedir. Bu algoritmanın performansı Zeidler [3]
tarafından incelenmiştir. Öğrenme kuralı yapay sinir ağlarında genel öğrenme prensibine göre
çalışmaktadır. Girdilerden çıktılar hesaplanır ve ağırlıklar çıktıya göre değiştirilir. Öğrenme şu
şekildedir.
ADALİNE ünitesinin net girdisi NET ve çıktısı (Ç) şu şekilde hesaplanmaktadır.
Ağın çıktısını üreten fonksiyon bilinen step fonksiyonudur. Beklenen değerin B olduğu
varsayılırsa; Adaline ünitesinin çıktısını ürettikten sonraki hatası;
E = B-Ç
olacaktır. Amaç bu hatayı en aza indirecek ağırlıkları bulmaktır. Bunun için her seferinde ağa farklı
örnekler gösterilerek hatalar hesaplanmakta ve ağırlıklar hatayı azaltacak şekilde değiştirilmektedir.
Zaman için de hata, olması gereken en küçük değere düşmektedir. Bu hatayı azaltmak için kullanılan
kural şu formül ile gösterilmektedir.
Wy = We + α (B-Ç) X
Diğer bir deyişle her hangi bir t anında,
Wi(t) = Wi(t-l) + α *E*Xi
25
olacaktır. Bu formülde W(t) ağırlıkların t zamanındaki yeni değerlerini, W (t-l) ağırlıkların
değişmeden önceki (t-l. zamandaki) değerlerini, a öğrenme katsayısını, B beklenen çıktıyı, E beklenen
değer ile çıktı arasındaki hatayı ve X' de girdileri göstermektedir.
Benzer şekilde eşik değeri de yine zaman içerisinde değiştirilerek olması gereken eşik değeri
bulunur. Buda şu formüle göre yapılır.
Φy= Φe + α (B-Ç)
Burada, Φy yeni eşik değerini, Φe değiştirilmeden önceki eşik değerini göstermektedir.
Örnek: ADALİNE ünitesinin çalışma prensibini göstermek için şu örnek verilebilir. Bir meyve
üreticisi firmanın elma ve portakalların ambara geldiklerinde karışmasının önlemek için bir makine
yapmak istediğini varsayınız. Bu amaçla bir yapay sinir ağının kurulabilmesi nasıl mümkün olacaktır?
Meyveleri gösteren ve birbirinden farklılıklarını ortaya koyan örnekler oluşturmak yapılacak ilk
iştir. Bunun için meyveleri ve onun özelliklerini gösteren vektörleri belirlemek gerekmektedir.
Meyvelerin şeklini, görüntüsünü ve ağırlığını temsil etmek üzere 3 boyutlu bir vektör oluşturulabilir.
Elma ve portakalı gösteren prototiplerin şu vektörler ile gösterildiği varsayılırsa örnek setinde iki
örnek olacaktır.
Örnek 1: Portakal X1 = (1,0); Bu örneğin beklenen çıktısı Çl= -1
Örnek 2: Elma X2 = (0.1); Bu örneğin beklenen çıktısı Ç2= 1
Bu problemi çözebilmek için 2 girdisi olan bir Adaline ünitesi tasarlanacaktır. Öğrenmenin
amacı problem girdilerini doğru sınıflandıracak ağırlık değerleri ve eşik değerini bulmaktır (bkz. Şekil
3.13.).
Şekil 3.13. İki girdili bir adaline ünitesi
Problemin çözümü için ağırlık değerleri ( Wl, W2 ve eşik değerinin değerleri başlangıçta
rasgele atanmaktadır). Bunun aşağıdaki gibi olduğu varsayılsın.
W1=0.3
W2= 0.2
α=0.5
Φ=0.1.
26
1. iterasyon: Bu iterasyonda öncelikle birinci girdi vektörünün ağa gösterilmesi sonucu ağın çıktısı
hesaplanır.
NET değeri sıfırdan büyük bir değer olduğundan ağın çıktı değeri 1 kabul edilir. B = -l
olduğundan ağın ağırlıklarının değiştirilmesi gerekmektedir. Beklenen ve gerçekleşen çıktılar
arasındaki hata E ile gösterilirse, E = B-Ç= -l -l = -2 olur.
Ağın ağırlıkları da yukarıda verilen formüle göre değiştirilecek olursa yeni değerleri şöyle olur.
Wy = We + α (B- Ç) X
Wy=[0.3, 0.2]+ 0.5* (-2 ) [l ,0]
Wy=[0.3, 0.2]+ (-l ) [l ,0]
Wy= [0.3 - 1, 0.2 - 0] =[ -0.7, 0.2 ]
Eşik değer ünitesinin ağırlığı da benzer şekilde değiştirilir.
Φy= Φe + α (B-Ç)
Φy = 0.1+ 0.5* (-2) = -0.9
Böylece öğrenmede birinci iterasyon tamamlanmış olur.
2. iterasyon: İkinci iterasyonda benzeri işlemler ikinci örnek için yapılır. Ağırlıkların ve eşik değerinin birinci iterasyonda değiştirilen değerleri kullanılarak NET girdi ve çıktı değeri benzer şekilde
hesaplanır.
Bu örnek için B = 1 olması gerektiğinden ortaya çıkan hata; E = B-Ç = l-(-l)= 2 olur. Yeni ağırlık
değerleri ise,
Wy = [-0.7, 0.2] + 0.5* 2 [0, 1]
Wy = [-0.7, 0.2]+ [0, 1]
Wy = [-0.7, 1.2]
Φy = -0.9 + 0.5*(2) = 0.1
27
şeklinde hesaplanır.
3. iterasyon:
Bu örnek için B = -1 olması gerektiğinden ağın sınıflandırması doğrudur. Bu ağırlıklarda bir
değişiklik yapılmasını gerektirmez. Çünkü B-Ç = 0 olacak ve formülde herhangi bir değişiklik
olmayacaktır.
4. iterasyon:
Bu örnek için B= 1 olması gerektiğinden ağın sınıflandırması doğrudur. İki örneği de doğru
sınıflandırdığına göre öğrenme tamamlanmıştır. Ağırlıkların ve eşik değerinin aşağıdaki gibi olması
sonucu bu ağ meyveleri sınıflandırıcı olarak (bu örnek için) kullanılabilir.
d) MADALINE Modeli
MADALİNE ağları birden fazla ADALİNE ünitesinin bir araya gelerek oluşturdukları ağa
verilen isimdir. MADALİNE ile ilgili ayrıntılı açıklamalar Widrow ve Lehr [4] tarafından verilmiştir.
MADALİNE ağları genel olarak iki katmandan oluşmaktadır. Her katmanda değişik sayıda adaline
ünitesi bulunmaktadır. Ağın çıktısı da yine 1 ve -1 değerleri ile gösterilmektedir. Her biri bir sınıfı
temsil etmektedir. Şekil 3.14.' de iki adaline ünitesinden oluşan bir MADALİNE gösterilmiştir.
28
Şekil 3.14. İki ADALİNE ağından oluşan MADALINE ağı
MADALİNE' nin öğrenme kuralı ADALİNE üniteleri için kullanılan öğrenme kuralı ile aynıdır.
Burada en sonda bulunan AND veya OR sonlandırıcısı önemlidir. Klasik mantık teorisinde olduğu
gibi AND sonlandırıcısı olması durumunda bütün ADALİNE ünitelerinin 1 değerini üretmesi sonucu
MADALINE ağının çıktısı 1 olur. Aksi halde -1 (veya 0) değerini alır. OR sonlandırıcısı olması
durumunda ADALİNE ünitelerinin birisinin 1 üretmesi MADALINE ağının çıktısının 1 olması için
yeterlidir.
3.8. Eğiticili YSA Modeli
Bir önceki bölümde anlatılan yapay sinir ağlarının ilk modellerinin en temel özellikleri doğrusal
olan olayları çözebilme yeteneklerine sahip olmalarıdır. Bu ağlar ile doğrusal olmayan ilişkiler
öğrenilememektedir. Bu sorunu çözmek için çok katmanlı algılayıcılar geliştirilmiştir. Bu bölümde
çok katmanlı algılayıcılar detaylı olarak anlatılacaktır.
a) Çok Katmanlı Algılayıcı (ÇKA)
Bir yapay sinir ağının öğrenmesi istenen olayların girdi ve çıktıları arasındaki ilişkiler doğrusal
olmayan ilişkiler olursa o zaman daha önce anlatılan modeller ile öğrenme gerçekleştirmek mümkün
değildir. Bu tür olayların öğrenilmesi için daha gelişmiş modellere ihtiyaç vardır. Bu bölümde
anlatılan Çok Katmanlı algılayıcı modeli bunlardan birisidir. Olayın doğrusal olup olmaması ne
demektir? Bu konuyu iyi anlayabilmek için ünlü XOR problemine bakmak gerekir. Bu problemin
özelliği doğrusal olmayan bir ilişkiyi göstermesidir. Yani çıktıların arasına bir doğru veya doğrular
çizerek onları iki veya daha fazla sınıfa ayırmak mümkün değildir. Bu problem Tablo 3.3.'de
gösterildiği gibidir. Basit algılayıcı ve ADALİNE ile bu problemi çözmek mümkün olmamıştır.
29
Tablo 3.3. XOR problemi
Bu problem, hemen hemen her yapay sinir ağının anlatan her kitapta örnek olarak verilmektedir.
Bundan çok yaygın olarak bahsedilmesinin nedeni şöyle açıklanabilir. Minsky özellikle basit
algılayıcı (perseptrori) modelinin bu probleme çözüm üretemediğini göstermiş ve yapay sinir ağlarının
doğrusal olmayan problemlere çözüm üretemediğini iddia ederek bilimsel araştırmaların durmasına
neden olmuştur. Çünkü günlük olayların çoğu (hemen hemen hepsi) doğrusal olmayan bir nitelik
taşımaktadır. XOR probleminin çözülememesinden sonra neredeyse bütün çalışmalar durmuş sadece
birkaç araştırmacı çalışmalara devam etmiştir. Bu problemi çözerek yapay sinir ağlarına tekrar
dikkatleri çekmeyi başarmışlardır. O nedenle bu problem yapay sinir ağı araştırmalarında bir
kilometre taşı olarak görülmektedir.
XOR problemini çözmek amacı ile yapılan çalışmalar sonucu çok katmanlı algılayıcı modeli
(ÇKA) geliştirilmiştir. Rumelhart ve arkadaşları [2] tarafından geliştirilen bu modele hata yayma
modeli veya geriye yayım modeli (backpropogation network) de denmektedir. ÇKA modeli yapay
sinir ağlarına olan ilgiyi çok hızlı bir şekilde artırmış ve yapay sinir ağları tarihinde yeni bir dönemin
başlamasına neden olmuştur. Bu model günümüzde mühendislik problemlerinin hemen hemen
hepsine çözümler üretebilecek bir güce sahiptir. Özellikle sınıflandırma, tanıma ve genelleme yapmayı
gerektiren problemler için çok önemli bir çözüm aracıdır. Bu model Delta Öğrenme Kuralı denilen bir
öğrenme yöntemini kullanmaktadır. Bu kural aslında ADALİNE ve basit algılayıcı modellerinin
öğrenme kurallarının geliştirilmiş bir şeklidir. Temel amacı ağın beklenen çıktısı ile ürettiği çıktı
arasındaki hatayı en aza indirmektir. Bunu hatayı ağa yayarak gerçekleştirdiği için bu ağa hata yayma
ağıda denmektedir.
b) ÇKA Modelinin Yapısı
ÇKA ağlarının yapısı Şekil 3.15.'de gösterildiği gibidir. Şekilden de görüldüğü gibi ÇKA ileriye
doğru bağlantılı ve 3 katmanda oluşan bir ağdır. Bunlar:
30
Şekil 3.15. ÇKA modeli
 Girdi katmanı: Dış dünyadan gelen girdileri (Gl, G2, ... GN) alarak ara katmana gönderir.
Bu katmanda bilgi işleme olmaz. Gelen her bilgi geldiği gibi bir sonraki katmana gider.
Birden fazla girdi gelebilir. Her proses elemanın sadece bir tane girdisi ve bir tane çıktısı
vardır. Bu çıktı bir sonraki katmanda bulunan bütün proses elemanlarına gönderilir. Yani,
girdi katma-nmdaki her proses elemanı bir sonraki katmanda bulunan proses elemanlarının
hepsine bağlıdır.
 Ara katmanlar: Ara katmanlar girdi katmanından gelen bilgileri işleyerek bir sonraki
katmana gönderir. Bir ÇKA ağında birden fazla ara katman ve her katmanda birden fazla
proses elemanı olabilir. Ara katmandaki her proses elemanı bir sonraki katmandaki bütün
proses elemanlarına bağlıdır.
 Çıktı katmanı: Ara katmandan gelen bilgileri işleyerek ağa girdi katmanından verilen
girdilere karşılık ağın ürettiği çıktıları (Çl, Ç2, ...ÇN) belirleyerek dış dünyaya gönderir. Bir
çıktı katmanında birden fazla proses elemanı olabilir. Her proses elemanı bir önceki
katmanda bulunan bütün proses elemanlarına bağlıdır. Her proses elamanın sadece bir tane
çıktısı vardır.
ÇKA ağında bilgiler girdi katmanından ağa sunulur ve ara katmanlardan geçerek çıktı
katmanına gider ve ağa sunulan girdilere karşılık ağın cevabı dış dünyaya iletilir.
ÇKA ağı öğretmenli öğrenme stratejisini kullanır. Ağa, hem örnekler hem de örneklerden elde
edilmesi gereken çıktılar (beklenen çıktı) verilmektedir. Ağ kendisine gösterilen örneklerden
genellemeler yaparak problem uzayını temsil eden bir çözüm uzayı üretmektedir. Daha sonra
gösterilen benzer örnekler için bu çözüm uzayı sonuçlar ve çözümler üretebilmektedir.
c) ÇKA Ağının Öğrenme Kuralı
31
ÇKA ağları öğretmenli öğrenme stratejisine göre çalışırlar. Yani; bu ağlara eğitim sırasında hem
girdiler hem de o girdilere karşılık üretilmesi gereken (beklenen) çıktılar gösterilir. Ağın görevi her
girdi için o girdiye karşılık gelen çıktıyı üretmektir. ÇKA ağının öğrenme kuralı en küçük kareler
yöntemine dayalı Delta Öğrenme Kuralının genelleştirilmiş halidir. O nedenle öğrenme kuralına
Genelleştirilmiş Delta Kuralı da denmektedir. Ağın öğrenebilmesi için eğitim seti adı verilen ve
örneklerden oluşan bir sete ihtiyaç vardır. Bu set içinde her örnek için ağın hem girdiler hem de o
girdiler için ağın üretmesi gereken çıktılar belirlenmiştir. Genelleştirilmiş "Delta Kuralı" iki safhadan
oluşur.
1. safha- ileri doğru hesaplama: Ağın çıktısını hesaplama safhasıdır.
2. safha- geriye doğru hesaplama: Ağırlıkları değiştirme safhasıdır.
İleri Doğru Hesaplama: Bu safhada bilgi işleme eğitim setindeki bir örneğin Girdi Katmanından (Gl,
G2...) ağa gösterilmesi ile başlar. Daha önce belirtildiği gibi, girdi katmanında herhangi bir bilgi
işleme olmaz. Gelen girdiler hiç bir değişiklik olmadan ara katmana gönderilir.
Yani girdi katmanındaki k. Proses elemanının çıktısı Çi
k şu şekilde belirlenir.
Ara katmandaki her proses elemanı girdi katmanındaki bütün proses elemanlarından gelen
bilgileri bağlantı ağırlıklarının (Al, Al...) etkisi ile alır. Önce ara katmandaki proses elemanlarına
gelen net girdi ( NETa
j ) şu formül kullanılarak hesaplanır.
Burada Akj k. girdi katmanı elemanını j. ara katman elemanına bağlayan bağlantının ağırlık
değerini göstermektedir. j. ara katman elemanın çıktısı ise bu net girdinin aktivasyon fonksiyonundan
(genellikle sigmoid fonksiyonundan) geçirilmesiyle hesaplanır. Uygulamada genellikle bu fonksiyon
kullanılmakla beraber, kullanılması zorunlu değildir. Önemli olan burada türevi alınabilir bir
fonksiyon kullanmaktır. Daha önce belirtilen aktivasyon fonksiyonlardan herhangi birisini burada
kullanmak mümkündür. Yalnız geriye doğru hesaplamada burada kullanılan fonksiyonun türevinin
alınacağını unutmamak gerekir. Sigmoid fonksiyonu kullanılması halinde çıktı,
şeklinde olacaktır. Burada (Bj, ara katmanda bulunan j. elemana bağlanan eşik değer elemanın
ağırlığını göstermektedir. Bu eşik değeri ünitesinin çıktısı sabit olup l' e eşittir. Ağırlık değeri ise
sigmoid fonksiyonunun oryantasyonunu belirlemek üzere konulmuştur. Eğitim esnasında ağ bu değeri
kendisi belirlemektedir.
32
Ara katmanın bütün proses elemanları ve çıktı katmanın proses elemanlarının çıktıları aynı
şekilde kendilerine gelen NET girdinin hesaplanması ve sigmoidi fonksiyonundan geçirilmesi sonucu
belirlenirler. Çıktı katmanından çıkan değerler, yani çıktıları, (Çl, Ç2,...) bulununca ağın ileri
hesaplama işlemi tamamlanmış olur.
Geriye Doğru Hesaplama: Ağa sunulan girdi için ağın ürettiği çıktı ağın beklenen çıktıları (#1,
J52,...) ile karşılaştırılır. Bunların arasındaki fark hata olarak kabul edilir. Amaç bu hatanın düşürülmesidir. O nedenle geriye hesaplamada bu hata ağın ağırlık değerlerine dağıtılarak bir sonraki
iterasyonda hatanın azaltılması sağlanır. Çıktı katmanındaki m. proses elemanı için oluşan hata (Em).
Em = Bm- Çm
olacaktır. Bu bir proses elemanı için oluşan hatadır. Çıktı katmanı için oluşan toplam hatayı (TH)
bulmak için bütün hataların toplanması gerekir. Bazı hata değerleri negatif olacağından toplamın sıfır
olmasını önlemek amacı ile ağırlıkların kareleri hesaplanarak sonucun karekökü alınır. ÇKA ağının
eğitilmesindeki amaç bu hatayı en azlamaktır. TH şu formül ile bulunur.
Toplam hatayı enazlamak için bu hatanın kendisine neden olan proses elemanlarına dağıtılması
gerekmektedir. Bu ise proses elemanlarının ağırlıklarını değiştirmek demektir. Ağın ağırlıklarını
değiştirmek için iki durum söz konusudur.
• Ara katman ile çıktı katmanı arasındaki ağırlıkların değiştirilmesi
• Ara katmanlar arası veya ara katman girdi katmanı arasındaki ağırlıkların değiştirilmesi
Ara katman ile çıktı katmanı arasındaki ağırlıkların değiştirilmesi
Ara katmanındaki j. proses elemanını çıktı katmanındaki m. proses elemanına bağlayan
bağlantının ağırlığındaki değişim miktarına ∆Aa
denirse; herhangi bir t zamanında (t. iterasyonda)
ağırlığın değişim miktarı şöyle hesaplanır.
Burada λ öğrenme katsayısını, a momentum katsayısını göstermektedir. Öğrenme katsayısı
ağırlıkların değişim miktarını, Momentum katsayısı ise ÇKA ağının öğrenmesi esnasında yerel bir
optimum noktaya takılıp kalmaması için ağırlık değişim değerinin belirli bir oranda bir sonraki
değişime eklenmesini sağlarlar. Bu konu aşağıda tekrar tartışılacaktır. Eşitlikteki ise m. çıktı
ünitesinin hatasını göstermektedir. Şu şekilde hesaplanır.
33
Buradaki f ’ (NET) aktivasyon fonksiyonunun türevidir. Sigmoid fonksiyonunun kullanılması
durumunda;
olacaktır. Değişim miktarı hesaplandıktan sonra ağırlıkların t. iterasyondaki yeni değerleri şöyle
olacaktır.
Benzer şekilde eşik değer ünitesinin de ağırlıklarını değiştirmek gerekmektedir. Onun için
Öncelikle değişim miktarını hesaplamak gerekir. Eğer çıktı katmanında bulunan proses elemanlarının
eşik değer ağırlıkları βç
ile gösterilirse; bu ünitenin çıktısının sabit ve 1 olması nedeni ile değişim
miktarı,
olacaktır. Eşik değerin t. iterasyondaki ağırlığının yeni değeri ise,
şeklinde hesaplanacaktır.
Ara katmanlar arası veya ara katman girdi katmanı arasındaki ağırlıkların değiştirilmesi
Dikkatli incelenirse, ara katman ile çıktı katman arasındaki ağırlıkların değişiminde her ağırlık
için sadece çıktı katmanındaki bir proses elemanının hatası dikkate alınmıştır. Bu hataların
oluşmasında girdi katmanı ve ara katman arasındaki ağırlıkların (varsa iki ara katman arasındaki
ağırlıkların) payı vardır. Çünkü, en son ara katmana gelen bütün bilgiler girdi katmanı veya önceki ara
katmandan gelmektedir. O nedenle girdi katmanı ile ara katman arasındaki (veya iki ara katman
arasındaki) ağırlıkların değiştirilmesinde çıktı katmanındaki proses elemanların hepsinin hatasından
payını alması gerekir. Bu ağırlıklardaki değişimi (mesela girdi katmanı ile ara katman arasındaki
ağırlıkların değişimi) ∆Ai
ile gösterilirse değişim miktarı;
olacaktır. Buradaki hkta terimi δa ise şöyle hesaplanacaktır.
Aktivasyon fonksiyonu olarak sigmoid fonksiyonu düşünülürse bu hata değeri şu şekilde
hesaplanacaktır.
34
Hata değeri hesaplandıktan sonra yukarıda verilen eşitlik ile değişim miktarını bulmak mümkün
olur. Ağırlıkların yeni değerleri ise,
şeklinde olacaktır. Benzer şekilde, eşik değer ünitesinin yeni ağırlıkları da yukarıdaki gibi hesaplanır.
Ara katman eşik değer ağırlıkları βa
ile gösterilirse değişim miktarı,
olacaktır. Ağırlıkların yeni değerleri ise t. iterasyonda şöyle hesaplanacaktır.
Böylece ağın ağırlıklarının hepsi değiştirilmiş olacaktır. Bir iterasyon hem ileri hem de geriye
hesaplamaları yapılarak tamamlanmış olacaktır. İkinci bir örnek verilerek sonraki iterasyona başlanır
ve aynı işlemler öğrenme tamamlanıncaya kadar yinelenir.
d) ÇKA Ağının Çalışma Prosedürü
ÇKA ağlarının çalışması şu adımları içermektedir:
1.Örneklerin toplanması: Ağın çözmesi istenilen olay için daha önce gerçekleşmiş örneklerin
bulunması adımıdır. Ağın eğitilmesi için örnekler toplandığı gibi (eğitim seti) ağın test edilmesi
için de örneklerin (test seti) toplanması gerekmektedir. Ağın eğitilmesi sırasında test seti ağa hiç
gösterilmez. Eğitim setindeki örnekler tek tek gösterilerek ağın olayı öğrenmesi sağlanır. Ağ
olayı öğrendikten sonra test setindeki örnekler gösterilerek ağın performansı ölçülür. Hiç
görmediği örnekler karşısındaki başarısı ağın iyi öğrenip öğrenmediğini ortaya koymaktadır.
2.Ağın topolojik yapısının belirlenmesi: Öğrenilmesi istenen olay için oluşturulacak olan ağın
topolojik yapısı belirlenir. Kaç tane girdi ünitesi, kaç tane ara katman, her ara katmanda kaç tane
proses elemanı ve kaç tane çıktı elemanı olması gerektiği bu adımda belirlenmektedir.
3.Öğrenme parametrelerini belirlenmesi: Ağın öğrenme katsayısı, proses elemanlarının
toplama ve aktivasyon fonksiyonları, momentum katsayısı gibi parametreler bu adımda
belirlenmektedir.
4.Ağırlıkların başlangıç değerlerinin atanması: Proses elemanlarını birbirlerine bağlayan
ağırlık değerlerinin ve eşik değer ünitesinin ağırlıklarının başlangıç değerlerinin atanması
yapılır. Başlangıçta genellikle rasgele değerler atanır. Daha sonra ağ uygun değerleri öğrenme
sırasında kendisi belirler.
5.Öğrenme setinden örneklerin seçilmesi ve ağa gösterilmesi: Ağın öğrenmeye başlaması ve
yukarıda anlatılan öğrenme kuralına uygun olarak ağırlıkları değiştirmesi için ağa örnekler
(Girdi/Çıktı değerleri) belirli bir düzeneğe göre gösterilir.
6.Öğrenme sırasında ileri hesaplamaların yapılması: Yukarıda anlatıldığı şekilde sunulan
girdi için ağın çıktı değerleri hesaplanır
35
7.Gerçekleşen çıktının beklenen çıktı ile karşılaştırılması: Ağın ürettiği hata değerleri bu
adımda hesaplanır.
8.Ağırlıkların değiştirilmesi: Yukarıda anlatıldığı gibi geri hesaplama yöntemi uygulanarak
üretilen hatanın azalması için ağırlıkların değiştirilmesi yapılır.
Yukarıdaki adımlar ÇKA ağının öğrenmesi tamamlanıncaya, yani gerçekleşen çıktılar ile
beklenen çıktılar arasındaki hatalar kabul edilir düzeye ininceye, kadar devam eder. Ağın öğrenmesi
için bir durdurma kriterinin olması gerekmektedir. Bu ise genellikle üretilen hatanın belirli bir düzeyin
altına düşmesi olarak alınmaktadır.
e) Ağın Eğitilmesi
ÇKA ağlarının eğitilmesi felsefesi diğer ağlarınkinden farklı değildir. Ağın kendisine gösterilen
girdi örneği için beklenen çıktıyı üretmesini sağlayacak ağırlık değerleri bulunmaktadır. Başlangıçta
bu değerler rasgele atanmakta ve ağa örnekleri gösterdikçe ağın ağırlıkları değiştirilerek zaman
içerisinde istenen değerlere ulaşması sağlanmaktadır. İstenen ağırlık değerlerinin ne olduğu
bilinmemektedir. Bu nedenle yapay sinir ağlarının davranışlarını yorumlamak ve açıklamak mümkün
olmamaktadır. Zaten bu ağların diğer yapay zekâ tekniklerinden meselâ uzman sistemlerden, ayıran en
önemli farkı da davranışlarını açıklayamamasıdır. Bunun temel nedeni Bölüm 2'de açıklandığı gibi
bilginin ağ üzerine dağıtılmış olması ve ağırlık değerlerinin kendi başlarına herhangi bir anlam
göstermemeleridir. Ağ ile ilgili bilinen konu problem uzayında en az hata verebilecek ağırlık
değerlerinin bulunmasıdır. Hatanın en az değeri kavramını anlatabilmek için basit bir problem
düşünülürse, ağın öğrenmesi istenen olayın (problem uzayının) Şekil 3.16.'da gösterildiği gibi bir hata
uzayının olduğu varsayılsın. Şekildeki W* en az hatanın olduğu ağırlık vektörünü göstermektedir.
Şekil 3.16. Öğrenmenin hata uzayındaki gösterimi
Ağın W* değerine ulaşması istenmektedir. Bu ağırlık değeri problem için hatanın en az olduğu
noktadır. O nedenle her iterasyonda ∆W kadar değişim yaparak hata düzeyinde ∆E kadar bir hatanın
36
düşmesi sağlanmaktadır. Burada bir noktaya dikkatleri çekmek gerekir. Problemin hata düzeyi her
zaman böyle basit ve iki boyutlu olmayacaktır. Şekil 3.17. daha karmaşık bir hata düzeyini
göstermektedir. Görüldüğü gibi problemin çözümü için en az hatayı veren ağırlık vektörü W*
olmasına rağmen pratikte bu hata değerini yakalamak çoğu zaman mümkün olmayabilmektedir. Bu
çözüm ağın sahip olabileceği en iyi çözümdür. Fakat bu çözüme nasıl ulaşılacağı konusunda elimizde
bir bilgi yoktur. Ağ, eğitim sırasında kendisi bu çözümü yakalamaya çalışmaktadır.
Bazen farklı bir çözüme takılabilmekte ve performansı daha iyileştirmek mümkün
olamamaktadır. O nedenle kullanıcılar ağların performanslarında (problemlere ürettikleri çözümlerde)
s kadar hatayı kabul etmektedirler (tolerans değeri). Tolerans değeri altındaki her hangi bir noktada
olay öğrenilmiş kabul edilmektedir. Şekildeki W0 ve Wl çözümlerinin hataları kabul edilebilir hata
düzeyinin üzerinde olduğundan bu çözümler kabul edilemez çözümlerdir. Bunlara yerel çözümler
denilmektedir. Wl ve W3 çözümleri en iyi çözüm olmamalarına rağmen kabul edilebilir hata
düzeyinin altında bir hataya sahiptiler. Bunlarda yerel çözümler olmalarına rağmen kabul edilebilir
çözümlerdir. Görüldüğü gibi bir problem için birden fazla çözüm üretilebilmektedir. Bu nedenle
yapay sinir ağlarının her zaman en iyi çözümü ürettikleri söylenemez. Kabul edilebilir bir çözüm
ürettiklerini söylemek daha doğrudur. Üretilen çözüm en iyi çözüm olsa bile bunun bilinmesi zordur.
Çoğu durumda bilinmesi mümkün değildir.
Şekil 3.17. Çok boyutlu hata uzayı
Şekil 3.17. aynı zamanda başka bir gerçeği daha göstermektedir. Neden en iyi sonuç
bulunamamaktadır? Bunun başka nedenleri de olabilir. Örneğin,
• Problem eğitilirken bulunan örnekler problem uzayını %100 temsil etmeyebilir.
• Oluşturulan ÇKA ağı için doğru parametreler seçilmemiş olabilir.
• Ağın ağırlıkları başlangıçta tam istenildiği şekilde belirlenmemiş olabilir.
• Ağın topolojisi yetersiz seçilmiş olabilir.
Bu ve benzeri nedenlerden dolayı ağ, eğitim sırasında, hatayı belirli bir değerin altına
düşüremeyebilir. Mesela Wl ağırlıklarını bulur hatayı daha aşağıya düşüremez. Bu aslında yerel bir
37
çözümdür. En iyi çözüm değildir. Hata kabul edilebilir düzeye indiğinden yerel en iyi bir çözüm
olarak görülebilir. Global çözümün bulunması da mümkün olabilir. Bu tamamen ağın tasarımına,
örneklerin niteliğine ve eğitim sürecine bağlıdır.
Bazı durumlarda ağın takıldığı lokal sonuç kabul edilebilir hata düzeyinin üstünde kalabilir
(Mesela Şekil 3.18.'deki W0 ağırlıklarının bulunması ve hatanın daha fazla azaltılmasının mümkün
olmaması). Bu durumda ağın olayı öğrenmesi için bazı değişiklikler yapılarak yeniden eğitilmesi
gerekir. Bu değişiklikler arasında şunlar sayılabilir:
• Başka başlangıç değerlerinin kullanılabilir.
• Topolojide değişiklikler yapılabilir (ara katman sayısını artırmak, proses elemanı sayısını
artırmak veya azaltmak gibi),
• Parametrelerde değişiklik yapılabilir (fonksiyonların başka seçilmesi, öğrenme ve momentum
katsayılarının değiştirilmesi gibi)
• Problemin gösterimi ve örneklerin formülasyonu değiştirilerek yeni örnek seti oluşturulabilir
• Öğrenme setindeki örneklerin sayısı artırılabilir veya azaltılabilir
• Öğrenme sürecinde örneklerin ağa gösterilmesi
ÇKA ağlarının yerel sonuçlara takılıp kalmaması için momentum katsayısı geliştirilmiştir. Bu
katsayının iyi kullanılması yerel çözümleri kabul edilebilir hata düzeyinin altına çekebilmektedir.
ÇKA ağlarının eğitilmesinde diğer önemli bir sorun ise öğrenme süresinin çok uzun olmasıdır.
Ağırlık değerleri başlangıçta büyük değerler olması durumunda ağın lokal sonuçlara düşmesi ve bir
lokal sonuçtan diğerine sıçramasına neden olmaktadır. Eğer ağırlıklar küçük aralıkta seçilirse o zaman
da ağırlıkların doğru değerleri bulması uzun zamanlar almaktadır. Bazı problemlerin çözümü sadece
200 iterasyon sürerken bazıları 5-10 Milyon iterasyon gerektirmektedir. Bu konuda da elimizde
bilimsel bir yaklaşım yoktur. Tamamen deneme yanılma yolu ile en uygun başlama koşullarının
belirlenmesi gerekmektedir. Aşağıda ÇKA ağlarını daha etkin kullanabilmek için bu kapsamda bazı
öneriler verilecektir.
Şekil 3.18. Öğrenen bir ÇKA ağının öğrenme eğrisine örnek
38
Ağın öğrenmesinin gösterilmesinin en güzel yol hata grafiğini çizmektir. Öğrenen bir ağ için her
îterasyonda oluşan hatanın grafiği çizilirse Şekil 3.18.'de gösterildiği şekle benzer bir hata grafiği
oluşur. Burada hatanın zaman içerisinde düştüğü görülür.
Belirli bir iterasyondan sonra hatanın daha fazla azalmadığı görülür. Bu ağm öğrenmesini
durdurduğu ve daha iyi bir sonuç bulunamayacağı anlamına gelir. Eğer elde edilen çözüm kabul
edilemez ise o zaman ağ yerel bir çözüme takılmış demektir. Bu durumda ağın yukarıda önerilen
değişiklikleri yaparak yenide eğitilmesi gerekir.
f) XOR Probleminin Çözülmesi
ÇKA ağlarının yapısını ve öğrenme kuralını anlattıktan sonra XOR problemine nasıl sonuç
ürettiklerini bir örnek üzerinde göstermek faydalı olacaktır. Çünkü bu örnek, ÇKA ağlarının
bulunmasının en temel nedenlerinden birisidir. Bu problem, yapay sinir ağlarında bir devrin kapanıp
bir devrin açılmasına neden olmuş önemli bir kilometre taşıdır. Yukarıda anlatılan ÇKA ağının
çalışma süreci XOR problemine şöyle uygulanır.
1. Adım: Örneklerin Toplanması:
Daha önce Şekil-5.1'de de gösterildiği gibi XOR problemi için 4 örnek vardır. Bunlar 1 ve 0
değerlerinden oluşmaktadır. Her örnek için girdiler ve beklenen çıktı şöyledir:
2. Adım: Ağın Topolojik Yapısının Belirlenmesi:
XOR probleminde 2 girdi ve 1 de çıktı olduğundan, oluşturulacak olan ÇKA ağının da 2 girdi ünitesi
ve 1 çıktı ünitesi olacaktır. 1 ara katman ve 2 tanede ara katman proses elemanının bu problemi
çözebileceği varsayılmaktadır. Şekil-5.5'de oluşturulan ağın topolojisi gösterilmektedir. Görüldüğü
gibi ara katman için bir adet, çıktı katmanı içinde bir adet eşik değer ünitesi vardır.
3. Adım: Öğrenme Parametrelerini Belirlenmesi:
Oluşturula ağ için aktivasyon fonksiyonu olarak sigmoid fonksiyonunun kullanıldığını, öğrenme (λ)
ve momentumun (α) katsayılarının ise şu şekilde belirlendiği varsayılsın,
λ =0.5
α =0.8
sse = 0.03
39
4. Adım: Ağırlıkların Başlangıç Değerlerinin Atanması:
Oluşturulan ağ için ağırlık vektörleri ve başlangıç değerleri de şu şekilde belirlenmiş olsun.
Girdi katmanı ile ara katman arasındaki ağırlıklar Ai
matrisi ile gösterilsin;

Çıktı katmanı ile ara katman arasındaki ağırlıklar ise Aa
gösterilsin;
Aa
= [0.164732 0.75262l]
Eşik değeri ağırlıkları şöyle olsun.
βa
= [0.341332 -0.115223]
βç
=[-0.993423]
5. Adım: Örneklerin Ağa Gösterilmesi ve İleri Doğru Hesaplama:
Birinci örnek G1=0, G2=0 ve B=0 olarak belirlenmiştir.
Ara katman ünitelerinin NET girdileri (eşik değer ünitesinin ağırlık değerleri eklenmiş olarak) şu
şekilde hesaplanır.
Netl = (0 * 0.129952) + (0 * -0.923123)+ (1 * 0.341232) = 0 341232
Net2= + (0 * 0.570345) + (0 * -0.328932) +(1 *-0.115223) = -0.115223
Ara katman ünitelerinin çıktıları ise şöyle hesaplanır.
Çıktı katmanındaki proses elemanının NET girdisi hesaplanırsa;
Net= (l*-0.993423) + (0.584490*0.164732) + (0.471226*0.752621) = -0.542484
Değeri bulunur. Bu değer ile ağın çıktısı;
Beklenen çıktı 0 olduğuna göre ağın hatası: E= 0-0.367610 = -0.367610 olur.
Bu hatanın geriye doğru yayılması sonucu ara katman ile çıktı katmanı arasındaki ağırlıkların
değişim miktarları şu şekilde hesaplanır.
40
Ağırlıklardaki bu değişim miktarları ile ara katman ve çıktı katmanı arasındaki ağırlıklar
yeniden hesaplanabilir.
Benzer şekilde, girdi katmanı ile ara katman arasındaki ağırlıkların değişim miktarları ve yeni
ağırlık değerleri hesaplanır. Ara katmandaki hata oranları ve değişim miktarları şu şekilde bulunur.
Bu değerleri kullanılarak ağırlıklar değiştirilir. Ağırlıklardaki değişim miktarı 0 olduğundan
ağırlık değerlerinde herhangi bir değişiklik olmayacak ancak eşik değeri ağırlıklarında değişiklik
olacaktır.
Birinci iterasyon bittikten sonra ikinci iterasyon başlayacaktır. Bu kez ikinci örnek ağa
gösterilir. G1=0, G2=l ve B=l olacaktır. Yukarıdaki işlemler aynı şekilde tekrar edilir. Bu iterasyonlar
bütün çıktılar doğru cevap verinceye kadar devam etmelidir.
Bu ağırlıklar ile girdiler ağa tekrar gösterildiğinde o zaman Tablo 3.4'de gösterilen sonuçlar elde
edilir. Bu sonuçlar ağın problemi çok düşük hatalar ile çözebilecek şekilde öğrendiğini
göstermektedir.
41
Tablo 3.4. XOR problemini öğrendikten sonra ağın ürettiği çözümler ve hata oranları
g) ÇKA Ağının Öğrenmek Yerine Ezberlemesi
Bazı durumlarda eğitilen ÇKA ağı eğitim setindeki bütün örneklere %100 doğru cevap
üretmesine rağmen test setindeki örneklere doğru cevaplar üretememektedir. Ancak %10-%20
civarında bir performans yakalanabilmektedir. Hatta bu oranlara bile ulaşılamamaktadır. Bu durumda
ÇKA ağının öğrenmediği fakat öğrenme setini ezberlediği görülmektedir. ÇKA ağı tasarımcıları bu
durumdan kurtulmak istemektedirler. Çünkü öğrenim %100 görülmekte fakat ağ öğrenmemektedir.
Bu ağın günlük kullanıma alınması mümkün olmaz. Onun için aşağıda belirtilen konular tekrar gözden geçirilerek ağın ezberlemesinden kurtulmak ve gerçekten öğrenmesini sağlamak gerekir. Çok iyi
ezberleyen bir ağ yerine azar azar öğrenen ve kabul edilebilir bir hata ile öğrenme gerçekleştiren
performansı düşük ağ daha iyidir.
h) Bir ÇKA Ağının Oluşturulmasında Dikkat Edilmesi Gereken Bazı Önemli Noktalar
Yapılan araştırmalar ve tecrübeler bir ÇKA ağının performansını etkileyen unsurların şunlar
olduğunu göstermektedir.
• Örnekleri seçilmesi
• Girdi ve çıktıların ağa gösterimi
• Girdilerin nümerik gösterimi
• Çıktıların nümerik gösterimi
• Başlangıç değerlerinin atanması
• Öğrenme ve momentum katsayılarının belirlenmesi
• Örnekleri ağa sunulması
• Ağırlıkların değiştirilme zamanları
• Girdi ve çıktıların ölçeklendirilmesi
• Durdurma Kriterinin belirlenmesi
• Ara katmanların ve her katmandaki proses elemanlarının sayısının belirlenmesi
• Ağların büyütülmesi veya budanması
Bu unsurların ağın performansına etkileri aşağıda tartışılmış ve her birisi ile ilgili önerilerde
bulunulmuştur.
42
Örneklerin Seçilmesi: Örneklerin seçilmesi ağın performansını yakından ilgilendiren bir konudur.
Çünkü ağ, bu örnekleri dikkate alarak ağırlıklarını değiştirmektedir. Seçilen örneklerin problem
uzayını temsil edebilecek nitelikte olması çok önemlidir. Bazı ÇKA ağı tasarımcıları problem uzayının
sadece bir dilimini gösteren örnekleri ağa göstermekte fakat tamamı ile ilgili yorumlar yapmasını
beklemektedir. Bu mümkün değildir. Bazıları ise elmayı gösterip portakalı sormaktadır.
Unutulmaması gereken şudur ki ağa ne gösterilirse ağ ancak o konularda yorumlar yapabilir ve ancak
o konuda görmediği örneklere çözümler üretebilir. 2X2=4 diye ağa öğretirseniz 3X3 kaç eder diye
soramazsınız. Çünkü ağ bu konuda bir örnek görmemiş ve genellemeleri yapacak durumda
olmamıştır.
Girdi ve Çıktıların Gösteriminin Belirlenmesi: Örneklerin belirlenmesi kadar belki ondan da daha
önemlisi örneklerin gösteriminin nasıl olacağının belirlenmesidir. Girdi/çıktı çiftlerinden oluşan
örnekler ağa nasıl gösterilecektir? Yapay sinir ağları daha önce belirtildiği gibi sadece rakamlar ile çalışmaktadırlar. Eğer problem uzayında sayısal (nümerik) olmayan faktörleri dikkate almak gerekiyor
ise o zaman onların rakamlar ile temsil edilebilmesi gerekmektedir. Bu dönüştürme çeşitli şekillerde
olabilmekte ve bu da ağın performansını etkilemektedir. Hem girdi değerlerinin hem de beklenen çıktı
değerlerinin nümerik olarak gösterilmesi gerekmektedir.
Girdi Değerlerinin Nümerik Gösterimi: Ağa gösterilen girdi değerlerini ağın anlayabilmesi için
nümerik olma zorunluluğu problemin girdilerinin nümerik gösterimini gerektirmektedir. Bu ise her
zaman kolay olmamakta ve problem tasarımcısını zor durumda bırakabilmektedir. Çünkü bu güne
kadar geliştirilmiş her olay için uygulanabilir bir dönüştürme mekanizması geliştirilmemiştir. Her olay
için ayrı bir yöntem uygulanabilmektedir. Hatta birden fazla yöntem arasından bir tanesi
seçilmektedir. Bu seçim de ağın performansı üzerinde etkili olabilmektedir.
Tablo 3.5. Örneklerdeki sayısal ve alfa nümerik değerlere örnekler
43
Görüldüğü gibi bazı değerler tamamen alfa nümerik değerlerdir. Bu olayı ÇKA ağına öğretmek için
bunları nümerik değerlerle gösterilmek zorundadır. Bu değişik şekillerde yapılabilir. Mesela B faktörü
için 1 tam değerini O'da yarım değerini gösterebilir. Benzer şekilde Tam için 1, yarım içinde 2
değerleri de kullanılabilir. Seçilecek yöntem başarıyı etkileyecektir. O nedenle öğrenmenin
gerçekleşmeme durumunda bu gösterim yöntemlerini değiştirmek başarılı çözümler üretilebilir.
Çıktıların Nümerik Gösterimi: Çıktıların nümerik gösterimi gerçekleştirilmez ise çıktı değerleri ile
beklenen değerler arasındaki hatayı bulmak mümkün olmaz. Girdilerde olduğu gibi çıktılarda da
nümerik gösterim problemden probleme değişmektedir. Bir problem için birden fazla yöntem
kullanarak nümerik gösterim sağlanabilir. Bunların en iyisinin hangisi olduğu bilinmemektedir.
Önemli olan uygun olanı bulmaktır. Öğrenemeyen ağlarda tasarımcılar çoğu zaman bu konuyu da göz
ardı etmektedirler. Mesela, daha önce verilen kadın ve erkek resimlerini birbirinden ayıran bir ağın
çıktısı nasıl olacaktır? Tasarımcı ister ise bir tek çıktı yaparak gösterilen resmin erkek resmi olması
durumunda 1 değerini, kadın resmi olması durumunda 0 değerini almasını isteyebilir. Alternatif olarak
tasarımcı 2 çıktı ünitesi belirleyerek erkek resimleri için çıktının 1 0 kadın resimleri için ise 0 1
olmasını isteyebilir. İkinci durumda tanıma işleminin sorumluluğu çıktı üniteleri alasında
paylaştırılmış olacaktır. Şekil 3.19. bu iki durumu göstermektedir. Bunlardan hangisinin daha iyi
olduğunu söylemek mümkün değildir. Bu eğitimin başlaması ile görülebilir.
Şekil 3.19. Çıktıların sayısal gösterimi
Başlangıç Değerlerinin Atanması: ÇKA ağının proses elemanlarını birbirine bağlayan bağlantıların
ağırlıklarının başlangıç değerlerinin atanması da ağın performansı ile yakından ilgilidir. Genel olarak
ağırlıklar belirli aralıklarda atanmaktadır. Bu aralık eğer büyük tutulursa ağın yerel çözümler arasında
sürekli dolaştığı küçük olması durumunda ise öğrenmenin geç gerçekleştiği görülmüştür. Bu
değerlerin atanması için henüz belirlenmiş standart bir yöntem yoktur. Ağırlıkların başlangıç
değerlerinin rasgele atanmaları istenmektedir. Tecrübeler-1.0 ile 0.1 arasındaki değerlerin başarılı
sonuçlar ürettiğini göstermektedir. Fakat bu tamamen öğrenilmesi istenen problemin niteliğine
bağlıdır. Diğerleri ile birlikte düşünmek gerekir. Şekil 3.20. başlangıç noktalarının önemini
göstermektedir.
44
Şekil 3.20. ÇKÂ ağlarında başlangıç noktasının etkisi
Şekilde görüldüğü gibi eğer bir ÇKA ağı öğrenmeye A noktasından başlar ise yerel bir çözüme
(Wl) takılabilme olasılığı var iken B noktasından başlarsa en iyi çözümü (W*) bulunması daha kolay
olmaktadır.
Öğrenme Katsayısı ve Momentum Katsayılarının Belirlenmesi: Öğrenme katsayısı ağırlıkların
değişim miktarını belirlemektedir. Eğer büyük değerler seçilirse o zaman yerel çözümler arasında ağın
dolaşması ve osilasyon yaşaması söz konusu olmaktadır. Küçük değerler seçilmesi ise öğrenme
zamanını artırmaktadır. Tecrübeler genellikle 0.2- 0.4 arasındaki değerlerin kullanıldığını
göstermektedir.
Benzer şekilde momentûm katsayısı da öğrenmenin performansını etkiler. Momentûm katsayısı bir
önceki iterasyondaki değişimin belirli bir oranının yeni değişim miktarına eklenmesi olarak
görülmektedir. Bu özellikle yerel çözümlere takılan ağların bir sıçrama ile daha iyi sonuçlar bulmasını
sağlamak amacı ile önerilmiştir. Bu değerin küçük olması yerel çözümlerden kurtulmayı
zorlaştırabilir. Çok büyük değerler ise tek bir çözüme ulaşmada sorunlar yaşanabilir.
Örneklerin Ağa Sunulması Şekli: Örneklerin ağa sunulma şekli de öğrenme performansını
etkileyebilir. Genel olarak örnekler ağa iki türlü sunulabilirler. Bunlar:
• Sıralı sunum
• Rasgele sunum
Sıralı sunumda örnek setindeki birinci örnek ağa sunulur. Bir sonraki iterasyonda ise sırası ile ikinci,
üçüncü sırası ile en sonuncu örneğe örneklerin tamamı ağa sunulur. Sonra tekrar başa dönerek örnek
setindeki örnekler tek tek sıra ile ağa tekrar sunulur. Bu işlem öğrenme sağlanıncaya kadar devam
eder. Bu tür bir sunuşta örnek setindeki bütün örneklerin ağa gösterilme şansları eşittir.
45
Rasgele sunumda ise örnekler eğitim seti içinden rasgele seçilirler. Burada da iki durum söz
konusudur.
• Seçilen bir örnek tekrar set içine atılıp rasgele yeniden seçim yapılır. Bu durumda bir örneğin
peş peşe birden fazla defa seçilme şansı vardır. Öğrenme gerçekleşene kadar böyle devam edilir.
Örneklerin ağa gösterilme şansları eşit değildir.
• Rasgele seçilen örnek eğitim içine tekrar atılmaz. Kalanlar arasından rasgele tekrar yeni örnek
seçilerek ağa sunulur. Bütün örnekler ağa gösterilince, eğitim seti tekrar içinden rasgele örnekler
seçilerek ağa gösterilir. Bir gösterilen örnek bütün set ağa gösterilinceye kadar bekler. Öğrenme
sağlanıncaya kadar bu işlem aynı şekilde tekrar eder. Örneklerin ağa gösterilme şansları bu
durumda da eşittir.
Ağırlıkların Değiştirilmesi Zamanı: Ağırlıkların değiştirilmesi öğrenme kuralına göre
yapılmaktadır. Doğru zamanlama ağın, öğrenme performansını etkilemektedir. Bu 3 durum şöyle
özetlenebilir.
1. Her örnek ağa gösterildiğinde (pattern based learning): Bu durumda ağa her örnek
gösterildiğinde beklenen çıktı ile ağın gerçekleştirdiği çıktı arasındaki hata bulunur ve bu hata
ağın ağırlıklarına daha önce anlatılan öğrenme kuralı gereğince dağıtılır. İkinci örnek ağa
sunulduğunda çıktının hatası hesaplanır ve ağırlıklar değiştirilir. Her örnek gösterimi sonucu
ağırlıklar değiştirilir.
2. Belirli sayıda örnek gösterildiğinde (batch based learning): Bu durumda ağa her örnek
gösterildiğinde hatası hesaplanıp ağırlıklar değiştirilmez. Belirli sayıda örnek tek tek ağa gösterilir
ve hatalar toplanırlar. îstenen sayıdaki örneğin ağa gösterilmesi bitince toplanan hata ağırlıklara
dağıtılır. Genellikle 5-10 örnekten oluşan örnek grupları oluşturulmaktadır. Yani 5 örnek peş peşe
ağa gösterilmekte hatalar hesaplanıp toplanmakta ve toplam hata öğrenme kuralına göre
ağırlıklara dağıtılmaktadır.
3. Bütün örnek seti gösterildiğinde (epoch based leanıing): Bu durumda örnek setindeki bütün
örnekler ağa tek tek gösterilir. Hatalar hesaplanır ve eğitim setindeki örneklerin tamamının
hataları toplandıktan sonra bu hata ağırlıklara dağıtılır. Yani; ağın ağırlık değerleri örneklerin
tamamı ağa gösterilmedikçe değiştirilmez. Örnek sayısının az olduğu durumlarda önerilmektedir.
Örneklerin Değerlerinin Ölçeklendirilmesi (Scaling): ÇKA ağlarında girdi ve çıktıların
ölçeklendirilmeside ağın performansını yakından etkilemektedir. Çünkü ölçeklendirme örneklerin
değerlerinin dağılımını düzenli hale getirmektedir.
 Girdilerin Ölçeklendirilmesi: Bütün girdilerin belirli aralıkta (çoğunlukla 0-1
aralığında) ölçeklendirilmesi hem farklı ortamlardan gelen bilgilerin aynı ölçek üzerine
46
indirgenmesine hem de yanlış girilen çok büyük ve küçük şekildeki değerlerin etkisinin
ortadan kalkmasına neden olur. Ölçeklendirme değişik şekillerde yapılmaktadır. Bazı
araştırıcılar girdi vektörünü normalize etmektedirler. Yani her değeri girdi vektörünün
değerine bölerek yeni değerleri bulmaktadırlar. Bu ise şu şekilde verilmektedir.

Burada x girdi değerini, x' ölçeklendirilmiş yeni girdi değerini, |X| ise girdi vektörünün
büyüklük (vektörel) değerini göstermektedir.
Bazı araştırmacılar ise aşağıdaki gibi bir formülasyon kullanmakta ve örnekleri oluşturan değerleri belirli bir aralık içine çekmektedirler.
Burada x girdi değerini, x' girdi değerinin ölçeklendirilmiş halini, xmin girdi setindeki
olası en küçük değeri xmax ise girdi setindeki olası en büyük değeri göstermektedir.
Burada önemli olan hangi yöntem kullanıldığından çok girdiler içindeki olumsuz
etkileri önleyecek şekilde ölçeklendirme yapmaktır. Bu konuda bir standart koymak
doğru olmaz.
 Çıktıların Ölçeklendirilmesi: Çıktıların ölçeklendirilmesi de yukarıda girdilerin
ölçeklendirilmesi için anlatılan yöntemlerin birisi ile yapılabilir. Mesela Yukarıda
verilen ikinci formül ile ölçeklendirme yapılmış ise orijinal değerlere dönüştürme için o
formül tersine çevrilerek şu şekilde kullanılacaktır.
X= X’ {Xmax — Xmin ) + Xmin
Böylece kullanıcı ağın ürettiği çıktıların sıfırdan küçük veya birden büyük değerler olması
sağlanacaktır. Bu ölçeklendirmede girdi setindeki her değer 10 ile bölünerek örnekler oluşturulmuştur.
Daha sonra bunların çarpım değerleri ağın beklenen değerleri olmuştur. Ağın ürettiği çıktılar ise 100
ile çarpılarak dış dünyaya gönderilmiştir.
Tablo 3.6. İki'li çarpma setinin ölçeklendirilmesi
47
Ağ eğitildikten sonra ağa 2*3=? sorusu 0.2*0.3=? şeklinde sorulmakta ve ağda buna cevap
olarak 0.0598 değerini üretmektedir. Daha sonra bu değer 100 ile çarpılarak ağın 2 *3 =5.98 değerini
ürettiği söylenmektedir.
Durdurma Kriterleri: ÇKA modelinde ağın eğitilmesi kadar gereğinden fazla eğitilmemesi de
önemlidir. Pratikte, genel olarak iki türlü durdurma kriteri kullanılmaktadır.
• Hatanın belirli bir değerin altına düşmesi halinde eğitimi durdurma: Bu durumda hatanın bütün
eğitim seti için kabul edilebilir bir değerin altına düşmesi kriter olarak alınmaktadır. Öğrenme
performansı %100 olmaz da %98-99 gibi bir düzeyde kalabilir. ÇKA tasarımcısı bunu kendisi
belirler. Bazı örnekler için %5 kabul edilemez bir hata oranı iken (özellikle insan hayatını
ilgilendiren konularda) bazı örnekler için % 15-20 hata dahi kabul edilebilir nitelikte
olabilmektedir.
• Ağın belirli bir iterasyon sayısını tamamlaması sonucu eğitimi durdurma: Hatanın hangi
değerlerin altına düşebileceğinin kestirilemediği (yani kabul edilebilir hatanın belirlenemediği)
durumlarda bu tür bir durdurma kriteri uygulanabilir.
Ara Katman Sayısı ve Proses Elemanlarının Sayısının Belirlenmesi: ÇKA modelinde herhangi bir
problem için kaç tane ara katman ve her ara katmanda kaç tane proses elemanı kullanılması
gerektiğini belirten bir yöntem şu ana kadar bulunmuş değildir. Tasarımcılar kendi tecrübelerine
dayanarak bunları belirler. Bazı durumlarda başlangıçta bir ağ oluşturulup zaman içinde büyütülerek
veya küçültülerek istenen ağa ulaşılır. Aşağıda bu durum açıklanmıştır.
Ağların Büyütülmesi veya Budanması: ÇKA ağlarında problemin çözümü için gerekli en iyi
topolojiyi belirlemek mümkün olmadığından deneme yanılma yöntemi kullanılmakta bazen eksik
sayıda bazen de fazla sayıda proses elemanı kullanılmaktadır. Gereken sayıda proses elemanı
belirlemek için iki yoldan birisi denenmektedir. Bunlar:
• Küçük bir ağdan başlayıp büyük bir ağa doğru eğitim esnasında sürekli proses elaman sayısını
artırmak. Bu durum Şekil 3.21.'de gösterildiği gibi gerçekleştirilir.
• Büyük bir ağdan başlayıp küçük bir ağa doğru eğitim sırasında sürekli ağı küçültmek ve proses
elemanlarını teker teker ağdan çıkartmak. Buna ağın budanması denmektedir.
48
Şekil 3.21. Büyüyen ağlar
İşlemler ağ öğrenmeyi başardığı sürece devam etmekte ve ağın öğrenemediği nokta bulunduğunda ara
katmanda kaç proses elemanı var ise o olay için oluşturulacak ağın topolojisi ona göre belirlenmektedir.
3.9. Eğiticisiz YSA Modeli
Bu bölümde ise öğretmensiz öğrenmeye dayalı ART (Adaptif Rezonans Teori (Art) Ağları)
ağlarına değinilecektir. Bu konuyu iyi anlamak için öncelikle hafıza ve bilgilerin hafızada saklanması
kavramları açıklanacaktır.
a) Hafıza (Bellek) Kavramı
ART ağlarında öğrenme doğru bilgilerin belirlenerek hafızaya alınması anlamına gelmektedir.
Öğrenme sırasında kullanılan örneklerden öğrenilen bilgilere dayanarak daha sonra görülmemiş
örnekler hakkında yorumlar yapılabilmektedir. Bilgilerin hafızada saklanması ve hafızada tutulması
ise iki şekilde olmaktadır:
• Kısa Dönemli Hafıza (KDH): Bilgilerin geçici olarak tutulduğu ve zaman içerisinde yok olduğu
ve yerlerine başka bilgilerin saklandığı hafızadır. Bu insanda da böyledir. Çoğu insan dün akşam
ne yediğini hatırlamayabilir. Çünkü bu bilgiler kısa dönemli hafızada tutulur ve zamanla başka
olayların etkisi ile unutulurlar.
• Uzun Dönemli Hafıza (UDH): Bilgilerin sürekli tutulduğu ve kolay kolay unutulmadığı
hafızadır. Bilginin silinmesi için çok uzun zamanın geçmesi gerekebilmektedir. Örneğin aradan
yıllar geçmesine rağmen çok sevdiğimiz bir arkadaşımızı görürsek onu hemen hatırlarız. Aradan
geçen yıllar onunla ilgili bilgilerin hafızada tutulmasını önleyememektedirler. Hepimiz ilk yaş
günü partimizi, ilk okula gidişimizi, ilk mezun oluşumuzu, evlilik törenimizi vb. bir çok olayı hiç
49
unutamayız. Bilginin uzun dönemli tutulabilmesi için o bilginin bizim için öneminin olması gerekmektedir. Çünkü aradan geçen seneler bazı arkadaşlarımızın unutulmamasına neden olmakta
iken bazılarının ise kısa süre sonra hatırlanamaz hale getirmektedir. Komşusunun ilk doğum günü
partisini hatırlayan kaç kişi vardır. Ancak o partide çok önemli bir olay olmuş ise hiç
unutulmayabilir. Ben etrafımda ölen komşulardan hiç birini hatırlamaz iken bir tanesini hiç
unutamıyorum. Çünkü onun öldüğü gün dışarıdan geldiğimde herkes bizim balkonda ve evin
etrafında toplanmış ve ben bizim aileden birisine bir şey oldu zannetmiştim. Ama babamın teyzesi
öldüğü halde yakın akrabam olmasına rağmen bende o kadar etki yapmamıştır. Bilgilerin hafızada
kalma süresi beyinde oluşturdukları etkiye göre de değişmektedir.
ART ağlarında bilgiler ileride anlatılacağı gibi hem kısa dönemli hem de uzun dönemli hafızada
saklanmaktadır. Yani bazı bilgiler öğrenilirken bazı bilgiler de unutulmaktadır. Zaman içerisinde
öğrenilen bilgiler ağın ilgili olay hakkında karar vermesine neden olmaktadır.
b) ART Ağları
ART ağları Grosberg' in 1976 yılında biyolojik beynin fonksiyonlarına yönelik olarak yaptığı
çalışmalar neticesinde ortaya çıkmıştır. Kendisi çalışmaları neticesinde beynin çalışmasını açıklayacak
bir model önermiştir. Bu modelin 3 temel özelliği vardır. Bunlar:
1. Normalizasyon: Bu, özellikle biyolojik sistemlerin çevredeki büyük değişikliklere karşı adaptif
olduklarının durumu göstermektedir. Örneğin insanın çok fazla gürültülü bir ortamda bir süre
sonra gürültüden rahatsız olmaması sisteme adapte olunduğunu ve çevredeki olayların
normalize edildiğini göstermektedir. Tren yoluna yakın yaşayan insanların gürültü
anlayışlarında tren sesi gürültü sayılmamaktadır. Günde defalarca geçen tren kimseyi rahatsız
etmez iken, başka küçük bir gürültü herkesin dikkatini çekebilmektedir. Bazı insanlar tren
yoluna yakın yaşayanların sese karşı duyarsızlıklarım anlatmakta güçlük çekmektedirler.
Hâlbuki bu insanlarında bazıları minibüs yoluna yakın yerde oturmakta ve korna sesinden
etkilenmemektedirler.
2. Ayrıştırabilme: İnsanın karar verebilmesinde ve olayları yorumlayabilmesinde çevredeki
olaylar arasında var olan fakat görülmesi zor farklılıkları ayrıştırmak çok önemlidir. Bazen
küçük ayrıntılar hayati öneme sahip olabilir. Uyuyan bir aslan ile saldırıya hazır bir aslanın fark
edilmesinin önemi açık olarak ortadadır. Yatan bir aslanın vücudunun hareketlerinin fark
edilmesi çok önemli bir tehlikeyi önleyebilir. Biyolojik sistemlerin böyle ayrıntıları fark
etmeleri çok önemli bir özellikleridir.
3. Ayrıntıların saklandığı kısa dönemli hafıza: Belirlenen farklılıklar ve çevresel olaylar
davranışlara neden olmadan önce hafızada saklanmakta ve daha sonra eyleme dönüşmektedir.
Bu uzun dönemli hafızada değişikliklere neden olmaktadır. Hafızadaki her olay uzun süre etkili
olmamakla beraber, sürekli aynı şeyleri tekrar etmek sonucu olaylar unutulmaz hale
50
gelebilmektedir. Karşılaşılan ani olaylar karar vermede öncelikli olabilmektedir. Fakat uzun
karar vermede uzun dönemli hafızadaki bilgiler daha etkili olmaktadır. Anlık kararlar bazen
olumsuz sonuçlar doğurmaktadır.
Grosberg, bu özelliklerden yola çıkarak arkadaşları ile Adaptif Rezonans Teorisi ağı (ART)
adını verdiği yapay sinir ağları setini oluşturmuştur. ART ağlan daha sonra geliştirilen öğretmensiz
öğrenme ağlarının geliştirilmesine de temel olmuştur. Grosberg' in önerdiği ART ağlarının en temel
özelliği sınıflandırma problemleri için geliştirilmiş olmalarıdır.
Sınıflandırma günümüzde en çok karşılaşılan problemlerin başında gelmektedir. Çevremizdeki
birçok nesneyi de bizler sınıflandırmış durumdayız. Örneğin hayvanları cinslerine göre (köpek, kedi,
at vb.) sınıflandırmışızdır. Kedi cinsinden ise bir çok farklı örnek görmek mümkündür. Kedi
sınıflaması ile kedilere ait genel özellikler dile getirilmektedir. Bu genel özellikler düşünülerek kediler
ile ilgili yorumlar yapılabilmektedir. Örneğin bütün kediler tırmalama özelliğine sahiptir diyoruz.
Benzer şekilde endüstriyel kuruluşlarda makineler üzerinde oluşacak olan hataları sınıflandırmakta ve
her sınıfa giren hatalar için o sınıfa özel çözümler üretilmektedir. Meslekler değerlendirilirken de
sınıflandırılmaktadır. Mühendislik problemlerinin çoğu da sınıflama problemi haline getirilerek
çözülmektedir. Sınıflandırma hayatımızda bu kadar önemli bir yer tuttuğundan sınıflandırma
yapabilen yapay sinir ağları da önemli bir yer tutmaktadır. ART ağları bu amaçla geliştirilmiş ve
başarılı bir şekilde kullanılabilen bir yöntem olarak bilim dünyasında kabul görmüştür. Bir önceki
bölümde anlatılan LVQ ağları da sınıflandırma için kullanılmaktadır. ART ağlarının LVQ ağlarından
farkı ise yapılacak olan sınıflandırma ile ilgili olarak ağa herhangi bir bilginin verilmeyişidir. ART
ağları sınıflandırmayı kendi başlarına yapmaktadırlar.
ART ağlarının bilim dünyasında bu derece önemli olmasının nedenlerinden birisi de, nedeni
yapısal olarak insan beyninin davranışları ve sinir sistemi hakkında bilinen (veya varsayılan) bulgular
üzerine kurulmuş olmalarıdır. Bu ağlar, memeli hayvanların beyinlerinin çalışma prensipleri dikkate
alınarak geliştirilmiştir. Beynin kullandığı sezgisel yaklaşımları matematik bir modele
dönüştürmelerinden dolayı da bu ağlar oldukça yoğun bir ilgi görmüştür.
c) ART Ağlarının Diğer Yapay Sinir Ağlarından Farkları
ART ağlarının diğer yapay sinir ağlarından farklılıklarının iyi anlaşılması da bu ağlardan daha
iyi faydalanabilmek için önemlidir. Bilinen diğer ağlardan özellikle en yaygın olarak kullanılan çok
katmanlı algılayıcılardan temel farklılıkların bazılarını, Grosberg şu şekilde özetlemektedir:
• ART ağları gerçek zamanlı olarak oldukça hızlı ve kararlı bir şekilde öğrenme yeteneklerine
sahiptirler. Bu yetenek birçok ağda yoktur. ART ağları bu özellikleri ile gerçek zamanlı
kullanılabilen donanımla da desteklenerek gerçek zamanlı öğrenebilen bilgisayarların
oluşmasına yardımcı olmaktadırlar.
51
• Gerçek zamanda ortam genel olarak durağan değildir. Olayların oluşumu her an beklenmedik
olaylar ile değişebilmektedir. Bununda ötesinde gerçek zamanlı olaylar sürekli devam
etmektedir. ART ağları bu durağan olmayan dünyada sınırsız karmaşıklık altında çalışabilme
yeteneğine sahiptirler. Diğer ağların çoğu ise durağan olarak çevrimdışı (off-line) öğrenip
çalışırlar. Esneklikleri yoktur. Ortama anında uyum sağlamaları çok sınırlıdır.
• ART ağları beklenen çıktıları bir öğretmenden almak yerine kendi kendine öğrenmeye çalışır.
• ART ağları ağa sunulan farklı nitelikteki ve değişik durumlardaki örnekler karşısında kendi
kendilerine kararlı (stabil) bir yapı oluşturabilirler. Ağa sunulan, yeni bir girdi geldiği zaman ya
bilinen sınıfların kodlarına (sınıflarına) ulaşabilecek şekilde ağda iyileşmeler yapılır ya da yeni
kod (sınıf) oluşturulur. Bu ağın büyümesine de neden olabilir ve ağın bütün kapasitesini
kullanana kadar devam eder.
• ART ağları çevredeki olayları sürekli öğrenmeye devam eder. Uzun dönemli hafızada bulunan
ağırlıklar sürekli olarak gelen girdi değerlerine göre değişmeye devam ederler.
• ART ağları girdi değerlerini otomatik olarak normalize ederler. Çok fazla ve oldukça düşük
orandaki gürültülerin girdi işaretindeki etkileri ortadan kaldırılmış olur.
• ART ağlarında hem aşağıdan yukarı hem de yukarıdan aşağıya ağırlık değerleri vardır. Özellikle
yukarıdan aşağıya ağırlıklar sınıfları temsil etmektedirler. Bunları ağ kendisi girdilere bağlı
olarak otomatik olarak belirlemektedir. Bu ağırlıklar aynı sınıftan olan bütün örneklerin ortak
yönlerini içermektedir. Bu ağırlıklardan oluşan örüntülere kritik özellik örüntüleri denmektedir.
Yukarıdan aşağıya ağırlıklar ağın öğrendiği beklentileri (beklenen girdi temsilcileri)
göstermektedir. Bu değerler aşağıdan yukarı gelen bilgiler ile karşılaştırılarak eşleme yapılır.
Aşağıdan yukarı gelen bilgiler ile karşılaştırma kısa zamanlı hafızada (KDH) oluşmaktadır.
Aşağıdan yukarı ve yukarıdan aşağı ilişkiler bir ART ağında kapalı çevrimi tamamlamaktadır.
• Bu kapalı çevrimden dolayı Yukarıdan aşağı ağırlıklar KDH' da yapılan karşılaştırma ile Kazanç
faktörünü kullanarak aynı kategoride olmayan girdilerin o kategoriye girmesini önlemektedir.
Böylece kategoriyi gösteren ağırlıkların gerçek zamanlı gelen farklı bir girdiden etkilenmeleri
önlenmektedir. Böyle bir kontrol yapılmaması gelen her girdi değerinin ağırlıkları değiştirerek
önceden öğrenilen bilgilerin kayıp olmasına neden olacaktır. ART bu özelliği ile sürekli
öğrenmeyi desteklemekte ve önceden öğrenilenler ancak aynı gruptaki başka örneklerin yeni
özellikleri olunca değiştirilmektedir. Bu özellik ise yakın eşleme (approximate match) olarak
bilinmektedir.
• ART ağlarının yakın eşleme özelliğinden dolayı hem hızlı hem de yavaş öğrenebilme
yetenekleri vardır. Hızlı öğrenme Uzun Dönemli Hafızada (UDH) bir denemede yeni bir
dengenin (equilibrium) oluşturulması ile gerçekleştirilir. Yavaş öğrenme ile bir dengenin
oluşması için birden çok denemenin yapılması durumu kastedilmektedir. Hâlbuki çok katmanlı
algılayıcılar gibi ağlarda osilasyonları önlemek için özellikle yavaş öğrenme zorunluluğu vardır.
52
1976 yılından bugüne kadar değişik ART ağları tanımlanmıştır. Bunlar arasında ART1, ART2,
ART3 , ARTMAP, Fuzzy ART gibi ağları saymak mümkündür. Bu ağların hepsi aslında aynı temel
felsefeye dayanmakta ve çok az farklılıklar göstermektedir. En yaygın olarak kullanılan ART1 ve
ART2 ağlarıdır. O nedenle bu bölümde bu iki ağ ayrıntılı olarak tanıtılacaktır. Diğerleri ile ilgili
bilgiler ise verilen kaynaklarda bulunabilir. Öncelikle ART ağların genel yapısı ve çalışma ilkesi
anlatılacaktır; daha sonra bu modeller tanıtılacaktır.
d) ART Ağlarının Yapısı
Adaptif Rezonans Teorisi (ART) ağları genel olarak iki katmandan oluşmaktadır. Bu katmanlar
Fİ ve F2 olarak isimlendirilmiştir. Fİ katmanı girdinin özelliklerini gösterirken F2 katmanı kategorileri
(ayrıştırılmış sınıfları) göstermektedir. Bu iki katman birbirlerine UDH ile bağlanmaktadırlar. Girdi
bilgileri Fİ katmanından alınır ve sınıflandırma ise F2 katmanında yapılır. Modelin genel yapısı Şekil
3.22. 'de verilmektedir.
Şekil 3.22. ART ağının genel yapısı
ART ağlarında girdiler direkt olarak sınıflandırılmazlar. Öncelikle girdilerin özellikleri
incelenerek Fİ katmanının aktivasyonu belirlenir. UDH'da ki bağlantı değerleri ile gelen bilgiler
kategorilere ayrılarak F2 katmanına gönderilir. F2 katmanındaki sınıflandırma ile F1 katmanından
gelen sınıflandırma birbirleri ile eşleştirilerek, eğer örnek belirlenmiş bir sınıfa uyuyorsa o kategoride
gösterilir. Aksi takdirde, ya yeni bir sınıf oluşturulur veya girdinin sınıflandırılması yapılmaz.
e) ART Ağlarının Çalışma Prensibi
Daha önce belirtildiği gibi ART ağları Fİ katmanından gelen bilgileri F2 katmanındaki
kategorilere eşleştirmektedir. Bu eşleşme sağlanamaz ise yeni bir kategori oluşturulmaktadır. ART
ağlarının çalışması iki yönlü olmaktadır:
53
• Aşağıdan yukarı (F1 den F2'ye) bilgi işleme
• Yukarıdan aşağı (F2 den F1 'e) bilgi işleme
ART ağlarında aşağıdan yukarı bilgi işleme prensibi Şekil 3.23.'de gösterilmiştir. Şekilden de
görüldüğü gibi, bir girdi örüntüsü (I) ağa gösterilir. Bu örüntü hem Fİ katmanında KDH da X aktivite
örüntüsünü oluşturur hem de oryantasyon sistemini veya diğer bir deyişle yeniden yerleştirme
modülünü (YYM) aktif etmek üzere bir işaret (signal) gönderir. Benzer şekilde oluşturulan X
örüntüsü hem YYM' ne bir men-edici (inhibitory) işaret (O) göndermekte hem de F1 katmanından bir
çıktı örüntüsü (S) oluşturmaktadır. S sinyali F2 katmanına giden bir girdi örüntüsüne (T) dönüştürülür.
Bu girdi örüntüsü ise F2 katmanının çıktısı olan örüntüyü (Y) oluşturur. Bu aynı zamanda ağında
çıktısıdır. Bu şekilde aşağıdan yukarı (F1 katmanından F2 katmanına) bilgi işleme tamamlanmış olur.
Şekil 3.23. ART ağında çıktı oluşturma süreci (aşağıdan yukarı)
Yukarıdan aşağı bilgi işleme de, benzer şekilde, Şekil 3.24'te gösterildiği gibi yapılmaktadır. Bu
durumda, F2 katmanında oluşturulan çıktı örüntüsü yukarıdan aşağıya bir sinyal (U) gönderir. Bu
sinyal daha sonra beklenen şablon örüntüye (V) dönüştürülür. Aynı zamanda kontrol faktörü (kazanç)
için men-edici (inhibitory) bir işaret üretir. Bundan sonra şablon örüntünün girdi örüntüsü ile eşlenip
eşlenemeyeceği sınanır. Eğer böyle bir eşleşme mümkün değilse o zaman F1 katmanında yeni bir
KDH örüntüsü (X*) oluşturulur. Bu örüntü oryantasyon sistemindeki men-edici işaretin etkisini
azaltır.
54
Şekil 3.24. ART ağında çıktı oluşturma süreci (yukarıdan aşağı)
Oluşturulan X* sinyali oryantasyon sisteminde O işaretinin men-edici etkisini azaltarak YYM'
nün (oryantasyon modülünün) F2 katmanına bir sinyal göndermesini sağlar. Bu işaret F2 katmanında
Y* örüntüsünü oluşturur. Böylece, Şekil 3.25'te gösterildiği gibi girilen I örüntüsü için doğru sınıfı
gösteren Y* çıktısı üretilmektedir.
Şekil 3.25. ART ağında yeni bir sınıf oluşturma
Eğer üretilen V şablon örüntüsü ile girdi örüntüsü eşleşir işe o zaman sadece yukarıdan aşağı o
girdinin sınıfını gösteren ağırlıklar değiştirilir. Bu değiştirme öğrenme kuralına göre gerçekleştirilir.
Her ART modelinin öğrenme kuralı ayrıdır. Aşağıda ART1 ve ART2 ağlarının öğrenme kuralları
tanıtılmıştır.
f) ART1 Ağı
ART1 ağı sadece ikili (binary) girdiler ile çalışan ve en basit ART ağının örneğidir. Geliştirilen
ilk ART ağıda denilebilir. Yukarıda belirtildiği gibi iki katmandan oluşmaktadır. F1 katmanını
karşılaştırma katmam, F2 katmanı ise tanıma katmanı olarak isimlendirilmiştir. F1 katmanındaki
bütün proses elemanları F2 katmanındaki proses elemanlarının tamamına bağlanmıştır. Bu bağlantılar
sürekli değerlerden oluşan UDH bağlantılarıdır (burada Ai
ile gösterilmiştir). Bu bağlantıların
özellikleri ileri doğru bağlantılar olmalıdır. Aynı zamanda F2 katmanından Fİ katmanına geriye doğru
ikili değerleri olan bağlantılar vardır (burada Ag
ile gösterilmiştir). Modelin K1 ve K2 olarak
55
isimlendirilen iki tane kazanç modülü ve bir tanede yeniden yerleştirme modülü (YYM) vardır. Bu
modüle bazı kaynaklarda oryantasyon modülü de denmektedir. ART1 ağının geometrik gösterimi
Şekil 3.26.'da verilmiştir:
Şekil 3.26. ART1 modelinin geometrik gösterimi
Karşılaştırma katmanındaki her proses elemanının 3 girdisi vardır. Bunlar:
• Girdi örneğinin bir elemanı (aşağıdan yukarı)
• Geri besleme değeri (yukarıdan aşağıya)
• Kazanç değeri (K1 den gelen değer)
F1 katmanındaki proses elemanı bu üç girdiden en az ikisinin aktif olması durumunda çıktı
olarak 1 değerini oluşturur. Buna 2/3 kuralı denilmektedir.
F2 katmanındaki proses elemanları ise kendilerine gelen net girdiyi hesaplarlar. Proses
elemanları birbirleri ile yarışmaktadırlar. Genellikle en fazla çıktıyı üreten proses elemanı yarışmayı
kazanmaktadır.
K2 girdi örneğindeki bütün elemanlar arasında mantıksal VEYA (OR) operatörüdür. Sadece
yeni bir sınıfın oluşmasında kullanılır.
K1 modülü girdi örüntüsünün değerlerini hafızada bulunan şablon değerler ile eşleştirmede
kullanılmaktadır. Gelen bilgilerin aşağıdan yukarı veya yukarıdan aşağıya olup olmadığının
bilinmesini sağlar. Aşağıdan gelen değerler bu kazanç değerini aktif yukarıdan gelenler ise pasif
yaparlar.
YYM ise girdi vektörü ile F1 katmanı çıktısı (çıktı vektörü) arasındaki fark belirli bir değeri
aşması durumunda F2 katmanına bir sinyal göndermekle yükümlüdür. İki vektörün arasındaki fark
benzerlik katsayısı denilen bir değer ile karşılaştırılır. Bu katsayı girdi vektörünün hafızada bulunan
çıktı vektörlerine uygunluğunu belirler. Aradaki fark benzerlik katsayısından küçük ise o zaman
56
benzerlik yok demektir. Bu durumda girdi vektörü için yeni bir sınıf oluşturmak ve hafızaya koymak
gerekir. ART1 ağının öğrenmesi bu mantık ile çalışmaktadır. Benzerlik katsayısı aşağıda açıklanmış
olup kullanıcı tarafından belirlenmektedir.
ART 1 Ağının Eğitilmesi ve Öğrenmesi: ART konusunda yukarıdaki açıklamaları dikkate alarak
öğrenme olayı basitleştirilmiş ve aşağıda adım adım açıklanan öğrenme kuralı geliştirilmiştir.
Adım 1: Ağırlıklara başlangıç değerleri atanır;
F1 katmanından ağa sunulan N adet örnek, F2 katmanında ise M adet çıktı proses elemanı
olduğu varsayılsın. Burada M≥N olması önemlidir. Çünkü N adet örneğin hepsinin birbirinden farklı
olması durumunda ağın her biri için bir sınıf ayıracak durumda olması gerekir. Bazı uygulamalarda
sınıf sayısı belirli bir sayı ile sınırlandırılmaktadır. Bu durumda ağın görevi girdi setini belirlenen
sayıda sınıfa ayırmaktır. Bunu sağlamak için aşağıda anlatılacak olan benzerlik katsayısının önemi
artmaktadır. Daha önce belirtildiği gibi bu katsayı girdilerin hangi sınıfın üyesi olduğunu belirlemede
kullanılmaktadır. ART ağlarının başlangıç değerlerinin atanmasında da iki durum söz konusudur.
Bunlar:
a) F2 ve F1 arasındaki geriye doğru ağırlıkların bütün değerleri başlangıçta 1 değerini alır. Yani:
burada M çıktı elemanı, n ise girdi elemanı sayısını (girdi vektörünün boyutunu) göstermektedir.
b) F1 ve F2 arasındaki ileri doğru ağırlıkların başlangıç değerleri, F1 katmanındaki proses elemanı
sayısı n olmak üzere ise şu şekilde atanmaktadır.
Adım 2: Benzerlik katsayısının (p) değeri belirlenir;
Benzerlik katsayısı p ile gösterilmekte olup 0 ile 1 arasında bir sayıdır. Bu katsayı iki vektörün
aynı sınıfın elemanı sayılabilmesi için birbirlerine ne kadar benzemesi gerektiğini belirler. Örneğin, bu
değerin 0.8 olması benzerliğin %80 olması aynı sınıfın elemanı olmak için yeterli görülüyor demektir.
Yani %100 benzerlik yerine %80 benzerlik kabul edilmektedir. %20'lik bir farklılığa izin
verilmektedir. Bunun altında bir benzerlik aynı grubun elemanı olmak için yeterli görülmemektedir.
Benzerlik katsayısı ne kadar büyük alınırsa farklı sınıf sayısı da o kadar çoğalır. Bu sayı düşük
alınırsa o zaman sınıf sayısı da az olur. Çünkü benzerlik için vektörler arasındaki farklılığa daha çok
izin verilmektedir. Böylece daha çok örnek aynı sınıfın üyesi olabilmektedir. Yalnız burada bir
noktaya dikkatleri çekmekte yarar vardır. Sınıf sayısının az olması durumunda ağın öğrenme
57
performansı düşük olabilir. Sınıf sayısının az veya çok olmasından çok öğrenilmesi istenilen olayı
doğru temsil edebilen sınıf sayısını oluşturacak şekilde benzetim katsayısını belirlemektir.
Adım 3: Girdi setinden bir örnek ağa gösterilir;
Girdi setindeki örnek X (x1,x2,.......xn) vektörü olarak (her bir elemanı xi olarak tanımlanmış
şekilde) ağa gösterilir.
Adım 4: F2 katmanındaki proses elemanlarının çıktılarının hesaplanması;
F2 katmanındaki her proses elemanının çıktı değeri şu şekilde hesaplanmaktadır:
Adım 5: Kazanan elemanın seçilmesi;
Kazanan eleman en büyük (maksimum) çıktıya sahip proses elemanıdır. Bu elemanın sahip
olduğu ağırlık vektörüne en uygun sınıf (kategori) gösterim vektörü denmektedir. Bunun k. proses
elemanı olduğu varsayılırsa kazanan elemanın çıktısı,
yk* =max (yj ‘)
olacaktır. Burada * işareti kazanan elemanı temsil etmektedir. Bu elemanın ağırlık vektörü girdi
vektörü ile karşılaştırılarak benzetim katsayısına göre uygunluk sınaması yapılacaktır.
Adım 6: Uygunluk testinin yapılması;
Burada kazanan elemanın ağırlık vektörünün ile girdi vektörünü temsil edip edemeyeceğine
karar verilmektedir. Bunun için önce girdi vektöründe bulunan 1 sayısı (s1) belirlenir.
Daha sonra kategori gösterimi vektörü (kazanan elemanın ağırlık vektörü) ile girdi vektörünün
uyuştuğu 1 sayısı (s2) bulunur. Bunu veren formül ise şöyledir:
Eğer, S2/S1 ≥ p ise o zaman iki vektör birbirinin benzeri kabul edilir. Yani kategori gösterim
vektörü girdi vektörünü temsil edebiliyor demektir. Bu durumda ağırlıklar şu şekilde değiştirilir.
58
Eğer; S2/S1 < p ise o zaman maksimum çıktıyı veren proses elemanının çıktısı 0 olarak atanır
ve ondan sonraki maksimum çıktıyı veren (ikinci en büyük çıktıyı üreten) proses elemanı seçilerek
4üneü adımdan itibaren işlemler tekrar edilir. Girdi vektörü bu sınıfın elemanı olarak atanamaz ise
üçüncü en büyük çıktıyı veren proses elemanının sınıf (kategori) gösterim vektörü ile benzerliğine
bakılarak benzerlik olması durumunda ağırlıklar değiştirilir. Başlangıçta birinci örnek birinci sınıfın
temsilcisi olarak atanır. İkinci örnek birinci ile aynı sınıfından ise (benzer ise) birinci sınıfın elemanı
sayılır. Yoksa bu örnek ikinci sınıfın temsilcisi olur. Böylece örneklerin hepsi ya var olan sınıflardan
birisine girer ve ağırlık değerleri değiştirilir. Ya da yeni bir sınıfın temsilcisi olur. En kötü olasılık ile
N örnek için N adet sınıf oluşturulabilir (N=M). Bu şekilde yukarıdaki işlemler bütün girdi vektörleri
sınıflandırılıncaya kadar devam eder.
g) ART Ağlarında Etiketlendirme
ART ağları öğretmensiz öğrenme gerçekleştirdiklerinden eğitim setindeki örnekler ağ tarafından
otomatik olarak sınıflandırılmaktadır. Eğitilen ağa daha sonra görmediği örnekler sorulunca, ağ
kendisi bu örneğin kendisinin belirlediği sınıflardan hangisine gireceğine karar verir. Örneklerin
sınıflarının bulunmasına rağmen hangi sınıfın neyi temsil ettiği bilinmemektedir. Grupların neyi
temsil ettikleri öğrenme bittikten sonra tasarımcı tarafından belirlenir. Buna sınıfın etiketlenmesi
denir. Bu konuyu bir örnek ile açıklamak gerekirse, hata teşhisi yapmak üzere eğitilmiş olan bir ağ
için 4 çıktı grubunun (hata sınıfının) olduğu varsayılsın. Oluşturulan ağın 4 tane çıktı ünitesi olacaktır.
Bu ağ örnekler üzerinde eğitildikten ve 4 tür hatayı teşhis edecek duruma geldikten sonra ağ kullanıma
alındığında kendisine gösterilen bir örneğin (hata türünün) sadece 4 sınıftan hangisine ait olduğunu
söyleyecektir. Bu sınıfın hangi tür hata olduğu ise bilinmemektedir. Sadece bu sınıfa ait örneklerin
hepsinin temsil ettiği hata türü aynıdır. Sınıfların hangi hata türünü gösterdiklerini belirlemek için
tasarımcı incelemeler yaparak sınıfların etiketlerini belirler. Böylece ağ görmediği örnekler gelince
önce grubunu belirler ve o grubun etiketine göre dış dünyaya örnek hakkında bilgiler verebilir.
Hatanın türü belirlendikten sonra o hatayı önleyici tedbirler kullanıcıya sunulabilir. Şekil 3.27. bu
durumu göstermektedir.
Şekil 3.27. Art ağında etiketlendirme
59
Etiketlendirme ağın eğitilmesi kadar önemlidir. Ağı eğitmenin amacı belirli sorunları çözmektir.
Sorunu tespit etmek kadar sorunu çözmekte önemlidir. Ağın eğitilmesinde bir öğretmen
kullanılmamaktadır. Çıktıların sınıfları temsil ettiği bilinmektedir. Etiketlendirme ile hangi sınıfın ne
anlama geldiğinin belirlenmektedir. Bu ise sorunların tespit edilmesi ve gerekli çözüm önerilerinin
oluşturulması demektir. Etiketlendirme o nedenle çok önemlidir. Bazı araştırmacılar bunu öğrenmeye
müdahale olarak görse de bu ağın öğretmenli öğrenme yaptığı anlamına gelmez.
ÖRNEK: ART1 - Bir Grup Teknolojisine Dayalı İmalât Uygulaması
Daha önce anlatılan ağlarda olduğu gibi ART ağları da endüstriyel problemlere çözümler
üretebilmektedir. Aşağıda Grup teknolojisinde gerçekleştirilen bir uygulama anlatılacaktır.
• Problemin Tanımlanması: Grup teknolojisi imalat sistemlerinin en yaygın biçimde kullanılan
yaklaşımlarından birisidir. Bu yaklaşımın verimliliği artırdığı, üretim maliyetlerini düşürdüğü,
özellikle kütle üretimini çok rahat desteklediği bilinmektedir. Grup teknolojisinin temel felsefesi
birbirine benzer aynı makineleri kullanılarak üretilen parçaları ve prosesleri belirleyerek bunları
üretecek makineleri bir arada toplamaktır. Bu amaçla çeşitli gruplama algoritmaları
geliştirilmiştir. Bu algoritmaların farklılıkları performanslarının farklı olmasından
kaynaklanmaktadır. Üretilecek parça ve kullanılan makine sayısı arttıkça üretilen çözümlerin
performansı düşmektedir. Bu algoritmalara alternatif olarak yapay sinir ağlarından yararlanan bir
çalışma yapılmış ve ART algoritması kullanılarak makinelerin sınıflandırılması
gerçekleştirilmiştir. Yapay sinir ağlarının bilinen geleneksel algoritmalar ile üretilen sonuçlardan
daha yüksek performansta sonuçlar ürettikleri görülmüştür.
Grup teknolojisinde genel olarak, seri üretim yapan bir fabrikalarda benzer ürünleri üreten
makineleri bir araya getirmek istenmektedir. Oluşturulan makine gruplarına makine hücreleri
denilmektedir. Her makine hücresi için atölyede bulunan işler ve bu işleri işleyecek makinelerin
sınıflandırılmasının yapılması düşünülmektedir. Bu sınıflamanın maliyetleri en azlayacak şekilde
yapılması gerekmektedir. Bazı makineler bütün parçaları işleyebilmekte bazıları ise sadece belirli
parçaları işleyebilmektedir. Makineler arasında ara stokların azalması ve parçaların atölye içinde
en az yol kat ederek üretim hattından çıkması oluşturulacak olan makine hücrelerinin doğru
oluşturulmasına bağlıdır.
Aşağıda ART1 ağlarının grup teknolojisinde kullanılmasına yönelik geliştirilmiş bir model
açıklanacaktır. Geliştirilen ART1 ağından makine/parça arasındaki ilişkileri gösteren örnekleri
alarak, dış dünyadan herhangi bir yardım almadan makine/parça sınıflandırmasını otomatik olarak
yapması istenmektedir. Problemin nasıl çözüldüğünün daha iyi anlaşılması için burada 3 makine
ve 3 parçadan oluşan küçük bir problem için tasarlanmış ART1 ağı açıklanmıştır. Mamafih,
istenilen sayıda makine ve parça için ART1 ağının uygulanması mümkündür. Modelin
uygulanmasında parça ve makine sayısında herhangi bir sınırlama yoktur. Kullanılan öğrenme
60
kuralında da bir değişiklik gerekmektedir. Özellikle çok sayıda makine ve parçanın söz konusu
olması durumunda yapay sinir ağlarının, özellikle ART ağının, avantajlarını daha açık olarak
görmek mümkündür.
• Problemin Modelinin Oluşturulması: Gösterim amaçlı düşünülen ve 3 makine ve 3 parçadan
oluşan problemde makine/ parça ilişkilerini gösteren matris şu şekilde verilmiştir.
Bu matristen anlaşıldığına göre birinci parça hem birinci hem de ikinci makinede işlenebilmektedir. İkinci parça ise sadece ikinci makinede işlenebilmektedir. Üçüncü parça is& hem
birinci hem de üçüncü makinede işlenebilmektedir. Problemde makinelerin aynı sınıfın üyesi olup
olmadıklarını belirlemeye yarayan benzerlik katsayısı p=0.8 olarak alınmıştır. Yani %80 civarında
bir benzerlik aynı grubun elemanı olmak için yeterli görülmektedir. Oluşturulan ART1 ağı Şekil
3.27' de gösterilmiştir. Şekildeki F1 ve F2 katmanları arasındaki koyu renkli bağlantılar aşağıdan
yukarıya açık renkli bağlantılar ise yukarıdan aşağı ağırlıkları göstermektedir.
Şekil 3.27. Oluşturulan ART 1 ağının gösterimi
• Oluşturulan Ağın Eğitilmesi: Oluşturulan makine/parça matrisinin her satırı bir örnek
olarak ağa gösterilecektir. Birincisi ağa gösterildiği zaman, daha önce herhangi bir
sınıflandırma yapılmadığından ağ otomatik olarak birinci sınıfı oluşturacak ve birinci
makineyi birinci sınıfın üyesi olarak belirleyecektir. İkinci örnek geldiği zaman bunu
birinci örnek ile karşılaştıracak ve eğer birbirlerine benzer bulursa (hesaplanacak
61
benzerlik katsayısı 0.8 üzerinde ise) ikinci makineyi de birinci sınıfa koyacaktır. Eğer
benzer bulmaz ise ikinci makineyi ikinci sınıfın temsilcisi olarak belirleyecektir. Bütün
makineler sınıflandırılıncaya kadar bu çalışma devam eder. Bu süreç aşağıda
gösterilmiştir. Eğitim süresince geliştirilen her iterasyonda yapılacak olan işlemler
açıklanmıştır.
1. İterasyon: Ağın eğitilmesine başlanan birinci iterasyonda aşağıdaki hesaplamalar yapılır.
1. Adım: Ağırlıklara başlangıç değerleri atanması;
F1 katmanındaki proses elemanı sayısı N=3
F2 katmanındaki proses elemanı sayısı M=3
Benzerlik katsayısı p=0.8
F2 ve F1 katmanları arasındaki geriye doğru ağırlıkların bütün değerleri başlangıçta 1
değerini alır. Yani,
Ag
matris şeklinde yazılırsa,
bu matrisin her satırı bir kategori gösterim vektörü olarak düşünülebilir.
F1 ve F2 katmanları arasındaki ileri doğru ağırlıkların başlangıç değerleri ise, F1 katmanındaki proses
elemanı sayısı N olmak üzere ise şu şekilde atanmaktadır.
2. Adım: Girdi setinden bir örnek ağa gösterilmesi; Girdi setindeki örnek X= (1,0,1) ağa gösterilir.
3. Adım: F2 katmanındaki proses elemanlarının çıktılarının hesaplanması;
F2 katmanındaki her proses elemanının çıktı değerleri sırası ile şu şekilde hesaplanmaktadır.
62
4. Adım: Kazanan elemanın seçilmesi;
F2 katmanındaki proses elemanlarının çıktı (y) değerlerinin hepsi eşit ve 0.5 olduğundan F2
katmanındaki elemanlardan bir tanesi rasgele yarışmayı kazanmış sayılır. Bu örnekte 1. proses
elemanı kazanan eleman olarak seçilmiştir. Yani,
yk* =max(yj)=>y1* =0.5
5. Adım: Uygunluk testinin yapılması;
Burada kazanan elemanın ağırlık vektörü ile girdi vektörünün birbirlerine benzerliği kontrol
edilmektedir. Bunun için önce girdi vektöründe bulunan 1 sayısı (s1) belirlenir.
Bundan sonra kategori gösterimi vektörü ile girdi vektörünün uyuştuğu 1 sayısı (s2) bulunur.
Bunu veren formül ise şöyledir:
olduğundan,
olduğundan bu örneğin birinci kategori gösterim vektörünün gösterdiği 1.sınıfın bir üyesi olur. Hem
ileriye doğru hem de geriye doğru ağırlıklar aşağıdaki gibi değiştirilir.
Benzer şekilde,
63
Böylece birinci iterasyon tamamlanmış ve birinci makine birinci grubun elemanı olarak
atanmıştır. Çünkü benzerlik katsayısından büyük bir benzerlik ortaya çıkmıştır.
2. İterasyon: İkinci iterasyonda işlemlere 2. adımdan başlayarak devam edilir.
2. Adım: Girdi setinden bir örnek ağa gösterilmesi; Girdi setindeki örnek X= (1,1,0) ağa gösterilir.
3. Adım: F2 katmanındaki proses elemanlarının çıktılarının hesaplanması;
F2 katmanındaki her proses elemanının çıktı değeri birinci iterasyondakine benzer şekilde
hesaplanmaktadır.
4. Adım: Kazanan elemanın seçilmesi;
İkinci ve üçüncü proses elemanlarının çıktı değeri en yüksek olup birbirine eşit olduklarından bunların
arasından 2. proses elemanı (rasgele) kazanan olarak alınmıştır. Yani,
5. Adım: Uygunluk testinin yapılması;
Girdi vektöründeki 1 sayısı 2 (s1=2) tanedir. Sınıf (kategori) gösterim vektöründe girdi ile uyuşan 1
sayısı da yine 2'dir (s2=2). A2
g
= [l 1 l ] olduğundan benzerlik katsayısı ile mukayese yapılırsa;
sonucu elde edilir. Bu durumda ilgili ağırlıkların değiştirilmesini gerektirir. Yeni ağırlıklar şöyle
belirlenir.
64
Benzer şekilde;
Böylece ikinci iterasyon tamamlanmış ve ikinci makine ikinci proses elemanının temsil ettiği sınıf ile
benzerlik gösterdiğinden 2. sınıfın elemanı olarak seçilmiştir.
3. İterasyon: 3. iterasyonda işlemlere yine 2. adımdan başlanarak adımların hepsi yerine getirilir.
2. Adım: Girdi setinden bir örnek ağa gösterilir; Girdi setindeki üçüncü örnek X= (0,0,1) ağa sunulur.
3. Adım: F2 katmanındaki proses elemanlarının çıktılarının hesaplanması;
F2 katmanındaki her proses elemanının çıktısının değeri benzer şekilde hesaplanmaktadır.
4. Adım: Kazanan elemanın seçilmesi;
Birinci proses elemanın çıktı değeri en yüksek olduğundan bu proses elemanı kazanan olarak alınır.
Yani;

5. Adım: Uygunluk testinin yapılması;
Önceki örneklerde gösterildiği gibi s1 ve s2 değerleri hesaplanarak benzetim katsayısı ile
karşılaştırılır.
65
olduğundan bu makinede yine 1. sınıfın bir makinesi olarak sınıflandırılır. Birinci iterasyonda
Al
9
= [l 0 l] olmuştu. Bu vektörün ağırlık değerleri yeniden değiştirilir.
Benzer şekilde,
olacaktır. Bundan sonra birinci örnek ağa tekrar gösterildiğinde birinci sınıfın bir üyesi olarak
sınıflandırıldığı görülür. Böylece bütün parça/makine sınıfları belirlenmiş olur.
Sınıflandırılacak başka makine kalmadığından iterasyon tamamlanmış olur. Ağırlıkları tekrar
değiştirmenin bir anlamı olmayacaktır.
Sonuç olarak 1. ve 3. makineler birinci sınıfın elemanları olup aynı yere konulacak 2. makine
ise ayrı bir sınıf olarak farklı bir yere konulacaktır. Böylece iş akışı düzenli olarak yürütülecek ve ara
stoklar sorun oluşturmayacaktır.
Makine Öğrenmesi Dersi
Son
Vtys-Veri Tabanı Yönetim Sistemleri Dersi
Giriş
Bütünlük Kısıtlamaları ve İlişkisel
Tasarım
1.Bütünlük Kısıtlamaları
Veri tabanının "tutarlı bir bütün"
oluşturması; yanlış, eksik, birbiriyle çelişen,
tutarsız veri içermemesi istenir. Bunu
sağlamak için tanımlanan her türlü
kısıtlamaya bütünlük kısıtlaması adı verilir.
Veri tabanı üzerinde yapılan her türlü ekleme,
günleme ve silme işleminin bütünlük
kısıtlamalarına uyması ve yapılan işlemin veri
tabanı bütünlüğü ve tutarlılığını bozmaması
gerekir.
Her veri tabanı ile ilgili çok sayıda bütünlük
kısıtlaması vardır. Bu kısıtlamaların bir kesimi
veri tabanının yapısında yer alır. Kısıtlamaların
bir kesimi kural olarak tanımlanır ve
denetimleri işletim aşamasında yapılır.
Kısıtlamaların bir kesimi ise ne veri tabanı
yapısında, ne de tanımlanan kurallar arasında
yer alır.
Veri tabanı tanımlarında yer almayan ve
Veri Tabanı Yönetim Sistemi tarafından
bilinmeyen bu tür kısıtlamaların bir kesimi
uygulama programları içinde yer alır; bir
kesiminin ise kullanıcılar tarafından bilindiği
varsayılır ve kullanıcıların bu kurallara uyması
beklenir. Uygulama programlarında yer alan
ya da kullanıcıların uyması gereken bütünlük
kısıtlamalarına uyumun yüzde yüz olması
beklenemez.
Çünkü belli bir uygulama ile ilgili bir
kısıtlama bir uygulama programı içinde yer
alırken bir başka program içinde yer
almayabilir; bir kullanıcı bu kısıtlamaya
uyarken bir başkası uymayabilir. Bu nedenle
bütünlük kısıtlamalarının olabildiğince
çoğunun veri tabanı tanımında yer alması ve
Veri Tabanı Yönetim Sistemi tarafından
uygulanmasında yarar vardır.
Ancak veri tabanı ile ilgili değişik türde çok
sayıda bütünlük kısıtlaması olduğu için
bunların tümünün veri tabanı tanımında yer
alması da mümkün değildir.Veri tabanı
bütünlüğünün sağlanması hem tasarımı hem
de uygulamaları ilgilendiren bir konudur. İyi
tasarlanmış bir veri tabanının bütünlük ve
tutarlılığının sağlanması kolayken, kötü
tasarlanmış bir veri tabanının bütünlük ve
tutarlılığının sağlanması çok zordur.
Başka bir deyişle bütünlük ve tutarlılığının
sağlanması için veri tabanının iyi tasarlanmış
olması gereklidir, ancak yeterli değildir.
Bütünlük kısıtlamalarının çok çeşitli
olabileceği açıktır. Biz bunlardan yalnız
dördü(alan kısıtlamaları, referans
kısıtlamaları, kurallar ve nitelikler arası
bağımlılıklar) üzerinde duracağız.
2. Alan Kısıtlamaları
Veri tabanındaki her niteliğin bir değer
alanının bulunacağı ve niteliğin alabileceği
olurlu değerlerin bu alandaki değerler olduğu
bilinmektedir. Alan kısıtlamaları her niteliğe bir
alan eşlenmesi ve niteliğin alabileceği
değerlerin bu alandaki değerlerle sınırlanması
ile ilgilidir.
Ancak Veri Tabanı Yönetim Sistemleri
genellikle kullanıcıların alan tanımlamasına
izin vermezler. Bu nedenle alan kısıtlaması tür
tanımı ve değerlerle ilgili kimi kısıtlamalarla
gerçekleştirilir. Bu kapsamca sayabileceğimiz
kısıtlamalardan birkaçı aşağıda yer almaktadır.
 Alan türleri: Tamsayı, kesirli sayı, karakter,
değişken uzunluklu karakter, tarih, parasal
değer, …vb.
 Değer sınırları: Alt sınır değeri, üst sınır
değeri, … vb.
 Boş (null) değer: Nitelik değerinin eksik
olup olamayacağı.
3. Referans Kısıtlaması
Referans kısıtlaması bir ilişkideki (A) kimi
niteliklerin alabileceği değerlerinin, bir başka
ilişkideki (B) kimi niteliklerin var olan
değerleri ile sınırlanmasıdır. Başka bir deyişle
bir ilişkideki çokluların varlığının, bir başka
ilişkideki belirli çokluların varlığına bağımlı
olmasıdır.
İlişkiler arası bir kısıtlama olan referans
kısıtlamasında, A ilişkisi referans gösteren
ilişki, B ilişkisi ise referans gösterilen ilişkidir.
A ve B ilişkileri aynı ilişki de olabilir.
Örnek 4.1.
ÜRÜN (ÜKODU, ÜADI, ÜTÜRÜ, BİRİMİ,
FİYATI)
MAĞAZA (MNO, MADI, KENT, ADRES,
TELNO)
SATIŞ (SÜKODU, SMNO, STARİHİ,
SMİKTARI)
PERSONEL (PERNO, ADISOYADI,
GÖREVİ, ÇALMNO)
Yukarıdaki veri tabanı şemasında yer alan
4 ilişkinin birbirinden bağımsız olmadığı,
örneğin SATIŞ ilişkisine birçoklu eklemenin
ÜRÜN ve MAĞAZA ilişkilerinden bağımsız
olamayacağı görülmektedir. Çünkü SATIŞ
ilişkisinde satışı yapılan ürünün kodu
(SÜKODU) ve satışı yapan mağazanın
numarası (SMNO) nitelikleri yer almaktadır.
Ancak var olan bir mağaza var olan bir
ürünü satabilir. Dolayısıyla, veri tabanı
bütünlüğünün korunabilmesi için, SATIŞ i
ilişkisine bir çoklu eklenirken:
eklenecek çokludaki SÜKODU değerinin, var
olan bir ÜRÜN çoklusundaki ÜKODU değerine
eşit olması (deyişle böyle bir ürünün var
olması),
 eklenecek çokludaki SMNO değerinin,
var olan bir MAĞAZA çoklusundaki MNO
değerine eşit olması (başka bir deyişle satışı
yapan mağazanın var olması) gerekir.
Bu bütünlük kısıtlaması “ancak var olan bir
ürün, var olan bir mağaza tarafından
satılabilir” biçiminde ifade edilebilir.
Diğer taraftan PERSONEL ilişkisinde,
personelin çalıştığı mağazayı gösteren bir
nitelik (ÇALMNO) yer almaktadır. Her
personel çoklusunda (ÇALMNO) niteliğinin
değerinin MAĞAZA ilişkisinde var olan bir
çokludaki MNO değerine eşit olması gerekir.
Bu bütünlük kısıtlaması da “her personel
ancak var olan bir mağazada çalışabilir”
biçiminde ifade edilebilir.
Örnek 4.1’deki veri tabanı şemasında yer alan
referanslar aşağıdakilerdir(Çizim 4.1).
1.SATIŞ ilişkisinde SÜKODU niteliği, ÜRÜN
ilişkisinin birincil anahtarını (ÜKODU)
referans göstermektedir. Bu durumda
SÜKODU niteliği SATIŞ ilişkisinde yabancı
anahtardır.
2.SATIŞ ilişkisinde SMNO niteliği, MAĞAZA
ilişkisinin birincil anahtarını (MNO) referans
göstermektedir. SATIŞ ilişkisinde SMNO
niteliği de yabancı anahtardır.
3.PERSONEL ilişkisinde ÇALMNO niteliği,
MAĞAZA ilişkisinin birincil anahtarını (MNO)
referans göstermektedir. PERSONEL
ilişkisinde ÇALMNO yabancı anahtardır.
PER NO ADI SOYADI GÖREVİ ÇALMNO
PERSONEL
MAĞAZA
MNO MADI KENT ADRES TELNO
ÜRÜN
ÜKODU ÜADI ÜTÜRÜ BİRİMİ FİYATI
SATIŞ
SÜKODU SMNO SMİKTARI SFİYATI
Referans kısıtlamasının biçimsel tanımı
aşağıdaki gibi yapılabilir.
İlişki şemaları R1 ve R2 olan r1ve r2
ilişkilerini düşünelim.
R1
ilişkisinin anahtarlarından biri K1 olsun
(birincil anahtar olması zorunlu değildir).
A ile R2
ilişkisinin niteliklerinin bir altkümesini
gösterelim.
Eğer r2
'de bir t2 çoklusunun varlığı, r1
'de
anahtar (K1) değeri t2
'deki A değerine eşit bir
t1 çoklusunun varlığına(Ǝ t1 : t1 [K1]= t2 [A] )
bağımlı ise, A R2 için bir yabancı anahtardır ve
R1
ilişkisinin K1 anahtarını referans gösterir
denir.
Bu durumda r2 üzerinde yapılacak her ekleme,
silme ve günleme işleminde referans
kısıtlamasının sağlanması gerekir.
4. Nitelikler Arası Bağımlılıklar
İlişkilerin bütünlük ve tutarlılığı ile ilgili
kısıtlamaların önemli bir kesimi nitelikler arası
bağımlılıklardan kaynaklanan kısıtlamalardır.
Bu gruptaki kısıtlamalar “bazı niteliklerin
birbirinden bağımsız olmamasından ve bu
niteliklerin değerlerinin birbirinden bağımsız
olarak belirlenememesinden" kaynaklanır.
Eğer ilişkiler oluşturulurken nitelikler arası
bağımlılıklar dikkate alınmazsa, veri tabanında
bir dizi aykırılıklar oluşabilir. Bu durumda veri
tabanının bütünlük ve tutarlılığı korunamaz.
Karşılaşılabilecek sorunları, nitelikler arası
bağımlılıklar dikkate alınmadan (kötü)
tasarlanmış somut bir örnek üzerinde
inceleyelim.
Örnek 4.2. SATICI (ÜKODU, FNO, FADI,
FADRESİ, SFİYATI)
Bu ilişkideki her çokluda bir ürünün kodu;
bu ürünü satan bir firmanın numarası, adı ve
adresi ile firmanın bu ürüne ilişkin satış fiyatı
yer almaktadır. Bu ilişki şemasının yol
açabileceği sorunları aşağıdaki başlıklar
altında inceleyebiliriz.
a. Veri yinelemesi: Firmaların ad ve adresleri,
pazarladıkları her ürün için yinelenmektedir.
Gereksiz veri yinelemesi hem gereksiz bellek
kullanımına yol açtığı, hem de bir tutarsızlık
kaynağı oluşturduğu için sakıncalıdır.
b.Günleme aykırılığı: Bir firmanın adı ve/veya
adresi değiştiğinde, bu değişikliğin firmayla
ilgili her çokluda yapılması gerekir. Eğer
güncelleme işlemi çokluların bir kısmında
yapılır, bir kısmında yapılmazsa tutarsızlık
oluşur (her firmanın bir adı, bir adresi vardır
ilkesi bozulmuş olur).
c. Ekleme Aykırılığı: Bir firmanın bilgilerinin
veri tabanında saklanabilmesi için, firmanın
pazarladığı bir ürünün bulunması ve verilerin
veri tabanına eklenmesi gerekir. SATICI
ilişkisine bir çoklunun eklenmesi aşağıdaki
işlemlere karşı gelir.
 Eğer ilgili firmayla ilgili ilk çoklu ekleniyorsa,
veri tabanındaki firmalar arasına bir yenisinin
eklenmesi.
 Firmanın pazarladığı ürünlere bir yenisinin
eklenmesi.
Firma bilgisi ekleme ve firmanın pazarladığı
ürün bilgisi ekleme olarak adlandırılabilecek bu iki
işlemin tek bir ekleme işlemiyle gerçekleştirilmesi
bir aykırılıktır. Bu iki işlemin değişik zamanlarda
değişik kişiler tarafından yapılması daha uygun
olabilir.
d.Silme aykırılığı: Veri tabanında bir firmaya
ilişkin tek bir çoklu varsa, bu çoklunun
silinmesi de iki işleme (firma bilgisi silme ve
firmanın pazarladığı ürün bilgisi silme) karşı
gelir. Bu işlemlerin de değişik zamanlarda,
değişik kişiler tarafından yapılması daha
uygun olabilir.
Yukarıda sayılan sorunların tümü ilişki
şemasından; ilişki şeması oluşturulurken
nitelikler arası bağımlılıkların dikkate
alınmamasından kaynaklanmaktadır. Eğer
örnek 4,2’deki tek ilişki yerine, Örnek 4,3’deki
iki ilişki oluşturulursa, yukarıda sayılan
sorunların tümünün ortadan kalktığı görülür.
Örnek 4.3. FİRMA (FNO, FADI, FADRESİ)
SÜRÜN (FNO, ÜKODU, SFİYAT)
4.1. İşlevsel Bağımlılık: Temel
Kavramlar
R bir ilişki şeması, X ve Y ise niteliklerin iki
altkümesi olsun.
R=(A1, A2, A3,…,An)
X ⊆ R , Y ⊆ R
Eğer X nitelik değerleri aynı olan tüm
çoklularda, Y nitelik değerlerinin de aynı
olması gerekiyorsa X Y’ yi işlevsel belirler, ya
da Y X’ e işlevsel bağımlıdır denir ve X  Y
gösterimi kullanılır.
Eğer R ilişki şemasında X  Y işlevsel
bağımlılığı varsa, bu şemaya göre oluşan her r
ilişki olgusunda:
t1 [X] = t2[X]  t1 [Y]= t2 [Y]
koşulunun sağlanması gerekir.
İşlevsel bağımlılık kavramı iki düzeyde
düşünülebilir.
1. Kavramsal düzeyde. Gerçek dünyanın bir
yansıması olarak, ilişki şeması düzeyinde
belirli işlevsel bağımlılıklar vardır ve bu
işlevsel bağımlılıklar tanımlanır. Örneğin,
örnek 4.2'deki ilişki şemasında bulunan
(tanımlı) işlevsel bağımlılıklar aşağıdakilerdir.
FNO  FADI, FADRESİ
ÜKODU, FNO  SFİYATI
Ayrıca eğer gerçek dünyada, veri tabanının
kullanıldığı ortamda, firma adları tek ise (firma
adlarının birbirlerinden farklı olması
gerekiyorsa; bunu zorlayan bir kural varsa),
ilişki şemasında tanımlı işlevsel bağımlılıklar
arasında aşağıdaki de bulunur.
FADI  FNO, FADRESİ
2. Olgu (örnek) düzeyinde. Bir r ilişki olgusu,
ilişkide o anda mevcut çoklulara göre, belirli
işlevsel bağımlılıkları sağlar. Örnek 4,2’deki
ilişkisinin bir r olgusunda, örneğin aşağıdaki
işlevsel bağımlılıklar sağlanabilir.
FNO  FADI, FADRESİ
FADI  FNO, FADRESİ
ÜKODU, FNO  SFİYATI
FADRESİ  FNO, FADI
İlişki olgusunda sağlanan işlevsel
bağımlılıklardan ilk üçünün kavramsal düzeyde
var olan ve şema tanımında yer alan işlevsel
bağımlılıklar olduğu görülmektedir. Buna göre
r geçerli bir ilişki olgusudur (bir ilişki
olgusunun geçerli olabilmesi için, ilişki
şemasında tanımlı tüm kısıtlamaların, bu
arada işlevsel bağımlılıkların bu ilişki
olgusunda sağlanması gerekir).
r ‘de sağlanan son işlevsel bağımlılık ise,
ilişkide o anda bulunan veri değerlerine göre,
belki de tesadüfen sağlanan bir işlevsel
bağımlılıktır. Gerçek dünyada tüm firmaların
adreslerinin birbirinden farklı olmasını
zorlayan bir kural yoksa bu işlevsel bağımlılık
kavramsal düzeyde tanımlı değildir.
Ancak belirli bir anda, ilişkide adresleri aynı
olan firmalar yer almıyorsa, o an için bu
işlevsel bağımlılık sağlanır. Ancak ilişki
değiştiğinde, bu işlevsel bağımlılık artık
sağlanmayabilir.
Bu kitapta, kısaca işlevsel bağımlılık deyince
kavramsal düzeydeki işlevsel bağımlılık
anlaşılacaktır.
Bir ilişki olgusunun sağladığı işlevsel
bağımlılıktan söz edilirse de bu mutlaka
belirtilecektir.
Örnek 4.4. TAŞIT(PLAKANO, MARKA,
MODEL, YIL, AĞIRLIK, RENK)
Bu örnekteki işlevsel bağımlılıklar şunlardır:
PLAKANO  MARKA, MODEL, YIL,
AĞIRLIK,RENK
MARKA, MODEL  AĞIRLIK
Anlaşılırlığı arttırmak için işlevsel bağımlılıklar
bir çizimle gösterilebilir. Örnek 4.4’deki TAŞIT
ilişkisinin işlevsel bağımlılık çizeneği Çizim
4.2’de görülmektedir.
Çizim 4.2. Örnek 4.4’deki İlişki Şeması
için İşlevsel Bağımlılık Çizeneği
PLKNO
RENK
YIL
AĞIRLIK
MODEL
MARKA
Örnek 4.5. R(A, B, C, D) ilişki şemasına göre
oluşturulmuş aşağıdaki r ilişki olgusu veriliyor.
r :
A B C D
1 a x e
2 a y b
2 b x c
3 c x c
4 a x e
bu ilişki olgusunun sağladığı işlevsel
bağımlılıklar şunlardır.
D  C
A,B  C,D
A,C  B,D
A,D  B,C
B,C  D
Not: Bundan sonraki kesimlerde A,B  C,D
yerine AB  CD yazılacaktır.
4.2. İşlevsel Bağımlılık Türleri
Kısmi İşlevsel Bağımlılık: Eğer X A’ yı
belirliyorsa ve X’ in en az bir öz altkümesi de
A’ yi belirliyorsa (X  A ve ƎZ ⊂ X : Z
 A) X  A işlevsel bağımlılığına kısmi
işlevsel bağımlılık denir.
Tam İşlevsel Bağımlılık: Eğer X A’ yı
belirliyorsa ve X’ in hiçbir öz altkümesi A’ yı
belirlemiyorsa (X  A ve ∄ Z ⊂ X : Z 
A) X  A işlevsel bağımlılığına tam işlevsel
bağımlılık denir.
Önemsiz İşlevsel Bağımlılık: Eğer X, A
yı belirliyorsa ve A, X’ in bir altkümesi ise ( X
 A ve A ⊆ X ) X A işlevsel bağımlılığına
önemsiz işlevsel bağımlılık denir.
Önemli İşlevsel Bağımlılık: Eğer X A’ yı
belirliyorsa ve A X’ in bir altkümesi değilse (
X  A ve A ⊆ X ) X A işlevsel bağımlılığına
önemli işlevsel bağımlılık denir.
Geçişli İşlevsel Bağımlılık: Eğer X Y’yi,
Y de Z’i belirliyorsa (X  Y ve Y  Z) X Z
işlevsel bağımlılığına geçişli işlevsel bağımlılık
denir.
Not: Kısmi/tam ve önemli/önemsiz işlevsel
bağımlılık tanımlarında X  A gösterimi
kullanılmış, sağ tarafta tek bir niteliğe yer
verilmiştir. Eğer işlevsel bağımlılığın sağ
tarafında (örneğin X AB gibi) birden çok
nitelik yer alıyorsa, bu işlevsel bağımlılığın
tam/kısmi ve önemli/önemsiz olduğu her
zaman söylenemez.
Örneğin hem A hem de B X’ e tam işlevsel
bağımlı ise X  AB bir tam işlevsel
bağımlılıktır. Ancak A X ’e tam işlevsel bağımlı
iken, B X’ e kısmi işlevsel bağımlı ise X  AB
işlevsel bağımlılığının tam ya da kısmi olduğu
söylenemez.
Örnek 4.6.
R(ÖNO,ÖADI,BNO,BADI,FAKNO,DKODU,DA
DI,KRD,NOTU)
Yukarıdaki nitelik kümesindeki (ilişki
şemasındaki) nitelikler bir öğrencinin
numarasını ve adını; öğrencinin bölümünün
numarasını ve adını; öğrencinin fakültesinin
numarasını; öğrencinin aldığı bir dersin
kodunu, adını, kredisini ve öğrencinin bu
dersten aldığı notu göstermektedir. Aşağıda
bu nitelikler arasındaki işlevsel
bağımlılıklardan kimi örnekler verilmektedir.
Önemsiz işlevsel bağımlılık örnekleri:
DKODU  DKODU
ÖNO, ÖADI  ÖADI
BNO, BADI, FAKNO  BNO, FAKNO
Önemli işlevsel bağımlılık örnekleri:
ÖNO  ÖADI
ÖNO, ÖADI, DKODU  BNO, KRD
ÖNO, DKODU  NOTU
Kısmi işlevsel bağımlılık örnekleri:
ÖNO, ÖADI  BNO
ÖNO, DKODU  KRD
ÖNO, DKODU, DADI  NOTU
Tam işlevsel bağımlılık örnekleri:
ÖNO  ÖADI, BNO
BNO  FAKNO
ÖNO, DKODU  NOTU
Geçişli işlevsel bağımlılık örnekleri:
ÖNO  FAKNO (ÖNO  BNO, BNO 
FAKNO)
ÖNO  BADI (ÖNO  BNO, BNO
BADI)
İşlevsel bağımlılıklar içinde önemsiz işlevsel
bağımlılıkların hiç bilgi taşımadığı açıktır.
Kısmi ve geçişli işlevsel bağımlılıklar ise,
diğerlerinden türetilebildiği için sınırlı bilgi
taşımaktadır. Buna göre en değerli, en çok
bilgi taşıyan işlevsel bağımlılıklar önemli, tam
ve geçişli olmayan(bu üç özelliği birlikte
taşıyan) işlevsel bağımlılıklardır. Örnek 4.6
için, nitelikler arasındaki bu tür işlevsel
bağımlılıklar aşağıdakilerdir (Çizim 4.3).
ÖNO  ÖADI, BNO
BNO  BADI, FAKNO
DKODU  DADI, KRD
DKODU, ÖNO  NOTU
Çizim 4.3. Örnek 4.6’daki İlişki Şeması İçin
Bağımlılık Çizeneği
ÖNO
DKODU
KRD
DADI
ÖADI
BNO
FAKNO
BADI
NOTU
4.3 İşlevsel Bağımlılıklarla İlgili Kimi
Tanım, Önerme ve Algoritmalar
A. Bir İşlevsel Bağımlılık Kümesinin
Kapanışı
Bir R nitelik kümesi ve bu nitelikler üzerinde
tanımlı bir F işlevsel bağımlılık kümesi
verildiğinde, F’deki işlevsel bağımlılıklara ek
olarak:
R’ deki tüm önemsiz işlevsel bağımlıklar ile
 F’ deki işlevsel bağımlılıklardan
türetilebilecek tüm kısmi ve geçişli bağılılıkları
içeren işlevsel bağımlılık kümesine F’ nin
kapanışı (closure) denir ve bu küme F+ olarak
gösterilir.
Örnek 4.7. R(A,B,C,D) ve F = {A  B , BC
 D} verildiğinde F+ aşağıdaki gibi bulunur.
F+ : A  AB AB  AB ABC  ABCD
B  B AC  ABCD ABD BD
C  C AD  ABD ACD 
ABCD
D D BC  BCD BCD BCD
BD  BD ABCD 
ABCD
CD  CD
Yukarıda görüldüğü gibi, F’ de yalnız 2
işlevsel bağımlılık varken bu kümenin kapanışı
olan F+ da 15 işlevsel bağımlılık
bulunmaktadır. F+ da yer alan her işlevsel
bağımlılık yerine birçok işlevsel Bağımlılık
yazılabileceği (örneğin AB  AB yerine AB 
A ve AB  B ) de düşünülürse bu sayının çok
daha fazla olabileceği görülür. Diğer taraftan
F+ da yer alan işlevsel bağımlılıkların büyük
çoğunluğunun önemsiz olduğu görülmektedir.
B. İşlevsel Bağımlılıkları Türetme
Kuralları
Bir F işlevsel bağımlılık kümesi verildiğinde,
bu kümenin kapanışı (F+ ) bulmak için, başka
bir deyişle bu kümedeki işlevsel
bağımlılıklardan türetilebilecek diğer işlevsel
bağımlılıkları bulmak için kullanılabilecek 6
türetme kuralı vardır. Bunlardan armstrong
aksiyomları olarak da bilinen ilk üçü temel
kurallardır.
Temel kurallar yetkin bir küme oluşturur ve
F+ daki tüm işlevsel bağımlılıklar bu 3 kural
kullanılarak türetilebilir. Ancak türetme
kolaylığı ve esnekliği açısından kullanılan 3
türetme kuralı daha bulunmaktadır.
Temel Kurallar(Armstrong
aksiyomları)
1.Dönüşlülük (reflexitivity) kuralı:
Y ⊆ X  X  Y
2.Artırma(augmentation) kuralı:
X  Y  XZY
3.Geçişlilik (transitivity )kuralı:
X  Y ve Y  Z  X  Z
Diğer Kurallar:
4. Birleşim (union) kuralı:
X  Y ve X  Z  X  YZ
5. Ayrışma (decomposition) kuralı:
X  YZ  X  Y ve X  Z
6.Sözde geçişlilik(pseudo transitivity)
kuralı:
X  Y ve YZ  W  XZ  W
Örnek 4.8.R(A,B,C,D,E,G)
F: A  BD
BC  EG
D  E
Bu örnek için (bkz Çizim 4.4), türetme kuralları
kullanılarak türetilebilecek işlevsel
bağımlılıklardan bir kaçı örnek olarak aşağıda yer
almaktadır.
 DG  E (artırma kuralına göre)
A  E (ayrıştırma ve geçişlilik kurallarına göre)
A  ABD(dönüşlülük ve birleştirme kurallarına
göre)
A  B ve A  D(ayrıştırma kuralına göre),
AC  EG(ayrıştırma ve sözde geçişlilik kurallarına
göre)
Çizim 4.4. Örnek 4.8’ deki İlişki Şeması İçin
İşlevsel Bağımlılık Çizeneği
B
C
A
E
G
D
C.Kanonik Örtü
Her işlevsel bağımlılık bir bütünlük kısıtlamasıdır.
Bütünlük ve tutarlık için her değişiklik işleminde işlevsel
bağımlılıkların sağlandığı denetlenmelidir.
Her denetimin her bir maliyeti vardır.
Az sayıda işlevsel bağımlılık denetimi kolaylaştırır.
F ‘in en az sayıda işlevsel bağımlılık içeren eş değeri aranır.
(Fc), F’ ye eşdeğer olan en az sayıda işlevsel bağımlılık içeren
kümedir.
 F : Fc
‘den türetilebilir.
 Fc
: F ‘ten türetilebilir.
 F+= (Fc)
+ : F ve Fc eşdeğerdir.
 Kanonik örtüsünün sağlaması gereken kurallar:
 K1
: Fc
‘ de sol tarafları birbirinden farklı olmalıdır.
 K2 : Fc
‘ de sol tarafta artık nitelik bulunmamalıdır.
(Fc
‘de sol taraftaki niteliklerden biri atıldığında oluşan yeni
küme Fc
‘ ye eşdeğer olmamalıdır.)
 K3
: Fc
’ de sağ tarafta artık nitelik bulunmamalıdır.
(Fc
‘de sağ tarafındaki niteliklerden herhangi biri atıldığında
oluşan yeni küme Fc
‘ ye eşdeğer olmamalıdır.)
K1
: Fc
‘de, sol tarafı aynı olanlar birleştirilmelidir.
K2 ve K3
: Fc
, F ‘ye eşdeğer olan ve önemsiz, kısmi ya
da geçişli hiçbir işlevsel bağımlılık içermeyen bir
kümedir.
Örnek 4.9.
R (A,B,C,D)
F : B  C
C  A
BC  A
BA
Kanonik örtü:
Geçişlilikler kaldırılırsa:
Fc
: B  C , C A
Artıklık Algoritması
Bir F işlevsel bağımlılık kümesi verildiğinde,
eğer kümedeki işlevsel bağımlılıklardan biri (
f ), kümedeki diğer işlevsel bağımlılıklardan
türetilebiliyorsa, bu işlevsel bağımlılık ( f )
kümede artıktır. Diğer bir deyişle eğer “F- (f)“
deki işlevsel bağımlılıklardan f türetilebiliyorsa
f işlevsel bağımlılığı F kümesinde artıktır.
F kümesindeki bir işlevsel bağımlılığın
(f : X  Y) artık olup olmadığı aşağıdaki
algoritmaya göre belirlenir.
Artıklık algoritması
1. Başlangıçta T = { X } yap
2. “F – { f }” teki her W  Z işlevsel
bağımlılığı için :
Eğer { W} ⊆ T ise  T= T ∪ { Z } yap
3.T değiştiği sürece 2. Adımı tekrarla
4.Sonuçta eğer Y ⊆ T ise (f : X  Y )
işlevsel bağımlılığı F’ de artıktır.
Bir işlevsel bağımlılık kümesindeki işlevsel
bağımlılıklardan artık olanlar aranırken iki
noktaya dikkat etmek gerekir.
1.Eğer X  Y işlevsel bağımlılığında Y birden
çok nitelikten oluşuyorsa, X  Y işlevsel
bağımlılığı artık olmayabilir. Ancak bu işlevsel
bağımlılık ayrıştırma kuralına göre birçok
işlevsel bağımlılığa ayrıştırılırsa, elde edilen
işlevsel bağımlıklardan bir kısmı artık olabilir.
Örneğin, bir F işlevsel bağımlılık kümesinde
BC ADE işlevsel bağımlılığı artık olmayabilir.
Ancak bu işlevsel bağımlılık BC  A , BC 
D ve BC  E işlevsel bağımlılıklarına
ayrıştırılırsa, F kümesinde bunların birinin ya
da ikisinin artık olması olasıdır. Buna göre
artık işlevsel bağımlılıklar araştırılırken, sağ
tarafı birden çok nitelikten oluşan işlevsel
bağımlılıkları ayrıştırmak gerekir.
2.F= {f1
,f2
,f3
,…,f n} işlevsel bağımlılık
kümesinde fi
’ nin artık olduğunun
bulunduğunu varsayalım. Kümedeki diğer
işlevsel bağımlılıkların artık olup olmadığını
araştırırken artıklık algoritmasında F yerine “F
– { fi }” koymak gerekir.
Başka bir deyişle bir işlevsel bağımlılık
kümesindeki artık işlevsel bağımlılıklar
araştırılırken, artık olduğu bulunan her işlevsel
bağımlılık kümeden çıkarılmalı ve sonraki
işlevsel bağımlılıkların eksilen kümede artık
olup olmadığı araştırılmalıdır. Yoksa yanlış
sonuçlar elde edilebilir.
Örneğin F={f1
,f2
,f3
,f4
,f5} kümesinde f2
artık olabilir. Aynı kümede f3 de artık olabilir.
Ancak f2 ve f3 F ‘ de birlikte artık olmayabilir.
Başka bir deyişle f3
işlevsel bağımlılığı
F={f1
,f2
,f3
,f4
,f5} kümesinde artık iken
örneğin F={f1
,f3
,f4
,f5} kümesinde artık
olmayabilir.
Örnek 4.10. R(A,B,C,D,E,G) nitelik kümesi
üzerinde tanımlı aşağıdaki işlevsel bağımlılık
kümesi verilmiş olsun.
F: A  BCDE
G  BD
BC  E
CG  A
BDE  ACG
Kümedeki işlevsel bağımlılıklardan sağ
tarafında birden çok nitelik bulunanları
ayrıştırdığımızda, toplam 11 işlevsel bağımlılık
elde edilir. Bunların artık olup olmadığını
inceleyelim
R(A,B,C,D,E,G)
F: A  B G  B BDE  A
A C G  D BDE  C
A  D BC  E BDE  G
A E CG  A
1.F’'de A  B artık mı? T = {A,C,D,E} elde
edilir
=> hayır
2.F 'de A  C artık mı? T ={A,B,D,E,C,G}
elde edilir => evet
F1 = F - {A  C}
3.F1
'de A D artık mı? T = {A,B,E} elde
edilir => hayır
4. F1
'de A  E artık mı? T={A,B,D} elde
edilir => hayır
5.F1
'de G  B artık mı? T = {G,D} elde
edilir
=> hayır
6. F1
'de G D artık mı? T = {G,B} elde
edilir => hayır
7. F1
'de BC  E artık mı? T ={B,C}
elde edilir =>hayır
8. F1
'de CG  A artık mı? T= {C,G,B,D,E,A}
elde edilir =>evet F2 = F1
- {CG  A}
9. F2
'de BDE  A artık mı? T = {B,D,E,C,G}
elde edilir =>hayır
10. F2
'de BDE  C artık mı? T = {B,D,E,A,G}
elde edilir => hayır
11. F2
'de BDE  G artık mı?T = {B,D,E,A,C}
elde edilir => hayır
Sonuç olarak F' de A  C ve CG  A işlevsel
bağımlılıkları artıktır. Buna göre F 'nin kanonik
örtüsü aşağıdaki gibi bulunur
Fc : A  BDE
G  BD
BC E
BDE ACG
E.Türetilebilirlik Algoritması
Bir F işlevsel bağımsızlık kümesi verildiğinde, bu
kümedeki işlevsel bağımlılıklardan f : X  Y
işlevsel bağımlılığının türetilip
türetilemeyeceğini bulan bir algoritmadır.
5. Başlangıçta T={ X } yap
6. F’deki her W  Z işlevsel bağımlılığı için:
Eğer { W } ⊆ T ise  T = T ∪ {Z}
yap
7. T değiştiği sürece 2. Adımı tekrarla
8. Sonuçta eğer Y ⊆ T ise (f : X  Y)
işlevsel bağımlılığı F’ den türetilebilir.
Eğer X Y işlevsel bağımlılığında Y birden
çok nitelikten oluşuyorsa, F’ den X  Y
işlevsel bağımlılığını türetmek mümkün
olmayabilir. Ancak bu işlevsel bağımlılık
ayrıştırma kuralına göre birçok işlevsel
bağımlılığa ayrıştırılırsa, elde edilen işlevsel
bağımlılıklardan bir kısmının F’ den türetilmesi
olasıdır.
Örneğin bir F işlevsel bağımlılık kümesinden
AC  BDE işlevsel bağımlılığı
türetilemeyebilir. Ancak bu işlevsel bağımlılık
AC  B, AC  D ve AC E işlevsel
bağımlılıklarına ayrıştırılırsa, F’ den bunların
birinin ya da ikisinin türetilebilir olması
olasıdır. Buna göre işlevsel bağımlılıkların
türetilebilirliği araştırılırken, sağ tarafı birden
çok nitelikten oluşan işlevsel bağımlılıkları
ayrıştırmak gerekir.
Türetilebilir algoritmasının özde artıklık
algoritması ile aynı olduğu gözlenmektedir.
Gerçekten de eğer F ‘den f türetilebiliyorsa,
“{F ∪ f}” f atıktır.
F. Bir Nitelik Kümesinin
Kapanışı
R (A1
, A2 A3
, ...., An) nitelik kümesi
üzerinde tanımlı bir F işlevsel bağımlılık kümesi
verilmiş olsun. Eğer X R‘ nin bir altkümesi ise
(X ⊆ R), X' in kapanışı X' e işlevsel bağımlı
(ya da X’ in belirlediği) niteliklerin tümüdür. X'
in kapanışı X+ diye gösterilir ve aşağıdaki
algoritmaya göre hesaplanır.
X+ hesaplama algoritması
1. Başlangıçta T = { X } yap
2. F'deki her W  Z işlevsel bağımlılığı için:
eğer {W} ⊆ T ise => T=T ∪ { Z } yap
3. T değiştiği sürece 2. adımı tekrarla
Sonuçta X+ = T olarak bulunur.
Örnek 4.11. Örnek 4.10'daki R nitelik
kümesi ve bu nitelik kümesi üzerinde tanımlı F
işlevsel bağımlılık kümesi için, aşağıda kimi
nitelik altkümelerinin kapanışlarına yer
verilmiştir.
A+ =ABCDEG (AB) + = ABCDEG
B+ =B (BC)+ = BCE
C+=C (CG)+ = ABCDEG
D+=D (CDE)+ = CDE
E+=E (DEG)+ = ABCDEG
G+=BDG (BCDE)+ = ABCDEG
5. İlişki Anahtarları
İlişkisel kurama göre ilişki anahtarlarının
tanımı önceki bölümlerde yapılmıştı (bkz 3.2).
Bu bölümde işlevsel bağımlılıklara dayalı
olarak ilişki anahtarlarını bir kez daha
tanımlayacağız.
R ( A1 A2, A3, …, An) ilişki şeması ve bu
nitelikler üzerinde tanımlı bir F işlevsel
bağımlılık kümesi verilmiş olsun. R ilişki
şeması ve F işlevsel bağımlılık kümesine
uygun olarak gerçekleşen ilişkinin bir örneğini
r ile gösterelim. İlişkinin süper anahtarları ile
anahtar adayları aşağıdaki gibi tanımlanır.
Süper anahtar: Eğer bir nitelik alt kümesi (K)
ilişkideki tüm nitelikleri işlevsel belirtiyorsa,
başka bir deyişle K' nın kapanışı R'ye eşitse,
bu nitelik altkümesi ilişkinin süper anahtarıdır.
K ⊆ R : K  R' dir ve K+
Anahtar ya da anahtar adayı: Eğer bir nitelik
altkümesi (K) ilişkideki tüm nitelikleri işlevsel
belirtiyorsa (başka bir deyişle K’nın kapanışı
R'ye eşitse), ve de K'nın hiçbir altkümesi tüm
nitelikleri belirlemiyorsa, K ilişkinin anahtar
adayı, ya da kısaca anahtarıdır. Anahtar
tanımını, süper anahtara dayalı olarak şöyle
yapabiliriz: eğer K R‘ nin bir süper anahtarı
ise, ve de K‘ nın hiçbir öz altkümesi R‘ nin
süper anahtarı değilse, K R‘ nin anahtar
adayı, ya da kısaca anahtarıdır.
(K ⊆ R : K  R) ve ( ƎK1  K : K1  R )  K
ilişkinin anahtarıdır.
Bir ilişkinin anahtarlarının bilinmesi son
derece önemlidir. Çünkü her anahtar bir
bütünlük kısıtlamasıdır. İlişkinin tüm
örneklerinde, her anahtarın değeri ilişkinin
tüm çoklularında birbirinden farklı olmalıdır.
İlişki kuramında anahtar bir erişim
mekanizması değil, bir bütünlük kısıtlamasıdır.
Bu açıdan ilişkinin bütünlük ve tutarlılığının
korunması için anahtarlarının bilinmesi
gerekir. "Anahtar adayı", "anahtar" ve
"ilişki anahtarı" eşanlamlıdır. Bu kitapta
daha çok anahtar ya da anahtar adayı
terimleri kullanılacaktır.
Süper anahtar deyiminin İngilizce karşılığı
"süper set of key" nin kısaltması olan
"superkey" dir. Dolayısıyla her ilişki anahtarı
bir nitelik kümesi olduğuna göre, her
anahtarın her üst kümesi bir süper anahtardır.
Uygulama açısından önemli olan süper
anahtarlar değil anahtarlardır. Süper
anahtarların önemi ise sadece kuramsaldır.
Tanım gereği her anahtar aynı zamanda
süper anahtardır. Buna karşılık her süper
anahtarın anahtar olmadığı, az sayıda süper
anahtarın anahtar olduğu açıktır. Bir ilişkinin
süper anahtarlarının sayısı anahtarlarının
sayısına göre çok daha fazladır.
Örnek 4.12. R(A, B, C, D, E) ilişki şeması
üzerinde tanımlı aşağıdaki işlevsel bağımlılık
kümesi veriliyor.
F={A  C, B D , D  AE, CE  B}
İlişkinin 4 anahtarı(ya da anahtar adayı)
vardır: B, D, AE ve CE
B, D, AE ve CE' nin tüm üst kümeleri
ilişkinin süper anahtarıdır. İlişkinin süper
anahtarlarından birkaçı şunlardır: B, AB, ABC,
DC, ADE, ABCDE
6. İlişkiler İçin Normal Biçimler
Bütünlük kısıtlamaları, özellikle de nitelikler
arası bağımlılıklar dikkate alınmadan
oluşturulan ilişkilerin sorunlara yol
açabileceğini yukarıda gördük (bkz 4.4).
Sorunsuz ilişkiler oluşturabilmek amacıyla
ilişkiler için bir dizi normal biçim
tanımlanmıştır.
Normal biçimlerin çoğu işlevsel
bağımlılıklara göre, bir kısmı ise diğer
bütünlük kısıtlamalarına (örneğin anahtarlara
göre) tanımlanmıştır. Normal biçimler içinde
en çok bilinen ve en çok kullanılanları, işlevsel
bağımlılıklara göre tanımlanan ve kısaca 1NF,
2NF, 3NF ve BCNF diye bilinen normal
biçimlerdir. Bu normal biçimlerin her biri
aşağıda tanımlanmaktadır.
6.1. Birinci Normal Biçim (1NF)
1NF İlişki Tanımı: Eğer bir İlişkideki tüm
niteliklerin değer alanları yalın değer alanları
ise ilişki Birinci Normal Biçimdedir. İlişkinin
Birinci Normal Biçimde olması (ya da kısaca
1NF olması) için niteliklerin tek değerli yalın
nitelikler olması; hiçbir niteliğin hiçbir
değerinin bir dizi, bir matris (bir başka ilişki),
ya da karmaşık bir değer (mahalle, cadde,
sokak, kapı numarası, …değerlerinden oluşan
adres gibi) olmaması gerekir.
İlişkisel modelde, ilişkiler için verilen tanım
(bkz 3.1) 1NF ilişki tanımıdır. Başka bir
deyişle, ilişkisel modelde "ilişki" denildiğinde
1NF İlişki anlaşılır. Birinci Normal Biçimde
olmayan ilişkiye kısaca N1NF (Non 1NF) İlişki
denir.
Örneğin ÖĞRENCİ (ÖNO, ÖADI, DERS
(DADI, NOTU))
ilişkisi, DERS niteliği tek değerli yalın bir nitelik
olmadığı için 1NF değildir. Bu ilişki
ÖĞRDERS (ÖNO, ÖADI, DADI, NOTU)
biçimine dönüştürülürse, Birinci Normal Biçim
de olur.
ÖĞRENCİ ilişkisinin bir örneği ile, bu
örneğin ÖĞRDERS şemasına uygun
gerçekleşimi Çizim 4.5’de yer almaktadır.
Çizimde de görüldüğü gibi, aldığı ders sayısı
kaç olursa, her öğrenci için ÖĞRENCİ
ilişkisinde bir satır (çoklu) bulunmaktadır.
ÖĞRDERS ilişkisinde ise, her öğrenci için,
öğrencinin aldığı ders sayısı kadar satır
bulunmakta ve bu çokluların hepsinde
öğrencinin numarası ile adı tekrarlanmaktadır.
Çizim 4.5 Normal Biçimde Olmayan (N1NF) Bir
İlişkinin Normal Biçime(1NF) Dönüştürülmesi
DERS
ÖNO ÖADI DADI NOT
U
123 ALİ MAT. 87
FİZ. 69
KİM. 93
207 KAYA KİM. 64
186 NUR FİZ. 75
MAT. 45
316 AYŞE BİO. 59
KİM. 87
MAT. 60
FİZ. 77
İNG. 98
ÖNO ÖADI DADI NOTU
123 ALİ MAT. 87
123 ALİ FİZ. 69
123 ALİ KİM. 93
207 KAYA KİM. 64
186 NUR FİZ. 75
186 NUR MAT. 45
316 AYŞE BİO. 59
316 AYŞE KİM. 87
316 AYŞE MAT 60
316 AYŞE FİZ. 77
316 AYŞE İNG 98
6.2. İkinci Normal Biçim (2NF)
Asal ve Asal Olmayan Nitelik Tanımları:
İkinci Normal Biçimi tanımlayabilmek için asal
ve asal olmayan nitelik tanımlarına gereksinim
vardır. Bilindiği gibi her ilişkinin bir ya da bir
çok anahtarı vardır. Anahtarlardan her biri de
bir ya da birçok nitelikten oluşur.
İlişki anahtarlarının en az birinde yer alan
niteliklere asal nitelik; ilişki anahtarlarının
hiçbirinde yer almayan niteliklere ise asal
olmayan nitelik denir.
2NF İlişki Tanımı: Eğer bir ilişki Birinci Normal
Biçimde (1NF) ise ve asal olmayan
niteliklerden hiçbiri anahtarlardan hiçbirine
kısmi işlevsel bağımlı değilse bu ilişki ikinci
Normal Biçimdedir.
İkinci Normal Biçim asal olmayan tüm
niteliklerin tüm anahtarlara tam işlevsel
bağımlı olması koşulunu getirmekte, asal
olmayan herhangi bir niteliğin herhangi bir
anahtara kısmi işlevsel bağımlı olmasına izin
vermemektedir.
Örnek 4,2‘ de yer alan
SATICI (ÜKODU, FNO, FADI, FADRESİ,
SFİYATI) ilişkisini düşünelim. Tüm nitelikler
tek değerli yalın nitelikler olduğu için bu ilişki
1NF koşulunu sağlar. İlişkinin tek anahtarı
ÜKODU, FNO çiftidir.
Buna göre ÜKODU ve FNO asal nitelikler;
FADI, FADRESİ ve SFİYATI ise asal
olmayan niteliklerdir. Asal olmayan FADI ve
FADRESİ nitelikleri anahtarlara kısmi işlevsel
bağımlı olduğu için de bu ilişki İkinci Normal
Biçimde değildir.
6.3. Üçüncü Normal Biçim (3NF)
3NF İlişki Tanımı: Eğer bir ilişki 2. Normal
Biçimde ise ve asal olmayan hiçbir nitelik
hiçbir anahtara geçişli bağımlı değilse, bu ilişki
3. Normal Biçimdedir. 2.Normal Biçim asal
olmayan niteliklerin anahtarlara tam işlevsel
bağımlı olması koşulunu getiriyordu.
3. Normal Biçim, buna ek olarak asal
olmayan niteliklerin anahtarlara geçişli bağımlı
olmama koşulunu getirmektedir. Buna göre
eğer bir İlişkideki asal olmayan niteliklerin
tümü, anahtarlara tam işlevsel bağımlı ise ve
asal olmayan nitelikler birbirinden bağımsız
ise (hiçbiri hiçbir anahtara geçişli bağımlı
değilse) bu ilişki 3. Normal Biçimdedir.
Örnek 4.4'de yer alan TAŞIT (PLAKANO,
MARKA, MODEL, YIL, AĞIRLIK, RENK)
ilişkisini düşünelim. Tüm nitelikler tek değerli
yalın nitelikler olduğu için bu ilişki 1NF
koşulunu sağlar. İlişkinin tek anahtarı
PLAKANO' dur. PLAKANO dışındaki 5 nitelik
asal nitelik değildir ve asal olmayan bu
niteliklerin hepsi anahtara (PLAKANO) tam
işlevsel bağımlıdır.
Zaten tek nitelikten oluşan bir anahtara
niteliklerin kısmi işlevsel bağımlı olması söz
konusu olamaz. Bu durumda ilişki 2NF'dir.
Ancak asal olmayan nitelikler birbirinden
bağımsız değildir.
Bu nitelikler arasında MARKA, MODEL 
AĞIRLIK işlevsel bağımlılığı da vardır (bkz
Çizim 4.2). Bu nedenle 2. Normal Biçimde
olan TAŞIT ilişkisi 3. Normal Biçimde değildir.
6.4. Boyce Codd Normal Biçimi
(BCNF)
BCNF İlişki Tanımı: Eğer bir ilişki 1.
Normal Biçimde ise ve tüm belirleyenler
ilişkinin anahtarı ise bu ilişki Boyce Codd
Normal Biçimindedir. Buna göre, eğer K
ilişkinin bir anahtarını gösteriyorsa, BCNF
ilişkideki tüm işlevsel bağımlılıklar K  X
biçimindedir.
Başka bir deyişle ilişkinin BCNF olabilmesi
için, önemli her işlevsel bağımlılığın sol
tarafında yer alan her nitelik ya da nitelik
grubunun ilişkideki tüm nitelikleri belirlemesi,
dolayısıyla ilişkinin anahtarı olması gerekir.
Üçüncü Normal Biçimin asal olmayan
niteliklerin birbirinden bağımsız olmasını ve
anahtara tam işlevsel bağımlı olmasını
zorladığını" biliyoruz. Ancak Üçüncü Normal
Biçim asal nitelikler ile ilgili hiçbir zorlama
getirmemektedir. 3NF bir ilişkide asal nitelikler
birbirinden bağımsız olmayabilir ve
anahtarlara kısmi bağımlı olabilir.
Bu serbestlik birden çok anahtarı bulunan
ve anahtarlarından en az ikisi birden çok
nitelikten oluşan ilişkilerde sorunlar
oluşmasına yol açabilir.
Örnek 4.12'deki R (A, B, C, D, E) ilişkisinin
4 anahtarının bulunduğunu ve anahtarların B,
D, AE ve CE olduğunu biliyoruz. Bu durumda
ilişkinin tüm nitelikleri asal niteliklerdir.
İlişkide asal olmayan hiçbir nitelik
bulunmadığına göre ilişki otomatik olarak
3NF'dir.
Ancak bu ilişkide A C işlevsel bağımlılığı
vardır. A bir belirleyen olmasına karşın
anahtar değildir. Dolayısıyla 3NF olan bu ilişki
BCNF değildir.
Örnek 4.13. ÖĞRDERS (ÖĞRNO, DKODU,
DADI, NOTU) ilişkisinde nitelikler arasında
aşağıdaki işlevsel bağımlılıkların bulunduğunu
varsayalım (Çizim 4.6).
DKODU  DADI
DADI  DKODU
DKODU, ÖĞRNO  NOTU
DADI, ÖĞRNO  NOTU
Çizim 4.6. Örnek 4.13’ deki İlişki Şeması İçin
İşlevsel Bağımlılık Çizeneği
DKODU
ÖGRNO
DADI
NOTU
İlişkinin anahtarları DKODU, ÖĞRNO ve
DADI, ÖĞRNO’ dur. İlişkinin asal olmayan
tek niteliği (NOTU) anahtarlara tam işlevsel
bağımlıdır, geçişli bağımlı değildir (zaten asal
olmayan tek nitelik bulunduğuna göre, geçişli
bağımlılık söz konusu olamaz).
Bu durumda ilişki 3NF bir ilişkidir. Ancak
anahtar olmayan DKODU ve DADI birer
belirleyen olduğu için ilişki BCNF değildir.
Örnek 4.14. KURS (ÖĞRNO, DKODU,
ÖĞRETMEN, NOTU) ilişkisinde nitelikler
arasında aşağıdaki işlevsel bağımlılıkların
bulunduğunu varsayalım (Çizim 4.7).
ÖĞRETMEN  DKODU
ÖĞRNO,DKODUNOTU
Bu işlevsel bağımlılıklar her öğretmenin
yalnız bir ders verdiği; her dersin şubeler
halinde birçok öğretmen tarafından verildiği
ve şubelerin ayırımının sorumlu öğretmen ile
yapıldığı ve bir öğrencinin bir dersi yalnız bir
öğretmenden aldığı gerçek dünya kurallarının
yansımasıdır.
İlişkinin tek anahtarı ÖĞRNO, ÖĞRETMEN
ikilisidir. İlişkide asal olmayan DKODU niteliği
anahtara kısmi işlevsel bağımlı olduğu için
İlişkinin biçimi 1NF'dir. Dolayısıyla ilişki BCNF
değildir. İlişkinin BCNF bir ilişki olmadığı
anahtar olmayan ÖĞRETMEN ve ÖĞRNO ile
DKODU ' nun birer belirleyen olmasından da
anlaşılmaktadır.
Çizim 4.7. Örnek 4.14'deki İlişki Şeması İçin
İşlevsel Bağımlılık Çizeneği
ÖĞRNO
DKODU ÖĞRETMEN
NOTU
7. İlişkilerin Ayrıştırılması
R ilişki şeması ve nitelikler arasında tanımlı F
işlevsel bağımlılık kümesi verilmiş olsun.
Aşağıdaki koşullan sağlayan {R1
, R2
, R3
, ... ,
Rn} ilişki kümesi R' nin bir ayrıştırmasıdır.
K1. R‘ deki niteliklerin her biri en az bir Ri
' de
bulunmalıdır.
R = R1 ∪ R 2 ∪ R3 ∪ … Rn
K2. Ayrıştırma yitimsiz-birleştirme
ayrıştırması (lossless-join decomposition)
olmalıdır (bkz 4.7.1). Bir ayrıştırmanın
yitimsiz-birleştirme ayrıştırması olması için, R
ilişki şemasına göre gerçekleşen ve F'deki
işlevsel bağımlılıkları sağlayan her r ilişkisinin
Ri
’lere göre izdüşümlerinin doğal birleştirmesi
r'ye eşit olmalıdır.
r= p R1 (r) p R2 (r) p R3 (r)
….. p Rn (r)
K3
. Ayrıştırma F' deki işlevsel bağımlılıkları
korumalıdır (bkz 4.7.2).
Bu koşulların ilki aslında artık bir koşuldur.
Çünkü eğer ayrıştırma yitimsiz- birleştirme
ayrıştırması ise bu koşul sağlanır (K2
sağlandığında K1 mutlaka sağlanır). Buna
göre ayrıştırmanın geçerli bir ayrıştırma
olması için:
1. Yitimsiz-birleştirme ayrıştırması olması,
2. İşlevsel bağımlılıktan koruması,
gerekli ve yeterlidir. Bu özellikler aşağıda
incelenmektedir
7.1. Yitimsiz-Birleştirme Ayrıştırması
Eğer bir ilişki BCNF (ya da en azından 3NF)
değilse bir takım aykırılıklara yol açabileceğini
gördük. Bu tür bir ilişkiyi belirli sayıda BCNF
(ya da 3NF) ilişkiye ayrıştırarak aykırılıklara
yol açmayan, oluşturulması ve bakımı kolay
bir şema elde edebiliriz. Bu işleme ilişkinin
normalleştirilmesi (normalization) denir.
Ancak bir ayrıştırmanın öncelikle yitimsizbirleştirme ayrıştırması olması, ya da kısaca
yitimsiz olması gerekir. Yitimsizliğin kuramsal
tanımı yukarıda verildi.
Ancak verilen tanıma göre, bir ayrıştırmanın
yitimsiz olabilmesi için, ilişki şeması ve
nitelikler arası işlevsel bağımlılıkların bilinmesi
yeterli değildir; ilişkinin kendisine, hem de
olası tüm örneklerine gereksinim vardır.
Bir ilişkinin olası tüm örneklerinin
bilinmesinin de uygulanabilirlik açısından
olanaksız olduğu açıktır. Dolayısıyla bir ilişki
şeması, nitelikler üzerinde tanımlı bir işlevsel
bağımlılık kümesi ve ilişkinin bir ayrıştırması
verildiğinde, ilişkinin örneklerini hiç bilmeden,
ayrıştırmanın yitimsiz olup olmadığını bulmak
için uygulanabilir yöntem ya da yöntemlere
ihtiyaç vardır.
Bu yöntemlere geçmeden önce örnek bir
ilişki üzerinde yitimsiz ve yitimli
ayrıştırmaların birer örneği gösterilecektir.
Örnek 4.15. R (A, B, C) ilişki şeması ve
nitelikler arası F = { A  B , C  B} işlevsel
bağımlılık kümesi veriliyor.
Bu ilişkinin:
R1 (A, B) ve R2 (B, C)
ilişkilerine ayrıştırıldığım düşünelim. Bu
ilişkinin, F' deki işlevsel bağımlılıkları sağlayan
bir örneği ( r ) Çizim 4.8.a'da görülmektedir.
4.8.b'de bu ilişkinin AB ve BC niteliklerine
göre izdüşümleri olan r1 ve r2 yer almaktadır.
Çizim 4.8.c'de r1 ve r2
ilişkilerinin
birleştirilmesi ile elde edilen r3
ilişkisi
görülmektedir, r,r1
, r2 ve r3
incelendiğinde,
r'nin izdüşümleri alınıp izdüşümler arasında
doğal birleştirme işlemi uygulanarak elde
edilen r3
ilişkisinin r ilişkisine eşit olmadığı
görülmektedir. Bu da ayrıştırmanın yitimsiz
olmadığını (yitimli olduğunu) gösterir.
Oysa ilişkinin başlangıçtaki örneği r değil r3
olsaydı, r3
'ün AB ve BC'ye göre izdüşümlerini
aldığımızda yine aynı r1 ve r2 elde edilir; bu
iki ilişki birleştirildiğinde bulunacak ilişki de
başlangıçtaki ilişkinin aynısı olurdu. Bu örnek,
ilişkinin bir olgusu üzerinde, izdüşümlerin
birleştirilmesi yöntemiyle elde edilecek olumlu
sonucun ayrıştırmanın yitimsiz olduğunu
göstermek için yeterli olamayacağını açıkça
göstermektedir.
A B C A B B C A B C
a1 b1 c1 a1 b1 b1 c1 a1 b1 c1
a2 b2 c3 a2 b2 b2 c3 a1 b1 c2
a3 b1 c2 a3 b1 b1 c2 a2 b2 c3
a4 b2 c4 a4 b2 b2 c4 a2 b2 c4
a)r b)r1 =∏AB c) r2 =∏BC (r) a3 b1 c1
a3 b1 c2
a4 b2 c3
a4 b2 c4
d)r3= r1 r3
Çizim 4.8. Örnek 4.15 'teki Ayrıştırmanın Yitimsizliğinin
İncelenmesi
İkili Bir Ayrıştırma İçin Yitimsizlik
Koşulu
Tanım: Bir R ilişki şeması ve nitelikler arası F
işlevsel bağımlılık kümesi verildiğinde, R'nin
{R1
, R2} ikili ayrıştırması, eğer aşağıdaki
koşullar sağlanıyorsa yitimsizdir.
K1
. R1 ve R2
' de ortak nitelik ya da nitelikler
bulunmalıdır.
(Eğer R(X,Y,Z) ise R1 (X,Y) ve
R2(X,Z)olmalıdır).
K2
. R1 ve R2
'deki ortak nitelik ya nitelikler
(X) R1 ve R2
'den en az birinin anahtarı
olmalıdır, ( X  R1 ya da X  R2 işlevsel
bağımlılıklarından en az biri F+ da
bulunmalıdır).
Başka bir deyişle, {R1
, R2} ikili
ayrıştırmasının yitimsiz olması için:
(R1 ∩ R2)  R1 ve ( R1∩ R2)  R2
İşlevsel bağımlılıklarından en az birinin F+
da bulunması gereklidir.
Örnek 4.15’deki ikili ayrıştırmayı incelersek,
R1 ve R2
ilişki şemasındaki ortak nitelik B'dir.
Ancak B ne R1 ne de R2
ilişkisinin anahtarıdır
(F+ da ne B  A ne de B  C işlevsel
bağımlılığı vardır). Bu nedenle de bu
ayrıştırma yitimsiz-birleştirme ayrıştırması
değildir.
Örnek 4.16. R (A, B, C, D, E) ilişki şeması
ve nitelikler arası aşağıdaki işlevsel bağımlılık
kümesi veriliyor (Çizim 4,9).
F: A  BC
D  B
E A
CD  E
Bu ilişki R1 (A, B, C) ve R2 (A, D, E)
ilişkilerine ayrıştırılıyor. Bu ayrıştırma yitimsiz
midir?
R1 ve R2
ilişkilerindeki ortak nitelik A' dır. A R1
ilişkisinin anahtarı olduğu için bu ayrıştırma
yitimsizdir.
Çizim 4.9. Örnek 4.16 daki ilişki şeması için
işlevsel bağımlılık çizeneği
A
E C D
B
Ayrıştırmaların Yitimsizlik Sınaması
Yukarıda sunulan yöntem yalnız ikili
ayrıştırmaların yitimsizliğini sınamak için
kullanılabilir. Bir ilişki ikiden çok ilişkiye
ayrıştırıldığında, bu ayrıştırmanın yitimsizliği
yukarıdaki yöntemle sınanamaz. Aşağıda
sunulan yöntem genel amaçlı olup herhangi
bir ayrıştırmanın yitimsizliğini sınamak için
kullanılabilir.
Yitimsiz Ayrıştırma Algoritması
R (Aı, A2
, A3
,..., An) bir ilişki şeması, F bu
ilişki şeması üzerinde tanımlı bir işlevsel
bağımlılık kümesi olsun. R ilişkisinin {R1
, R2
,
R3
, ... , Rk} ayrıştırmasının yitimsiz olup
olmadığı aşağıdaki algoritma ile bulunabilir.
1. Ayrıştırmadaki her Ri
ilişkisi için bir satırı;
her Aj niteliği için de bir kolonu bulunan n
satır, k kolonlu bir çizelge oluştur. Her satır
başlığına bir ilişkinin (Ri) adını, her kolon
başlığına da bir niteliğin (Aj) adını yaz. Eğer
ilişki/nitelik adları sıradan dizinli (1'den n'e ;
1'den k'ya) adlar değilse, satırlara/kolonlara
1'den başlayarak sıra numarası ver.
2.Çizelgenin i. Satır j. Kolonundaki elemanına:
Eğer Ri
ilişkisinde Aj niteliği varsa : aj yaz.
Eğer Ri
ilişkisinde Aj niteliği yoksa : bij yaz.
3.F ‘deki her (f: X  Y) işlevsel bağımlılığı
için:
Eğer 2 ya da daha çok satırda, X'i oluşturan
tüm kolonlardaki değerleri aynı ise:
bu satırlarda Y'yi oluşturan tüm kolonlardaki
değerleri eşitle (eğer eşitlenecek değerlerden
enaz biri aj
ise hepsini aj yap; hiçbiri aj değil
hepsi b'lerden oluşuyorsa, aralarından
rastgele birini seç ve diğerlerini buna eşitle).
4. Çizelgede değişiklik olduğu sürece,
satırlardan biri tüm a'lardan oluşuncaya kadar
3. adımı tekrarla.
5. Sonuçta eğer satırlardan biri tüm a'lardan
(a1
, a2
, a3
, ... , ak) oluşuyorsa ayrıştırma
yitimsizdir; değilse ayrıştırma yitimsiz değildir.
Örnek 4.16'daki İlişki şeması ve İşlevsel
bağımlılık kümesi için aşağıdaki ayrıştırmanın
yitimsiz olup olmadığını araştıralım.
R1 (A, B, C)
R2(A,E)
R3 (C, D, E)
Bu ayrıştırmanın yitimsizliğini sınamak
üzere, yukarıdaki algoritmaya göre
oluşturulan sınama çizelgesinin başlangıç
durumu Çizim 4.10.a'da görülmektedir .
Algoritmaya uygun olarak çizelge üzerinde
aşağıdaki değişiklikler yapılır.
A  BC kullanılarak, R1 ve R2 satırlarının A
kolonundaki değerler eşit olduğu için, bu
satırların B ve C kolonundaki değerler de
eşitlenir (b22 yerine a2 , b23 yerine de a3
yazılır)
E  A kullanılarak, R2 ve R3 satırlarının E
kolonundaki değerler eşit olduğu İçin, bu
satırların A kolonundaki değerler de eşitlenir
(b31 yerine a1 yazılır).
A  BC kullanılarak, R1 ve R3 satırlarının A
kolonundaki değerler eşit olduğu için, bu
satırların B kolonundaki değerler de eşitlenir
(b32yerine a2 yazılır; C kolonundaki değerler
zaten eşit olduğu için herhangi bir değişiklik
yapılmaz.).
Sonuçta R3 satırı tüm a'lardan oluştuğu için
(Çizim 4.10.b) ayrıştırma yitimsizdir.
1 2 3 4 5
A B C D E
R1
R2
R3
a1 a2 a3 b14 b15
a1 b22 b23 b24 a5
b31 b32 a3 a4 a5
1 2 3 4 5
A B C D E
R1
R2
R3
a1 a2 a3 b14 b15
a1 b22 a2 b23 a3 b24 a5
b31 a1 b32 a2 a3 a4 a5
7.2. Ayrıştırmanın İşlevsel
Bağımlılıkları Koruması
Her işlevsel bağımlılık bir bütünlük
kısıtlamasıdır. Veri tabanının bütünlüğünün ve
tutarlılığının korunması için yapılan her
günleme (ekleme, silme ve değişiklik)
işleminde işlevsel bağımlılıkların sağlandığının
denetlenmesi gerekir. Bu denetimlerin her
birinin, birden çok ilişkinin birleştirilmesini
gerektirmeden, tek bir ilişki üzerinde
yapılabilmesi gerekir
Bunun için de bir R ilişki şeması ve
nitelikler arası F işlevsel bağımlılık kümesi
verildiğinde ve R ilişkisi R1
, R2 , R3
,… , Rk
ilişkilerine ayrıştırıldığında, F'deki işlevsel
bağımlılıklardan her birinin bir Ri
'de
bulunması, ya da Ri’
lerdeki işlevsel
bağımlılıklardan türetilebilmesi gerekir.
R (A1, A2
, A3,…, An) bir ilişki şeması, F bu
ilişki şeması üzerinde tanımlı bir işlevsel
bağımlılık kümesi olsun,R ilişkisinin {R1
, R2,
R3
,…, Rk} ayrıştırmasının işlevsel
bağımlılıkları koruyup korumadığı aşağıdaki
gibi bulunur.
İşlevsel Bağımlılıkların Korunması Algoritması
1.F+ nın her Ri üzerindeki izdüşümü bulunur.
Fi = pRi (F +) = { f (X  Y) : f ∈ F + ve X, Y ⊆
R}
2. F lerin küme birleşimi bulunur.
G=F1 ∪ F2 ∪ … ∪ Fk
3. Sonuçta eğer G F’ e eşdeğer ise (F’ deki her
işlevse bağımlılık G ‘ de varsa, ya da G’
dekilerden türetilebiliyorsa, başka bir deyişle
F + = G + ise) ayrıştırma işlevsel bağımlılıkları
korumaktadır. Değilse ayrıştırma da bazı
işlevsel bağımlılıklar yitirilmiştir. Yitirilen
işlevsel bağımlılıklar F’ de bulunup G’ de
bulunmayan ve de G’ de ki işlevsel
bağımlılıklardan türetilemeyenlerdir.
Bir kez daha örnek 4.16'daki ilişki şeması ve
işlevsel bağımlılık kümesini ele alalım ve bu
ilişkinin aşağıdaki ayrıştırmasını inceleyelim.
Rı (A, B, C)
R2 (A, E)
R3 (C,D,E)
Bu ayrıştırmanın işlevsel bağımlılıkları
koruyup korumadığını araştıralım. Bunun için
önce F+ yı bulalım.
F+ : A BC
D  B
E  ABC
CD  AE
AD  E
Şimdi de F+ nın Ri
'lere göre izdüşümlerini ve
bunların küme birleşimini bulalım.
F1={A  BC }
F2={E  A}
F3={CD  E}
G= F1 ∪ F2 ∪ F3 = {A  BC, E A, CD E}
F’ deki işlevsel bağımlılıklardan biri (D  B)
G’ de yoktur ve G’ deki işlevsel
bağımlılıklardan türetilemez. Bu nedenle daha
önce yitimsiz olduğunu gördüğümüz bu
ayrıştırma işlevsel bağımlılıkları
korumamaktadır. Bu nedenle de geçerli bir
ayrıştırma değildir.
Örnek 4.17. R (A,B,C,D) ilişki şeması ve
nitelikler arası aşağıdaki işlevsel bağımlılık
kümesi veriliyor(Çizim 4.11).
F : A  B
B C
C  D
D  A
R ilişkisinin {R1(A,B), R2(B,C), R 3(C,D)}
ayrıştırması yitimsiz bir ayrıştırmadır. Bu
ayrıştırma acaba işlevsel bağımlılıkları koruyor
mu?
F+ : A BCD
B  CDA
C  DAB
D  ABC
F1={A  B, BA}
F2={B  C, C B}
F3={C  D, D C}
G: A  B
B  AC
C  BD
D  C
F’ deki işlevsel bağımlılıklardan ilk üçü G’ de
vardır. Sonuncu işlevsel bağımlılık ise (D A)
G’ de yoktur. İlk bakışta ayrıştırmanın bu
işlevsel bağımlılığı koruyamadığı sanılabilir.
Ancak türetme kuralları ile G’ deki işlevsel
bağımlılıklardan bu işlevsel bağımlılık
türetilebilir ( D  C  A  D  A).
Bu nedenle de bu ayrıştırma işlevsel
bağımlılıkları korumaktadır.
Çizim 4.11Örnek 4.17 deki ilişki şeması için
işlevsel bağımlılık çizeneği
A B C D
7.3. BCNF Ayrıştırma
Algoritması
Bir R ilişki şeması (nitelik kümesi) ve
nitelikler arası F işlevsel bağımlılık kümesi
verildiğinde, eğer R BCNF bir ilişki değilse,
ilişkisinin BCNF İlişkilere ayrıştırılması için
aşağıdaki algoritma kullanılabilir.
BCNF Ayrıştırma Algoritması
1.R1 = R , k=1 T={R1}
2.F+ yı hesapla
3. T’ deki ilişkilerden BCNF olmayan her Ri
için:
F+’ daki işlevsel bağımlılıklardan, Ri
de tanımlı önemli her X  Y işlevsel bağımlılığı
için eğer X Ri
‘nin anahtarı değilse (X Ri F+‘ da yoksa)
Ri’ den Y’ deki nitelikleri çıkar, k’ yı 1 arttır, T’
ye Rk
(X,Y) ilişki şemasını ekle.
4. T ‘deki tüm ilişkiler BCNF oluncaya dek 3.
adımı tekrarla.
BCNF ayrıştırma algoritması ile elde edilen
ayrıştırma yitimsiz bir ayrıştırma olur. Ancak
ayrıştırmanın işlevsel bağımlılıkları koruma
güvencesi yoktur. Başka bir deyişle BCNF
ayrıştırma algoritması ile bulunacak ayrıştırma
yitimsiz ayrıştırmadır ancak işlevsel
bağımlılıkların bir kesimini korumayabilir.
Örnek 4.18. R (A, B, C, D, E) ilişki şeması ve
nitelikler arası aşağıdaki işlevsel bağımlılık
kümesi veriliyor (Çizim 4.12).
F: A  CDE
E  B
CD  E
Çizim 4.12'de R ilişkisinin tek anahtarının A
olduğu ve R' nin bir BCNF ilişki olmadığı
kolayca görülmektedir. BCNF ayrıştırma
algoritması uygulanarak aşağıdaki ayrıştırma
bulunur.
F+ : A  BCDE
E  B
CD  BE
BCNF ayrıştırma:
R1 (A, C, D)
R2 (C, D, E)
R3 (E, B)
Bu ayrıştırma yitimsizdir. Ayrıca ayrıştırma
İşlevsel bağımlılıkları da korumaktadır
Çizim 4.12 Örnek 4.18 deki ilişki şeması için
işlevsel bağımlılık çizeneği
A
E
D
C
B
Örnek 4.19. R (A,B,C) ilişki şeması ve
nitelikler arası F ={AB  C, C  A } işlevsel
bağımlılık kümesi veriliyor. İşlevsel
bağımlılıklardan ilişkinin anahtarlarının AB ve
BC olduğu, tüm nitelikler asal nitelik olduğu
için ilişkinin 3NF bir ilişki olduğu, ancak ancak
anahtar olmayan bir belirleyen olduğu için
ilişkinin BCNF bir ilişki olmadığı görülür.Önce
F+ yı bularak BCNF ayrıştırma algoritmasını
uygulayalım.
F+ : AB  C
C A
BCNF ayrıştırma:
R1 (B,C)
R2 (C,A)
Bu ayrıştırma yitimsizdir. Ancak
ayrıştırmada AB  C bağımlılığı
yitirilmektedir. Bu nedenle ayrıştırma
yitimsizdir ancak işlevsel bağımlılıkları
koruyamamaktadır.
7.4. 3NF Ayrıştırma Algoritması
Bir R ilişki şeması (nitelik kümesi) ve
nitelikler arası F işlevsel bağımlılık kümesi
verildiğinde, eğer R bir 3NF ilişki değilse
(ilişkinin biçimi 1NF ya da 2NF ise), R‘nin 3NF
ilişkilere ayrıştırılması için aşağıdaki algoritma
kullanılabilir.
3NF ayrıştırma algoritması
1. k=1, T={ }
2. Fc yi hesapla
3.Fc deki her X Y işlevsel bağımlılığı için:
eğer T’ deki Ri
ilişki şemalarından hiçbiri XY
niteliklerini içermiyorsa: k’yı 1 arttır, T’ ye Rk
(X, Y) ilişki şemasını ekle.
3NF ayrıştırma algoritması ile hem yitimsiz
olan, hem de işlevsel bağımlılıkları koruyan
ayrıştırmalar elde edilir. BCNF ayrıştırma
algoritması ile her zaman işlevsel bağımlılıkları
koruyan bir ayrıştırma bulmak mümkün
değilken, 3NF ayrıştırma algoritması ile her
zaman işlevsel bağımlılıkları koruyan bir
ayrıştırma bulmak mümkündür.
Buna göre, herhangi bir ilişki verildiğinde,
eğer ilişki BCNF değilse işlevsel bağımlılıkları
koruyan bir BCNF ayrıştırma bulunmaya
çalışılır. Eğer böyle bir ayrıştırma bulunamazsa
ve ilişkinin biçimi 3NF de değilse, bir 3NF
ayrıştırma bulunur. Bu ayrıştırma işlevsel
bağımlılıkları koruyan bir ayrıştırma olacaktır.
BCNF ve 3NF ayrıştırma algoritmaları
arasındaki bir diğer fark da bulunacak
ayrıştırma sayısı ile ilgilidir. Bir R ilişki şeması
ve nitelikler arası F işlevsel bağımlılık kümesi
verildiğinde, birden çok BCNF ayrıştırma
bulunabilir. Bunların tümü yitimsizdir.
Ancak bir bölümü ya da tümü işlevsel
bağımlılıkları korumayabilir. 3NF ayrıştırma
algoritması ile her Fc
için tek bir ayrıştırma
elde edilir. Bu ayrıştırma hem yitimsizdir hem
de işlevsel bağımlılıkları korur. Birden çok 3NF
ayrıştırma elde edilebilmesi için F' nin birden
çok kanonik örtüsünün (Fc) bulunması
gereklidir.
Örnek 4.20. R (A,B,C,D,E,G) ilişki şeması ve
nitelikler arası işlevsel bağımlılık kümesi
veriliyor(Çizim 4.13).
F : AB  CD
AC  E
DE  G
F’ deki işlevsel bağımlılıklar
incelendiğinde,ilişkinin tek anahtarının AB
olduğu ve geçişli bağımlılıklar nedeniyle de
ilişkinin biçiminin 2NF olduğu görülür. F zaten
kanonik biçimdedir (Fc=F) 3NF ayrıştırma
algoritması ile aşağıdaki ayrıştırma elde edilir.
3NF Ayrıştırma
R1 (A,B,C,D)
R2 (A,C,E)
R3(D,E,G)
R için BCNF ayrıştırmaları bulmak
istediğimizde, F+ yı hesaplayıp algoritmayı
uyguladığımızda, aşağıdaki 2 ayrıştırmadan
birini bulabiliriz.
F+ :AB  CDEG
AC  E
DE  G
ACD  G
BCNF Ayrıştırmalar:
1.Ayrıştırma 2.Ayrıştırma
R1 (A,B,C,D) R1 (A,B,C,D)
R2 (A,C,E,) R2 (A,C,E,)
R3 (D,E,G) R3 (A,B,G)
Bu ayrıştırmalardan ilki işlevsel bağımlılıkları
korumaktadır. İkinci ayrıştırmada ise DE  G
işlevsel bağımlılığı yitirilmektedir.
Çizim 4.13 Örnek 4.20 deki ilişki şeması için
işlevsel bağımlılık çizeneği
A C
B D E G
7.5 BCNF ve 3NF Normal Biçimlerinin
Karşılaştırılması
Yukarıdaki iki algoritmayla bir İlişki
şemasının BCNF ve 3NF İlişki şemalarına
ayrıştırılabileceğini gördük. Bu İki biçimin artı
ve eksi yönleri aşağıda İncelenmektedir.
1. BCNF İlişkiler 3NF ilişkilere göre daha
sorunsuz, aykırılıklara yol açmayan ve
bakımı daha kolay ilişkilerdir. Ancak BCNF
ayrıştırma algoritması, elde edilecek
ayrıştırmanın yitimsizliğini güvencelemekle
birlikte işlevsel bağımlılıkların korumasını
güvencelememektedir. İşlevsel
bağımlılıkların korunmaması ise sakıncalıdır.
Bu nedenle verilen bir İlişki şeması için,
BCNF ayrıştırma algoritması ile işlevsel
bağımlılıkları koruyan bir ayrıştırma elde
edilebiliyorsa, bu ayrıştırma öncelikle tercih
edilmelidir. Eğer böyle bir ayrıştırma elde
edilemiyorsa, 3NF ilişki şemaları kullanmak
daha uygun olabilir.
2. 3NF ayrıştırma algoritması ile elde edilen
ayrıştırmanın hem yitimsiz olması hem de
işlevsel bağımlılıkları koruması bir
üstünlüktür. Ancak BCNF koşulunu
sağlamayan 3NF ilişkilerin kimi sakıncaları
vardır. Bu sakıncaların bir bölümü veri tekrarı
ve günleme aykırılıklarıdır.
Diğer bir bölümü ise “null” değeri
kullanılarak aşılabilecek ekleme silme
aykırılıklardır Yukarıdaki açıklamalardan da
anlaşılabileceği gibi ilişkisel tasarımda birinci
öncelik işlevsel bağımlılıkları koruyan bir BCNF
ayrıştırma bulmaktır. Eğer bu özellikte bir
ayrıştırma elde edilemiyorsa aşağıdaki
seçeneklerden birini seçmek gerekecektir.
A. İşlevsel bağımlılıkları korumayan(birkaç
işlevsel bağımlılığı yitiren) BCNF ayrıştırma ile
elde edilen BCNF ilişkilerdir.
B. İşlevsel bağımlılıkları koruyan 2NF ayrıştırma
ile elde edilen 3NF ilişkiler.
Bu seçeneklerin her ikisinin de belirli
sakıncaları vardır. A seçeneğinde yitirilen
işlevsel bağımlılıkların denetimi
yapılamayacaktır. Mutlaka yapılmak istenirse
de bu denetimlerin yapılması çok güç ve çok
pahalı olacaktır. B seçeneğinde ise günleme,
ekleme ve silme aykırılıkları oluşabilir.
Genel değerlendirmede, B seçeneğinde
“null” değerler kullanılarak ekleme ve silme
aykırılıklarının aşılabileceği günleme
aykırılıklarının oluşmaması içinde gerekli
önlemlerin alınabileceği; böylece B
seçeneğinin sakıncalarının azaltılabileceği ve A
seçeneğine tercih edilebileceği söylenebilir.
8.Çok Değerli Bağımlılık Ve Dördüncü Normal
Biçim
8.1Çok Değerli Bağımlılığın Tanımı
Nitelikler arasındaki tüm bağımlılıklar işlevsel
değildir. Nitelikler arasında çok değerli
bağımlılık olarak adlandırılan bağımlılıklar da
bulunabilir. Çok değerli bağımlılığın biçimsel
tanımını vermeden önce aşağıdaki örneği
inceleyelim.
Örnek 4.21.
PERSONEL(ÇALIŞAN,ÜCRETİ,ÇOCUĞU)
F: ÇALIŞAN  ÜCRETİ
Yukarıda tanımlanan PERSONEL
ilişkisindeki nitelikler arasında tek bir işlevsel
bağımlılık (ÇALIŞAN  ÜCRETİ ) vardır.
İlişkinin bir örneği çizim 4.14’ de
görülmektedir.
Bu ilişkide ÇALIŞAN ve ÇOCUĞU nitelikleri
arasında çok değerli bağımlılık vardır. Bu
bağımlılık “ her çalışanın belirli sayıda çocuğu
vardır ve bunlar çalışanın ücretinden
bağımsızdır” gerçeğine karşı gelmektir.
Bu çok değerli bağımlılık ÇALIŞAN 
ÇOÇUĞU biçiminde gösterilir ve ÇALIŞAN
ÇOÇUĞU’ nu çok değerli belirler ya da
ÇOCUĞU ÇALIŞAN’ na çok değerli bağımlıdır
biçiminde ifade edilir.
Çizim 4.14 Örnek 4.21’ deki PERSONEL İlişkisinin
Bir Örneği
ÇALIŞAN ÜCRETİ ÇOCUĞU
Metin
Mehmet
Mehmet
Mehmet
Kaya
Kaya
Temel
500
300
300
300
500
500
600
Hasan
Ahmet
Ayşe
Hüsnü
Kemal
Mustafa
Fatma
Çok Değerli Bağımlılığın Biçimsel Tanımı
R (A1
,A2
,A3
,…,An) ilişki şemasındaki (nitelik
kümesindeki) nitelikleri 3 ayrı altkümeye (X,Y
ve Z) ayıralım.
X ∪Y ∪ Z = R ∩ X ∩ Y ∩ Z = { }
x ve z birer değişmez olmak üzere Yxz ile X
niteliklerinin değeri x, Z niteliklerinin değeri
ise z olan çoklulardaki Y niteliklerinin
değerlerinin kümesini gösterelim.
Yxz ={ y: < x,y,z > ∈ r}
Eğer Yxz yalnız x‘e bağımlı ise (z‘den bağımsız
ise), başka bir deyişle:
Yxz
1 = Yxz
2 =…=Yxz
n
İse, R ilişkisinde X  Y çok değerli bağımlılığı
vardır denir.
Örnek 4.22. R(DERS,KİTAP,ÖĞRETMEN)
R ilişkisinde her çoklu hangi dersin, hangi
kaynak kitap ile, hangi öğretmen tarafından
verilebileceğini göstermektedir. İlişkinin bir
örneği Çizim 4.15’ de yer almaktadır
Çizimde de görüldüğü gibi, her ders
kullanılan kaynak kitaptan bağımsız olarak,
belirli öğretmenler tarafından
verilebilmektedir. Örneğin “Mat” dersini
verebilecek öğretmenler “Ali” ve “Mehmet”
öğretmenlerdir.
ÖĞRETMENMat,K1 = ÖĞRETMENMat,K2 = {Ali,
Mehmet}
Bu nedenle, DERS ve ÖĞRETMEN nitelikleri
arasında çok değerli bağımlılık vardır; DERS
ÖĞRETMEN' i çok değerli belirlemektedir.
DERS  ÖĞRETMEN
Diğer taraftan her ders için kullanılabilecek
belirli kaynak kitaplar vardır ve bunlar dersi
veren öğretmenden bağımsızdır. Örneğin Mat
dersi için kullanılabilecek kaynak kitaplar,
ders ister Ali ister Mehmet öğretmen
tarafından verilsin, K1 ve K2'dir
Fizik dersi için kullanılabilecek kaynak
kitaplar ise, ders ister Ali ister Kemal
öğretmen tarafından verilsin K1, K3 ve
K4'tür.
KİTAP Mat, Ali = KİTAP Mat , Mehmet = {K1, K2)
KİTAP Fizik , Ali = KİTAP Fizik, Kemal = {K1, K3,
K4}
DERS KİTAP ÖĞRETMEN
Mat.
Mat.
Mat.
Mat.
Fizik
Fizik
Fizik
Fizik
Fizik
Fizik
K1
K2
K1
K2
K3
K4
K1
K3
K4
K1
Ali
Ali
Mehmet
Mehmet
Ali
Ali
Ali
Kemal
Kemal
Kemal
8.2. İlişkiler İçin 4. Normal Biçim
(4NF)
4NF ilişki tanımını vermeden önce önemli ve
önemsiz çok değerli bağımlılık tanımlarını vermek
gereklidir.
R (X, Y) ilişkisinde X  Y, Y  X ve X ∅ çok
değerli bağımlılıkları önemsiz çok değerli
bağımlılıklardır. Bunların dışındaki çok değerli
bağımlılıklar ise önemli çok değerli bağımlılıklar
olarak nitelenir. Kısaca "çok değerli bağımlılık"
denildiğinde de önemli çok değerli bağımlılıklar
anlaşılır.
4NF İlişki Tanımı
Eğer bir R ilişkisinde, K bir anahtar olmak
üzere:
Tüm işlevsel bağımlılıklar K  X
tüm çok değerli bağımlılıklar da K  Y
biçiminde ise R ilişkisi 4. Normal Biçimdedir
(4NF) denir.
Önermeler
1. Eğer bir ilişki 4NF ise bu ilişki aynı zamanda BCNF' dir.
Başka bir deyişle 4NF ilişkiler kümesi BCNF ilişkiler
kümesinin bir altkümesidir.
2. X ∩ Y = ∅ olmak üzere, eğer X Y ‘yi işlevsel belirtiyorsa; X
Y‘ yi aynı zamanda çok değerli de belirliyordur. Başka bir
deyişle her işlevsel bağımlılık aynı zamanda bir (önemli
ya da önemsiz) çok değerli bağımlılıktır.
X Y  X Y
Ancak bunun tersi doğru değildir: her çok değerli bağımlılık
bir işlevsel bağımlılık değildir.
SHIPPING (Ship, Capacity, Date, Cargo, Value)
Ship  Capacity
ShipDateCargo
CargoCapacityValue
R1
(Ship,Capacity) with the FD Ship
Capacity
R2
(Ship, Date, Cargo, Value) with the FD
ShipDateCargo
R1
(Cargo, Capacity, Value) with the FD
CargoCapacityValue
R2
(Ship, Capacity ) with the FD Ship
Capacity
R2
(Ship, Date, Cargo) with the FD
ShipDate Cargo
<(ABCD), {AB  C, C  A} >
<(ABC),{AB  C, C  A} >
<(ABC), {AB  C, C  A>}
<(AC), {C  A} > and <(BC), { }>
VERİ TABANI SİSTEMLERİ
(BMÜ 329)
Fırat Üniversitesi
Bilgisayar Mühendisliği
2
Kaynaklar
• Veri Tabanı Sistemleri, Ünal Yarımağan,
Akademi & Türkiye Bilişim Vakfı (2002)
• Fundementals of Database Systems,
Elmasri, Navathe, Addision-Wesley, 2000
• An Introduction to Database Systems,
Bipin C. Desai, West Publishing Company,
1990
3
Veri Tabanı Yönetim Sistemi
(VTYS)
• VTYS, veri tabanı sistemlerini tanımlamak,
oluşturmak, kullanmak, değiştirmek ve veri
tabanı sistemleri ile ilgili her türlü işletimsel
gereksinimleri karşılamak için kullanılan geniş
kapsamlı yazılım sistemidir.
• VTYS, birbirleri ile ilişkili veri ve programlar
topluluğundan oluşmaktadır.
• Veri tabanı olarak adlandırılan veri topluluğu, bir
kuruluşa ait bilgilerin düzenli bir yapı içerisinde
saklandığı ortamdır.
• Programlar ise saklanan bu verilerin yönetildiği
ortamlardır.
4
VTYS’nin Temel Bileşenleri
Veri
Tabanı
Yöneticisi
Veri Tanımlama
Dili (DDL)
Derleyicisi
Sorgu İşleyicisi
(SQL)
Tablo yaratma
Form yaratma
Sorgu yaratma
Rapor yaratma
Kayıt ekleme
Kayıt silme
Kayıt güncelleme
Veri Tabanı
Genişletilmiş
Programlama
Dili (DML +
taşıyıcı dil)
Derleyicisi
Uygulama
Programı
VT
Sorgusu
VT
Tanımları
Derlenmiş
Uygulama
Programı
Derlenmiş
VT
Tanımları
Kullanıcı verileri
Metadata
Dizinler
Uygulama Metadatası
Veri Tabanını
Oluşturma
Veri Tabanını
Kullanma
5
Neden VTYS?
• VTYS yaklaşımında veri girişi ve
depolanması veriye erişen uygulama
programlarından bağımsızdır.
• Klasik dosya kullanımında ise, kayıt
desenleri ve dosya yapılarında ortaya
çıkabilecek en ufak bir değişiklik bile
uygulama programlarının değiştirilmesine
neden olmaktadır.
6
Veri Tabanı Sistemlerinin
Üstünlükleri (1)
• Gereksiz veri tekrarını önler.
– Tüm uygulamaların gereksinim duyduğu
veriler birbirleri ile bütünleşik yapıdadır.
Dolayısıyla veri kaynağı tek olarak tasarlanır,
böylece veri tekrarı önlenmiş olur.
– Örneğin, Türkiye’deki il kodları ve isimleri hem
personel alt sisteminde hem de pazarlama alt
sisteminde ayrı ayrı tutulmaz.
7
Veri Tabanı Sistemlerinin
Üstünlükleri (2)
• Veri bütünlüğünü (data integrity) sağlar.
– Veri bütünlüğü, verinin doğruluğunu ve
tutarlılığını anlatmaktadır.
– Veri bütünlüğü için bazı kısıtlamalar
tanımlanabilir.
– Örneğin, öğrenci bilgileri girilirken doğduğu il
koduna 100 değeri girilirse, yanlış bilgi
nedeniyle bu isteğin yerine getirilmemesi
istenebilir.
8
Veri Tabanı Sistemlerinin
Üstünlükleri (3)
• Verilerin güvenliğini sağlar.
– Tüm verilere her kullanıcının kolayca
erişebilmesi çoğu zaman istenmeyen bir
durumdur.
– Her kullanıcıya çeşitli yetkiler atanarak, bu
kullanıcının erişebileceği, değiştirebileceği ve
silebileceği veriler ayrı ayrı tanımlanabilir.
– Örneğin, pazarlama bölümünde çalışan bir
kullanıcının diğer personelin özlük bilgilerine
ulaşması engellenebilir.
9
Veri Tabanı Sistemlerinin
Üstünlükleri (4)
• Aynı zamanda yapılan erişimlerde
tutarsızlıkların ortaya çıkmasını önler.
– İki veya daha fazla kullanıcı aynı anda aynı
veri üzerinde değişiklik yapmak istediğinde,
yetkiye ve/veya kimin önce eriştiğine bakarak,
birine önceliği verir, diğerlerini bekletir.
10
Veri Tabanı Sistemlerinin
Üstünlükleri (5)
• Veriler üzerinde merkezi denetim sağlar.
– Kullanıcılar işletim sistemi komutları ya da
genel amaçlı programlama dilleri ile yazılmış
uygulama programlarını kullanarak doğrudan
veri tabanındaki verilere erişemezler ve bu
verileri değiştiremezler.
– Veri tabanı kullanımı yalnız VTYS (DBMS -
Data Base Management System) olarak
adlandırılan yazılım sistemi aracılığıyla
mümkündür.
11
Veri Tabanı Sistemlerinin
Üstünlükleri (6)
• Veri tabanının bilgisayar belleklerindeki fiziksel
yapısı kullanıcılardan gizlenir.
– Kullanıcılara daha yalın mantıksal yapılar sunulur.
– VTYS, bir anlamda yüksek düzeyli programlama dili
derleyicisi gibi davranarak kullanıcının, soyut terimler
kullanarak veri tabanıyla ilişki kurmasını sağlar.
– Böylece kullanıcı, sistem tarafından kullanılan
karmaşık veri gösterimleri ve algoritmaların
ayrıntılarıyla uğraşmadan, neyin yapılmasını istediğini
belirterek isteklerini ortaya koyabilir.
12
VTYS’nin Temel Bileşenleri (1)
Veri
Tabanı
Yöneticisi Sorgu İşleyicisi
(SQL)
Tablo yaratma
Form yaratma
Sorgu yaratma
Rapor yaratma
Kayıt ekleme
Kayıt silme
Kayıt güncelleme
Veri Tabanı
Genişletilmiş
Programlama
Dili (DML +
taşıyıcı dil)
Derleyicisi
Uygulama
Programı
VT
Sorgusu
VT
Tanımları
Derlenmiş
Uygulama
Programı
Derlenmiş
VT
Tanımları
Kullanıcı verileri
Metadata
Dizinler
Uygulama Metadatası
Veri Tabanını
Oluşturma
Veri Tabanını
Kullanma
Veri Tanımlama
Dili (DDL)
Derleyicisi
13
Veri Modeli
• Her Veri Tabanı Yönetim Sistemi bir Veri Modeli
(Data Model) kullanır.
• Veri modeli, verileri mantıksal düzeyde
düzenlemek için kullanılan yapılar, kavramlar ve
işlemler topluluğu olarak tanımlanır.
• Veri tabanını tasarlayan kullanıcı, veri modelinin
yapılarını ve kavramlarını kullanarak mantısal
düzeydeki düzenlemelerini oluşturur, veri tabanı
tasarım belirtimlerini hazırlar.
• Hazırlanan tasarım belirtimleri biçimsel
tanımlara dönüştürülerek Veri Tabanı Yönetim
Sistemine girilir.
14
Veri Tanımlama Dili (VTD)
• Veri tabanı tanımlarını VTYS'ye iletmek için
kullanılan biçimsel dile Veri Tanımlama Dili
(DDL: Data Definition Language) adı verilir.
• Veri Tanımlama Dili kullanılarak oluşturulan veri
tabanı tanımları, VTYS'nin Veri Tanımlama Dili
Derleyicisi olarak adlandırılabilecek bir bileşeni
tarafından çözümlenir, varsa eksik ve yanlışları
bulunarak kullanıcıya iletilir.
• Yanlışlardan arınmış veri tabanı tanımları VTYS
tarafından uygun yapılara dönüştürülerek
saklanır.
15
Veri Tanımlama Dili (VTD)
• Veri tabanı tanımlarının VTYS tarafından
derlenerek saklanması veri tabanı yaklaşımının
temel özelliklerinden biridir.
• Bu süreç sayesinde, veri tabanı tanımlarının
yetkili kişiler tarafından bir kez yapılması,
tanımların kalıcılığının sağlanması ve
kullanıcıların bu tanımları kullanmaları ve bu
tanımlara uygun işlem yapmaları sağlanmış olur.
• Programlama dili kullanılarak gerçekleştirilen
dosya tabanlı uygulamalarda, bilgisayar
belleklerinde yalnız veri saklanır. Uygulama
programlarında, veri üzerinde yapılacak işlemler
yanında verinin tanımı da yer alır.
16
Veri Tanımlama Dili (VTD)
• Veri tabanı yaklaşımında ise veri tanımlama ile
veriler üzerindeki uygulama işlemleri birbirinden
tamamen ayrılmıştır.
• Veri tanımlama ve daha önce yapılmış tanımları
değiştirme yetkisi yalnız Veri Tabanı Sorumlusu
(Data Base Administrator) olarak adlandırılan ve
veri tabanının tümünden sorumlu olan kişi ya da
kişilere aittir.
• Veri tabanı üzerinde işlem yapan, uygulamaları
gerçekleştiren kullanıcıların ise veri tanımlama
ya da mevcut tanımları değiştirme yetkisi yoktur.
17
Veri Tanımlama Dili (VTD)
• VTD ile yapılan tanımlarda veri tabanı tanımları
içinde yer alan en önemli tanımlar şunlardır:
1. Mantıksal düzeyde yapılan düzenlemeler oluşturulan
yapılar ve her yapıda hangi verilerin yer aldığı.
2. Her verinin türü, uzunluğu, varsa varsayılan değeri
ve diğer özellikleri.
3. Veriler arası ilişkiler ve her türlü kısıtlamalar.
4. Fiziksel veri yapıları ile ilgili tercihler ve parametreler.
5. Kullanıcı tanımları ve kullanıcıların hangi veriler
üzerinde hangi işlemleri yapmaya yetkili olduklarına
ilişkin tanımlar.
18
Veri Tanımlama Dili (VTD)
• Veri tabanı tanımları veri sözlüğü (data
dictionary) olarak da adlandırılır.
• VTYS’nin fiziksel ortamında aşağıda belirtilen
çeşitli veriler saklanır:
1. veri kütükleri (dosyalar)
2. veri tabanı tanımlarının yer aldığı veri sözlüğü
3. veri kütüklerine ya da veri sözlüğüne erişim için
kullanılan dizinler (indices)
4. veri değerlerine ve uygulamalara ilişkin istatistiksel
veriler ve günlük kütükleri (logfiles)
19
VTYS’nin Temel Bileşenleri (2)
Veri
Tabanı
Yöneticisi
Tablo yaratma
Form yaratma
Sorgu yaratma
Rapor yaratma
Kayıt ekleme
Kayıt silme
Kayıt güncelleme
Veri Tabanı
Genişletilmiş
Programlama
Dili (DML +
taşıyıcı dil)
Derleyicisi
Uygulama
Programı
VT
Sorgusu
VT
Tanımları
Derlenmiş
Uygulama
Programı
Derlenmiş
VT
Tanımları
Kullanıcı verileri
Metadata
Dizinler
Uygulama Metadatası
Veri Tabanını
Oluşturma
Veri Tabanını
Kullanma
Veri Tanımlama
Dili (DDL)
Derleyicisi
Sorgu İşleyicisi
(SQL)
20
Sorgu Dili ve Sorgu İşleyicisi
• Veri tabanı uygulamaları için kullanılan en
yaygın araç sorgu dilidir.
• Kullanıcı, sorgu dili ile, gerçekleştirmek
istediği işlemi yalın bir biçimde ifade eder.
• Kullanıcının oluşturduğu sorguda, neyin
yapılmasının istendiği yer alır; bunun nasıl
yapılacağı ise yer almaz.
21
Yapısal Sorgu Dili (SQL)
• IBM, deneysel bir ilişkisel veritabanı
yönetim sistemi geliştirmek amacıyla
System/R adlı bir proje başlatır.
• Bu sistem için SEQUEL (Structured
English Query Language) adında bir sorgu
dili geliştirilmeye başlanmıştır.
• 1979’ da tamamlanan bu proje sırasında
geliştirilen dilin adı SQL (Structured Query
Language) olarak değiştirilmiştir.
22
ORACLE
• System/R projesini izleyen bir grup
mühendis, ilişkisel veritabanındaki
potansiyeli görmüş ve Relational Software,
Inc. adında bir şirket kurmuşlardır (1979)
• Oracle adını verdikleri ilk ticari ilişkisel veri
tabanı yönetim sistemini geliştirmişler ve
SQL’i bu sistemde sorgu dili olarak
kullanmışlardır.
23
SQL Örneği
• İngilizce diline çok benzeyen SQL sorgu dilinde
oluşturulmuş bir sorgu aşağıda yer almaktadır.
SELECT ADI, SOYADI, ADRESİ FROM
PERSONEL WHERE BÖLÜMNO = 17 AND
GÖREVİ = 'Sekreter’;
• Yukarıdaki sorgu ile “17 numaralı bölümde
çalışan sekreterlerin ad, soyad ve adreslerinin”
bulunmak istendiği kolayca anlaşılmaktadır.
24
Sorgu İşleyicisi
• VTYS'nin, sorguların işlenmesi ile ilgili görevleri
gerçekleştiren bileşenine Sorgu İşleyici (Query
Processor) adı verilir.
• Sorgu işleyicinin görevleri:
– Sorgunun sözdizimsel ve anlamsal özümlemesini
yapmak.
– Kullanıcının verilen işlemi yapmaya yetkili olup
olmadığını denetlemek.
– Sorguyu işletmek için kullanılabilecek algoritmaları
(işletim senaryolarını) belirlemek ve “Query
Optimizer” alt bileşeni yardımıyla en iyisini seçmek.
– Sorgunun işletimini gerçekleştirdikten sonra yanıtını
oluşturup kullanıcıya iletmek.
25
VTYS’nin Temel Bileşenleri (3)
Veri
Tabanı
Yöneticisi
Tablo yaratma
Form yaratma
Sorgu yaratma
Rapor yaratma
Kayıt ekleme
Kayıt silme
Kayıt güncelleme
Veri Tabanı
Uygulama
Programı
VT
Sorgusu
VT
Tanımları
Derlenmiş
Uygulama
Programı
Derlenmiş
VT
Tanımları
Kullanıcı verileri
Metadata
Dizinler
Uygulama Metadatası
Veri Tabanını
Oluşturma
Veri Tabanını
Kullanma
Veri Tanımlama
Dili (DDL)
Derleyicisi
Sorgu İşleyicisi
(SQL)
Genişletilmiş
Programlama
Dili (DML +
taşıyıcı dil)
Derleyicisi
26
Veri İşleme Dili (DML)
• Veri tabanı üzerinde, veriyi değiştirme,
silme ve güncelleme gibi sorgularla ifade
edilemeyecek ya da sorgularla ifade
edilmesi uygun olmayan işlemler de
gerçekleştirilir.
• Bu işlemler için Veri İşleme Dili (DML:
Data Manipulation Language) olarak
adlandırılan bir dil kullanılır.
27
Genişletilmiş Programlama Dili
• Veri tabanı üzerindeki uygulamaları gerçekleştirmek için
genişletilmiş bir dil oluşturulur.
• Bu dilde hem veri tabanı işlemlerini gerçekleştiren DML
komutları, hem de diğer işlemleri gerçekleştiren C,
Pascal, Cobol gibi genel amaçlı programlama dillerinden
bir ya da birkaçı ile yazılmış taşıyıcı dil komutları yer alır.
• Oluşturulan genişletilmiş dil (DML + taşıyıcı dil) ile
hazırlanan uygulama programları, VTYS'nin bileşeni
olan genişletilmiş derleyicilerle derlenerek saklanır ve
gerektiğinde çalıştırılarak kullanılır.
28
VTYS’nin Temel Bileşenleri (4)
Tablo yaratma
Form yaratma
Sorgu yaratma
Rapor yaratma
Kayıt ekleme
Kayıt silme
Kayıt güncelleme
Veri Tabanı
Uygulama
Programı
VT
Sorgusu
VT
Tanımları
Derlenmiş
Uygulama
Programı
Derlenmiş
VT
Tanımları
Kullanıcı verileri
Metadata
Dizinler
Uygulama Metadatası
Veri Tabanını
Oluşturma
Veri Tabanını
Kullanma
Veri Tanımlama
Dili (DDL)
Derleyicisi
Sorgu İşleyicisi
(SQL)
Genişletilmiş
Programlama
Dili (DML +
taşıyıcı dil)
Derleyicisi
Veri
Tabanı
Yöneticisi
29
Veri Tabanı Yöneticisi
• Veri Tabanı Yöneticisi (Database
Manager), kullanıcı isteklerini veri tabanı
üzerinde gerçekleştiren ve çok kullanıcılı
ortamdaki işletimsel sorunları çözümleyen
yazılımlar bütünüdür.
• VTYS’nin gerçekleştirdiği işlemlerin önemli
bir bölümü bu katman tarafından
gerçekleştirilmektedir.
30
Veri Tabanı Yöneticisi
• Veri Tabanı Yöneticisinin birçok bileşeni
vardır. Bunlardan en önemli iki tanesi
şunlardır:
• Bellek Yöneticisi (Storage Manager)
– Kütük Yöneticisi (File Manager)
– Tampon Yöneticisi (Buffer Manager)
• Hareket Yöneticisi (Transaction Manager)
31
• Veri Tabanı Yöneticisinin, verilerin ikincil
belleklerde saklanması ile ilgili işlevlerini
yöneten kesimdir.
• Bir VTYS'nin Bellek Yöneticisi olarak, VTYS'nin
altında çalıştığı işletim sisteminin kütük sistemi
(file system) kullanılabilir.
• Ancak büyük boyutlu veri tabanlarını kurmak
ve işletmek için kullanılan VTYS'ler için verimlilik
çok önemlidir ve gerek ana bellek, gerekse
ikincil bellek yönetiminin VTYS tarafından
gerçekleştirilmesinde yarar vardır.
Bellek Yöneticisi
32
• Bellek Yöneticisi aşağıdaki iki bileşenden oluşur:
• Kütük Yöneticisi (File Manager)
– Verinin ikincil bellek kütüklerinde saklanmasını
sağlayan ve ana bellek ile ikincil bellek arasında
verinin bloklar halinde aktarılmasını sağlayan
yazılımlardır.
• Tampon Yöneticisi (Buffer Manager)
– Kütük yöneticisi aracığıyla ikincil bellekten getirilen
veri bloklarını ana bellek sayfalarında saklayan, ana
bellek sayfalarını yöneten ve gerektiğinde ana bellek
sayfalarındaki veri bloklarının, kütük yöneticisi
aracılığıyla ikincil belleklere yazılmasını sağlayan
yazılımdır.
Bellek Yöneticisi
33
• Veri Tabanı Yöneticisinin, veri tabanı
yaklaşımının üstünlüklerinden faydalanmasını
sağlayan kesimidir.
• Veri tabanı yaklaşımının üstünlükleri arasında:
– Çok kullanıcılı ortamda çok çeşitli kullanıcı isteklerinin
eşzamanlı gerçekleştirilmesi ve bu arada veri tabanı
ve uygulama tutarlılıklarının korunması,
– Veri tabanı üzerinde yapılan işlemlerin yazılım,
donanım ya da güç kaynağı ile ilgili bozukluklar
nedeniyle yitirilmemesi
gibi özellikler bulunmaktadır.
Hareket Yöneticisi
34
• Hareket Yöneticisinde belirtilen hareket, bir
bütün oluşturan ve tutarlılık açısından veri tabanı
üzerinde birlikte gerçekleştirilmesi gereken
işlemler bütünüdür.
• Tutarlılık açısından, bir hareketi oluşturan
işlemlerin ya tümünün gerçekleştirilmesi, ya da
hiçbirinin gerçekleştirilmemesi gerekir. Bu
Özelliğe hareketin ACID (Atomicity, Consitency,
Isolation, Durability) özelliği adı verilir.
Hareket Yöneticisi
35
• Diğer taraftan, veriler üzerinde değişikliğe
neden olan (veri ekleyen, silen ya da
verileri güncelleyen) hareketler birlikte
işletildiğinde, henüz tamamlanmamış (ve
belki de tamamlanmayarak geriye
alınacak) bir hareket tarafından
gerçekleştirilen değişiklik işlemleriyle
oluşturulan veri değerlerinin diğer
hareketler tarafından görülmemesi gerekir.
Hareket Yöneticisi
36
• Hareket yöneticisi, hem hareketlerin ACID
özelliğinin bozulmamasını hem de birlikte
(eşzamanlı) işletilmelerini sağlar.
• Bunu gerçekleştirmek için de kilitleme
(locking), günlük tutma (logging) ve
hareket tamamlama (transaction
commitment) gibi teknikleri kullanır (daha
sonra açıklanacaktır).
Hareket Yöneticisi
VERİ TABANI SİSTEMLERİ
(BMÜ 329)
Fırat Üniversitesi
Bilgisayar Mühendisliği
2
Kaynaklar
• Veri Tabanı Sistemleri, Ünal Yarımağan,
Akademi & Türkiye Bilişim Vakfı (2002)
• Fundementals of Database Systems,
Elmasri, Navathe, Addision-Wesley, 2000
• An Introduction to Database Systems,
Bipin C. Desai, West Publishing Company,
1990
VERiTABANLARI İLE NERELERDE
KARŞILAŞIYORUZ?
• ATM’ler ile işlem yaparken;
• Kütüphane bilgisayarında tarama
yaparken;
• İnternet yoluyla alışveriş yaparken;
• Üniversite kayıt işlemlerinde;
• Otel, uçak bileti rezervasyonlarında;
• …
3
• Multimedya Veritabanları
Resim, video klip, sesli mesaj vs…
• Coğrafi Bilgi Sistemleri
Haritalar, hava durumu, uydu görüntülerini depolama,analiz
• Internet
• Gerçek-zamanlı Aktif Veritabanı Teknolojileri
Endüstriyel üretim aşamalarının kontrolü
• Bilimsel Araştırmalar
gen araştırmaları
4
Veri Tabanı nedir?
• İncelenen konuya açıklık getirmek amacıyla toplanan bilgiler,
belgeler, ölçümler, vb. veri denir.
• Veri tabanı düzenli bilgiler topluluğudur.
• Bir başka tanımı da, bir bilgisayarda sistematik şekilde saklanmış,
programlarca işlenebilecek veri yığınıdır.
Bir veritabanı
• Gerçek dünyanın bazı yönlerini yansıtır.
• İçsel bütünlüğe sahip, mantıksal bir koleksiyondur.
• Özel amaçlı bir veri yığını için kurulur.
5
Örnek bir Veritabanı
6
Prolemler
• Bazı kitaplar birden çok yazar tarafından yazılmıştır.
• Tek tabloda kitabın yazarlarıyla ilgili bilgilerin tamamının
gösterilebilmesi için neler yapabiliriz?
• Örnek tabloda olduğu gibi her yazar için kitabın her verisi
tekrarlanarak yeni bir satır oluşturulabilir.
• Tek bir satırda birden çok yazar için sütun açılabilir.
• Tüm yazarlar için sadece bir sütun kullanılabilir.
7
Problemler
• Örnek tabloda olduğu gibi her yazar için kitabın her verisi
tekrarlanarak yeni bir satır oluşturulabilir.
Birçok veri gereksiz olarak yinelenecek.
• Tüm yazarlar için sadece bir sütun kullanılabilir.
Aradığımız yazarı bulmamız zorlaşacak.
• Tek bir satırda birden çok yazar için sütun açılabilir.
Hangi kitap, kaç yazar tarafından yazılmış? Bir çok bos hücre oluşacak.
8
Tipik bir veritabanı uzun yıllar boyu varolur. Bu nedenle VTYS zaman içindeki
değişim ihtiyaçlarına izin vererek evrimleşmelidir.
Veritabanı Yönetim Sistemi (VTYS), kullanıcılara veritabanı oluşturma ve bu
yapıyı yürütme olanağı sağlayan programlar bütünüdür.
• VTYS, çeşitli kullanıcı ve uygulamaların veritabanını tanımlama, biçimleme,
değiştirme, paylaşım ve koruma işlemlerini yürüten genel amaçlı yazılım
sistemidir.
• Tanımlama: Veri tipleri, yapıları ve uygulamaları
• Biçimleme: VTYS tarafından kontrol edilen kayıt biriminde saklama
• Değiştirme: Saklanan bilginin sorgulanması, gerçek hayatta temsil
• ettiği örneğin değişimlerine göre güncelleme, rapor üretilmesi
• Paylaşım: Aynı anda birden çok kullanıcı ve uygulamanın erişimine
• izin verme
• Koruma: Yazılım ve donanım hatalarına, yetkisiz ve zararlı erişime
• karşı
9
10
Veri Tabanı Yönetim Sistemi
(VTYS)
• VTYS, veri tabanı sistemlerini tanımlamak,
oluşturmak, kullanmak, değiştirmek ve veri
tabanı sistemleri ile ilgili her türlü işletimsel
gereksinimleri karşılamak için kullanılan geniş
kapsamlı yazılım sistemidir.
• VTYS, birbirleri ile ilişkili veri ve programlar
topluluğundan oluşmaktadır.
• Veri tabanı olarak adlandırılan veri topluluğu, bir
kuruluşa ait bilgilerin düzenli bir yapı içerisinde
saklandığı ortamdır.
• Programlar ise saklanan bu verilerin yönetildiği
ortamlardır.
11
VTYS’nin Temel Bileşenleri
Veri
Tabanı
Yöneticisi
Veri Tanımlama
Dili (DDL)
Derleyicisi
Sorgu İşleyicisi
(SQL)
Tablo yaratma
Form yaratma
Sorgu yaratma
Rapor yaratma
Kayıt ekleme
Kayıt silme
Kayıt güncelleme
Veri Tabanı
Genişletilmiş
Programlama
Dili (DML +
taşıyıcı dil)
Derleyicisi
Uygulama
Programı
VT
Sorgusu
VT
Tanımları
Derlenmiş
Uygulama
Programı
Derlenmiş
VT
Tanımları
Kullanıcı verileri
Metadata
Dizinler
Uygulama Metadatası
Veri Tabanını
Oluşturma
Veri Tabanını
Kullanma
12
Neden VTYS?
• VTYS yaklaşımında veri girişi ve
depolanması veriye erişen uygulama
programlarından bağımsızdır.
• Klasik dosya kullanımında ise, kayıt
desenleri ve dosya yapılarında ortaya
çıkabilecek en ufak bir değişiklik bile
uygulama programlarının değiştirilmesine
neden olmaktadır.
13
Veri Tabanı Sistemlerinin
Üstünlükleri (1)
• Gereksiz veri tekrarını önler.
– Tüm uygulamaların gereksinim duyduğu
veriler birbirleri ile bütünleşik yapıdadır.
Dolayısıyla veri kaynağı tek olarak tasarlanır,
böylece veri tekrarı önlenmiş olur.
– Örneğin, Türkiye’deki il kodları ve isimleri hem
personel alt sisteminde hem de pazarlama alt
sisteminde ayrı ayrı tutulmaz.
14
Veri Tabanı Sistemlerinin
Üstünlükleri (2)
• Veri bütünlüğünü (data integrity) sağlar.
– Veri bütünlüğü, verinin doğruluğunu ve
tutarlılığını anlatmaktadır.
– Veri bütünlüğü için bazı kısıtlamalar
tanımlanabilir.
– Örneğin, öğrenci bilgileri girilirken doğduğu il
koduna 100 değeri girilirse, yanlış bilgi
nedeniyle bu isteğin yerine getirilmemesi
istenebilir.
15
Veri Tabanı Sistemlerinin
Üstünlükleri (3)
• Verilerin güvenliğini sağlar.
– Tüm verilere her kullanıcının kolayca
erişebilmesi çoğu zaman istenmeyen bir
durumdur.
– Her kullanıcıya çeşitli yetkiler atanarak, bu
kullanıcının erişebileceği, değiştirebileceği ve
silebileceği veriler ayrı ayrı tanımlanabilir.
– Örneğin, pazarlama bölümünde çalışan bir
kullanıcının diğer personelin özlük bilgilerine
ulaşması engellenebilir.
16
Veri Tabanı Sistemlerinin
Üstünlükleri (4)
• Aynı zamanda yapılan erişimlerde
tutarsızlıkların ortaya çıkmasını önler.
– İki veya daha fazla kullanıcı aynı anda aynı
veri üzerinde değişiklik yapmak istediğinde,
yetkiye ve/veya kimin önce eriştiğine bakarak,
birine önceliği verir, diğerlerini bekletir.
17
Veri Tabanı Sistemlerinin
Üstünlükleri (5)
• Veriler üzerinde merkezi denetim sağlar.
– Kullanıcılar işletim sistemi komutları ya da
genel amaçlı programlama dilleri ile yazılmış
uygulama programlarını kullanarak doğrudan
veri tabanındaki verilere erişemezler ve bu
verileri değiştiremezler.
– Veri tabanı kullanımı yalnız VTYS (DBMS -
Data Base Management System) olarak
adlandırılan yazılım sistemi aracılığıyla
mümkündür.
18
Veri Tabanı Sistemlerinin
Üstünlükleri (6)
• Veri tabanının bilgisayar belleklerindeki fiziksel
yapısı kullanıcılardan gizlenir.
– Kullanıcılara daha yalın mantıksal yapılar sunulur.
– VTYS, bir anlamda yüksek düzeyli programlama dili
derleyicisi gibi davranarak kullanıcının, soyut terimler
kullanarak veri tabanıyla ilişki kurmasını sağlar.
– Böylece kullanıcı, sistem tarafından kullanılan
karmaşık veri gösterimleri ve algoritmaların
ayrıntılarıyla uğraşmadan, neyin yapılmasını istediğini
belirterek isteklerini ortaya koyabilir.
19
VTYS’nin Temel Bileşenleri (1)
Veri
Tabanı
Yöneticisi Sorgu İşleyicisi
(SQL)
Tablo yaratma
Form yaratma
Sorgu yaratma
Rapor yaratma
Kayıt ekleme
Kayıt silme
Kayıt güncelleme
Veri Tabanı
Genişletilmiş
Programlama
Dili (DML +
taşıyıcı dil)
Derleyicisi
Uygulama
Programı
VT
Sorgusu
VT
Tanımları
Derlenmiş
Uygulama
Programı
Derlenmiş
VT
Tanımları
Kullanıcı verileri
Metadata
Dizinler
Uygulama Metadatası
Veri Tabanını
Oluşturma
Veri Tabanını
Kullanma
Veri Tanımlama
Dili (DDL)
Derleyicisi
20
Veri Modeli
• Her Veri Tabanı Yönetim Sistemi bir Veri Modeli
(Data Model) kullanır.
• Veri modeli, verileri mantıksal düzeyde
düzenlemek için kullanılan yapılar, kavramlar ve
işlemler topluluğu olarak tanımlanır.
• Veri tabanını tasarlayan kullanıcı, veri modelinin
yapılarını ve kavramlarını kullanarak mantısal
düzeydeki düzenlemelerini oluşturur, veri tabanı
tasarım belirtimlerini hazırlar.
• Hazırlanan tasarım belirtimleri biçimsel
tanımlara dönüştürülerek Veri Tabanı Yönetim
Sistemine girilir.
21
Veri Tanımlama Dili (VTD)
• Veri tabanı tanımlarını VTYS'ye iletmek için
kullanılan biçimsel dile Veri Tanımlama Dili
(DDL: Data Definition Language) adı verilir.
• Veri Tanımlama Dili kullanılarak oluşturulan veri
tabanı tanımları, VTYS'nin Veri Tanımlama Dili
Derleyicisi olarak adlandırılabilecek bir bileşeni
tarafından çözümlenir, varsa eksik ve yanlışları
bulunarak kullanıcıya iletilir.
• Yanlışlardan arınmış veri tabanı tanımları VTYS
tarafından uygun yapılara dönüştürülerek
saklanır.
22
Veri Tanımlama Dili (VTD)
• Veri tabanı tanımlarının VTYS tarafından
derlenerek saklanması veri tabanı yaklaşımının
temel özelliklerinden biridir.
• Bu süreç sayesinde, veri tabanı tanımlarının
yetkili kişiler tarafından bir kez yapılması,
tanımların kalıcılığının sağlanması ve
kullanıcıların bu tanımları kullanmaları ve bu
tanımlara uygun işlem yapmaları sağlanmış olur.
23
Veri Tanımlama Dili (VTD)
• Veri tabanı yaklaşımında ise veri tanımlama ile
veriler üzerindeki uygulama işlemleri birbirinden
tamamen ayrılmıştır.
• Veri tanımlama ve daha önce yapılmış tanımları
değiştirme yetkisi yalnız Veri Tabanı Sorumlusu
(Data Base Administrator) olarak adlandırılan ve
veri tabanının tümünden sorumlu olan kişi ya da
kişilere aittir.
• Veri tabanı üzerinde işlem yapan, uygulamaları
gerçekleştiren kullanıcıların ise veri tanımlama
ya da mevcut tanımları değiştirme yetkisi yoktur.
24
Veri Tanımlama Dili (VTD)
• VTD ile yapılan tanımlarda veri tabanı tanımları
içinde yer alan en önemli tanımlar şunlardır:
1. Mantıksal düzeyde yapılan düzenlemeler oluşturulan
yapılar ve her yapıda hangi verilerin yer aldığı.
2. Her verinin türü, uzunluğu, varsa varsayılan değeri
ve diğer özellikleri.
3. Veriler arası ilişkiler ve her türlü kısıtlamalar.
4. Fiziksel veri yapıları ile ilgili tercihler ve parametreler.
5. Kullanıcı tanımları ve kullanıcıların hangi veriler
üzerinde hangi işlemleri yapmaya yetkili olduklarına
ilişkin tanımlar.
25
Veri Tanımlama Dili (VTD)
• Veri tabanı tanımları veri sözlüğü (data
dictionary) olarak da adlandırılır.
• VTYS’nin fiziksel ortamında aşağıda belirtilen
çeşitli veriler saklanır:
1. veri kütükleri (dosyalar)
2. veri tabanı tanımlarının yer aldığı veri sözlüğü
3. veri kütüklerine ya da veri sözlüğüne erişim için
kullanılan dizinler (indices)
4. veri değerlerine ve uygulamalara ilişkin istatistiksel
veriler ve günlük kütükleri (logfiles)
26
VTYS’nin Temel Bileşenleri (2)
Veri
Tabanı
Yöneticisi
Tablo yaratma
Form yaratma
Sorgu yaratma
Rapor yaratma
Kayıt ekleme
Kayıt silme
Kayıt güncelleme
Veri Tabanı
Genişletilmiş
Programlama
Dili (DML +
taşıyıcı dil)
Derleyicisi
Uygulama
Programı
VT
Sorgusu
VT
Tanımları
Derlenmiş
Uygulama
Programı
Derlenmiş
VT
Tanımları
Kullanıcı verileri
Metadata
Dizinler
Uygulama Metadatası
Veri Tabanını
Oluşturma
Veri Tabanını
Kullanma
Veri Tanımlama
Dili (DDL)
Derleyicisi
Sorgu İşleyicisi
(SQL)
27
Sorgu Dili ve Sorgu İşleyicisi
• Veri tabanı uygulamaları için kullanılan en
yaygın araç sorgu dilidir.
• Kullanıcı, sorgu dili ile, gerçekleştirmek
istediği işlemi yalın bir biçimde ifade eder.
• Kullanıcının oluşturduğu sorguda, neyin
yapılmasının istendiği yer alır; bunun nasıl
yapılacağı ise yer almaz.
28
Yapısal Sorgu Dili (SQL)
• IBM, deneysel bir ilişkisel veritabanı
yönetim sistemi geliştirmek amacıyla
System/R adlı bir proje başlatır.
• Bu sistem için SEQUEL (Structured
English Query Language) adında bir sorgu
dili geliştirilmeye başlanmıştır.
• 1979’ da tamamlanan bu proje sırasında
geliştirilen dilin adı SQL (Structured Query
Language) olarak değiştirilmiştir.
29
ORACLE
• System/R projesini izleyen bir grup
mühendis, ilişkisel veritabanındaki
potansiyeli görmüş ve Relational Software,
Inc. adında bir şirket kurmuşlardır (1979)
• Oracle adını verdikleri ilk ticari ilişkisel veri
tabanı yönetim sistemini geliştirmişler ve
SQL’i bu sistemde sorgu dili olarak
kullanmışlardır.
30
SQL Örneği
• İngilizce diline çok benzeyen SQL sorgu dilinde
oluşturulmuş bir sorgu aşağıda yer almaktadır.
SELECT ADI, SOYADI, ADRESİ FROM
PERSONEL WHERE BÖLÜMNO = 17 AND
GÖREVİ = 'Sekreter’;
• Yukarıdaki sorgu ile “17 numaralı bölümde
çalışan sekreterlerin ad, soyad ve adreslerinin”
bulunmak istendiği kolayca anlaşılmaktadır.
31
Sorgu İşleyicisi
• VTYS'nin, sorguların işlenmesi ile ilgili görevleri
gerçekleştiren bileşenine Sorgu İşleyici (Query
Processor) adı verilir.
• Sorgu işleyicinin görevleri:
– Sorgunun sözdizimsel ve anlamsal özümlemesini
yapmak.
– Kullanıcının verilen işlemi yapmaya yetkili olup
olmadığını denetlemek.
– Sorguyu işletmek için kullanılabilecek algoritmaları
(işletim senaryolarını) belirlemek ve “Query
Optimizer” alt bileşeni yardımıyla en iyisini seçmek.
– Sorgunun işletimini gerçekleştirdikten sonra yanıtını
oluşturup kullanıcıya iletmek.
32
VTYS’nin Temel Bileşenleri (3)
Veri
Tabanı
Yöneticisi
Tablo yaratma
Form yaratma
Sorgu yaratma
Rapor yaratma
Kayıt ekleme
Kayıt silme
Kayıt güncelleme
Veri Tabanı
Uygulama
Programı
VT
Sorgusu
VT
Tanımları
Derlenmiş
Uygulama
Programı
Derlenmiş
VT
Tanımları
Kullanıcı verileri
Metadata
Dizinler
Uygulama Metadatası
Veri Tabanını
Oluşturma
Veri Tabanını
Kullanma
Veri Tanımlama
Dili (DDL)
Derleyicisi
Sorgu İşleyicisi
(SQL)
Genişletilmiş
Programlama
Dili (DML +
taşıyıcı dil)
Derleyicisi
33
Veri İşleme Dili (DML)
• Veri tabanı üzerinde, veriyi değiştirme,
silme ve güncelleme gibi sorgularla ifade
edilemeyecek ya da sorgularla ifade
edilmesi uygun olmayan işlemler de
gerçekleştirilir.
• Bu işlemler için Veri İşleme Dili (DML:
Data Manipulation Language) olarak
adlandırılan bir dil kullanılır.
34
Genişletilmiş Programlama Dili
• Veri tabanı üzerindeki uygulamaları gerçekleştirmek için
genişletilmiş bir dil oluşturulur.
• Bu dilde hem veri tabanı işlemlerini gerçekleştiren DML
komutları, hem de diğer işlemleri gerçekleştiren C,
Pascal, Cobol gibi genel amaçlı programlama dillerinden
bir ya da birkaçı ile yazılmış taşıyıcı dil komutları yer alır.
• Oluşturulan genişletilmiş dil (DML + taşıyıcı dil) ile
hazırlanan uygulama programları, VTYS'nin bileşeni
olan genişletilmiş derleyicilerle derlenerek saklanır ve
gerektiğinde çalıştırılarak kullanılır.
35
VTYS’nin Temel Bileşenleri (4)
Tablo yaratma
Form yaratma
Sorgu yaratma
Rapor yaratma
Kayıt ekleme
Kayıt silme
Kayıt güncelleme
Veri Tabanı
Uygulama
Programı
VT
Sorgusu
VT
Tanımları
Derlenmiş
Uygulama
Programı
Derlenmiş
VT
Tanımları
Kullanıcı verileri
Metadata
Dizinler
Uygulama Metadatası
Veri Tabanını
Oluşturma
Veri Tabanını
Kullanma
Veri Tanımlama
Dili (DDL)
Derleyicisi
Sorgu İşleyicisi
(SQL)
Genişletilmiş
Programlama
Dili (DML +
taşıyıcı dil)
Derleyicisi
Veri
Tabanı
Yöneticisi
36
Veri Tabanı Yöneticisi
• Veri Tabanı Yöneticisi (Database
Manager), kullanıcı isteklerini veri tabanı
üzerinde gerçekleştiren ve çok kullanıcılı
ortamdaki işletimsel sorunları çözümleyen
yazılımlar bütünüdür.
• VTYS’nin gerçekleştirdiği işlemlerin önemli
bir bölümü bu katman tarafından
gerçekleştirilmektedir.
37
Veri Tabanı Yöneticisi
• Veri Tabanı Yöneticisinin birçok bileşeni
vardır. Bunlardan en önemli iki tanesi
şunlardır:
• Bellek Yöneticisi (Storage Manager)
– Kütük Yöneticisi (File Manager)
– Tampon Yöneticisi (Buffer Manager)
• Hareket Yöneticisi (Transaction Manager)
38
• Veri Tabanı Yöneticisinin, verilerin ikincil
belleklerde saklanması ile ilgili işlevlerini
yöneten kesimdir.
• Bir VTYS'nin Bellek Yöneticisi olarak, VTYS'nin
altında çalıştığı işletim sisteminin kütük sistemi
(file system) kullanılabilir.
• Ancak büyük boyutlu veri tabanlarını kurmak
ve işletmek için kullanılan VTYS'ler için verimlilik
çok önemlidir ve gerek ana bellek, gerekse
ikincil bellek yönetiminin VTYS tarafından
gerçekleştirilmesinde yarar vardır.
Bellek Yöneticisi
39
• Bellek Yöneticisi aşağıdaki iki bileşenden oluşur:
• Kütük Yöneticisi (File Manager)
– Verinin ikincil bellek kütüklerinde saklanmasını
sağlayan ve ana bellek ile ikincil bellek arasında
verinin bloklar halinde aktarılmasını sağlayan
yazılımlardır.
• Tampon Yöneticisi (Buffer Manager)
– Kütük yöneticisi aracığıyla ikincil bellekten getirilen
veri bloklarını ana bellek sayfalarında saklayan, ana
bellek sayfalarını yöneten ve gerektiğinde ana bellek
sayfalarındaki veri bloklarının, kütük yöneticisi
aracılığıyla ikincil belleklere yazılmasını sağlayan
yazılımdır.
Bellek Yöneticisi
40
• Veri Tabanı Yöneticisinin, veri tabanı
yaklaşımının üstünlüklerinden faydalanmasını
sağlayan kesimidir.
• Veri tabanı yaklaşımının üstünlükleri arasında:
– Çok kullanıcılı ortamda çok çeşitli kullanıcı isteklerinin
eşzamanlı gerçekleştirilmesi ve bu arada veri tabanı
ve uygulama tutarlılıklarının korunması,
– Veri tabanı üzerinde yapılan işlemlerin yazılım,
donanım ya da güç kaynağı ile ilgili bozukluklar
nedeniyle yitirilmemesi
gibi özellikler bulunmaktadır.
Hareket Yöneticisi
41
• Hareket Yöneticisinde belirtilen hareket, bir
bütün oluşturan ve tutarlılık açısından veri tabanı
üzerinde birlikte gerçekleştirilmesi gereken
işlemler bütünüdür.
• Tutarlılık açısından, bir hareketi oluşturan
işlemlerin ya tümünün gerçekleştirilmesi, ya da
hiçbirinin gerçekleştirilmemesi gerekir. Bu
Özelliğe hareketin ACID (Atomicity, Consitency,
Isolation, Durability) özelliği adı verilir.
Hareket Yöneticisi
42
• Diğer taraftan, veriler üzerinde değişikliğe
neden olan (veri ekleyen, silen ya da
verileri güncelleyen) hareketler birlikte
işletildiğinde, henüz tamamlanmamış (ve
belki de tamamlanmayarak geriye
alınacak) bir hareket tarafından
gerçekleştirilen değişiklik işlemleriyle
oluşturulan veri değerlerinin diğer
hareketler tarafından görülmemesi gerekir.
Hareket Yöneticisi
43
• Hareket yöneticisi, hem hareketlerin ACID
özelliğinin bozulmamasını hem de birlikte
(eşzamanlı) işletilmelerini sağlar.
• Bunu gerçekleştirmek için de kilitleme
(locking), günlük tutma (logging) ve
hareket tamamlama (transaction
commitment) gibi teknikleri kullanır (daha
sonra açıklanacaktır).
Hareket Yöneticisi
Kullanıcı Türleri
• Kullanıcıları kullandıkları veri tabanı
hakkında bilgi ve yetki düzeylerine göre
sınıflandıracak olursak:
1. Veri Tabanı Yöneticisi
2. Uygulama Programcıları
3. Sorgu Dili Kullanıcıları
4. Uygulama Programı Kullanıcıları
5. Rasgele Kullanıcılar
1) Veri Tabanı Yöneticisi
• Veri tabanının tasarımından işletimine her
şeyinden sorumlu olan kişiler veri tabanı
yöneticisi (DBA: Database Administrator)
ya da veri tabanı sorumlusu olarak
adlandırılırlar.
Veri Tabanı Yöneticisinin Görevleri
(1)
• Veri ve veriler üzerinde yapılacak uygulama
gereksinimlerini belirlemek, veri tabanı içeriğini
oluşturmak, veri tabanı şemalarını tanımlamak.
• Bütünlük kısıtlamalarını belirleyip tanımlamak.
• Veri tabanı kullanıcılarını ve her kullanıcının
hangi veriler üzerinde hangi işlemleri yapmaya
yetkili olduğunu belirlemek; kullanıcı ve kullanım
yetkilerini tanımlamak.
Veri Tabanı Yöneticisinin Görevleri
(2)
• Veri Tabanı Yönetim Sisteminin sunduğu
seçenekler çerçevesinde, veri tabanının fiziksel
yapısı ile ilgili parametreleri ve erişim yollarını
(dizinleri) belirlemek ve tanımlamak.
• Yedekleme, yeniden başlatma ve kurtarma
düzenlerini belirlemek.
• Veri tabanı sistemini sahiplenmek, işletimini
izlemek, veri tabanının sürekli olarak kullanıma
açık olmasını sağlamak.
Veri Tabanı Yöneticisinin Görevleri
(3)
• Gereksinimlerdeki değişiklikleri izlemek ve değişikliklere
paralel olarak veri tabanı içeriği, şema tanımları,
bütünlük kısıtlamaları, fiziksel yapı ile ilgili parametreler,
erişim yolları, kullanıcılar ve kullanıcı yetkilerinde gerekli
değişiklikleri oluşturmak ve tanımlamak.
• Veri tabanı bütünlük kısıtlamalarının yeterliliğini izlemek;
bütünlük kısıtlamaları ile ilgili gerekli değişiklikleri
oluşturmak ve tasarlamak.
• Veri tabanı kullanım istatistiklerini ve veri tabanı
başarımını izlemek; varsa sorunları ve yetersizlikleri
belirlemek ve gerekli her türlü önlemi almak.
Bir Yönetici Yeterli mi?
• Bu görevleri yürütmek için küçük sistemlerde bir
kişinin tam hatta yarı zamanlı çalışması yeterli
olabilir.
• Büyük sistemlerde ise bu görevleri yürütmek için
değişik konularda uzmanlaşmış çok sayıda veri
tabanı yöneticisine ihtiyaç vardır.
• Veri tabanı yöneticisinin kullandığı başlıca
olanak veri tanımlama dilidir (DDL).
• Veri tanımlama diline ek olarak, başta sorgu dili
olmak üzere diğer tüm olanaklar da veri tabanı
yöneticisi tarafından kullanılabilir.
2) Uygulama Programcıları
• Veri tabanı yöneticisi gibi, uygulama
programcıları da veri tabanının gerçek anlamda
kullanıcıları değildirler.
• Uygulama programcıları, veri tabanı üzerindeki
rutin uygulamalar (güncelleme, rapor üretme,
önceden belirli standart sorgulamalar, .. vb) için
gerekli uygulama programlarını hazırlayan ve
gerçek kullanıcıların kullanımına sunan kişilerdir.
• Uygulama programcılarının kullandığı başlıca
olanaklar veri işleme dili (DML) ve diğer yazılım
geliştirme araçlarıdır.
Yazılım Geliştirme Araçları
• Kullanılan yazılım geliştirme araçları, ilgili
Veri Tabanı Yönetim Sisteminin sağladığı
araçlar (Oracle Forms, Oracle Reports
gibi) olabileceği gibi Veri Tabanı Yönetim
Sisteminden bağımsız araçlar (Power
Builder, MS Visual Basic, Delphi, .. vb) da
olabilir.
3) Sorgu Dili Kullanıcıları
• Veri tabanı üzerinde önceden belirlenmiş rutin
uygulamalar dışındaki işlemleri gerçekleştirmek
için genellikle sorgu dili (SQL) kullanılır.
• DML ve DDL dilleri sorgu amaçlı olmamalarına
rağmen çoğu zaman SQL’in bir parçası olarak
görülürler.
• Sorgu Dili Kullanıcıları DML komutlarını
kullanabilir, fakat DDL’i sadece VT Yöneticisi
kullanır.
• SQL doğal dile yakın, kolay öğrenilen ve kolay
kullanılan bir dildir (yine de biçimsel bir dildir).
Sorgu Dili Kullanıcıları
• Bu dili kullanacak kişinin, veri tabanının ilgili alt
şemasının içeriğini (alt şemada hangi
çizelgelerin bulunduğunu, çizelgelerin adlarını,
her çizelgede hangi niteliklerin bulunduğunu,
niteliklerin adları ve özelliklerini, ... vb.) ve sorgu
dilinin; yapısını bilmesi gerekir.
• Dolayısıyla sorgu dilini kullanacak kişinin bir
bilişim uzmanı olmasına gerek yoktur, ancak
veritabanının içeriği ile sorgu dilinin yapısını
bilen, bu konularda eğitilmiş, bilinçli bir kişi
olması gerekir.
Sorgu Dili Kullanıcıları
• Sorgu dili kullanıcıları genellikle yönetimin
alt ve orta kademelerinde görev yapan
kişilerdir.
• Bunların dışında, sorgu dilleri sistem
çözümleyici, sistem tasarımcı, uygulama
programcısı, veri tabanı sorumlusu gibi
bilişim teknik personeli tarafından da çok
kullanılır.
4) Uygulama Programı Kullanıcıları
• Bu kullanıcılar, uygulama programlarını
kullanarak, veri tabanı üzerinde işletimsel
düzeydeki rutin işlemleri gerçekleştiren kişilerdir.
– Ambar giriş-çıkışlarını işleyen stok kontrol görevlisi
– Faturaları işleyen muhasebe görevlisi
– Personel sicil bilgilerini işleyen personel dairesi
çalışanı
– Verdiği dersin sınıf listesini almak veya öğrencilerin
notlarını girmek isteyen öğretim üyesi
– ÖSS sonucunu öğrenmek isteyen adaylar ...
Uygulama Programları
• Uygulama programları daha çok işletimsel
düzeydeki işlemler (veri tabanından bilgi
alma, bilgiyi ekleme/silme/değiştirme) için
kullanılır.
• Ancak bazı uygulama programları
önceden belirli yönetimsel işler için de
kullanılabilir. Bunları kullanan kişi VT
sorumlusudur (DBA).
5) Rasgele Kullanıcılar
• Veri tabanı yaklaşımının temel amaçları
arasında, hangi düzeyde olursa olsun, her
kullanıcının veri tabanı ile doğrudan
(herhangi bir aracı kullanmadan) iletişim
kurabilmesinin ve veri tabanı kullanımının
yaygınlaşmasının sağlanması da vardır.
• Bu amaçla doğal dillere yakın etkileşimli
veri tabanı dilleri geliştirilmiştir.
Rasgele Kullanıcılar
• Veri tabanının içeriği konusunda biçimsel
bilgisi olmayan, veri tabanı ve veri tabanı
dilleri konusunda hiçbir eğitim görmemiş
kullanıcılara rasgele kullanıcılar denir.
• Rasgele kullanıcıların veri tabanı ile
iletişim kurabilmesini sağlayan dillerde
kullanıcı önce isteğini doğal dilde,
serbestçe ifade eder.
Rasgele Kullanıcılar
• Dil yorumlayıcısı, kullanıcının biçimsel olmayan
ifadesini çözümleyerek ne istediğini anlamaya
çalışır.
• Bunun için kullanıcıya bir dizi soru yönelterek
kullanıcının isteğini belirginleştirmeye çalışır.
• Kullanıcı ile sistem arasındaki bu etkileşim
sonunda kullanıcı isteğinin belirginleşmesi
sağlanır ve biçimsel sorgu oluşturulabilirse bu
sorgu işletilerek kullanıcı isteği karşılanır.
Rasgele Kullanıcılar
• Rasgele kullanıcılara yönelik bu tür olanaklar,
sorgu dili ve veri işleme dili kadar yaygın
değildir.
• Her Veri Tabanı Yönetim Sistemi kapsamında
en az bir sorgu dili ile, en az bir taşıyıcı dil ile
birlikte kullanılan bir veri işleme dili bulunmasına
karşın, çok az sayıda Veri Tabanı Yönetim
Sistemi kapsamında rasgele kullanıcılara yönelik
doğal dile yakın, diyalog tabanlı, etkileşimli bir dil
olanağı yer almaktadır.
Soyutlama Düzeyleri
• Yandaki çizimde üç
soyutlama düzeyinin
yer aldığı örnek bir
mimari yer
almaktadır.
• Fiziksel veri tabanı ile uç kullanıcı arasında
birçok soyutlama düzeyi bulunur.
İç (fiziksel) Şema
• İç şema, veri tabanının fiziksel çevresi ile ilgili
tanımları içerir.
• Veri tabanı bilgisayarda bir disk dosyası
biçiminde yer aldığı için, bu dosyanın disk
üzerindeki adresi ve özellikleri ile ilgili tanımlar iç
şemayı oluşturur.
• Aslında fiziksel veri tabanı olarak adlandırılan
katman da kendi içinde, kütükler ve mantıksal
tutanaklar düzeyinden başlayıp, bitler ve fiziksel
adresler düzeyine kadar uzanan birçok
soyutlama düzeyinde görülebilir.
Kavramsal Şema
• Tüm veri tabanının kuruluş düzeyindeki
mantıksal yapısıdır.
• Her Veri Tabanı Yönetim Sistemi, veri tabanının
kavramsal şemasını tanımlamak ve bu şemanın
fiziksel gerçekleştirimi olan fiziksel şemanın kimi
özelliklerini belirtmek için gerekli veri tanımlama
olanaklarını sağlar.
• Veri tanımlama için kullanılan veri tanımlama dili,
kavramsal veri tabanının, veri modeli terimleri ile
tanımlanmasını sağlayan yüksek düzeyli bir
dildir.
Dış (alt) Şema
• Kavramsal şemanın bir alt kesiminin soyut
bir modelidir.
• Dış şemaları tanımlamak için de genellikle
veri tanımlama olanağı kullanılır.
• Dış şema, bir anlamda, küçük bir veri
tabanının kavramsal semasıdır ve
genellikle kavramsal şema ile dış şema
aynı soyutlama düzeyindedir.
Dış (alt) Şema
• Bazı yönleriyle dış şema kavramsal
şemadan daha soyut olabilir.
– Fiziksel veri tabanında ve kavramsal şemada
yer almayan, ancak kavramsal şemadaki
verilerden türetilebilen verilere dış şemada yer
verilebilir.
– Örneğin, kavramsal şemada kişilerin doğum
tarihleri yer alırken, dış şemada kişilerin
yaşlarına yer verilebilir.
Veri Bağımsızlığı
• Veri bağımsızlığı sayesinde
uygulamaların, veri saklama yapıları ve
erişim yöntemlerinden bağımsızlaştırılması
sağlanır.
• Dış şema, kavramsal şema ve iç şemadan
oluşan soyutlama zinciri, iki farklı veri
bağımsızlığı düzeyi sağlar.
– Fiziksel Veri Bağımsızlığı
– Mantıksal Veri Bağımsızlığı
Fiziksel Veri Bağımsızlığı
• Fiziksel Veri Bağımsızlığı, “bellekte saklı
verilerin yapı ve erişim yöntemi
değişikliklerinden uygulamaların
etkilenmemesi” olarak tanımlanabilir.
• Eğer bir bilişim sisteminde fiziksel veri
bağımsızlığı sağlanmışsa, bellek yapıları
ve erişim yöntemleri, hatta bellek ortamları
uygulamalardan etkilenmeden
değiştirilebilir.
Fiziksel Veri Bağımsızlığı
• Fiziksel veri bağımsızlığının önemini daha iyi anlamak
için, örnek olarak önce veri tabanı olanakları
kullanılmadan, genel amaçlı bir programlama dili ile
geliştirilen bir bilişim sistemini düşünelim.
• Bu örnekte veriler, kullanılan işletim sistemi ile
programlama dilinin sağladığı kütük yapıları ve erişim
yöntemleri kullanılarak ikincil belleklerde saklanır.
• Saklanan verilerin hacminin büyüklüğü ve veriler arası
bağıntıların çokluğu, verileri saklamak ve verilere
erişmek için kullanılan yapı ve yöntemlerin
karmaşıklaşmasına yol açar.
Fiziksel Veri Bağımsızlığı
• Veriler üzerinde işlem yapacak kullanıcıların,
karmaşık veri düzenleme ve erişim tekniklerini
tüm ayrıntıları ile bilmeleri, yazacakları uygulama
programlarında yapıları doğru olarak
tanımlamaları ve bu yapılarla uyumlu işlem
algoritmalarını oluşturmaları gereklidir.
• Bu nitelikteki uygulama programlarının yalnız
uzman bilişim teknik personeli tarafından
yazılabileceği açıktır.
Fiziksel Veri Bağımsızlığı
• Bilişim uygulamaları genellikle sürekli değişim halindedir.
Bir kez geliştirildikten sonra birkaç yıl değiştirilmeden
kullanılan uygulamaların sayısı son derece azdır.
• Değişiklikler işlevsel ya da işletimsel gereksinimlerden
kaynaklanabileceği gibi, teknolojik gelişmelerden veya
iyileştirme isteklerinden de kaynaklanabilir.
• Uygulamaların işlevsel ya da işletimsel
gereksinimlerinden kaynaklanan değişiklikler
kullanıcıların tümünü değil, yalnız belirli bir kesimini
doğrudan ilgilendirir. Diğer değişiklikler ise kullanıcıların
hiçbirini doğrudan ilgilendirmez.
Fiziksel Veri Bağımsızlığı
• Veri tabanında yapılan her değişiklikten sonra;
– tüm uygulama programlarının uyarlanması,
– yeniden derlenmesi,
– gerekiyorsa yeniden sınanması,
– tüm kullanıcıların da yapılan değişikliklerle ilgili bilgi
sahibi olmaları,
gerekir.
• Yukarıdaki örnekte olduğu gibi “uygulamaların
veriyi bellekte saklamak için kullanılan yapılara
ve veriye erişmek için kullanılan yöntemlere
bağımlı olduğu bilişim uygulamalarına” veriye
bağımlı uygulamalar denir.
Mantıksal Veri Bağımsızlığı
• Mantıksal veri bağımsızlığı, kavramsal şema
değişikliklerinden kullanıcıların olabildiğince
korunması anlamına gelmektedir. Özellikle,
yapılan değişiklik ile ilgisi olmayan dış şemaları
kullanan kullanıcıların, bu değişiklikten
etkilenmemesi amaçlanmaktadır.
• Kavramsal şema değişiklikleri; kullanıcı
gereksinimlerini karşılamak için mantıksal
düzeyde yapılan değişiklikler olduğu için,
genellikle kavramsal şema değişikliği ile birlikte
dış şemalardan bir kısmında da değişiklik yapılır.
Örnek bir VTYS mimarisi
• Bir veri tabanı kullanıcısı için,
veri tabanı dış şemadır.
• Kullanıcı dış şemayı görür ve
sağlanan yazılım olanakları ile
dış şemada yetkili olduğu
işlemleri gerçekleştirir.
• Kullanıcıların çoğu kavramsal
ve iç şemadan habersizdir,
verilerin dış şemaya uygun
biçimde saklandığını düşünür.
• Oysa dış ve kavramsal şemalar
tümüyle mantıksaldır.
Örnek bir VTYS mimarisi
• Kullanıcı tarafından dış
şemaya göre oluşturulacak
isteklerin iç şemada
karşılanması gerekir.
• Bunun için de kullanıcı
tarafından dış şemaya göre
tanımlanan verilerin önce
kavramsal şemadaki, sonra
da iç şemadaki karşılıklarının
belirlenmesi ve kullanıcı
isteğinin fiziksel veri tabanı
üzerinde gerçekleştirilmesi
gerekir.
Örnek bir VTYS mimarisi
• İstek bir sorgu ise, iç şemaya
göre seçilen veriler, bu defa
önce kavramsal sonra da dış
semaya göre dönüştürülerek
kullanıcıya sunulmalıdır.
• Bir VTYS’nin mantıksal ve
fiziksel veri bağımsızlığının
sağlanabilmesi için, şema
tanımlarına ek olarak
şemalar arası eşleme
tanımlarının da saklanması
gerekir.
Örnek bir VTYS mimarisi
• İç şemada bir değişiklik
yapıldığında, iç şema -
kavramsal şema eşlemesinde
gerekli uyarlamalar yapılarak
değişikliğin kavramsal ve dış
şemaları, dolayısıyla da
kullanıcıları etkilemesi
önlenerek fiziksel veri
bağımsızlığı sağlanmış olur.
Örnek bir VTYS mimarisi
• Kavramsal şemada bir
değişiklik yapıldığında ise, bir
yandan kavramsal şema - iç
şema eşlemeleri, diğer
taraftan da bazı dış şemalar
ile kavramsal şema
arasındaki eşlemeler
uyarlanır.
• Böylece kavramsal şemadaki
değişiklikten iç şema (fiziksel
veri bağımsızlığı) ve dış
şemaların en azından bir
kesimi (mantıksal veri
bağımsızlığı) etkilenmemiş
olur (Tsichritzis, 1977).
Örnek bir VTYS mimarisi
• Bu örnekten yola çıkarak,
VTYS mimarisinde üç
düzeyin bulunması gerektiğini
söyleyebiliriz. Üç düzeyin
bulunması, üç türlü şemanın
benimsenmesinin doğal bir
sonucudur.
• Üç düzeyli mimari ilk defa
1975 yılında “Bilgisayarlar ve
Bilgi İşlem konusundaki
Amerikan Ulusal Standartlar
Komitesinin VTYS Çalışma
Takımı” tarafından önerilmiş
ve büyük ilgi görmüştür.
(ANSI/X3/SPARC)
Örnek bir VTYS mimarisi
• Veri bağımsızlığının
sağlanması için VTYS
mimarisinin mutlaka üç
düzeyli mimaride olması
gerekmez.
• Veri bağımsızlığı VTYS
mimarisini en çok
etkileyen etmenlerden
biridir, fakat VTYS
mimarisinin sadece veri
bağımsızlığından
etkilendiği de
söylenemez.
Veri Modeli
• Verileri mantıksal düzeyde düzenlemek için
kullanılan yapılar, kavramlar ve işlemler
topluluğuna veri modeli (data model) denir.
• Her VTYS belirli bir veri modelini kullanır.
• Bir VTYS'yi kullanarak oluşturulacak her veri
tabanında yer alacak veriler ve veriler arası
ilişkiler, mantıksal düzeyde ilgili veri modeline
göre düzenlenir; bu veri modeli kullanılarak veri
tabanının kavramsal ve dış şemaları
oluşturulur.
Veri Modelleri
• Bugüne kadar geliştirilmiş olan çok sayıda veri
modeli vardır.
• Ancak geçmişte ve günümüzde yaygın kullanılan
veri modellerini 4 grupta toplamak mümkündür:
– Sıradüzensel Veri Modeli (Hierarchical Data Model)
– Ağ Veri Modeli (Network Data Model)
– İlişkisel Veri Modeli (Relational Data Model)
– Nesneye-Yönelik Veri Modeli (Object-oriented Data
Model)
• Yukarıdaki sıralama aynı zamanda kronolojik bir
sıralamadır.
Veri Modelleri : Tarihçe
• Sıradüzensel (Hiyerarşik) Veri Modeli en eski
model olup 60 ve 70'li yıllarda çok kullanılmıştır.
• 1969’da ortaya çıkan Ağ Veri Modeli 1970’li
yıllarda ve 1980’li yılların ilk yarısında
kullanılmıştır.
• İlişkisel veri modeli de ilk kez 1969 yılında
ortaya atılmış, 1970’li yılların sonunda
kullanılmaya başlanmış ve 1985 yılından
sonra yaygınlaşmış bir yaklaşımdır.
• 1990’lı yıllarda yaygın kullanılan VTYS'lerin
hemen hemen tümünün ilişkisel tabanlı olduğu
söylenebilir.
Veri Modelleri : Tarihçe
• Nesneye-yönelik veri modeli yaklaşımı ise on yılı aşkın
süredir gündemde olan, günümüzde çok yaygın
kullanılmasa bile, kullanımı giderek yaygınlaşan bir
yaklaşımdır.
• Geçmişe baktığımızda, ilişkisel yaklaşımın kullanılmaya
başlanması ile sıradüzensel ve ağ yaklaşımlarının terk
edildiği görülmektedir.
• Buna karşılık nesneye-yönelik yaklaşımın
kullanılmaya başlanması ile ilişkisel yaklaşım terk
edilmemiştir.
• Günümüzde hem ilişkisel hem de nesneye-yönelik
yaklaşımı birlikte kullanan VTYS'lerinin yaygınlaştığı
görülmektedir (ORDBMS).
Sıradüzensel (Hiyerarşik) Model
• 1960’lar ve 1970’ler
– Programlama dillerindeki veri yapılarına
benziyor. Bir kaydın 1 ebeveyn kaydı, 1’den
çok çocuk kaydı var.
Kitaplar
(no, başlık)
Yayıncılar Konular Yazarlar
(ad, soyad)
Ağ Modeli
• 1970’ler
– Her kaydın birçok ebeveyn ve birçok çocuk
kaydı bulunabilir. (TurboIMAGE, IDMS, RDM
Embedded, RDM Server )
Konular Kitaplar
Yazarlar
Yayıncılar
İlişkisel Model
• 1980’ler
– Veriler için kavramsal olarak basit bir model;
veriler ve ilişkiler “tablolar” üzerinde tanımlanır
ve tüm bilgiler görülebilecek şekildedir.
Book ID Title pubid Author id
1 Introductio 2 1
2 The history 4 2
3 New stuff ab 3 3
4 Another title 2 4
5 And yet more 1 5
pubid pubname
1 Harper
2 Addison
3 Oxford
4 Que
Authorid Author name
1 Smith
2 Wynar
3 Jones
4 Duncan
5 Applegate
Subid Subject
1 cataloging
2 history
3 stuff
Book ID Subid
1 2
2 1
3 3
4 2
4 3
Nesneye-Yönelik Model
• 1990’lar
– Veriler nesne olarak modellenir ve yaratılır.
– Nesneye-Yönelik Programlama (OOP) da
olan sınıf ve miras kavramlarına sahiptir.
– Karmaşık veriler üzerinde işlem yaparken
yüksek performans sunan bir yaklaşımdır.
Nesneye-Yönelik İlişkisel Model
• 1990’lar
– İlişkisel Modelin iyi bilinen özelliklerini Nesne
Tabanlı özelliklerle birleştirir. Bunlar:
• Kullanıcı tanımlı veri türleri
• Kullanıcı tanımlı fonksiyonlar
• Kalıtım ve alt sınıflar
Varlık-İlişki Modeli (E-R Modeli)
• Varlık-ilişki modeli, ya da kısaca E-R modeli
(Entity-Relationship model) 1976 yılında P.P.
Chen tarafından geliştirilen bir modeldir.
• Bugüne kadar varlık-ilişki modeline dayalı
hiçbir VTYS geliştirilmemiştir.
• Buna karşılık varlık-ilişki modeli, VTYS'den
bağımsız veri çözümlemede ve semantik veri
modellemede en çok kullanılan modeldir.
Varlık-İlişki Modeli
• Bu model kullanılarak önce;
– VTYS'den bağımsız olarak veriler çözümlenir,
– veri modellemesi yapılır,
– veriler ve veriler arası ilişkilerin anlamları ve özellikleri
incelenerek E-R çizelgeleri oluşturulur;
– kullanılacak VTYS belirlenir
• sonra da E-R çizelgeleri bu sistemin veri
modeline dönüştürülerek veri tabanı şemaları
oluşturulur.
Varlık ve Varlık Kümesi
• Var olan ve benzerlerinden ayırt edilebilen her
nesneye varlık (entity) denir.
– Bir öğrenci, veri tabanı dersi, belirli bir kitap, Burak
birer varlık olarak değerlendirilir.
• Aynı türden benzer varlıkların oluşturduğu
kümeye ise varlık kümesi (entity set) adı
verilir.Varlık kümeleri iç içe, kesişen ya da ayrık
kümeler olabilir.
– Öğrenciler, kız öğrenciler, Bilgisayar Mühendisliği
Bölümü öğrencileri, yurtta kalan öğrenciler, renkler,
dersler, yıllar, tarihler, satış miktarları,... vb. varlık
kümesi örnekleri olarak sayılabilir.
Nitelik
• Bir varlık kümesindeki varlıkların özelliklerini
göstermek ve varlıkları birbirinden ayırt etmek
için nitelikler (attributes) kullanılır.
• Gerçek dünyada varlık kümelerinin çok sayıda
nitelikleri olabilir, ancak veri modellemede,
gerçek dünyanın soyut bir modeli oluşturulduğu
için, bu niteliklerin yalnız küçük bir kısmı,
uygulamalar için gerekli olanları (örn. Sicil no,
Ad, Soyad, Adres, … vb) seçilerek kullanılır.
Etki Alanı (Değer Alanı)
• Her niteliğin bir etki alanı (domain) vardır.
Etki alanı ilgili niteliğin olabilecek
değerlerinin tümünü içeren bir kümedir.
Adı ve Soyadı
Burak Özkan
Begüm Özkan
Dilay Dondurmacı
Nitelik
Etki Alanı
Türetilen Nitelik
• Bir nitelik kullanılarak bir başka varlık
niteliği elde edilebiliyorsa, bu yeni niteliğe
türetilen nitelik adı verilir.
• Örneğin, “personel” varlığının “doğum
tarihi” niteliğinden yararlanılarak “yaş”
niteliği elde edilebilir. Bu örnekte “yaş”
niteliği türetilen niteliktir, tasarımda ayrıca
tanımlanmasına gerek yoktur.
Birleşik Nitelik
• Birden fazla nitelik birleştirilerek yeni bir
nitelik oluşturulabilir. Bu tür niteliklere
birleşik nitelik adı verilir.
• Örneğin, “mahalle”, “cadde”, “sokak”,
“apartman”, “posta kodu” ve “şehir” gibi
nitelikler birleştirilerek “adres” isimli yeni
bir nitelik oluşturulabilir.
İlişki
• Varlıklar arasındaki bağıntıya ilişki adı
verilir.
• İkili ilişki:
– bir öğrenci ile bir ders
– bir firma ile bir malzeme
• Üçlü ilişki:
– Bir işçi, bir ürün ve bir makine (işçi bu ürünü
üretirken bu makineyi kullandığı için)
İlişki Kümesi
• Aynı türdeki ilişkilerin oluşturduğu kümeye
ilişki kümesi denir.
• Matematiksel olarak E1
, E2
, E3
, ..., En
varlık kümeleri arasındaki bir R ilişkisi
aşağıdaki gibi tanımlanır:
R = {(e1
, e2
, e3
, ..., en
) :
e1  E1
, e2  E2
, e3  E3
, ..., en  En
}
İlişki Kümesi : Örnek
• Aşağıdaki iki varlık kümesini göz önüne
alalım:
E1 = { Ali, Ayşe }
E2 = { Matematik, Fizik }
• Bu varlık kümeleri için öğrenci ve aldığı
ders ilişkileri aşağıdaki gibi ifade edilebilir:
R1 = { (Ali, Matematik) } R2 = { (Ali, Fizik) }
R3 = { (Ayşe, Matematik) } R4= { (Ayşe, Fizik) }
İlişki Kümesi : Örnek
• Aşağıda şekilde “öğrenci” ve “ders” varlık
kümeleri ile bu iki varlık kümesi arasındaki
“aldığı” ilişki kümesi görülmektedir.
Çoklu İlişki Kümesi
• İlişki kümeleri ikili, üçlü, dörtlü, .. vb. olabilir.
• Ancak genellikle ikili ilişki kümeleri tercih edilir.
• Üçlü, dörtlü, ..vb. ilişki kümesi yerine, istenirse
birkaç ikili ilişki kümesi kullanılabilir. Örneğin;
– Öğrenci, ders ve öğretmen varlık kümeleri arasındaki
üçlü ilişki yerine 2 ya da 3 ikili ilişki kullanılabilir.
– “Ali, Mehmet Hoca’nın anlattığı Fizik dersini alıyor”
yerine “Ali Fizik dersini alıyor” ve “Mehmet Hoca Fizik
dersini anlatıyor” kullanılabilir.
Aynı Varlık Kümesi ile İlişki
• Aralarında ilişki tanımlanan varlık
kümelerinden ikisi ya da daha çoğu aynı
varlık kümesi de olabilir.
Ali
Ayşe
Fatma
Mustafa
Kemal
Nuri
Annelik Vatandaş Evlilik
Rol
• Aralarında ilişki kurulan varlıklardan her
birinin ilişkideki işlevine varlığın rolü denir.
• Farklı varlık kümeleri arasındaki ilişkilerde
roller dolaylı yoldan anlaşılabildiği için
çoğunlukla açıkça belirtilmez
– Örneğin, öğrenci ve ders arasında kurulan
“aldığı” ilişkisinde varlıkların rolleri bellidir:
öğrenci dersi alan, ders ise öğrenci tarafından
alınandır.
Rol
• Oysa kişi1 ve kişi2 arasında kurulan evlilik
ilişkisinde kişilerden hangisinin erkek hangisinin
kadın olduğunun belirtilmesi gerekebilir (bazı
isimler hem erkek hem kadınlar tarafından
kullanıldığı için).
• Benzer biçimde bir kurumda çalışan personel1
ve personel2 arasında kurulan yönetici ilişkisinde
hangi personelin rolünün yönetici (üst), hangi
personelin rolünün ise yönetilen (ast) olduğunun
belirtilmesine gerek vardır.
Rol : Örnek
• İlişkilerdeki roller
belirlenirken, başka
niteliklere de bakmak
gerekebilir.
– Örneğin “Personel”
varlığında “ast-üst”
ilişkisini belirlemek için
“Görevi” niteliği dışında
“Bölümü” niteliğine de
bakmak gerekebilir.
Adı Bölümü Görevi
Burak Muhasebe İşçi
Begüm Muhasebe Yönetici
Dilay Muhasebe İşçi
Selin Satış Yönetici
Sezin Satış İşçi
Personel varlığı:
Yönetici (üst, ast) ilişkileri:
(Begüm, Burak)
(Begüm, Dilay)
(Selin, Sezin)
İlişki Kümelerinin Sınırlandırılması
• İlişki kümeleri ile ilgili olarak bir dizi
sınırlama tanımlanabilir.
• Bu sınırlamaların en önemlileri, aralarında
ilişki kurulan varlık kümeleri arasındaki
eşlemelerle ilgili sayısal sınırlamalardır.
• Bu tür sayısal sınırlamalar özellikle ikili
ilişki kümeleri için çok önemlidir.
İlişki Türleri
• A ve B varlık kümeleri arasında
tanımlanan (A ve B varlık kümeleri aynı da
olabilir), A'dan B'ye bir ilişki kümesi,
eşleme sınırlamaları açısından aşağıdaki
dört türden birinde olabilir.
– Birden-bire (one-to-one)
– Birden-çoğa (one-to-many)
– Çoktan-bire (many-to-one)
– Çoktan-çoğa (many-to-many)
İlişki Türleri : Birden-bire (1-1)
• Her a ile en çok bir b ve her b ile de en çok
bir a arasında ilişki kurulabilir (aA, bB).
• Örnek: “Evlilik” ilişkisi T.C. Medeni
Kanunu’na göre birden-bire’dir.
Ali
Ahmet
Mustafa
Cemal
Veli
Ayşe
Fatma
Buket
Selin
Sezin
Kadın Evlilik Erkek
İlişki Türleri : Birden-çoğa (1-n)
• Her a ile sıfır, bir veya birçok b ve her b ile de en
çok bir a arasında ilişki kurulabilir.
• Örnek: “Bölüm” ve “Öğrenci” varlık kümeleri
arasındaki “Okuyan” ilişkisi, bölümden öğrenciye
doğru birden-çoğa şeklindedir.
Ali
Ahmet
Mustafa
Cemal
Veli
Mimarlık
Mak. Müh.
Bilg. Müh.
Bölüm Okuyan Öğrenci
İlişki Türleri : Çoktan-bire (n-1)
• Her a ile en çok bir b ve her b ile de sıfır, bir
veya birçok a arasında ilişki kurulabilir.
• Örnek: “Öğrenci” ve “Bölüm” varlık kümeleri
arasındaki “Okuduğu” ilişkisi, öğrenciden bölüme
doğru çoktan-bire şeklindedir.
Tarih
Arkeoloji
Zooloji
Öğrenci Okuduğu Bölüm
Ayşe
Fatma
Kemal
Sabri
Ali
İlişki Türleri : Çoktan-çoğa (n-m)
• Her a ile sıfır, bir veya birçok b ve her b ile de
sıfır, bir veya birçok a arasında ilişki kurulabilir.
• Örnek: “Öğrenci” ve “Ders” varlık kümeleri
arasındaki “Aldığı” ilişkisi, çoktan-çoğa şeklinde
bir ilişkidir.
Fizik
Matematik
Kimya
Öğrenci Aldığı Ders
Ayşe
Ali
İlişki Türünü Belirlerken…
• Yapılan modellemenin gerçek dünyaya
uygunluğunu sağlaması için tanımlanan ilişki
kümesinin türünün doğru belirlenmesi önemlidir.
• İlişki kümelerinin türü evrensel ve değişmez
değildir. Gerçek dünya kurallarının bir yansıması
olarak bir ilişkinin türü bir kurumdan diğerine
değişebilir.
• İlişkinin türünün aynı kurum içinde zamanla
değişmesi de olasıdır.
Tür Seçimi için Örnek
• “Depo” ve “Malzeme” varlık kümeleri
arasındaki “Bulunan” ilişkisi genelde
çoktan-çoğa bir ilişkidir. Ancak eğer
malzemeler sınıflandırılmış ve her
sınıftaki malzemeler yalnız bir depoda
bulunuyorsa bu ilişki depodan
malzemeye bire-birçok şeklinde olacaktır.
Varolma Bağımlılığı
• “b” varlığının bulunması “a” varlığının
bulunmasına bağlı ise, yani:
– A ve B varlık kümeleri arasında birden-bire,
ya da A'dan B'ye birden-çoğa bir R ilişkisi
varsa … VE …
– bir b'nin var olması bu b ile bir a arasında r
ilişkisinin kurulmuş olmasına bağlı ise (r ilişkisi
yüzünden bir a'ya bağlı olmayan b'ler var
olamıyorsa)
«b, a'ya var olma bağımlıdır» denir.
Varolma Bağımlılığı
• Bu durumda;
– a baskın (dominant) ya da birincil varlık,
– b bağımlı (subordinate) ya da ikincil varlık
olarak nitelenir.
– ve a’nın silinmesi durumunda b’nin bir anlamı
kalmayacaktır.
Varolma Bağımlılığı için Örnek
• Eğer ilgili öğretim kurumunda “bölümü belli
olmayan öğrenci bulunamaz” kuralı geçerli ise,
yani “her öğrenci mutlaka bir bölümün öğrencisi
olmak zorunda” ise, öğrenci ve bölüm varlık
kümeleri arasında varolma bağımlılığı vardır.
• Bu durumda bölüm üstün (dominant) varlık,
öğrenci ise bağımlı (subordinate) varlıktır. İlgili
öğretim kurumunda bir öğrencinin varolması
ancak bir bölümün öğrencisi olması ile
mümkündür.
Anahtarlar
• Bir varlık kümesi içindeki varlıkları ya da
bir ilişki kümesi içindeki ilişkileri birbirinden
ayırt etmek için kullanılan nitelik ya da
nitelik grubuna bu varlık ya da ilişki
kümesinin anahtarı denir.
• Anahtar, hem varlık kümeleri hem de ilişki
kümeleri için geçerli bir kavram olsa da,
daha çok varlık kümeleri için kullanılır.
Anahtar Türleri
• Süper anahtar (superkey)
– Değerleri ile bir kümedeki varlıkları (veya ilişkileri)
ayırt etmeyi sağlayan niteliğe (veya nitelik grubuna)
bu varlık / ilişki kümesinin süper anahtarı denir. Ayırt
etme özelliğine sahip olmak için gereğinden fazla
nitelik içerebilir.
• Aday anahtar (candidate key)
– Eğer bir varlık / ilişki kümesinin süper anahtarının bir
altkümesi de bu varlık / ilişki kümesini ayırt
edebiliyorsa, bu altküme aday anahtardır (ya da
kısaca anahtardır).
Anahtar Türleri için Örnek
• Eğer bir üniversitede tüm öğrencilerin
numaraları birbirinden farklı ise, öğrencileri ayırt
etmek için öğrenci numarası yeterlidir.
• Bu durumda “öğrenci numarası”, “öğrenci” varlık
kümesi için aday anahtar ya da kısaca
anahtardır, içinde öğrenci numarası bulunan her
nitelik grubu (örneğin “öğrenci numarası”, “adı”
ve “soyadı”) ise bu varlık kümesinin süper
anahtarıdır.
Güçlü & Zayıf Varlık Kümeleri
• Her varlık kümesi için bir anahtar bulmak
mümkün olmayabilir.
• Eğer bir varlık kümesinin niteliklerinden en az bir
anahtar oluşturulabiliyorsa, bu varlık kümesine
güçlü (strong) varlık kümesi denir.
• Eğer bir varlık kümesinin niteliklerinin tümü
alınsa bile bir anahtar oluşturmuyorsa bu varlık
kümesine zayıf (weak) varlık kümesi denir.
Zayıf Varlığı Güçlendirmek
• Zayıf bir varlık kümesinde, niteliklerin değerleri ile
varlıkları birbirinden ayırdetmek mümkün değildir.
• Zayıf bir varlık kümesinin anlamlı olabilmesi için şu
özelliklere sahip olması gerekir:
– Bu varlık kümesi ile güçlü bir varlık kümesi arasında birden-bire
ya da (güçlüden-zayıfa) birden-çoğa bir ilişki bulunmalıdır.
– Zayıf varlıklar için bu ilişkinin var olma bağımlılığı oluşturmalıdır.
– Zayıf varlık kümesinin nitelikleri arasında, aynı güçlü varlığa
bağlı zayıf varlıkları birbirinden ayırt etmeyi sağlayan bir nitelik
grubu (discriminator) bulunmalıdır.
• Böylece zayıf bir varlığın anahtarı, bağlı olduğu üstün
varlığın anahtarına ayırıcı nitelikler eklenerek elde edilir.
Zayıf Varlığı Güçlendirme Örneği
• Türkiye'deki tüm lise öğrencilerinin bilgilerini
içeren ÖĞRENCİ varlık kümesi zayıf bir varlık
kümesidir. Çünkü farklı liselerde öğrenci
numarası, adı ve soyadı aynı olan öğrenciler
bulunabilir.
• ÖĞRENCİ varlık kümesi ile LİSE varlık kümesi
arasında bir OKUYAN ilişkisi kurulursa,
öğrencileri birbirinden ayırdetmek için kullanılan
ÖĞR_NO niteliğine, LİSE varlık kümesinin
anahtarı olan LİSE_KODU eklenir. Bu durumda
ÖĞRENCİ varlık kümesinin anahtarı
(LİSE_KODU, ÖĞR_NO) ikilisi olur.
Varlık-İlişki Çizelgeleri
Varlık Kümesi Nitelik
İlişki Kümesi Zayıf Varlık
Kümesi Anahtar Nitelik
Bağımlı Varlık Türetilen Nitelik
Kümesi
Varlık Kümesi ve Nitelik Örnekleri
Öğrenci No Öğrenci
Adı Soyadı Yaşı
D. Tarihi
Ders Kodu Ders
Ders Adı
Kredisi
İçeriği
İlişki Kümesi Örnekleri
Erkek Evlilik Kadın
Öğrenci Aldığı Ders
1 1
n m
Bölüm Okuyan Öğrenci
1 n
Rol Örnekleri
Personel Yönetici
Soyadı
Adı
Bölümü
Görevi
Sicil No
üst
ast
1
n
İlişkilerde Nitelik
• İlişkilerde de tanımlayıcı nitelikler bulunabilir.
• Aşağıdaki “Miktar” niteliği “Sattığı” ilişkisi için
tanımlayıcı niteliktir.
Mağaza Sattığı Mal
Mağz. No Mağz. Adı Mal Kodu Mal Adı
Miktar
n m
Varlık, İlişki ve Nitelik seçimleri
• Varlık-ilişki modelinin sunduğu 3 temel kavram:
varlık kümesi, nitelik, ilişki kümesi kavramlarıdır.
• Gerçek dünyayı soyutlayarak semantik
modelleme yapmak için kullanılabilen bu üç
kavram birbirinden kesin çizgilerle
ayrılmamaktadır.
• Varlık kümesi ile nitelik, ya da varlık kümesi ile
ilişki kümeleri birbirinin yerine kullanılabilir; aynı
konuda değişik düzenlemeler yapılabilir.
Örnek : Telefon Numarası (1)
• “telefon numarası” kişi varlık kümesinin bir
niteliği olarak düşünülürse;
– “telefon numarası” kişilerden bağımsız olarak
varolamaz.
– bir kişinin sadece bir telefon numarası
bulunabilir.
– birden çok kişinin telefon numarası aynı
olabilir (telefon numarası kişi varlık kümesinin
anahtarlarından biri olarak tanımlanmadığı
sürece).
Kişi Tel No
Örnek : Telefon Numarası (2)
• “telefon numarası” ayrı bir varlık kümesi
olarak düşünülüp, bu varlık kümesi ile kişi
varlık kümesi arasında ilişki kurulursa;
– telefonun numarası dışında nitelikleri de
bulunabilir.
– kişi ve telefon varlık kümeleri arasındaki
ilişkinin türüne göre her kişinin bir ya da birçok
telefonu olabilir.
– bir telefon numarası bir ya da birçok kişiye
verilebilir.
Kişi Tel No Sahip
Olduğu
Örnek : Banka Hesabı
• "Banka hesabı" banka şubesi ve müşteri varlık kümeleri
arasında bir ilişki olarak düşünülebilir.
• “Banka hesabı” ayrı bir varlık kümesi olarak düşünülüp
bu varlık kümesi ile banka şubesi ve müşteri varlık
kümeleri arasında birer ilişki de kurulabilir.
Banka Şubesi Müşteri Banka
Hesabı
Banka Şubesi Yatırım Banka Hesabı
Müşteri Vadeli Banka Hesabı
Seçerken Dikkat !
• Veri modellemede varlık kümelerinin,
niteliklerin ve ilişki kümelerinin seçimi çok
önemlidir, Ancak bunların nasıl
seçileceğine ilişkin kesin kurallar da
yoktur.
• Kuruluşun öncelikleri ve uygulamaların
özellikleri yanında veri modellemeyi
gerçekleştiren bilişim teknik personelinin
anlayışı da düzenlemede etkili olmaktadır.
GENELLEME (Generalization)
• Varlık kümeleri arasında özel ilişkiler
bulunabilir, bunların en önemlisi “ait olma”
ilişkisidir.
• Alt düzey varlık kümeleri genellenerek
bir üst düzey varlık kümesi
oluşturulabilir.
Genelleme Örneği
• VSZ-HES (vadesiz hesap) ile VLİ-HES (vadeli
hesap) kümeleri genellenerek BANKA-HES
(banka hesap) varlık kümesi oluşturulabilir.
Genelleme Örneği
• VSZ-HES ile BANKA-HES varlık kümeleri arasındaki
ilişki özel ilişkidir (ait olma ilişkisi).
• Her VSZ-HES bir BANKA-HES’dir biçiminde ifade
edilebilecek bu ilişkiye ISA (is-a) ilişkisi adı verilir.
Genelleme Örneği
• ISA ilişkisi üst düzey bir varlık türü ile bunun alt
türleri arasında kurulan özel bir ilişkidir.
• ISA ilişkisinde üst düzey varlığın nitelikleri
kalıtım yoluyla alt düzey varlık türlerine geçer.
KÜMELEME (Aggregation)
• Varlık-ilişki modelinde veri modellemeyi
kolaylaştıran kavramlardan biri de
kümeleme kavramıdır.
• Bilindiği gibi ilişki kümeleri iki ya da daha
çok sayıdaki varlık kümesi arasında
kurulur, ikiden çok sayıda varlık kümesi
arasında kurulan ilişkiler, çoğunlukla, hem
semantik açıdan hem de işletimsel açıdan
uygun çözümler oluşturmazlar.
Kümeleme Örneği
• ÇALIŞAN, PROJE ve MAKİNE varlık
kümeleri arasındaki üçlü ÇPM ilişkisini
düşünelim.
Ç_No Adı Soyadı K_Süre P_No P_Adı P_Bütçe
ÇALIŞAN ÇPM PROJE
MAKİNE
M_No M_Adı M_Türü Yeri
Kümeleme Örneği
• ÇPM ilişki kümesindeki [ç,p,m] üçlüsü çalışan
ç'nin p projesinde çalıştığını ve bu proje için m
makinesini kullandığını gösterecektir.
• Bu ilişki hangi çalışanın hangi projelerde
çalıştığını ve hangi çalışanın hangi proje için
hangi üretim makinesini ne kadar süre
kullandığını gösterecektir.
Ç_No Adı Soyadı K_Süre P_No P_Adı P_Bütçe
ÇALIŞAN ÇPM PROJE
MAKİNE
M_No M_Adı M_Türü Yeri
Kümeleme Örneği
• Bu ilişkinin uygun bir düzenleme olmadığı
görülmektedir. Nedenleri:
– Çalışanlar ile projeler arasındaki görevlendirme bilgisi
makine kullanımından bağımsız yapılamamaktadır.
– Bir çalışanın bir projedeki görevlendirme bilgisi,
kullanılan makine sayısı kadar tekrarlanmaktadır.
Ç_No Adı Soyadı K_Süre P_No P_Adı P_Bütçe
ÇALIŞAN ÇPM PROJE
MAKİNE
M_No M_Adı M_Türü Yeri
Kümeleme Örneği
• Bu üçlü ilişki hem gereksiz tekrarlar içerir,
hem de bir dizi aykırılıklara yol açabilir.
• Bu nedenle bu üçlü ilişki yerine iki tane ikili
ilişki kullanmak daha uygun bir çözümdür.
Ç_No Adı Soyadı K_Süre P_No P_Adı P_Bütçe
ÇALIŞAN ÇPM PROJE
MAKİNE
M_No M_Adı M_Türü Yeri
Kümeleme Örneği
K_Süre
ÇPM
Ç_No Adı Soyadı
ÇALIŞAN
P_No P_Adı P_Bütçe
PROJE
MAKİNE
M_No M_Adı M_Türü Yeri
ÇALIŞTIĞI
KULLANDIĞI
n m
n
m
Kümeleme Örneği
K_Süre
Ç_No Adı Soyadı
ÇALIŞAN
P_No P_Adı P_Bütçe
PROJE
MAKİNE
M_No M_Adı M_Türü Yeri
ÇALIŞTIĞI
KULLANDIĞI
n m
n
m
• Daha önce yapılan tanıma göre ikili ilişki iki varlık kümesi
arasında kurulur. Kümeleme kavramı varlık kümeleri ve
aralarındaki ilişkinin kümelenmesini ve bu kümenin bir
varlık kümesi gibi düşünülmesini sağlar.
Küme
Kümeleme Örneği
K_Süre
Ç_No Adı Soyadı
ÇALIŞAN
P_No P_Adı P_Bütçe
PROJE
MAKİNE
M_No M_Adı M_Türü Yeri
ÇALIŞTIĞI
KULLANDIĞI
n m
n
m
m
• Böylece ÇALIŞAN ve PROJE varlık kümeleri ile
aralarındaki ÇALIŞTIĞI ilişkisi kümelenir;
KULLANDIĞI ilişkisi ise bu küme ile MAKİNE
varlık kümesi arasında kurulur.
Küme
Kümeleme Örneği
• Kümeleme kavramı, ikili bir ilişkinin iki
varlık kümesi arasında olduğu gibi bir
varlık kümesi ile bir ilişki kümesi, ya da iki
ilişki kümesi arasında kurulmasını olanaklı
kılar.
• Not: Varlık-ilişki çizeneklerinde, çizimin
karmaşıklaşmaması için, genellikle
kümelemeyi gösteren kesikli
dikdörtgenlere yer verilmez.
Varlık-İlişki Modeli Örneği
• Bir elektronik firması ürettiği ürünler, kullandığı
bileşenler ve her ürün için hangi bileşenlerin hangi
miktarlarda kullanıldığını gösteren bir Ürün-Bileşen Veri
Tabanı oluşturmak istiyor:
1. Veri tabanında her bileşenin kodu, adı, tanıtıcı açıklaması, stok
miktarı ile hangi satıcıdan satın alındığı verilerinin bulunması
isteniyor.
2. Her satıcının numarası, adı, adresi ve telefon numarasının veri
tabanında yer alması isteniyor.
3. Her bileşen tek bir satıcıdan satın alınıyor; ancak aynı satıcıdan
birden çok bileşen alınabiliyor.
4. Her ürünün kodu, adı, birim fiyatı ve stok miktarı gerekiyor.
5. Bu ürünün üretilmesi için hangi bileşenlerden kaçar adet gerekli
olduğu önem taşıyor.
6. Her ürün bileşenlere varolma bağımlıdır.
Çözüm 1
• Veri tabanında her bileşenin kodu, adı,
tanıtıcı açıklaması, stok miktarı ile hangi
satıcıdan satın alındığı verilerinin
bulunması isteniyor.
BİLEŞEN
Miktar
Adı
Kodu
Açıklama
Satıcı_Kodu
Çözüm 2
• Her satıcının numarası, adı, adresi ve
telefon numarasının veri tabanında yer
alması isteniyor.
SATICI
Adresi
Kodu
Telefon_No
Adı
Çözüm 3
• Her bileşen tek bir satıcıdan satın alınıyor;
ancak aynı satıcıdan birden çok bileşen
alınabiliyor.
SATICI
Adresi
Kodu
Telefon_No
Adı
BİLEŞEN
Miktar
Adı
Kodu
Açıklama
Satıcı_Kodu
Satın
Alma
n 1
Çözüm 4
• Her ürünün kodu, adı, birim fiyatı ve stok
miktarı gerekiyor.
ÜRÜN
Stok_Miktarı
Kodu
Birim_Fiyat
Adı
Çözüm 5
• Bu ürünün üretilmesi için hangi
bileşenlerden kaçar adet gerekli olduğu
önem taşıyor.
Üretim
Ürün_Kod
Adet
Bil_Kod
BİLEŞEN ÜRÜN
n m
Çözüm 6
ÜRÜN
Stok_Miktarı
Kodu
Birim_Fiyat
Adı
• Her ürün bileşenlere varolma bağımlıdır.
– Bu durumda BİLEŞEN üstün (dominant)
varlık, ÜRÜN ise bağımlı (subordinate)
varlıktır.
BİLEŞEN
Miktar
Adı
Kodu
Açıklama
Satıcı_Kodu
Üretim n m
Adet
Çözümün Tamamı
ÜRÜN
Stok_Miktarı
Kodu
Birim_Fiyat
Adı
BİLEŞEN
Miktar
Adı
Açıklama Kodu
Satıcı_Kodu
Üretim n m
Adet
SATICI Adresi
Kodu
Telefon_No
Adı
Satın
Alma
n
1
Tarih Adet
Alternatif Gösterimler


İLİŞKİSEL VERİ MODELİ
• İlişkisel veri modelinin temelindeki düşünceyi, bu
modeli ilk kez geliştiren E. F. Codd’un bir
makalesinde yazdığı şu cümleler çok güzel ifade
etmektedir.
– “Bilgisayar başındaki rastgele kullanıcı çoğunlukla
tabloların yazılmasını ya da gösterilmesini ister.
Tablodan daha yalın, daha evrensel, daha çok
gereksinim duyulan ve daha kolay anlaşılan veri
yapısı ne olabilir? Niçin bu tür kullanıcıların veri
tabanındaki tüm veri ve ilişkileri tablolar biçiminde
görmesine izin verilmesin?”
İlişki Kavramı
• İlişki (relation) kavramı bu modelde
matematiksel bir kavramdır.
• Daha önce gördüğümüz Varlık-İlişki
modelindeki ilişki ile karıştırılmamalıdır.
• Aslında bu modeldeki ilişki, Varlık-İlişki
modelindeki hem varlıkların hem de
ilişkilerin yerini tutar.
Temel İlişki Yapısı
• Matematiksel ilişki kavramı aşağıdaki gibi
tanımlanır:
– Her biri birer değerler kümesi olan D1
, D2
, ... , Dk
alanları (domains) göz önüne alınsın.
– Bu alanların kartezyen çarpımı D1 x D2 x ... x Dk
ile
gösterilir ve 1. elemanı D1 alanından, 2. elemanı D2
alanından, .. , k. elemanı ise Dk alanından alınan [d1,
d2, ... , dk] k-çoklular kümesidir.
– Bu k alan üzerinde tanımlanan her r ilişkisi, bu
alanların kartezyen çarpımının bir altkümesidir:
r  D1 x D2 x ... x Dk
Tablolar ile Gösterim
• Her İlişki iki boyutlu bir tablo olarak
gösterilir.
• Tablonun her sütununa bir nitelik atanır.
• Tablonun her satırı ise bir kaydı gösterir.
– 1. elemanı 1. niteliğin değer alanından, 2.
elemanı 2. niteliğin değer alanından, .. , k.
elemanı ise k. niteliğin değer alanından alınan
ve k değerden oluşan bir çoklu değerler
topluluğu kayıt olarak adlandırılır.
Tablolar ile Gösterim
• Tablo, niteliklerin değer alanlarının kartezyen
çarpımının bir altkümesidir.
• Bu tanıma göre tablo matematiksel anlamda bir
ilişkidir.
• İlişkisel model, temel yapı olarak, matematiksel
bir yapı olan ilişki yapısını kullanır.
• Böylece modeli sağlam bir matematiksel temele
oturtarak gerek tasarım kriterlerinde, gerekse
kullanıcı dillerinde bu kuramdan yararlanır.
Tablolar ile Gösterim
• Matematiksel ilişki yapısı, özde hiçbir değişiklik
yapmadan, kullanıcının alışık olduğu ve görsel
bir yapı olan tablo yapısı olarak sunulur.
• Buna göre ilişkisel veri modeli açısından ilişki ve
tablo terimleri eşanlamlıdır.
• Bilimsel kesimde daha çok ilişki terimi
kullanılırken, kullanıcılar arasında daha çok
tablo terimi kullanılmaktadır.
• Her ilişkinin (tablonun) tekil bir adı vardır.
Tablolar ile Gösterim
• İlişki şeması, ilişkinin adı ile niteliklerini gösteren
R(A1
, A2
, ...., Ak
) biçimindeki bir tanımdır.
• R ilişki şemasına göre gerçekleşen her r ilişkisi
(ya da ilişki olgusu), yukarıdaki tanıma uygun
olarak oluşmuş k-çoklular kümesi ya da bir
tablodur.
• Veri tabanı ilişkisi ile matematiksel ilişki
arasındaki başlıca fark, veri tabanı ilişkisinin
kullanıldığı ortama ve zamana göre değişmesine
karşın matematiksel ilişkinin evrensel olması,
ortama ve zamana göre değişmemesidir.
Örnek
• D1 = {a, b, c} D2 ={1, 2, 3} D3 = {x, y}
olsun. Bu üç alanın kartezyen çarpımı
3x3x2 = 18 adet 3-çokludan oluşan bir
kümedir.
D1 x D2 x D3 = { [a,1,x], [a,2,x], [a,3,x], [a,1,y],
[a,2,y], [a,3,y], [b,1,x], [b,2,x], [b,3,x], [b,1,y],
[b,2,y], [b,3,y], [c,1,x], [c,2,x], [c,3,x], [c,1,y],
[c,2,y], [c,3,y] }
Örnek
• Eğer A, B, C niteliklerinin değer alanı
sırasıyla D1
, D2 ve D3
ise, bu üç değer
alanı üzerinde tanımlı, şeması R(A, B, C)
olan bir r ilişkisi örneğin aşağıdaki gibi
olabilir.
r = {[a,2,x], [a,2,y], [a,3,y], [b,1,x], [c,1,y], [c,3,x]}
Örnek
• Örnek olan r ilişkisi 3 kolon, 6 satırlı bir tablo
olarak görülebilir.
• İlişkinin nitelikleri tablonun kolonlarına karşı gelir
ve kolon başlıklarına niteliklerin adları yazılır.
İlişkinin çokluları (kayıtları) ise tablonun
satırlarına karşı gelir.
A B C
a 2 x
a 2 y
a 3 y
b 1 x
c 1 y
c 3 x
Nitelik İsimleri
Değer Alanları
(Kayıtlar)
İlişkinin (tablonun) Özellikleri
1. Satırların (kayıtların) sırası önemsizdir.
2. Tüm satırların birbirinden farklı olması gerekir
(ilişki bir satırlar kümesi olduğuna göre aynı
satır ilişkide birden çok kez yer alamaz).
3. Tüm satırlar birbirinden farklı olduğuna göre
ilişkinin en az bir anahtarı (anahtar adayı)
vardır. En kötü olasılıkla, tüm niteliklerin
birleşimi anahtarı oluşturur.
4. İlişkinin her sütunu bir niteliğe karşı geldiğine
ve sütun başlığında niteliğin adı yer aldığına
göre, sütunların sırası da önemsizdir.
İlişkinin (tablonun) Özellikleri
5. Bir sütünda yer alan tüm değerler, belirli bir
değer alanından gelen değerler olup tümünün
türü aynıdır.
6. Tabloda yer alan her değer bir sayı, bir ad, bir
miktar, bir tutar, bir adres, bir tarih,.. vb gibi
yalın değerler olabilir. Tablonun bir öğesi bir
dizi, bir vektör, bir başka tablo ya da karmaşık
bir değer olamaz. Başka bir deyişle tablonun
nitelikleri yalın ve tek değerli niteliklerdir.
İlişki Anahtarları
• İlişki kuramına göre her ilişkinin mutlaka
bir anahtarının bulunması gerekir.
• Bir ilişkinin niteliklerinin bir ya da birkaç
altkümesinin değerleri tüm kayıtlarda
birbirinden farklıdır.
• Bu özelliğe sahip nitelik altkümelerine
ilişkinin süper anahtar’ı denir.
• Süper anahtarlar ilişkideki kayıtları
(satırları) tekil belirleme özelliğine sahiptir.
İlişki Anahtarları
• Eğer bir süper anahtarda “artık nitelik”
yoksa (süper anahtarı oluşturan nitelik
grubunun hiçbir öz altkümesi ilişkinin bir
süper anahtarı değilse) bu süper anahtara
aday anahtar veya ilişki anahtarı, ya da
kısaca anahtar denir.
• Uygulama açısından önemli olan süper
anahtar değil ilişki anahtarıdır.
İlişki Anahtarları
• İlişki anahtarı hem ilişkideki kayıtları tekil
belirleme özelliğine sahip olan hem de
içinde “artık nitelik” bulunmayan bir nitelik
grubudur.
• En kötü koşullarda ilişki anahtarı tüm
niteliklerden oluşur.
• Her ilişkinin anahtarının ya da
anahtarlarının bilinmesi son derece
önemlidir.
Birincil Anahtar
• İlişkisel veri tabanında bir tablonun benzer
değerler içermeyen (tekil : unique) bir sütunu ya
da birkaç sütunu birlikte birincil anahtar
(primary key - PK) olarak tanımlanabilir.
• Birincil anahtar bir aday anahtardır ve söz
konusu varlığın kayıtlarını en iyi biçimde
karakterize eden bir anahtardır.
• Birincil anahtar tanımlandığında şu şekilde bir
sınırlama konulmuş olacaktır:
– Birincil anahtar NULL (boş) değerleri veya birbirinin
aynı değerleri içeremez.
Dış Anahtar
• Bir dış anahtar (foreign key - FK) bir sütun veya
çok sayıdaki sütunların birleşiminden oluşur.
• Dış anahtar aynı tablo ya da başka bir tablodaki
bir birincil anahtar ile eşleştirilir.
No Adı BölümNo
25 Burak 10
13 Begüm 10
28 Dilay 20
BölümNo BölümAdı
10 Personel
20 Muhasebe
30 Satış
PK FK PK
İlişki Şeması
• İlişkinin adı ile ilişki niteliklerinin adlarından
oluşan tanım deyimine ilişki şeması denir.
• İlişki şemasının özet gösterimi R(N1
, N2
,
.... , Nk
) biçimindeki tanımdır (ayrıntılı ilişki
şemasında ise niteliklerin değer alanları,
veri türleri, bütünlük kısıtlamaları gibi
ileride görülecek tanımlar da yer alır).
• İlişki şemasında genellikle, ilgili niteliklerin
altı çizilerek, ilişki anahtarı gösterilir.
İlişkisel Veri Tabanı Şeması
• Eğer ilişkinin birden çok anahtarı varsa
bunlardan en çok kullanılanı, en anlamlısı seçilir
ve ilişki şemasında bu anahtar gösterilir.
• Belirli bir kuruluşa/konuya ilişkin verilerin
mantıksal düzeyde düzenlenmesini gösteren ve
kendi aralarında anlamlı bir bütün oluşturan ilişki
şemalarının bütününe, ilişkisel veri tabanı
şeması adı verilir.
İlişki Şeması Örneği
• ÖĞRENCİ (ÖĞRNO, ADI, SOYADI, CNS, DOĞ-TAR,
ÖĞR-BNO)
• BÖLÜM (BNO, BADI, FAKÜLTE)
• DERS (DKODU, DADI, KRD, AÇ-BNO)
• ÖĞRDERS (ÖĞRNO, DKODU, DÖNEMİ, NOTU)
Veri Tabanı Örneği
• Veri tabanlarında sürekli olarak veri
ekleme, silme, güncelleme işlemleri
yapılmaktadır.
• Bu işlemler neticesinde veri tabanı sürekli
değişime uğrar.
• Veri tabanının herhangi bir andaki durumu
çok önemlidir ve buna veri tabanı örneği
(database instance) adı verilir.
Varlık-İlişki Çizelgelerinin İlişki
Şemalarına Dönüştürülmesi
• Varlık-ilişki modeli kullanılarak veri modelleme
yapıldığında, eğer veri tabanını gerçekleştirmek
için ilişkisel bir VTYS kullanılacaksa, oluşturulan
varlık-ilişki çizelgesinin ilişki şemalarına
dönüştürülmesi gerekir.
• Bu amaçla varlık-ilişki modelindeki her farklı
kavramın (varlık kümesi, nitelik, ilişki kümesi,
ilişki kümesinin tanımlayıcı niteliği, güçlü ve zayıf
varlık kümeleri, var olma bağımlılığı, genelleme,
kümeleme, ..vb) ilişkisel modelde nasıl
gösterileceğinin bilinmesi gerekir.
Varlık Kümelerinin Dönüştürülmesi
• Varlık-ilişki modelindeki her varlık kümesi
için ilişkisel modelde bir ilişki şeması
oluşturulur.
• İlişkinin nitelikleri olarak da varlık
kümesinin nitelikleri kullanılır.
• Daha önce verilmiş bir örnek olan, ÖĞRENCİ ve
DERS varlık kümelerine karşılık, ilişkisel
modelde aşağıdaki ilişki şemaları oluşturulur.
– ÖĞRENCİ (ÖĞRNO, ADI, SOYADI, CİNSİYETİ,
DOĞTAR)
– DERS (DKODU, DERSADI, KREDİSİ)
Örnek
ÖĞRENCİ
ADI SOYADI CİNSİYETi
ÖĞRNO DOĞTAR
DERS
DERSADI
DKODU
KREDİSİ
Varlık Kümelerinin Dönüştürülmesi
• Eğer varlık kümesi en az bir anahtarı
bulunan güçlü bir varlık kümesi ise, ilişki
nitelikleri olarak varlık kümesi özelliklerinin
kullanılması yeterlidir.
• Ancak eğer varlık kümesi, anahtarı
olmayan zayıf bir varlık kümesi ise, ilişki
nitelikleri olarak zayıf varlık kümesinin
niteliklerinin kullanılması yeterli değildir.
Varlık Kümelerinin Dönüştürülmesi
• Çünkü bu niteliklerin hepsi birlikte alındığında
bile bir anahtar oluşturmadığı ve anahtarı
bulunmayan bir ilişkinin olamayacağı
bilinmektedir.
• Bu nedenle zayıf bir varlık kümesine karşı gelen
ilişki şeması oluşturulurken, ilişki nitelikleri olarak
zayıf varlık kümesinin niteliklerine ek olarak, bu
varlık kümesinin var olma bağımlı olduğu güçlü
varlık kümesinin anahtarında yer alan
niteliklerde kullanılır.
• Daha önce verdiğimiz yukarıdaki çizimdeki güçlü
LİSE varlık kümesi ile zayıf ÖĞRENCİ varlık
kümelerine karşılık, ilişkisel modelde aşağıdaki
ilişki şemaları oluşturulur.
– LİSE (LİSENO, LİSEADI, KENT)
– ÖĞRENCİ (LİSENO, ÖĞRNO, ADI, SOYADI)
Örnek
ÖĞRENCİ
ADI SOYADI
ÖĞRNO LİSE
LİSEADI LİSENO
OKUDUĞU KENT
İlişki Kümelerinin Dönüştürülmesi
• Genel olarak varlık-ilişki modelindeki her ilişki
kümesi, ilişkisel modelde bir ilişki şemasına
dönüştürülür.
• Ancak kimi ilişki kümeleri için ilişkisel modelde
ayrı bir ilişki şeması oluşturmaya gerek yoktur.
• Bunun yerine varlık kümesi için oluşturulan ilişki
şemalarından birine, diğer varlık kümesinin
anahtarında yer alan nitelikleri eklemek
yeterlidir.
• Eğer bir ikili ilişki kümesinin türü çoktançoğa (ilişki hiçbir yönde işlevsel değil) ise
ilişkisel modelde bu ilişki kümesi için ayrı
bir şema oluşturulur.
• İlişki kümesine karşılık gelen ilişki
şemasında, her iki varlık kümesinin
anahtarları ile, varsa ilişki tanımlayıcı
niteliklerine yer verilir.
İkili Çoktan-Çoğa İlişki Kümelerinin
Dönüştürülmesi
Örnek
• Örneğin SATTIĞI ilişkisi ilişkisel modelde
aşağıda şeması verilen ilişki ile gösterilir.
SATTIĞI (MAĞNO, MALKODU, MİKTAR)
MAĞAZA SATTIĞI MAL
MAĞNO MAĞADI MALKODU MALADI
MİKTAR
n m
İkiden Büyük Dereceli İlişki Kümelerinin
Dönüştürülmesi
• Eğer bir ilişki kümesi ikiden çok varlık kümesi arasında
kurulmuşsa (ilişki üçlü, dörtlü,.. bir ilişki ise), ilişkinin
diğer özellikleri (eşleme sınırlamaları, ilişkinin tanımlayıcı
niteliklerinin bulunup bulunmaması, ..vb.) ne olursa
olsun, ilişkisel modelde bu ilişki kümesine karşılık ayrı bir
ilişki şeması oluşturulur.
• Oluşturulan ilişki şemasında, aralarında ilişki kurulan tüm
varlık kümelerinin anahtarlarına ek olarak, varsa ilişkinin
tanımlayıcı niteliklerine yer verilir.
• Bu varlık kümelerinden biri ya da birkaçı zayıf varlık
kümesi ise, bu varlık kümelerinin anahtarlarını bulmak
için ilgili yöntem kullanılır.
• KONSER, ESER ve MÜZİSYEN varlık
kümeleri arasındaki KATILIM adlı üçlü
ilişki kümesini düşünelim.
Örnek
KONSER
TARİH SALON GÖREVİ
KONSNO
MZSNO
ESER
ESTÜRÜ
ESNO
KATILIM BESTECİ
MÜZİSYEN SOYADI
ESADI
ADI
• Bu ilişki kümesi hangi konserde, hangi
eser çalınırken orkestrada hangi
müzisyenlerin yer aldığını ve görevlerinin
ne olduğunu göstermektedir.
Örnek
KONSER
TARİH SALON GÖREVİ
KONSNO
MZSNO
ESER
ESTÜRÜ
ESNO
KATILIM BESTECİ
MÜZİSYEN SOYADI
ESADI
ADI
KONSER(KONSNO, TARİH, SALON)
ESER(ESNO, ESADI, ESTÜRÜ, BESTECİ)
MÜZİSYEN(MZSNO, ADI, SOYADI)
Örnek
KONSER
TARİH SALON GÖREVİ
KONSNO
MZSNO
ESER
ESTÜRÜ
ESNO
KATILIM BESTECİ
MÜZİSYEN SOYADI
ESADI
ADI
Örnek
• Üçlü KATILIM ilişkisi için, ilişkisel modelde
aşağıdaki ilişki şeması oluşturulur:
KATILIM (KONSNO, ESNO, MZSNO, GÖREVİ)
• Eğer varlık kümeleri arasındaki ikili eşlemelerin
(konser-eser, konser-müzisyen ve esermüzisyen) her üçü de çoktan-çoğa ise KATILIM
ilişkisinin anahtarı, yukarıdaki ilişki şemasında
görüldüğü gibi üç varlık kümesinin anahtarlarının
birleşiminden oluşur.
• Eğer bir ikili ilişki kümesinin türü birdençoğa ya da çoktan-bire (ilişki bir yönde
işlevsel) ise ilişkisel modelde bu ilişki
kümesi için ayrı bir şema oluşturmaya
gerek yoktur.
• Örneğin BÖLÜM ve PERSONEL varlık
kümeleri arasındaki ÇALIŞAN ilişkisini
düşünelim.
İkili Birden-Çoğa İlişki Kümelerinin
Dönüştürülmesi
• Eğer her personel yalnız bir bölümde çalışıyorsa, bu
ilişkinin türü BÖLÜM'den PERSONEL'e birden-çoğadır.
Yani ilişki PERSONEL'den BÖLÜM'e işlevseldir.
• Bu varlık-ilişki çizelgesi ilişkisel modele dönüştürülürken
BÖLÜM ve PERSONEL varlık kümelerine karşı gelen ve
anahtarları sırasıyla BNO ve PNO olan iki şema
oluşturulur.
Örnek
• Eğer ÇALIŞAN ilişki kümesi için ayrı bir şema
oluşturulursa, bu şema, anahtarı PNO olan ve çalışan
her personel için yalnız bir satırı olan bir şema olacaktır.
• Oysa anahtarı PNO olan ve kurumdaki her personel için
yalnız bir satır içeren PERSONEL şeması zaten vardır.
• Dolayısıyla ÇALIŞAN ilişki kümesini göstermek için ayrı
bir ilişki oluşturmaya gerek yoktur.
Örnek
• Bu ilişki kümesini göstermek için PERSONEL ilişkisine
BÖLÜM varlık kümesinin anahtarı olan BNO ile ilişkinin
tanımlayıcı nitelikleri olan GÖREVİ ve GBAŞTAR eklenir.
• Bu durumda, yukarıdaki çizimdeki PERSONEL ve
BÖLÜM varlık kümeleri ile aralarındaki ÇALIŞAN
ilişkisine karşılık, ilişkisel modelde iki şema oluşturulur.
Örnek
BÖLÜM (BNO, BADI)
PERSONEL (PNO, ADI, SOYADI, DOĞTAR,
BNO, GÖREVİ, GBAŞTAR)
• Yukarıdaki ilişki şemalarından ilki varlık-ilişki
çizeneğindeki BÖLÜM varlık kümesine, ikincisi ise hem
PERSONEL varlık kümesine hem de ÇALIŞAN ilişkisine
karşılık gelmektedir.
Örnek
• Eğer bir ikili ilişki kümesinin türü birdenbire (ilişki her iki yönde de işlevsel) ise
ilişkisel modelde bu ilişki kümesini
göstermek için de ayrı bir şema
oluşturmaya gerek yoktur.
• Örneğin BÖLÜM ve PERSONEL varlık
kümeleri arasındaki BBAŞKANI (bölüm
başkanı) ilişkisini düşünelim.
İkili Birden-Bire İlişki Kümelerinin
Dönüştürülmesi
• Eğer her bölümün bir başkanı olabiliyorsa;
bir personel de en çok bir bölümün
başkanı olabiliyorsa, her iki yönde de
işlevsel olan bu ilişkinin türü bire-birdir.
Örnek
Örnek
• Bire-bir varlık kümelerini ilişkisel modelde
göstermek için, varlık kümelerinden birinin
anahtarını, varsa ilişkinin tanımlayıcı
nitelikleri ile birlikte, diğer varlık kümesine
karşı gelen şemaya eklemek yeterlidir.
• Bunun için de olası iki seçenekten biri
seçilir. İlişkilerin anlamlarına ve kullanım
ortamına göre bu seçeneklerden biri daha
uygun olabilir.
• 1. seçenek:
– BÖLÜM (BNO, BADI)
– PERSONEL (PNO, ADI, SOYADI, DOĞTAR, YBNO,
GBAŞTAR)
• Burada YBNO personelin (bölüm başkanının)
yönettiği bölümün numarasıdır.
Örnek
• 2. seçenek:
– BÖLÜM (BNO, BADI, BBPNO, GBAŞTAR)
– PERSONEL (PNO, ADI, SOYADI, DOĞTAR)
• Burada BBPNO bölüm başkanı personel
numarasıdır. (Bu örnek için bu seçenek daha
uygun bir çözüm olarak görülmektedir.)
Örnek
Aynı Varlık Kümesi İçindeki İlişki
Kümeleri
• Eğer ilişki kümesi iki farklı varlık kümesi
arasında tanımlanmak yerine, aynı varlık
kümesi içinde tanımlanmışsa, bu varlık
kümesinin işlevsel modele
dönüştürülmesinde hiçbir farklılık yoktur.
• İlişki kümesinin türünün birden-bire,
birden-çoğa ya da çoktan-çoğa olmasına
göre yukarıda söylenenlerin tümü
geçerlidir.
Aynı Varlık Kümesi İçindeki İlişki
Kümeleri
• Ancak aralarında ilişki kurulan varlık
kümeleri aynı olduğu için, bir ilişki
şemasında aynı niteliğin farklı rollerde yer
alması söz konusu olabilir.
• Bunun için de, roller de düşünülerek
niteliklere uygun adlar seçilmesi gerekir.
Örnek
• PERSONEL varlık kümesi ve bu varlık kümesi
içindeki birden-çoğa YÖNETİCİ ilişkisi ilişkisel
modelde tek bir şema ile gösterilebilir.
PERSONEL(SİCİLNO, ADI, BÖLÜMÜ, GÖREVİ,
GBAŞTAR, YSİCİLNO)
PERSONEL YÖNETİCİ
GBAŞTAR
ADI
BÖLÜMÜ
GÖREVİ
SİCİLNO
üst
ast
1
n
Örnek Soru
• Bir sanal alışveriş sitesi için geliştirilen veri
tabanında ürünler, kategoriler, tedarikçi
firmalar, müşteriler ve siparişler varlık
kümelerini, bu kümeler arasındaki ilişki
kümelerini (ilişki türlerini de belirterek) ve
size göre bu kümelerin sahip olması
gerekli nitelikleri de gösterecek şekilde
varlık-ilişki modeli çizelgesini oluşturunuz.
Sorunun Cevabı
ÜRÜN
Satış
Fiyat
Alış
Fiyat
Ürün ID KATEGORİ
Kategori ID
AİT OLDUĞU Kategori Adı
KDV Oranı
Ürün Adı
FİRMA
Adres
Firma ID
Firma Adı Telefon
TEDARİK
EDEN
SİPARİŞ
MÜŞTERİ
Mubayaacı ID
Soyad
Ad Adres
Telefon
n 1
1
n
YER ALDIĞI
VERDİĞİ
n
n
n
1
Tarih
Adet
SiparişID
İlişkisel Veri Modeli Gösterimi
• ÜRÜNLER(Ürün ID, Ürün Adı, Alış Fiyatı, Satış
Fiyatı, Kategori ID, Firma ID)
• KATEGORİLER(Kategori ID, Kategori Adı, KDV
Oranı)
• FİRMALAR(Firma ID, Firma Adı, Telefon, Adres)
• MÜŞTERİLER(Müşteri ID, Adı, Soyadı, Adresi,
Telefonu)
• SİPARİŞLER(Sipariş ID, Müşteri ID, Tarih)
• YER_ALDIĞI(Sipariş ID, Ürün ID, Adet)
İlişkilerin Tablolar ile Gösterimi
Veri Tabanı Yönetim Sistemleri
SQL'e Giriş
SQL (Structured Query Language)
• SQL çok yüksek seviyeli bir dildir.
– İngilizce bilen herkes bu dili kolayca öğrenebilir.
Programlama dillerine göre öğrenilmesi çok daha
kolaydır. Çünkü programlama dillerindeki gibi
işlemin “nasıl yapılacağı” değil, işlemde “ne
yapılacağı” yazılır.
• Birçok VTYS, yazılan sorguları en iyi şekilde
işlemek için sorgu en-iyileştirme (query
optimization) mekanizmaları kullanır.
DML, DDL ve DCL
• Sorgulama için sadece SELECT komutu kullanılsa da; SQL
içinde başka komutlar da yer alır. Bu komutlar işlevlerine
göre sınıflandırılmış ve başka alt-diller oluşturulmuştur:
– DML (Data Manipulation Language): Tablolara veri girmek için
kullanılan INSERT, var olan veriyi güncellemek için kullanılan
UPDATE ve veri silme için kullanılan DELETE komutlarını içerir.
– DDL (Data Definition Language): Veri tabanındaki nesneleri
yaratmak için kullanılan CREATE, yok etmek için kullanılan DROP
ve nesne üzerinde değişiklik işlemleri için kullanılan ALTER
komutlarını içerir.
– DCL (Data Control Language): Kullanıcılara yetki verme
işlemlerinde kullanılan GRANT ve verilen yetkileri geri alma
işlemleri için kullanılan REVOKE komutlarını içerir.
• NOT: DDL ve DCL “SQL Server” anlatıldıktan sonra detaylı
işlenecektir.
Örneklerde kullanılan
“Personel Bilgileri” Veri Tabanı
• PERSONEL Tablosu:
– PERSONEL_NO (PK)
– AD
– SOYAD
– GOREV
– MAAS
– BOLUM (FK-BOLUMLER)
– YONETICISI
– GIRIS_TARIHI
• BOLUMLER Tablosu:
– BOLUM_NO (PK)
– BOLUM_ADI
– BOLUM_YER
Örneklerde kullanılan
“Öğrenci İşleri” Veri Tabanı
• OGRENCILER Tablosu:
– OGR_NO (PK)
– AD
– SOYAD
– DOGUM_TARIHI
– DOGUM_YERI
– ADRES
• DERSLER Tablosu:
– DERS_KODU (PK)
– DERS_ADI
– DERS_KREDISI
– HOCASI (FK-HOCALAR)
• NOTLAR Tablosu:
– OGRENCI (FK-OGRENCILER)
– DERS (FK-DERSLER)
– DERS_YILI
– VIZE
– FINAL
• HOCALAR Tablosu:
– HOCA_NO (PK)
– AD
– SOYAD
– UNVAN
SELECT ifadesi
SELECT sütun [yada sütunlar]
FROM tablo [yada tablolar]
WHERE seçim kriteri
• SELECT ifadesinden sonra * kullanılırsa tüm
nitelikler (sütunlar) seçilir.
• Kriter verilmezse “WHERE” sözcüğü de yazılmaz.
Bu durumda tüm kayıtlar (satırlar) seçilir.
• Personel tablosundaki tüm kayıtların tüm
nitelikleri aşağıdaki SQL cümlesi ile gösterilir:
SELECT * FROM PERSONEL
WHERE ile kriter verme
• Eğer tüm kayıtların değil de sadece belirli
kayıtların görüntülenmesi istenirse WHERE ile
kriter verilir.
• Aşağıdaki SQL cümlesi maaşı 1800 TL’nin
üzerinde olan personelin adı ve soyadını
ekranda gösterir:
SELECT AD, SOYAD
FROM PERSONEL
WHERE MAAS > 1800
Kriterlerde kullanılan işleçler
• Programlama dillerinde kullanılan aritmetiksel
karşılaştırma işleçleri (<, <=, >, >=, =, <>) ve
mantıksal işleçler (AND, OR, NOT) SQL dilinde
de kriter verirken kullanılır.
• Aşağıdaki SQL cümlesi görevi müdür olan ve
maaşı 5000 TL’den fazla olan personeli
gösterir:
SELECT * FROM PERSONEL
WHERE GOREV =
'Müdür' AND MAAS > 5000
Programlama dillerinde olduğu gibi SQL’de de karakter türü veriler ile işlem yapılacaksa
tek tırnak yada çift tırnak kullanılır.
Karakter türü verilerin karşılaştırılması
• Karakter türü veriler ile de büyüklük-küçüklük
kıyaslamaları yapılabilir.
• Aşağıdaki SQL cümlesi adı N-Z arasında bir harf ile
başlayan personeli gösterir:
SELECT * FROM PERSONEL WHERE AD > 'N'
• Aşağıdaki SQL cümlesi adı E harfi ile başlayan
personeli gösterir:
SELECT * FROM PERSONEL
WHERE AD > 'E' AND AD < 'F'
LIKE işleci
• Belirli bir karakteri veya karakter katarını barındıran verileri
aramak için LIKE kullanılır.
• Önceki slaytta yer alan, adı E harfi ile başlayan personeli
gösteren sorgu LIKE ile de yazılabilir:
SELECT * FROM PERSONEL WHERE AD LIKE 'E*'
• Adresler şehir adı ile bitiyorsa, Edirne ilinde ikamet eden
öğrencileri görmek için:
SELECT * FROM OGRENCİLER WHERE ADRES LIKE '*Edirne'
• Sadece tek bir karakteri farklı olan verileri bulmak için *
yerine ? kullanılabilir:
SELECT * FROM DERSLER WHERE DERS_ADI LIKE ‘Fizik ?’
• ANSI SQL standartlarında * yerine %, ? yerine _ kullanılır
Oracle ve MS Server ANSI SQL standartlarını destekler
BETWEEN … AND … işleci
• İki değer arasında karşılaştırma yapmak için Between …
And … işleci (… ile … arasında) kullanılabilir.
• Aşağıdaki SQL cümlesi maaşı 1000 ile 2000 TL arasında
olan işçileri görüntüler:
SELECT * FROM PERSONEL
WHERE MAAS BETWEEN 1000 AND 2000
AND GOREVI = 'İşçi'
• Bu sorgu Between işleci kullanılmadan da yazılabilirdi:
SELECT * FROM PERSONEL
WHERE MAAS >= 1000 AND MAAS <= 2000
AND GOREVI = 'İşçi'
IN işleci
• Bir listedeki değerler ile karşılaştırma yapmak
için IN işleci kullanılır.
• 1000 ile 2000 TL arasında değil de sadece
1000, 1500 ve 2000 TL maaş alanları
listelemek için aşağıdaki SQL cümlesi
kullanılabilir:
SELECT * FROM PERSONEL WHERE MAAS IN
(1000, 1500, 2000)
Tarihsel türü verilerin karşılaştırılması
• Belirli bir tarihe eşit olan veya o tarihten
büyük yada küçük olan verilerin aranması
istenirse, tarih ay/gün/yıl biçiminde ve #
karakterleri arasında yazılmalıdır:
• 1989 doğumlu öğrenciler:
SELECT * FROM OGRENCILER
WHERE DOGUM_TARIHI BETWEEN
#1/1/1989# AND #12/31/1989#
DISTINCT ifadesi
• Eğer tablonun bir alanında yer alan veriler
içinde aynı olan veriler varsa SELECT
ifadesinden sonra kullanılan DISTINCT ile bu
tekrar eden verilerin sadece 1 defa
görüntülenmesi sağlanabilir.
• Aşağıdaki SQL cümlesi farklı kayıtlardaki aynı
adları her kayıt için tekrar göstermek yerine 1
defa gösterilmesini sağlar:
SELECT DISTINCT AD FROM PERSONEL
AS ifadesi ve sütun içeriklerini
birleştirme
• Sütunların kendi ismi yerine AS ifadesi ile takma
isim almaları sağlanabilir.
• İki yada daha fazla sayıda sütunun içeriğini
birleştirmek için sütun isimleri arasında Access’te
&, Oracle’da ise || işleçleri kullanılır.
• Aşağıdaki SQL cümlesi AD ve SOYAD sütunlarının
içeriklerini araya bir boşluk karakteri ekleyerek
birleştirir ve ISIM adlı bir sütun şeklinde gösterir.
SELECT AD & ' ' & SOYAD AS ISIM FROM OGRENCILER
Matematiksel İşlemler
• SELECT ifadesinden sonra bir sütunun bir
matematiksel işleme tabi tutulması ve bu işlemin
sonucunun gösterilmesi sağlanabilir.
• Personelin yıllık maaşlarının görüntülenmesi:
SELECT AD, SOYAD, MAAS * 12 AS YILLIK_MAAS
FROM PERSONEL
• Öğrencilerin BIL117 kodlu dersten başarı
notlarının görüntülenmesi:
SELECT OGR_NO, VIZE * 0.3 + FINAL * 0.7 AS
BASARI_NOTU FROM NOTLAR
WHERE DERS = 'BIL117'
NULL (boş) değerler ile ilgili işlemler
• Eğer bir kayıt, bazı alanları boş bırakılarak
eklendiyse, matematiksel işlemlerde sorun
çıkabilir (NULL, sıfır değeri ile aynı değildir).
1500 * 12 + 0 işleminin sonucu 1800 iken,
1500 * 12 + NULL işleminin sonucu NULL olacaktır.
• Karşılaştırma işlemlerinde de NULL ile = işleci
kullanılmaz, IS kullanılır. Notlar tablosunda
Final notu girilmemiş kayıtlar:
SELECT * FROM NOTLAR WHERE FINAL IS NULL
FINAL IS NOT NULL kullanılsaydı notu girilen öğrenciler görüntülenirdi.
Büyük/Küçük Harf Duyarlılığı
• SQL dili büyük/küçük harf ayrımı yapmaz
(case-sensitive değildir).
• Aşağıdaki yazımların hepsi aynı işi yapar
(Personel tablosundaki tüm personelin sadece
adı ve soyadı görüntülenir):
– SELECT AD, SOYAD FROM PERSONEL
– SELECT Ad, Soyad FROM Personel
– Select Ad, Soyad From Personel
– select ad, soyad from personel
Türkçe karakter kullanma
• Birçok VTYS, tablo ve nitelik isimlerinde Türkçe
karakter kullanımına izin verse de sorgularda
bazı sıkıntılara neden olabileceği için
kullanılması tavsiye edilmez.
– Örneğin PERSONEL tablosundaki nitelik isimleri
ADI ve SOYADI şeklinde büyük harfler ile verildiyse,
bazı VTYS’ler “SELECT Adı, Soyadı FROM Personel”
ifadesini, bazıları ise “SELECT Adi, Soyadi FROM
Personel” ifadesini (İngilizcede 'I' harfinin küçük
hali 'i' olduğu için) doğru kabul eder.
Alan ismi belirlerken dikkat edilmesi
gereken noktalar:
• Öğrencilerin not bilgilerini saklamak için “NOT” isminde bir
alan yaratılmamalıdır. İngilizcede “değil” anlamına geldiği ve
SQL'de kullanılan bir ifade olduğu için “NOT” yerine
“NOTU”, “VIZE”, “FINAL” gibi ifadeler tercih edilmelidir.
• Benzer şekilde SQL’de kullanılan AND, GROUP, ORDER, …
gibi ifadeler de alan ismi olarak kullanılmamalıdır.
• Alan isimlerinde boşluk karakteri kullanılırsa sorgularda o
alan ismini köşeli parantez içinde yazmak gerekeceği için alt
çizgi (_) kullanmak yada boşluksuz yazmak daha kullanışlı
olacaktır.
SELECT DersKodu FROM DERSLER;
SELECT Ders_Kodu FROM DERSLER;
SELECT [Ders Kodu] FROM DERSLER;
ORDER BY ile sıralama
• Eğer görüntülenecek olan kayıtların belirli bir
sütuna göre sıralı olarak görüntülenmesi
isteniyorsa ORDER BY kullanılır.
• Sıralama yukarıdan aşağıya doğru artan sırada
olacaksa ASC, azalan sırada olacaksa DESC
kullanılır. Varsayılan sıralama şekli artan olduğu
için ASC yazılmasa bile artan sıralama kullanılmış
olur.
• Aşağıdaki SQL cümlesi PERSONEL tablosundaki
kayıtları maaşa göre azalan sırada gösterir:
SELECT * FROM PERSONEL ORDER BY MAAS DESC
ORDER BY ile sıralama
• Eğer ORDER BY sonrasında birden çok sütun
adı yazılırsa, sıralama önceliği sütunların yazılış
sırasına göre yapılır.
• Aşağıdaki sorgu personel tablosundaki tüm
kayıtları bölümlere göre artan sırada sıralayıp,
her bölüme ait personelin maaşını da azalan
sırada gösterir.
SELECT * FROM PERSONEL
ORDER BY BOLUM, MAAS DESC
SQL Fonksiyonları
• Programlama dillerinde olduğu gibi, SQL’de de
aritmetik işlemler, tarihsel işlemler, string
işlemleri veya tip dönüşümü yapmak için hazır
olarak sunulan fonksiyonlar mevcuttur.
• SUM, AVG, MIN, MAX ve COUNT gibi bazı
fonksiyonlar birçok kayıt üzerinde işlem yapıp
tek bir sonuç üretirken, dönüşüm, string ve
tarih fonksiyonları ise üzerinde işlem yaptığı
her kayıt için ayrı sonuç üretir.
SUM ve AVG
• Belirli bir sütundaki sayısal verilerin toplanarak
sonucun gösterilmesi istenirse SUM, aritmetik
ortalamasının gösterilmesi istenirse AVG kullanılır.
• Aşağıdaki SQL ifadelerinden ilki tüm personelin
maaşlarının toplamını, ikincisi ise maaşların
aritmetik ortalamasını gösterir:
1. SELECT SUM(MAAS) AS TOPLAM_MAAS
FROM PERSONEL
2. SELECT AVG(MAAS) AS [MAASLARIN ORTALAMASI]
FROM PERSONEL
NOT: _ karakteri yerine boşluk karakteri
kullanılması istenirse [] içinde yazılmalıdır.
MIN ve MAX
• Belirli bir sütundaki en büyük veriyi görüntülemek
için MAX, en küçük veriyi görüntülemek için ise
MIN fonksiyonları kullanılır.
• Aşağıdaki SQL cümlesi, "2013-2014" öğretim
yılında "BİL118" dersinden en yüksek başarı
notunu gösterir:
SELECT MAX(VIZE * 0.3 + FINAL * 0.7) AS "Max BN"
FROM NOTLAR
WHERE DERS = "BİL118" AND DERS_YILI = "2013-2014"
COUNT
• Sorgunun ürettiği satır sayısını döndürür.
• Aşağıdaki SQL cümlesi PERSONEL tablosundaki
toplam kayıt sayısını döndürür:
SELECT COUNT(*) FROM PERSONEL
• Eğer COUNT içinde * yerine belirli bir sütun
ismi verilirse o sütundaki NULL olmayan değer
sayısını döndürür:
SELECT COUNT(ADRES) FROM OGRENCILER
TOP
• Önceki örnekte en yüksek başarı notunu alan öğrencinin
numarasını da göstermek istersek aşağıdaki kullanım hata
verecektir:
SELECT OGRENCI, MAX(VIZE * 0.3 + FINAL * 0.7) AS MAX_BN
FROM NOTLAR
WHERE DERS = "BİL118" AND DERS_YILI = "2013-2014"
• SELECT sonrasında “TOP n” kullanımı en üstteki n kaydı
gösterir. Örneğimizde başarı notuna göre azalan sıralama
yapıp en üstteki kaydı almak için “TOP 1” deyimini
kullanmak en uygun çözümdür:
SELECT TOP 1 OGRENCI, VIZE*0.3 + FINAL*0.7 AS Başarı_Notu
FROM NOTLAR
WHERE DERS = “BM 316” AND DERS_YILI = “2009-2010”
ORDER BY VIZE*0.3 + FINAL*0.7 DESC
NOT: Bu ifade yerine takma ismi olan
Başarı_Notu kullanılması hata verir
GROUP BY
• SUM, AVG, MIN, MAX ve COUNT fonksiyonlarının tablonun tamamı için değil de, belirli
bir sütuna göre gruplandırılarak çalıştırılması
GROUP BY deyimi ile sağlanabilir.
• Aşağıdaki SQL cümlesi personelin ortalama
maaşlarını her bölüm için ayrı ayrı listeler:
SELECT BOLUM, AVG(MAAS)
FROM PERSONEL
GROUP BY BOLUM
SELECT sonrasında BOLUM yer
almazsa görüntülenecek ortalama
maaşların hangi bölüme ait
olduğunun bilinemeyecek olması
mantıksal olarak hatadır
GROUP BY ifadesi silinirse veya sonrasında BOLUM yerine başka sütun yazılırsa sorgu çalışmaz.
Başka bir alana göre gruplandırılırsa, bölüm yanında neye göre maaş ortalaması yer alacak?
Birden fazla sütuna göre gruplama
• GROUP BY ile bir sütuna göre gruplama
yapılabildiği gibi, birden fazla sütun için de
gruplama yapılabilir.
• Her bölüm içindeki farklı görevlere sahip
personelin maaşlarının toplamlarını ayrı ayrı
elde etmek için:
SELECT BOLUM, GOREV, SUM(MAAS)
FROM PERSONEL
GROUP BY BOLUM, GOREV;
Bu sorguda da hem SELECT hem de GROUP BY sonrasında aynı sütun ismleri yer almıştır.
SELECT ifadesindeki fonksiyon hariç tüm sütun isimleri GROUP BY ifadesinde yer almalıdır.
• Personeline ödenen maaşların ortalaması 4000'den
fazla olan bölümlerin numarası ve yanında o bölüme ait
en yüksek maaşı gösteren sorgu:
SELECT BOLUM, MAX(MAAS) FROM PERSONEL
GROUP BY BOLUM HAVING AVG(MAAS) > 4000;
• Eğer aşağıdaki gibi WHERE koşulu içinde ortalama
fonksiyonu kullanılmaya çalışılırsa hata verecektir.
SELECT BOLUM, MAX(MAAS) FROM PERSONEL
WHERE AVG(MAAS) > 4000 GROUP BY BOLUM;
WHERE koşulunda AVG(MAAS)>4000 yerine MAAS>4000 yazılsaydı
sorgu çalışırdı. Fakat tüm tablodaki maaşı 4000'den fazla olan
personeli dikkate alarak sonrasında gruplama yapacağı için HAVING
kullanarak yazdığımız sorgu ile aynı sonucu vermeyecektir.
HAVING ile Grup Koşulu verme
Örnek 1
• Aşağıdaki sorgu neyi gösterir:
SELECT BOLUM, SUM(MAAS) AS TOPLAM_MAAS
FROM PERSONEL WHERE GOREV <> 'Müdür'
GROUP BY BOLUM HAVING SUM(MAAS) > 50000
ORDER BY SUM(MAAS);
Müdür haricindeki personelinin toplam maaşları
50.000’den fazla olan bölümleri seçer ve hesaplanan
toplam maaşlara göre artan sırada olacak şekilde bu
bölümleri ve yanlarında toplam maaşları listeler.
Örnek 2
• Aşağıdaki sorgu neyi gösterir:
SELECT AD, COUNT(AD) AS [Tekrar Sayısı]
FROM OGRENCILER
GROUP BY AD HAVING COUNT(AD)>1
ORDER BY COUNT(AD) DESC;
Aynı ada sahip olan öğrencileri bulur ve en çok tekrar
eden addan en az tekrar edene doğru, tekrar sayıları
ile birlikte sıralı olarak listeler.
NOT: Access’te «Oluştur + Sorgu Sihirbazı + Yinelenenleri Bulma Sorgusu» benzer bir sorgu
oluşturur (Önümüzdeki hafta değinilecek).
Diğer Fonksiyonlar
• GROUP BY ile kullanılan fonksiyonlar (SUM, AVG,
MIN, MAX ve COUNT) tüm İVTYS'lerde aynı olsa
da diğer fonksiyonlar farklılık gösterebilmektedir.
• Sonraki slaytlarda Access fonksiyonlarının sadece
bir kısmına değinilecektir.
• Tüm Access, SQL Server ve Oracle fonksiyonları ile
ilgili detaylı bilgiler aşağıdaki web adreslerinde
yer almaktadır:
– http://www.techonthenet.com/access/functions
– http://technet.microsoft.com/tr-tr/library/ms174318
– http://psoug.org/reference/builtin_functions.html
Nümerik Fonksiyonlar
• ROUND: Ondalıklı sayıları tamsayıya veya verilen
bir ondalık basamağa yuvarlamak için kullanılır.
– Round (210.67, 1)  210.7
– Round (210.67, 0) veya Round (210.67)  211
• FIX ve INT: Her ikisi de ondalıklı sayının tam
kısmını döndürür. Sadece negatif sayılarda farklı
sonuç üretirler:
– Fix (210.67)  210
– Fix (2.98)  2
– Fix (-2.98)  -2
Int (210.67)  210
Int (2.98)  2
Int (-2.98)  -3
String Fonksiyonları
• LCASE: Tüm karakterleri küçük harfe dönüştürür (SQL
Server, Oracle’da LOWER)
• UCASE: Tüm karakterleri büyük harfe dönüştürür (SQL
Server, Oracle’da UPPER)
• MID: Bir string'in m. pozisyonundan itibaren n
karakterinden oluşan yeni bir string döndürür (SQL
Server'da SUBSTRING, Oracle'da SUBSTR)
• LEN: Sütun yada ifade içindeki karakter sayısını döndürür
(Oracle’da LENGTH)
• Örn: AD'ın ilk harfinin yanına nokta ekleyip, SOYAD'ın tüm
karakterlerini büyük harf olarak ISIM altında birleştirme:
SELECT MID(AD,1,1) & '. ' & UCASE(SOYAD) AS ISIM
FROM PERSONEL
Tarih Fonksiyonları
• NOW: Sistem tarihini ve saatini döndürür.
• DATEDIFF: İki tarih arasındaki farkı verir.
• DATEADD: Aldığı tarihin üzerine aldığı değeri (gün,
ay, yıl) ekleyerek yeni bir tarih değeri üretir.
• DAY: Aldığı tarihin gün kısmını döndürür.
• MONTH: Aldığı tarihin ay kısmını döndürür.
• YEAR: Aldığı tarihin yıl kısmını döndürür.
• Örn: 1989 doğumlu öğrenciler:
SELECT * FROM OGRENCILER
WHERE YEAR(DOGUM_TARIHI) = 1989
Dönüşüm Fonksiyonları
• Access’te tip dönüşüm fonksiyonları "C" ile başlar
ve dönüştürülecek olan veri türü ile devam eder:
CBool CDate CInt CStr
CCur CDec CSng …
• Oracle’da ise genellikle "TO_" ile başlar ve veri
türü ile devam eder:
TO_CHAR TO_DATE TO_NUMBER …
• SQL Server ve Oracle’da CAST ve CONVERT gibi
dönüşüm işlemlerinde kullanılabilen daha detaylı
fonksiyonlar da vardır.
Bütünlük Kısıtlamaları ve İlişkisel
Tasarım
1.Bütünlük Kısıtlamaları
Veri tabanı, "tutarlı bir bütün" olmalı;
Yanlış veri olmamalı,
Eksik veri olmamalı,
Birbiriyle çelişen veri olmamalı,
Tutarsız veri içermemeli.
Bütünlük Kısıtlaması: Yukarıdakileri sağlamak için
tanımlanan her türlü kısıtlamadır.
Ekleme, Günleme ve Silme;
Bütünlük kısıtlamalarına uymalı,
Bütünlüğü ve tutarlılığını bozmamalı.
Bütünlük kısıtlaması çeşitleri:
1. Veri tabanının yapısında yer alanlar.
2. Kural olarak tanımlanıp denetimleri işletim
aşamasında yapılanlar.
3. Veri tabanı yapısında ve kurallarda olmayanlar.
a) Uygulama programları içinde yer alır;
b) Kullanıcılar tarafından bilindiği varsayılır ve kullanıcıların
bu kurallara uyması beklenir.
Tamamen uyum beklenemez.
Uygulama programına bağlı olarak kısıtlamalar değişebilir.
Kullanıcılar bu kısıtlamalara uymayabilir.
Bütünlük kısıtlamaları;
Olabildiğince veri tabanı tanımında yer almalı,
Veri Tabanı Yönetim Sistemi tarafından uygulanmalı.
Bütünlük kısıtlamalarının tümünün veri tabanı
tanımında yer alması mümkün değildir.
Veri tabanı bütünlüğünün sağlanması, tasarımı ve
uygulamaları ilgilendirir.
Bütünlük ve tutarlılık için veri tabanı iyi
tasarlanmalıdır. Ancak yeterli değildir.
Çok çeşitli kısıtlamalar olabilir.
Temel bütünlük kısıtlamaları:
 Alan kısıtlamaları,
 Referans kısıtlamaları,
 Kurallar ve nitelikler arası bağımlılıklar,
Alan Kısıtlamaları
Alan kısıtlamaları her niteliğe bir alan eşlenmesi ve
niteliğin alabileceği değerlerin bu alandaki
değerlerle sınırlanması ile ilgilidir.
Veri Tabanı Yönetim Sistemleri genellikle
kullanıcıların alan tanımlamasına izin vermezler.
Alan kısıtlaması tür tanımı ve değerlerle ilgili kimi
kısıtlamalarla gerçekleştirilir.
 Alan türleri: Tamsayı, kesirli sayı, karakter,
değişken uzunluklu karakter, tarih, parasal değer,
…vb.
 Değer sınırları: Alt sınır değeri, üst sınır değeri,
… vb.
 Boş (null) değer: Nitelik değerinin eksik olup
olamayacağı.
Referans Kısıtlaması
İlişkisinin bazı niteliklerin alabileceği değerlerin,
(B) ilişkisindeki niteliklerin var olan değerleri ile
sınırlanmasıdır.
Bir ilişkideki çokluların varlığının, bir başka
ilişkideki belirli çokluların varlığına bağımlı
olmasıdır.
A : Referans gösteren ilişki,
B : Referans gösterilen ilişki.
A ve B ilişkileri aynı ilişki de olabilir.
Örnek 4.1.
ÜRÜN (ÜKODU, ÜADI, ÜTÜRÜ, BİRİMİ, FİYATI)
MAĞAZA (MNO, MADI, KENT, ADRES, TELNO)
SATIŞ (SÜKODU, SMNO, STARİHİ, SMİKTARI)
PERSONEL (PERNO, ADISOYADI, GÖREVİ, ÇALMNO)
Dört ilişki birbirinden bağımsız değildir.
Örnek:
SATIŞ ilişkisine birçoklu ekleme, ÜRÜN ve MAĞAZA
ilişkilerinden bağımsız değildir.
SATIŞ ilişkisinde satışı yapılan ürünün kodu (SÜKODU) ve
satışı yapan mağazanın numarası (SMNO) nitelikleri yer
almaktadır.
Ancak var olan bir mağaza var olan bir ürünü
satabilir.
Bütünlüğünün korunabilmesi için,
 SATIŞ ilişkisine bir çoklu eklenirken:
Eklenecek çokludaki SÜKODU değerinin, var
olan bir ÜRÜN çoklusundaki ÜKODU değerine
eşit olması (deyişle böyle bir ürünün var
olması),
 Eklenecek çokludaki SMNO değerinin, var olan
bir MAĞAZA çoklusundaki MNO değerine eşit
olması (başka bir deyişle satışı yapan
mağazanın var olması) gerekir.
1. Bütünlük kısıtlaması ;
“Ancak var olan bir ürün, var olan bir mağaza
tarafından satılabilir.”
PERSONEL ilişkisinde, personelin çalıştığı
mağazayı gösteren bir nitelik (ÇALMNO) yer
almaktadır.
Her personel çoklusunda (ÇALMNO) niteliğinin
değerinin MAĞAZA ilişkisinde var olan bir
çokludaki MNO değerine eşit olması gerekir.
2. Bütünlük kısıtlaması:
“Her personel ancak var olan bir mağazada
çalışabilir”
1.SATIŞ ilişkisinde SÜKODU niteliği, ÜRÜN
ilişkisinin birincil anahtarını (ÜKODU) referans
göstermektedir.
SÜKODU: SATIŞ ilişkisinde yabancı anahtardır.
2.SATIŞ ilişkisinde SMNO niteliği, MAĞAZA
ilişkisinin birincil anahtarını (MNO) referans
göstermektedir.
SMNO: SATIŞ ilişkisinde yabancı anahtardır.
3.PERSONEL ilişkisinde ÇALMNO niteliği,
MAĞAZA ilişkisinin birincil anahtarını (MNO)
referans göstermektedir.
ÇALMNO: PERSONEL ilişkisinde yabancı
anahtardır.
PER NO ADI SOYADI GÖREVİ ÇALMNO
PERSONEL
MAĞAZA
MNO MADI KENT ADRES TELNO
ÜRÜN
ÜKODU ÜADI ÜTÜRÜ BİRİMİ FİYATI
SATIŞ
SÜKODU SMNO SMİKTARI SFİYATI
Referanslar Çizimi:
Referans kısıtlamasının biçimsel tanımı:
İlişki şemaları R1 ve R2 olan r1ve r2
ilişkilerini
düşünelim.
R1
ilişkisinin anahtarlarından biri K1 olsun
(birincil anahtar olması zorunlu değildir).
A ile R2
ilişkisinin niteliklerinin bir altkümesini
gösterelim.
Eğer r2
'de bir t2 çoklusunun varlığı, r1
'de
anahtar (K1) değeri t2
'deki A değerine eşit bir
t1 çoklusunun varlığına(Ǝ t1 : t1 [K1]= t2 [A] )
bağımlı ise, A R2 için bir yabancı anahtardır ve
R1
ilişkisinin K1 anahtarını referans gösterir
denir.
Bu durumda r2 üzerinde yapılacak her ekleme,
silme ve günleme işleminde referans
kısıtlamasının sağlanması gerekir.
Nitelikler Arası Bağımlılıklar
Bazı niteliklerin birbirinden bağımsız olmayabilir
Niteliklerin değerlerinin birbirinden bağımsız
olarak belirlenemeyebilir.
Örnek 4.2.
SATICI (ÜKODU, FNO, FADI, FADRESİ, SFİYATI)
ÜKODU: Ürün Kodu,
FNO: Firma No,
FADI: Firma Adı,
FADRESİ: Firma Adresi,
SFİYATI: Satış fiyatı.
a. Veri yinelemesi: FNO ve FADI her ürün için
yinelenmektedir. Gereksiz bellek kullanımına ve
tutarsızlığa yol açabilir.
b. Günleme aykırılığı: FNO ve FADI değişikliği bir
her çoklu (kayıt) için yapılmalı ve aynı olmalıdır.
Tutarsızlık oluşturabilir. (Her firmanın bir adı, bir
adresi vardır ilkesi bozulabilir.)
c. Ekleme Aykırılığı: Bir firma için FNO ve FADI
bilgilerinin saklanabilmesi için, firmanın
pazarladığı bir ürünün (ÜKODU) bulunmalıdır.
SATICI ‘ya ekleme;
 İlk çoklu ekleniyorsa, veri tabanındaki firmalar arasına
bir yenisinin eklenmesi.
 Firmanın pazarladığı ürünlere bir yenisinin eklenmesi.
Firma bilgisi ekleme ve firmanın pazarladığı ürün
bilgisi ekleme olarak adlandırılabilecek bu iki işlemin
tek bir ekleme işlemiyle gerçekleştirilmesi bir
aykırılıktır.
Bu iki işlemin değişik zamanlarda değişik kişiler
tarafından yapılması daha uygun olabilir.
d.Silme aykırılığı: Veri tabanında bir firmaya ilişkin tek
bir çoklu varsa, bu çoklunun silinmesi de iki işleme
(firma bilgisi silme ve firmanın pazarladığı ürün bilgisi
silme) karşı gelir.
Bu işlemlerin de değişik zamanlarda, değişik kişiler
tarafından yapılması daha uygun olabilir.
Çözüm:
Örnek 4.3:
FİRMA (FNO, FADI, FADRESİ)
SÜRÜN (FNO, ÜKODU, SFİYAT)
İşlevsel Bağımlılık: Temel
Kavramlar
R=(A1, A2, A3,…,An) ; R: bir ilişki şeması,
X ⊆ R , Y ⊆ R ; X ve Y: İki nitelik altkümesi.
Eğer X nitelik değerleri aynı olan tüm çoklularda, Y nitelik
değerlerinin de aynı olması gerekiyorsa X Y’ yi işlevsel
belirler.
Y, X’ e işlevsel bağımlıdır ( X  Y )
her r ilişki olgusunda:
t1 [X] = t2[X]  t1 [Y]= t2 [Y]
Kavramsal ve Olgu düzeyi işlevsel bağımlılığı.
1. Kavramsal düzeyde:
Gerçek dünyanın bir yansıması olarak,.
FNO  FADI, FADRESİ
ÜKODU, FNO  SFİYATI
Ayrıca eğer gerçek dünyada, veri tabanının
kullanıldığı ortamda, firma adları tek ise (firma
adlarının birbirlerinden farklı olması
gerekiyorsa; bunu zorlayan bir kural varsa),
ilişki şemasında tanımlı işlevsel bağımlılıklar
arasında aşağıdaki de bulunur.
FADI  FNO, FADRESİ
2. Olgu (örnek) düzeyinde:
Bir r ilişki olgusu, ilişkide o anda mevcut
çoklulara göre, belirli işlevsel bağımlılıkları
sağlar.
Örnek 4.2’de bir r olgusunda, işlevsel
bağımlılıklar sağlanabilir.
FNO  FADI, FADRESİ : Kavramsal
FADI  FNO, FADRESİ : Kavramsal
ÜKODU, FNO  SFİYATI : Kavramsal
FADRESİ  FNO, FADI : Olgu
Bir ilişki olgusunun sağladığı işlevsel
bağımlılıktan söz edilirse de bu mutlaka
belirtilecektir.
Örnek 4.4.
TAŞIT(PLAKANO, MARKA, MODEL, YIL,
AĞIRLIK, RENK)
Bu örnekteki işlevsel bağımlılıklar şunlardır:
PLAKANO  MARKA, MODEL, YIL,
AĞIRLIK,RENK
MARKA, MODEL  AĞIRLIK
Anlaşılırlığı arttırmak için işlevsel
bağımlılıklar bir çizimle gösterilebilir.
Çizim 4.2. Örnek 4.4’deki İlişki Şeması için
İşlevsel Bağımlılık Çizeneği
PLKNO
RENK
YIL
AĞIRLIK
MODEL
MARKA
Örnek 4.5. R(A, B, C, D) ilişki şemasına göre
oluşturulmuş aşağıdaki r ilişki olgusu veriliyor.
r :
A B C D
1 a x e
2 a y b
2 b x c
3 c x c
4 a x e
İşlevsel bağımlılıklar:.
D  C
A,B  C,D
A,C  B,D
A,D  B,C
B,C  D
Kısaca: A,B  C,D yerine AB  CD
Veri Tabanı Sisteminin
Kurulması
Ders 7
Sistem Analizi
• Bilgisayara dayalı bir sistemin ve bunun
içerisindeki veri tabanının kurulması ve
geliştirilmesi (sistem analizi) üç aşamada
gerçekleştirilir:
– İnceleme ve Analiz
– Sistem Tasarımı
• Genel Tasarım
• Ayrıntılı Tasarım
– Hazırlık ve Uygulama
1
İnceleme ve Analiz
• Kurum veya fabrikanın bilişim gereksinimlerinin
saptanması ve karşılanması yollarının
irdelenmesi amacı ile yapılmaktadır.
• Bu aşamada çalışmayı yürütecek ekibin
oluşturulması, sistem geliştirme planının
hazırlanması, bilgi toplanması, mevcut sistemin
analizi, gereksinimlerin belirlenmesi, verimliliğin
değerlendirilmesi, analiz raporunun hazırlanması
aşamaları yer almaktadır.
1.1
Sistem Tasarımı
• Kurulacak yada geliştirilecek bilgi işlem
sisteminin planlanması, yöntem ve
tanımların yapılması aşamasıdır.
• Onaylanan analiz raporundaki önerilere
dayanılarak hazırlanmaktadır.
• Genel Tasarım ve Ayrıntılı Tasarım olmak
üzere iki aşamadan oluşur.
1.2
Genel Tasarım
• Analiz aşamasında belirlenmiş olan amaç
ve hedeflere nasıl ulaşılacağına ilişkin
öneriler geliştirilmektedir.
• Sistem, önce alt sistemlere, sonra
işlemlere, ve son olarak ta yönetilebilir
küçük görevlere bölünmektedir.
• Her işlem ve görev için en uygun araçgereç ve yöntemler saptanmaktadır.
1.2.1
Ayrıntılı Tasarım
• Bilgisayar sisteminin kullanılışını gösteren
durumlar ve koşullar ayrıntılı olarak
belirlenmektedir.
• Önce, girdiler, çıktılar, raporlar, kütükler ve
veri tabanı ayrıntılı olarak
tasarlanmaktadır.
• Sonra, ayrıntılı mantıksal planlar (akış
diyagramları) geliştirilip, uygulama
programları düzenlenmektedir.
1.2.2
Hazırlık ve Uygulama
• Sistem tasarımı onaylandıktan sonra, bu
sistemin kurulması ve işletilmesi için gerekli
işlemler bu aşamada gerçekleştirilir.
• Bu işlemler;
– donanım ve yazılımın sağlanması
– görevlilerin eğitimi
– program tasarımı, kodlanması ve sınanması
– veri tabanının dönüştürülmesi
– sistemin sınanması
– kullanım kılavuzlarının ve sistem belgelerinin
hazırlanması
1.3
Veri Tabanının Geliştirilmesi
• Gereksinim Analizi ve Değerlendirilmesi
– Kavramsal Veri Modelinin Tasarımı
• Veri Tabanının Tasarımı
– Mantıksal Tasarım
– Fiziksel Tasarım
• Veri Tabanının Tamamlanması (uygulama
programları, testler, dokümantasyon, …)
• Veri Tabanının İşletilmesi ve Yönetilmesi
2.
Gereksinim Analizi
• Bir sistemin analizi yapılmış ve bir veri tabanı
kurulması önerilmiş ise, önce veri tabanından
beklenen amaçların ve işlevlerin, donanımyazılım ve personel gereksinimlerinin,
kullanılacak veri miktarı ve ilişkilerin saptanması
gerekmektedir. Bu bilgiler gereksinim analizi
yolu ile elde edilir.
• Sistemin inceleme ve analiz aşamasında
belirlenen gereksinimler, bir veri tabanı
geliştirme ekibi tarafından ayrıntılı incelenir.
2.1
Gereksinim Analizi
• Veri tabanı uygulamalarından yararlananlar
kullanıcılardır. Bu nedenle veri tabanı
gereksinim analizinde kullanıcıların görüşlerine
de başvurulmalıdır. Özellikle girdiler-çıktılar ve
işlem sınırlamaları bakımından gereksinimleri
sorulmalıdır.
• Veri tabanı geliştirme ekibi, formlar, raporlar ve
menüler (seçenekler) için örnekler hazırlayarak,
bunlar üzerinde kullanıcıların görüşlerini
almalıdır.
2.1
Gereksinim Analizi
• Gereksinim analizi sonunda belirlenen
gereksinimler; metin, veri akış
diyagramları, varlık-ilişki diyagramları,
nesne diyagramları şeklinde
olabilmektedir.
• Gereksinim belgeleri yeniden gözden
geçirilip gerekli düzeltmeler yapıldıktan
sonra kullanıcıların ve proje sahibinin
onayına sunulmaktadır.
2.1
Sistem Çözümleme Süreci
• Mevcut uygulamalarda kullanılan tüm bilgi kaynaklarını
incele
• Her veri öğesinin özeliklerini belirle
– sayı
– metin
– Tarih/saat
– vs.
• Bu bilgiyi kullanarak gerçekleştirilen görevleri incele
• Bu bilgiyi kullanarak yaratılan raporları ya da sonuçları
incele
2.1
Veri Modelinin Değerlendirilmesi
• Kullanıcıların ve proje sahibinin anlayabileceği
şekilde hazırlanan gereksinim modeli bu hali ile
veri tabanında yer almaz.
• Çok kullanıcılı sistemlerde bu gereksinimler
çelişkili ve tutarsız da olabilmektedir.
• Bu nedenle gereksinim modeli, veri tabanı
uzmanları tarafından yeniden yorumlanmakta,
veri tabanı tasarımında kullanılabilecek bir
modele (Kavramsal Model) dönüştürülmektedir.
2.1
Değerlendirilmenin Aşamaları
• Değişik uygulama sistemi yapılarının (mainframe
veya mini ya da mikro bilgisayarlardan
oluşturulan bilgisayar ağları) tanımlanması ve
içlerinden birinin seçimi
• Uygulamanın yapılabilirliğinin (fizibilitesinin)
yeniden belirlenmesi
• Seçilen çözümde bütün gereksinimlerin yer
aldığının denetlenmesi ve eksikler var ise, ilerde
eklenmesi yada elenmesi gereğinin
karşılaştırılması
2.1
Değerlendirmenin Önemi
• Hata ve eksiklerin değerlendirme aşamasında
bulunup düzeltilmesi kolay ve ucuzdur. Oysa
daha sonraki aşamalarda fark edilmesi halinde
geriye dönülmesi büyük iş kaybına ve gidere yol
açmaktadır.
• Bu aşamanın sonunda; sistem mimarisi, bir dizi
yapılabilir ve maliyeti uygun gereksinimler ve
kavramsal veri modeli elde edilir. Bu sonuçlar
onaylaması için proje sahibine sunulur ve
tasarım aşamasına girdi olarak aktarılır.
2.1
Kavramsal Model Geliştirme
• Gereksinim Analizi sırasında keşfedilen
bilgileri bütünleştirerek oluşturulan
Kavramsal Modelin öğeleri Varlık-İlişki
Diyagramları ile temsil edilir.
• Varlık İlişki diyagramları öğelerin
anlamlarını ve birbiriyle ilişkilerini belirli bir
veri tabanı sisteminden ya da kurulum
ayrıntılarından bağımsız olarak gösterir
2.1
Kavramsal Model Geliştirme
• Tüm uygulamaların ortak gereksinimlerini
birleştir
• Hangi Varlıklar ın kullanılacağını kararlaştır
– Varlık: Hakkında bilgi tutulan nesne
• Varlıkların Özellikler ini belirle
– Varlığı tekil olarak belirleyen anahtar özellik(ler) de
belirlenmelidir
• Varlıklar arasındaki İlişkiler i belirle
– Varlıklar birbiriyle nasıl etkileşiyor?
• İlişkilerin Özellikler ini belirle
2.1
Mantıksal Model Geliştirme
• Gereksinim analizi ve değerlendirilmesi
aşamasında, varlıkların ve aralarındaki ilişkilerin
belirlenmesi ve tanımlanması işlemi varlık-ilişki
modeli ile kavramsal olarak hazırlanmaktadır.
• Tasarım aşamasında bu yapı bilgisayara yönelik
özel bir veri yapısına yani mantıksal modele
(ilişkisel veri modeli) dönüştürülmektedir.
• Gereksiz bilgi tekrarını, bilginin kaybını veya
yetersizliğini önlemek için ayrıca bir de
normalleştirme işlemi uygulanarak ilişkiler
normal forma getirilmelidir.
2.2
Mantıksal Model
• Mantıksal model, kavramsal modelin seçilen
VTYS ile bağdaşacak şekilde uyarlanmış,
dönüştürülmüş halidir.
• Mantıksal modelin kurulmasından önce
düzenlenmiş olan kavramsal model için en
uygun veri modelinin belirlenmesi gerekir.
– Hiyerarşik veri modeli
– Ağ veri modeli
– İlişkisel veri modeli
– Nesne tabanlı veri modeli
2.2
Fiziksel (İç) Model
• Fiziksel tasarımın amacı en az giderle en
uygun performansın sağlanmasıdır.
• Fiziksel tasarımın dört temel aşaması
vardır:
– Veri Gösteriminin Belirlenmesi
– Erişim Yöntemlerinin Seçimi
– Verinin Dış Belleklere Atanması
– Veri Tabanının Yüklenmesi ve Tekrar
Düzenlenmesi
2.3
Veri Gösteriminin Belirlenmesi
• Mantıksal tasarım sırasında şema
oluşturulurken, aynı zamanda veri
öğesinin tipi ve uzunluğu gibi fiziksel
özellikler de kararlaştırılmalıdır.
• Ayrıca, fiziksel kütüklerin boyutları ya da
veri setleri saptanmalıdır.
• Veri tabanı tasarımcısı, veri tanımlama dili
(DDL) kullanarak veri gösterimini ayrıntılı
olarak belgelendirir.
2.3.1
Erişim Yöntemlerinin Seçimi
• Erişim yöntemleri, VTYS’ne bağlı olduğu
için belirlidir.
• Yine de veri tabanındaki her bir kayda
erişilecek yol saptanmalıdır.
• Veri tabanına kendi anahtarı ile doğrudan
erişebilen kayıt tipleri, başka kayıtların
göstergeleri yada indeksler aracılığı ile
girilebilenlerden ayırt edilmelidir.
2.3.2
Verinin Dış Belleklere Atanması
• Erişim yöntemleri ile tanımlanmış olan her
kaydın ve kütüğün fiziksel araçlarda, yani
dış belleklerde saklanacağı yerin
belirlenmesi gerekir.
• Atamada çok kullanılan veriye öncelik
verilmesi yada en büyük olasılığı sağlayan
veri düzeninin bellekte bir araya getirilmesi
(kümeleme-clustering) performansı arttırır.
2.3.3
Veri Tabanının Yüklenmesi ve
Tekrar Düzenlenmesi
• Yükleme, bir veri tabanı yükleme programı (SQL
script) oluşturularak, yada yardımcı bir program
kullanılarak gerçekleştirilir.
• Tekrar düzenlenmeyi gerektirebilecek nedenler:
– Yeni veri öğelerinin veya kayıt tiplerinin ortaya
çıkması (mantıksal tasarım da tekrar düzenlenmeli)
– Yeni işlemlerin gerekmesi (sadece fiziksel tasarım
tekrar düzenlenir)
– Veri tabanını değiştirmek yoluyla işlem etkinliğinin
arttırılması (sadece fiziksel tasarım tekrar düzenlenir)
2.3.4
Veri Tabanının Tamamlanması
• Uygulama programlarının tamamlanması
– Uygulama programları (dış modeller) aslında
mantıksal model tasarlanırken tasarlanırlar.
Bu aşamada kullanıcı arabirimleri de (form
yapıları, raporlar, …) tasarlanarak program
tamamlanır.
• Veri tabanının ve uygulama programlarının
doğruluğunun, bütünlüğünün ve
performansının test edilmesi
• Dokümantasyonun hazırlanması
2.4
Veri Tabanının İşletilmesi ve
Yönetilmesi
• Her sistem gibi veri tabanı sistemi de ne kadar
mükemmel tasarlanmış olursa olsun, kötü
işletilmesi halinde sorunlar ortaya
çıkabilmektedir.
• Aşağıdaki durumlarda uygulanacak yöntemler
mutlaka belirlenmelidir:
– Normal ve anormal durumlarda sistemin kapatılması
– Başarısızlık halinde kurtarma (recovery)
– Veri tabanının yedeklenmesi ve onarılması
2.5
Veri Sözlüğü
• Veri sözlüğü (sistem kataloğu) veri
hakkında veri (metadata) içerdiği için veri
tabanının veri tabanı olarak tanımlanabilir.
• Veri sözlüğünde her ilişki şeması (tablo)
için; şemanın ve içerdiği niteliklerin adları,
niteliklerin etki alanları, anahtarı, bütünlük
sınırları ve eğer tanımlandıysa görünüm
(view) tanımları saklanmaktadır.
Veri Sözlüğünde Saklanan
Diğer Bilgiler
• İlişki şemalarının indeksleri ile ilgili bilgiler
(indekslenen özellikler, indeks tipleri)
• Çoğu sistemde yetkili kullanıcıların adları
ve durumları
• Hiyerarşik veri modeli gibi yüksek düzeyli
modellerde her ilişki şemasındaki sıra
sayısı ve uygulanan saklama şekli (bloklubloksuz)
Veri Sözlüğünde Saklanan
Fiziksel Bilgiler
• Veri öğesinin tipi (sayı, karakter, tarih, …)
– Karakter ise uzunluğu
– Sayı ise tipi (tam sayı, ondalıklı sayı, …)
– Tarih ise biçimi (mm.dd.yyyy, …)
• Kullanılacak araçlar (disk, teyp, …)
• Veri tabanının saklanacağı birimler (c:\, …)
• Erişim denetimi
• …
Veri Sözlüğü Örneği
• sistem-katalog-şeması (şema-adı,
niteliklerinin-sayısı)
• nitelik-şeması (nitelik-adı, şema-adı,
etki-alanı-tipi, yeri)
• kullanıcı-şeması (kullanıcı-adı, şifresi,
grubu)
• indeks-şeması (indeks-adı, tipi, özellikleri)
• görünüm-şeması (görünüm-adı, tanımı)
• kullanıcı-grubu-şeması (…)
Veri Sözlüğünün Önemi
• Veri sözlüğünden beklenen veriye ilişkin
belgeleri yönetmesidir.
• Veri sözlüğü; veri tabanının gereksinim
analizi, tasarım, tamamlama, işletim ve
genişletme aşamalarında veriye ilişkin
bilginin denetim ve yönetimini
üstlenmektedir.
6
Büyüme,
Değişim ve
Yaşatma
5
İşlemler
4
Entegrasyon
1
Analiz ve
Tasarım
3
Dönüştürme
2
Fiziksel
Yaratım
VTYS Yaşam Döngüsü
1) Analiz ve Tasarım
• Örgütün gereksinimlerini belirleme
• Veri tabanı Kavramsal Modelini geliştirme
– Varlık-İlişki diyagramı tekniklerini kullanarak
• Veri Sözlüğü inşa etme
• Mantıksal Modeli geliştirme
– İlişkisel, Ağ, Hiyerarşik, Nesne Tabanlı, …
2) Fiziksel Yaratım
• Veri tabanı Fiziksel Modelini geliştirme
– Veri formatları ve türleri
– Dizinlerin belirlenmesi, vs..
• Prototip veri tabanının yüklenmesi ve test
edilmesi
• Güvenlik, gizlilik ve erişim denetimlerinin
kararlaştırılması ve kurulması
• Tutarlılık sınırlamalarının kararlaştırılması
ve kurulması
3) Dönüştürme
• Yeni veri tabanını kullanmak için mevcut
veri setlerini ve uygulamalarını
dönüştürme
– Eski verileri yeni formatlara dönüştürmek için
programlar ve dönüştürme programcıkları
(utility) gerekebilir
4) Entegrasyon
• 3. Adımla örtüşür
• Yeni veri tabanına dönüştürülmüş
uygulamaların ve yeni uygulamaların
entegrasyonu
5) İşlemler
• Tüm uygulamalar tam-ölçekli çalıştırılır
• Gizlilik, güvenlik ve erişim kontrolü
sağlanır
• Kurtarma ve Yedekleme prosedürleri
kurulmalı ve kullanılmalıdır
• Değişim, bir yaşam biçimidir.
• Uygulamalar, veri gerekleri, raporlar vs.
yeni gereksinimlere göre değişir.
• Veri tabanı ve uygulamaların değişiklik
gereksinimlerini karşılaması için
değiştirilmeleri gerekir.
6) Büyüme, Değişim ve Yaşatma
Bütünlük Kısıtlamaları ve İlişkisel
Tasarım
İşlevsel Bağımlılık Türleri
Kısmi İşlevsel Bağımlılık: Eğer X, A’ yı
belirliyorsa ve X’ in en az bir öz altkümesi de
A’ yi belirliyorsa;
(X  A ve ƎZ⊂ X : Z  A) X  A işlevsel
Tam İşlevsel Bağımlılık: Eğer X, A’ yı
belirliyorsa ve X’ in hiçbir öz altkümesi A’ yı
belirlemiyorsa;
(X  A ve ∄ Z ⊂ X : Z  A) X  A
Önemsiz İşlevsel Bağımlılık: Eğer X, A yı
belirliyorsa ve A, X’ in bir altkümesi ise;
( X  A ve A ⊆ X ) X A
Önemli İşlevsel Bağımlılık: Eğer X A’ yı
belirliyorsa ve A X’ in bir altkümesi değilse;
( X  A ve A ⊄ X ) X A
Geçişli İşlevsel Bağımlılık: Eğer X Y’yi, Y de Z’i
belirliyorsa;
(X  Y ve Y  Z) X Z
Not: Kısmi/tam ve önemli/önemsiz işlevsel bağımlılık
tanımlarında X  A gösterimi kullanılmış, sağ tarafta
tek bir niteliğe yer verilmiştir.
Eğer işlevsel bağımlılığın sağında (örneğin X AB gibi)
birden çok nitelik varsa, tam/kısmi ve önemli/önemsiz
olduğu her zaman söylenemez.
A ve B’den,
Her ikisi de X’ e tam işlevsel bağımlı ise;
X  AB : Tam işlevsel bağımlılık,
Sadece biri (A veya B), X’ e tam işlevsel bağımlı ise;
X  AB : Tam ya da kısmi olduğu söylenemez.
Örnek 4.6.
R(ÖNO,ÖADI,BNO,BADI,FAKNO,DKODU,DA
DI,KRD,NOTU)
ÖNO: Öğrenci No,
ÖADI: Öğrenci Adı,
BNO: BölümNo,
BADI: Bölüm Adı,
FAKNO: Fakülte No,
DKODU: Ders Kodu,
DADI: Ders Adı,
KRD: Kredi,
NOTU: Ders Notu.
I. Önemsiz işlevsel bağımlılık örnekleri:
 DKODU  DKODU
 ÖNO, ÖADI  ÖADI
 BNO, BADI, FAKNO  BNO, FAKNO
II. Önemli işlevsel bağımlılık örnekleri:
 ÖNO  ÖADI
 ÖNO, ÖADI, DKODU  BNO, KRD
 ÖNO, DKODU  NOTU
III. Kısmi işlevsel bağımlılık örnekleri:
 ÖNO, ÖADI  BNO
 ÖNO, DKODU  KRD
 ÖNO, DKODU, DADI  NOTU
IV. Tam işlevsel bağımlılık örnekleri:
 ÖNO  ÖADI, BNO
 BNO  FAKNO
 ÖNO, DKODU  NOTU
V. Geçişli işlevsel bağımlılık örnekleri:
 ÖNO  FAKNO (ÖNO  BNO, BNO  FAKNO)
 ÖNO  BADI (ÖNO  BNO, BNO BADI)
Değersiz:
Kısmi ve geçişli işlevsel bağımlılıklar
Değerli:
Önemli, tam ve geçişli olmayan (bu üç
özelliği birlikte taşıyan) işlevsel
bağımlılıklar.
ÖNO  ÖADI, BNO
BNO  BADI, FAKNO
DKODU  DADI, KRD
DKODU, ÖNO  NOTU
Çizim 4.3. Örnek 4.6’daki İlişki Şeması İçin
Bağımlılık Çizeneği
ÖNO
DKODU
KRD
DADI
ÖADI
BNO
FAKNO
BADI
NOTU
İşlevsel Bağımlılıklarla İlgili Kimi Tanım,
Önerme ve Algoritmalar
A. Bir İşlevsel Bağımlılık Kümesinin
Kapanışı
R : Nitelik kümesi,
F : İşlevsel bağımlılık kümesi ise,
F+ : F’ nin kapanışı (closure).
F+ Ek olarak:
Tüm önemsiz işlevsel bağımlıklar,
F’den türetilebilecek tüm kısmi ve geçişli
bağımlılıklar
Örnek 4.7.
R(A,B,C,D) ve F = {A  B , BC  D} verildiğinde F+
aşağıdaki gibi bulunur.
F+ :
A  AB AB  AB ABC  ABCD
B  B AC  ABCD ABD BD
C  C AD  ABD ACD  ABCD
D D BC  BCD BCD BCD
BD  BD ABCD  ABCD CD  CD
F’ de yalnız 2 işlevsel bağımlılık,
F+ da 15 işlevsel bağımlılık
F+ daki her işlevsel bağımlılık yerine birçok işlevsel
bağımlılık yazılabilir.
Örnek: AB  AB yerine AB  A ve AB  B
F+ da büyük çoğunluğunun önemsizdir.
İşlevsel Bağımlılıkları Türetme Kuralları
F+ bulmak için 6 Armstrong aksiyomu:
İlk üçü temel kurallardır.
1.Dönüşlülük (reflexitivity) kuralı: Y ⊆ X  X  Y
2.Artırma(augmentation) kuralı: X  Y  XZY
3.Geçişlilik (transitivity )kuralı: X  Y ve Y  Z  X  Z
4. Birleşim (union) kuralı:
X  Y ve X  Z  X  YZ
5. Ayrışma (decomposition) kuralı:
X  YZ  X  Y ve X  Z
6.Sözde geçişlilik(pseudo transitivity) kuralı:
X  Y ve YZ  W  XZ  W
Örnek 4.8.
R(A,B,C,D,E,G)
F: A  BD
BC  EG
D  E
Bazı türetilmiş işlevsel bağımlılıklar:
 DG  E (artırma kuralına göre)
A  E (ayrıştırma ve geçişlilik kurallarına göre)
A  ABD(dönüşlülük ve birleştirme kurallarına
göre)
A  B ve A  D(ayrıştırma kuralına göre),
AC  EG(ayrıştırma ve sözde geçişlilik kurallarına
göre)
Çizim 4.4. Örnek 4.8’ deki İlişki Şeması İçin
İşlevsel Bağımlılık Çizeneği
B
C
A
E
G
D
Bütünlük Kısıtlamaları ve İlişkisel
Tasarım
C.Kanonik Örtü
 Her işlevsel bağımlılık bir bütünlük kısıtlamasıdır.
 Bütünlük ve tutarlık için her değişiklik işleminde
işlevsel bağımlılıkların sağlandığının denetlenmesi
gerekir.
 Her denetimin bir maliyeti vardır.
 Az işlevsel bağımlılık az denetim gerektirir.
 Yani, F ‘e eşdeğer en az sayıda işlevsel bağımlılık
içeren kümesi bulunmalıdır.
 F ‘in kapalı örtüsü (Fc), F’ ye eşdeğer olan en az
sayıda işlevsel bağımlılık içeren kümedir.
F ve Fc kümelerinin eşdeğerliği;
F’ deki her işlevsel bağımlılığın Fc deki işlevsel
bağımlılıklardan,
Fc deki her işlevsel bağımlılığın da F’deki
işlevsel bağımlılıklardan türetilebilmesi
anlamındadır.
 Yada, F+= (Fc)
+ ise eşdeğerdir.
C.Kanonik Örtü
Kanonik örtüsü şu şartları sağlamalıdır:
K1
: Fc
‘ de sol tarafları birbirinden farklı olmalıdır.
K2
: Fc
‘ de sol tarafta artık nitelik bulunmamalıdır.
(Sol tarafındaki niteliklerden herhangi biri atıldığında
oluşan yeni küme Fc ‘ ye eşdeğer olmamalıdır.)
K3
: Fc
’de sağ tarafta artık nitelik bulunmamalıdır.
(Sağ taraftaki niteliklerden herhangi biri atıldığında
oluşan yeni küme Fc
‘ ye eşdeğer olmamalıdır.)
Fc
: F ’ye eşdeğer ve önemsiz, kısmi ya da geçişli
hiçbir işlevsel bağımlılık içermeyen (K2 ve K3
), sol
tarafı aynı olan işlevsel bağımlılıkların birleştirilmiş
(K1
) bir kümedir.
C.Kanonik Örtü
Örnek 4.9. R (A,B,C,D) nitelik kümesi,
İşlevsel bağımlılık kümesi:
F : B  C
C  A
BC  A
BA
F’nin kanonik örtüsü:
Fc
: B  C , C A
D.Artıklık Algoritması
F ‘teki bir işlevsel bağımlılık (f), diğer işlevsel
bağımlılıklardan türetilebiliyorsa, bu işlevsel
bağımlılık artıktır.
Yani, f, F- (f) ‘ten türetilebiliyorsa, f işlevsel
bağımlılığı F kümesinde artıktır.
(f : X  Y) artıklık araştırma algoritması:
1. Başlangıçta T = { X } yap
2. “F – { f }” teki her W  Z işlevsel
bağımlılığı için :
Eğer { W} ⊆ T ise  T= T ∪ { Z } yap
3.T değiştiği sürece 2. Adımı tekrarla
4.Sonuçta eğer Y ⊆ T ise (f : X  Y ) işlevsel
bağımlılığı F’ de artıktır.
Artıklık aranırken iki noktaya dikkat etmek
gerekir.
1.Eğer X  Y ’de Y birden çok nitelikten
oluşuyorsa, X  Y işlevsel bağımlılığı artık
olmayabilir.
Ayrıştırılırsa, bir kısmı artık olabilir.
Örnek: BC ADE artık olmayabilir.
Ayrıştırılırsa;
BC  A , BC  D ve BC  E
Biri ya da ikisinin artık olabilir.
Bu nedenle, sağ tarafa ayrıştırılmalıdır.
2.F= {f1
,f2
,f3
,…,f n} ‘de fi
’ nin artık ise;
Diğerleri için artıklık araştırmasında,
F yerine “F – { fi }” alınmalıdır.
Yani, artık işlevsel bağımlılıklar araştırılırken,
artık olduğu bulunan her işlevsel bağımlılık
kümeden çıkarılmalı ve eksilen kümede artık
araştırılmalıdır.
Örnek: F={f1
,f2
,f3
,f4
,f5} kümesinde f2 veya f3
artık olabilir.
Ancak f2 ve f3
, F ‘de birlikte artık olmayabilir.
f3
, F={f1
,f2
,f3
,f4
,f5} ’de artık iken
F={f1
,f3
,f4
,f5} ’de artık olmayabilir.
Örnek 4.10.
R(A,B,C,D,E,G) Nitelik kümesi
İşlevsel bağımlılık kümesi:
F: A  BCDE
G  BD
BC  E
CG  A
BDE  ACG
Sağ taraftakiler ayrıştırdığımızda, toplam 11 işlevsel
bağımlılık elde edilir.
F: A  B G  B BDE  A
A C G  D BDE  C
A  D BC  E BDE  G
A E CG  A
Artık olanı araştıralım.
F: A  B G  B BDE  A
A C G  D BDE  C
A  D BC  E BDE  G
A E CG  A
1. F’'de A  B artık mı? => hayır : T = {A,C,D,E}
2. F 'de A  C artık mı? => evet : T ={A,B,D,E,C,G}
F1 = F - {A  C}
3. F1
'de A D artık mı? => hayır : T = {A,B,E}
4. F1
'de A  E artık mı? => hayır : T={A,B,D}
5. F1
'de G  B artık mı? => hayır : T = {G,D}
6. F1
'de G D artık mı? => hayır : T = {G,B}
7. F1
'de BC  E artık mı? =>hayır : T ={B,C}
8. F1
'de CG  A artık mı? =>evet :T= {C,G,B,D,E,A}
F2 = F1
- {CG  A}
9. F2
'de BDE  A artık mı? =>hayır :T = {B,D,E,C,G}
10. F2
'de BDE  C artık mı? => hayır :T = {B,D,E,A,G}
11. F2
'de BDE  G artık mı? => hayır :T = {B,D,E,A,C}
Sonuç olarak F' de A  C ve CG  A işlevsel
bağımlılıkları artıktır.
Buna göre F 'nin kanonik örtüsü aşağıdaki gibi
bulunur:
Fc
: A  BDE
G  BD
BC E
BDE ACG
F ‘de f : X  Y işlevsel bağımlılığının türetilip
türetilemeyeceğini bulan bir algoritmadır.
5. Başlangıçta T={ X } yap
6. F’deki her W  Z işlevsel bağımlılığı için:
Eğer { W } ⊆ T ise  T = T ∪ {Z}
yap
7. T değiştiği sürece 2. Adımı tekrarla
8. Sonuçta eğer Y ⊆ T ise (f : X  Y)
işlevsel bağımlılığı F’ den türetilebilir.
E.Türetilebilirlik Algoritması
Eğer X Y ‘de Y birden çok nitelikten oluşuyorsa,
F’ den X  Y işlevsel bağımlılığını
türetilemeyebilir.
Ancak, ayrıştırılırsa, bir kısmının F’ den türetilebilir.
Misal;
Bir F işlevsel bağımlılık kümesinden AC  BDE
işlevsel bağımlılığı türetilemeyebilir.
Fakat, AC  B, AC  D ve AC E ‘ye ayrıştırılırsa,
F’ den bunların biri ya da iki türetilebilir.
Bu nedenle, türetilebilirliği araştırılırken, sağ tarafı
ayrıştırılmalıdır.
Türetilebilir algoritmasının özde artıklık algoritması
ile aynıdır.
Bütünlük Kısıtlamaları ve İlişkisel
Tasarım
R (A1
, A2 A3
, ...., An) nitelik kümesi,
F işlevsel bağımlılık kümesi
(X ⊆ R) ise; X+
, X’ in belirlediği niteliklerin
tümüdür.
X+ hesaplama algoritması
1. Başlangıçta T = { X } yap
2. F'deki her W  Z işlevsel bağımlılığı için:
Eğer {W} ⊆ T ise => T=T ∪ { Z } yap
3. T değiştiği sürece 2. adımı tekrarla
Sonuçta X+ = T olarak bulunur.
F. Bir Nitelik Kümesinin Kapanışı
Örnek 4.11:
Nitelik kümesi :
R(A,B,C,D,E,G)
İşlevsel bağımlılık kümesi:
F: A  BCDE
G  BD
BC  E
CG  A
BDE  ACG
A+ =ABCDEG (AB) + = ABCDEG
B+ =B (BC)+ = BCE
C+=C (CG)+ = ABCDEG
D+=D (CDE)+ = CDE
E+=E (DEG)+ = ABCDEG
G+=BDG (BCDE)+ = ABCDEG
5. İlişki Anahtarları
İşlevsel bağımlılıklara göre, ilişki anahtarları tanımı.
Süper anahtar:
Nitelik alt kümesi (K), ilişkideki tüm nitelikleri işlevsel belirliyorsa Süper
Anahtarıdır.
K ⊆ R : K  R ise K+=R
Anahtar ya da anahtar adayı:
Bir nitelik altkümesi (K), ilişkideki tüm nitelikleri işlevsel belirliyorsa ve hiçbir
altkümesi tüm nitelikleri belirlemiyorsa, K ilişkinin anahtar adayı ya da
kısaca anahtarıdır.
K ⊆ R : K  R ise K+=R ve Z ⊆ K : ! K  R ise K+≠R
Anahtar tanımını, süper anahtara dayalı olarak:
K, R‘ nin bir süper anahtarı ve K‘ nın hiçbir öz altkümesi R’nin süper anahtarı
değilse, K, R‘ nin anahtar adayı, ya da kısaca anahtarıdır.
(K ⊆ R : K  R) ve ( ƎK1  K : K1  R )  K ilişkinin anahtarıdır.
Önemli! Her anahtar bir bütünlük kısıtlamasıdır.
İlişkinin tüm örneklerinde, anahtarı değeri tüm çoklularında farklı olmalıdır.
İlişki kuramında anahtar bir erişim mekanizması
değil, bir bütünlük kısıtlamasıdır.
Bütünlük ve tutarlık için anahtarların bilinmesi
gerekir.
"Anahtar adayı", "anahtar" ve "ilişki
anahtarı" eşanlamlıdır.
 «Superkey» = «süper set of key»
 Her anahtarın, üst kümesi süper anahtardır.
Önemli olan süper anahtarlar değil
anahtarlardır.
 Her anahtar, süper anahtardır.
 Her süper anahtar, anahtar değildir.
Örnek 4.12.
R(A, B, C, D, E)
F={A  C, B D , D  AE, CE  B}
İlişkinin 4 anahtarı(ya da anahtar adayı) vardır:
B, D, AE ve CE
B, D, AE ve CE' nin tüm üst kümeleri ilişkinin
süper anahtarıdır.
Örnek: B, AB, ABC, DC, ADE, ABCDE
6. İlişkiler İçin Normal Biçimler
Sorunsuz ilişkiler oluşturabilmek için normal
formlar tanımlanmıştır.
Normal formların, çoğu işlevsel bağımlılıklara
göre, bir kısmı ise diğer bütünlük
kısıtlamalarına (örneğin anahtarlara göre)
tanımlanmıştır.
En çok kullanılanları:
1NF, 2NF, 3NF ve BCNF
6.1. Birinci Normal Biçim (1NF)
1NF İlişki Tanımı:
Değer alanları yalın ise ilişki Birinci Normal
Biçimdedir.
Dizi, Matris (bir başka ilişki) veya karmaşık bir
değer (mahalle, cadde, sokak, kapı numarası,
…değerlerinden oluşan adres gibi)
olmamalıdır.
Birinci Normal Biçimde değilse, N1NF (Non
1NF) ilişki denir.
Örnek:
ÖĞRENCİ (ÖNO, ÖADI, DERS (DADI,
NOTU))
DERS niteliği tek değerli yalın bir nitelik
olmadığı için N1NF dir.
ÖĞRDERS (ÖNO, ÖADI, DADI, NOTU)
Olursa 1NF olur.
Çizim 4.5 Normal Biçimde Olmayan (N1NF) Bir
İlişkinin Normal Biçime(1NF) Dönüştürülmesi
DERS
ÖNO ÖADI DADI NOT
U
123 ALİ MAT. 87
FİZ. 69
KİM. 93
207 KAYA KİM. 64
186 NUR FİZ. 75
MAT. 45
316 AYŞE BİO. 59
KİM. 87
MAT. 60
FİZ. 77
İNG. 98
ÖNO ÖADI DADI NOTU
123 ALİ MAT. 87
123 ALİ FİZ. 69
123 ALİ KİM. 93
207 KAYA KİM. 64
186 NUR FİZ. 75
186 NUR MAT. 45
316 AYŞE BİO. 59
316 AYŞE KİM. 87
316 AYŞE MAT 60
316 AYŞE FİZ. 77
316 AYŞE İNG 98
6.2. İkinci Normal Biçim (2NF)
Asal ve Asal Olmayan Nitelik Tanımları:
2NF için asal ve asal olmayan nitelik tanımı
gerekir.
Nitelik bir ilişki anahtarlarında varsa asal yoksa asal
olmayan nitelik denir.
2NF İlişki Tanımı:
Bir ilişki (1NF) ve hiçbir asal olmayan niteliklerden
hiçbir anahtara kısmi işlevsel bağımlı değilse
2NF’dir.
2NF, asal olmayan tüm niteliklerin tüm anahtarlara
tam işlevsel bağımlı olmasını ister.
Asal olmayan nitelik herhangi bir anahtara kısmi
işlevsel bağımlı olmasına izin vermez.
Örnek:
SATICI (ÜKODU, FNO, FADI, FADRESİ, SFİYATI)
1NF: Nitelikler tek değerli yalın
İlişkinin tek anahtarı ÜKODU, FNO çiftidir.
Yani,
ÜKODU ve FNO : Asal nitelikler;
FADI, FADRESİ ve SFİYATI : Asal olmayan nitelikler
Asal olmayan FADI ve FADRESİ nitelikleri anahtarlara
kısmi işlevsel bağımlı olduğundan 2NF değildir.
6.3. Üçüncü Normal Biçim (3NF)
3NF İlişki Tanımı:
2NF ve asal olmayan hiçbir nitelik hiçbir anahtara
geçişli bağımlı değilse 3NF’dir.
2NF asal olmayan niteliklerin anahtarlara tam
işlevsel bağımlı olması koşulunu getiriyordu.
3NF, ek olarak asal olmayan niteliklerin anahtarlara
geçişli bağımlı olmama koşulunu getirir.
Buna göre eğer bir İlişkideki asal olmayan
niteliklerin tümü, anahtarlara tam işlevsel bağımlı
ise ve asal olmayan nitelikler birbirinden bağımsız
ise (hiçbiri hiçbir anahtara geçişli bağımlı değilse)
bu ilişki 3. Normal Biçimdedir.
Örnek:
TAŞIT (PLAKANO, MARKA, MODEL, YIL, AĞIRLIK,
RENK)
1NF: Tüm nitelikler tek değerli yalın.
2NF: İlişkinin tek anahtarı PLAKANO' dur.
PLAKANO dışındaki 5 nitelik asal nitelik değildir.
Asal olmayan bu niteliklerin hepsi anahtara (PLAKANO)
tam işlevsel bağımlıdır.
Zaten tek nitelikten oluşan bir anahtara niteliklerin
kısmi işlevsel bağımlı olması söz konusu olamaz.
N3NF: Ancak asal olmayan nitelikler birbirinden
bağımsız değildir.
Bu nitelikler arasında MARKA, MODEL  AĞIRLIK
işlevsel bağımlılığı da vardır.
3NFdeğildir
6.4. Boyce Codd Normal Biçimi (BCNF)
BCNF İlişki Tanımı:
1NF ve tüm belirleyenler ilişkinin anahtarı
BCNF’ir.
Yani, K anahtar ise, BCNF’de tüm işlevsel
bağımlılıklar K  X biçimindedir.
Önemli her işlevsel bağımlılığın sol tarafında yer
alan her nitelik ya da nitelik grubunun
ilişkideki tüm nitelikleri belirlemesi,
dolayısıyla ilişkinin anahtarı olması gerekir.
3NF asal olmayan niteliklerin birbirinden
bağımsız olmasını ve anahtara tam işlevsel
bağımlı olmasını zorlar.
3NF asal niteliklere zorlama getirmez.
3NF bir ilişkide asal nitelikler birbirinden
bağımsız olmayabilir ve anahtarlara kısmi
bağımlı olabilir.
Bu serbestlik birden çok anahtarı bulunan ve
anahtarlarından en az ikisi birden çok
nitelikten oluşan ilişkilerde sorunlar
oluşmasına yol açabilir.
Örnek:
R(A, B, C, D, E)
F={A  C, B D , D  AE, CE  B}
İlişkinin 4 anahtarı(ya da anahtar adayı) vardır:
B, D, AE ve CE
 Bu durumda ilişkinin tüm nitelikleri asal
niteliklerdir.
 İlişkide asal olmayan hiçbir nitelik
bulunmadığından otomatik olarak 3NF'dir.
 Ancak bu ilişkide A C işlevsel bağımlılığı vardır.
A bir belirleyen olmasına karşın anahtar değildir.
Dolayısıyla BCNF değildir.
Örnek 4.13.
ÖĞRDERS (ÖĞRNO, DKODU, DADI, NOTU)
DKODU  DADI
DADI  DKODU
DKODU, ÖĞRNO  NOTU
DADI, ÖĞRNO  NOTU
DKODU
ÖGRNO
DADI
NOTU
 İlişkinin anahtarları DKODU, ÖĞRNO ve
DADI, ÖĞRNO’ dur.
İlişkinin asal olmayan tek niteliği (NOTU)
anahtarlara tam işlevsel bağımlıdır.
Geçişli bağımlı değildir (zaten asal olmayan
tek nitelik bulunduğuna göre, geçişli bağımlılık
söz konusu olamaz).
İlişki 3NF bir ilişkidir.
Ancak anahtar olmayan DKODU ve DADI
birer belirleyen olduğu için ilişki BCNF değildir.
Örnek:
KURS (ÖĞRNO, DKODU, ÖĞRETMEN, NOTU)
ÖĞRETMEN  DKODU
ÖĞRNO,DKODUNOTU
Her öğretmen yalnız bir ders verir.
Her dersin şubeler halinde birçok öğretmen tarafından
verilir.
Şubelerin ayırımının sorumlu öğretmen ile yapılır.
Bir öğrenci bir dersi yalnız bir öğretmenden alır.
ÖĞRNO
DKODU ÖĞRETM
EN
NOTU
İlişkinin tek anahtarı ÖĞRNO, ÖĞRETMEN
ikilisidir.
İlişkide asal olmayan DKODU niteliği anahtara
kısmi işlevsel bağımlı olduğu için İlişkinin
biçimi 1NF'dir. Dolayısıyla ilişki BCNF değildir.
 İlişkinin BCNF bir ilişki olmadığı anahtar
olmayan ÖĞRETMEN ve ÖĞRNO ile
DKODU’nun birer belirleyen olmasından da
anlaşılabilir.
7. İlişkilerin Ayrıştırılması
R ilişki şeması ve F işlevsel bağımlılık kümesi ise;
Aşağıdaki koşullan sağlayan {R1
, R2
, R3
, ... , Rn} ilişki
kümesi R' nin bir ayrıştırmasıdır.
K1
. R‘ deki niteliklerin her biri en az bir Ri
' de
bulunmalıdır.
R = R1 ∪ R 2 ∪ R3 ∪ … Rn
K2
. Ayrıştırma yitimsiz-birleştirme ayrıştırması (losslessjoin decomposition) olmalıdır. Yani, her r ilişkisinin
Ri
’lere göre izdüşümlerinin doğal birleştirmesi r'ye eşit
olmalıdır.
r= p R1 (r) p R2 (r) p R3 (r) ….. p Rn (r)
K3
. Ayrıştırma F' deki işlevsel bağımlılıkları korumalıdır.
K1 gereksizdir.
Geçerli bir ayrıştırma için:
1. Yitimsiz-birleştirme ayrıştırması olması,
2. İşlevsel bağımlılıktan koruması,
gerekli ve yeterlidir.
7.1. Yitimsiz-Birleştirme Ayrıştırması
Bir ilişkiyi belirli sayıda BCNF (ya da 3NF)
ilişkiye ayrıştırarak aykırılıklara yol açmayan,
oluşturulması ve bakımı kolay bir şema elde
edebilir.
Bu işleme normalleştirme (normalization) denir.
Ancak ayrıştırma yitimsiz olmalıdır.
Ayrıştırmanın yitimsiz olup olmadığı test
edilmelidir.
Örnek:
R (A, B, C)
F = { A  B , C  B}
R1 (A, B) ve R2 (B, C) ilişkilerine ayrıştırılırsa;
Şekilde, F'deki işlevsel bağımlılıkları sağlayan bir
örneği ( r ) verilmiştir.
AB ve BC niteliklerine göre izdüşümleri: r1 ve r2
r3 ,
r1 ve r2 doğal birleştirilmesi ile elde edilir.
r ve r3 eşit değildir.
Ayrıştırma yitimsiz değildir.
Olumlu bir örnek, ayrıştırmanın yitimsiz olduğunu
göstermez.
A B C A B B C A B C
a1 b1 c1 a1 b1 b1 c1 a1 b1 c1
a2 b2 c3 a2 b2 b2 c3 a1 b1 c2
a3 b1 c2 a3 b1 b1 c2 a2 b2 c3
a4 b2 c4 a4 b2 b2 c4 a2 b2 c4
a)r b)r1 =∏AB c) r2 =∏BC (r) a3 b1 c1
a3 b1 c2
a4 b2 c3
a4 b2 c4
d)r3= r1 r3
Ayrıştırmanın Yitimsizliğinin İncelenmesi
İkili Bir Ayrıştırma İçin Yitimsizlik Koşulu
Tanım:
Bir R, {R1
, R2} ikili ayrıştırması için aşağıdaki koşullar
sağlanıyorsa yitimsizdir.
K1
: R1 ve R2
' de ortak nitelik ya da nitelikler bulunmalıdır.
(Eğer R(X,Y,Z) ise R1 (X,Y) ve R2(X,Z)olmalıdır).
K2 : Ortak nitelik ya nitelikler (X), R1 ve R2
'den en az birinin
anahtarı olmalıdır.
( X  R1 ya da X  R2 ’den en az biri F+ da bulunmalıdır).
Yani,
(R1 ∩ R2)  R1 ve ( R1∩ R2)  R2 en az biri F+ da
olmalıdır.
Örnek:
R (A, B, C)
F = { A  B , C  B}
R1 (A, B) ve R2 (B, C)
Ayrıştırmasında, ortak nitelik B, R1 veya R2
’nin anahtarı değildir.
B  A veya B  C, F+ ’da yoktur.
Ayrıştırma yitimsiz-birleştirme ayrıştırması değildir.
Örnek:
R (A, B, C, D, E)
F: A  BC
D  B
E A
CD  E
R1 (A, B, C) ve R2 (A, D, E) ilişkilerine ayrıştırılıyor. Bu ayrıştırma yitimsiz
midir?
R1 ve R2
ilişkilerindeki ortak nitelik A' dır.
A, R1
ilişkisinin anahtarı olduğu için bu ayrıştırma yitimsizdir.
A
E C D
B
Ayrıştırmaların Yitimsizlik Sınaması
Çoklu ayrıştırma için, Yitimsiz Ayrıştırma Algoritması
R (Aı, A2
, A3
,..., An) bir ilişki şeması, F işlevsel bağımlılık kümesi
R‘nin {R1
, R2
, R3
, ... , Rk} ayrıştırmasının yitimsizliği şu algoritma ile bulunabilir.
1. Ayrıştırmadaki her Ri
ilişkisi için bir satırı; her Aj niteliği için de bir kolonu bulunan n satır, k
kolonlu bir çizelge oluştur. Her satır başlığına bir ilişkinin (Ri) adını, her kolon başlığına da bir
niteliğin (Aj) adını yaz. Eğer ilişki/nitelik adları sıradan dizinli (1'den n'e ; 1'den k'ya) adlar
değilse, satırlara/kolonlara 1'den başlayarak sıra numarası ver.
2. Çizelgenin i. Satır j. Kolonundaki elemanına:
 Eğer Ri
ilişkisinde Aj niteliği varsa : aj yaz.
 Eğer Ri
ilişkisinde Aj niteliği yoksa : bij yaz.
3. F ‘deki her (f: X  Y) işlevsel bağımlılığı için:
Eğer 2 ya da daha çok satırda, X'i oluşturan tüm kolonlardaki değerleri aynı ise:
bu satırlarda Y'yi oluşturan tüm kolonlardaki değerleri eşitle (eğer eşitlenecek değerlerden enaz biri aj
ise
hepsini aj yap; hiçbiri aj değil hepsi b'lerden oluşuyorsa, aralarından rastgele birini seç ve diğerlerini
buna eşitle).
4. Çizelgede değişiklik olduğu sürece, satırlardan biri tüm a'lardan oluşuncaya kadar 3. adımı
tekrarla.
5. Sonuçta eğer satırlardan biri tüm a'lardan (a1
, a2
, a3
, ... , ak) oluşuyorsa ayrıştırma
yitimsizdir; değilse ayrıştırma yitimsiz değildir.
Örnek:
R (A, B, C, D, E)
F ={ A  BC, D  B, E A, CD  E}
Ayrıştırma yitimsiz midir?
R1 (A, B, C) , R2(A,E), R3 (C, D, E)
 Eğer Ri
ilişkisinde Aj niteliği varsa : aj yaz.
 Eğer Ri
ilişkisinde Aj niteliği yoksa : bij yaz.
1 2 3 4 5
A B C D E
R1
R2
R3
a1 a2 a3 b14 b15
a1 b22 b23 b24 a5
b31 b32 a3 a4 a5
 A  BC ise, R1 ve R2 satırlarının A kolonu eşit olduğundan,
bu satırların B ve C kolonundaki değerler de eşitlenir (b22 yerine a2 , b23 yerine de a3 yazılır)
 E  A kullanılarak, R2 ve R3 satırlarının E kolonundaki
değerler eşit olduğu İçin, bu satırların A kolonundaki
değerler de eşitlenir (b31 yerine a1 yazılır).
 A  BC kullanılarak, R1 ve R3 satırlarının A kolonundaki
değerler eşit olduğu için, bu satırların B kolonundaki
değerler de eşitlenir (b32yerine a2 yazılır; C kolonundaki
değerler zaten eşit olduğu için herhangi bir değişiklik
yapılmaz.).
Sonuçta R3 satırı tüm a'lardan oluştuğu için ayrıştırma
yitimsizdir
1 2 3 4 5
A B C D E
R1
R2
R3
a1 a2 a3 b14 b15
a1 b22 a2 b23 a3 b24 a5
b31 a1 b32 a2 a3 a4 a5
7.2. Ayrıştırmanın İşlevsel Bağımlılıkları Koruması
R ilişkisinin {R1
, R2, R3
,…, Rk} ayrıştırmasının işlevsel
bağımlılıkları koruma testi şöyledir:
İşlevsel Bağımlılıkların Korunması Algoritması
1.F+ nın her Ri üzerindeki izdüşümü bulunur.
Fi = pRi (F +) = { f (X  Y) : f ∈ F + ve X, Y ⊆ R}
2. F lerin küme birleşimi bulunur.
G=F1 ∪ F2 ∪ … ∪ Fk
3. Sonuçta eğer G F’ e eşdeğer ise (F’ deki her işlevse
bağımlılık G ‘ de varsa, ya da G’ dekilerden
türetilebiliyorsa, başka bir deyişle
F + = G + ise) ayrıştırma işlevsel bağımlılıkları
korumaktadır. Değilse ayrıştırma da bazı işlevsel
bağımlılıklar yitirilmiştir. Yitirilen işlevsel bağımlılıklar
F’ de bulunup G’ de bulunmayan ve de G’ de ki işlevsel
bağımlılıklardan türetilemeyenlerdir.
R (A, B, C, D, E)
F ={ A  BC, D  B, E A, CD  E}
Ayrıştırma yitimsiz midir?
R1 (A, B, C) , R2(A,E), R3 (C, D, E)
İşlevsel bağımlılıkları koruyor mu?
Önce F+bulunur.
F+ : A BC
D  B
E  ABC
CD  AE
AD  E
Şimdi de F+ nın Ri
'lere göre izdüşümleri ve küme birleşimini
bulunur:
F1={A  BC }
F2={E  A}
F3={CD  E}
G= F1 ∪ F2 ∪ F3 = {A  BC, E A, CD E}
F’ deki işlevsel bağımlılıklardan biri (D  B) G’ de yoktur.
G’ deki işlevsel bağımlılıklardan türetilemez.
Bu nedenle, yitimsiz olan bu ayrıştırma işlevsel bağımlılıkları
korumamaktadır.
Geçerli bir ayrıştırma değildir.
Örnek 4: R (A,B,C,D)
F ={ A  B, B C, C  D, D  A}
R, {R1(A,B), R2(B,C), R 3(C,D)} ayrıştırması yitimsiz bir
ayrıştırmadır.
İşlevsel bağımlılıkları koruyor mu?
F+ : A BCD
B  CDA
C  DAB
D  ABC
A B C D
F+ : A BCD
B  CDA
C  DAB
D  ABC
F1={A  B, BA}
F2={B  C, C B}
F3={C  D, D C}
G : A  B
B  AC
C  BD
D  C
F’ deki işlevsel bağımlılıklardan ilk üçü G’ de vardır.
Sonuncu işlevsel bağımlılık ise (D A) G’ de yoktur.
İlk bakışta ayrıştırmanın bu işlevsel bağımlılığı koruyamadığı
sanılabilir.
Ancak türetme kuralları ile G’ deki işlevsel bağımlılıklardan bu işlevsel
bağımlılık türetilebilir ( D  C  A  D  A).
Bu nedenle de bu ayrıştırma işlevsel bağımlılıkları korumaktadır.
7.3. BCNF Ayrıştırma Algoritması
BCNF Ayrıştırma Algoritması
1.R1 = R , k=1 T={R1}
2.F+ yı hesapla
3. T’ deki ilişkilerden BCNF olmayan her Ri
için:F+’ daki
işlevsel bağımlılıklardan, Ri
de tanımlı önemli her X  Y işlevsel bağımlılığı için
eğer X Ri
‘nin anahtarı değilse (X Ri F+‘ da yoksa)
Ri’ den Y’ deki nitelikleri çıkar, k’ yı 1 arttır, T’ ye Rk
(X,Y) ilişki şemasını ekle.
4. T ‘deki tüm ilişkiler BCNF oluncaya dek 3. adımı
tekrarla.
BCNF arıştırma:
Yitimsizdir.
İşlevsel bağımlılıkları koruma güvencesi yoktur.
Örnek:
R (A, B, C, D, E)
F: A  CDE
E  B
CD  E
R ‘nin tek anahtarı A olup BCNF değildir.
F+ : A  BCDE
E  B
CD  BE
BCNF ayrıştırma:
R1 (A, C, D)
R2 (C, D, E)
R3 (E, B)
Bu ayrıştırma yitimsizdir. Ayrıca ayrıştırma İşlevsel bağımlılıkları da
korumaktadır
A
E
D
C
B
Örnek:
R (A,B,C) ve F ={AB  C, C  A }
 Anahtarlar AB ve BC,
 Tüm nitelikler asal nitelik olduğundan ilişki 3NF,
 Ancak anahtar olmayan bir belirleyen olduğu için ilişkinin BCNF
değil.
F+ yı bulunarak BCNF ayrıştırma yapılırsa;
F+ : AB  C
C A
BCNF ayrıştırma:
R1 (B,C)
R2 (C,A)
Bu ayrıştırma yitimsizdir.
Ayrıştırmada AB  C bağımlılığı korunamamıştır.
7.4. 3NF Ayrıştırma Algoritması
İilişki formu 1NF ya da 2NF ise olan, R‘nin 3NF
ilişkilere ayrıştırılması;
3NF ayrıştırma algoritması
1. k=1, T={ }
2. Fc yi hesapla
3.Fc deki her X Y işlevsel bağımlılığı için:
eğer T’ deki Ri
ilişki şemalarından hiçbiri XY
niteliklerini içermiyorsa: k’yı 1 arttır, T’ ye Rk
(X, Y) ilişki şemasını ekle.
3NF yitimsiz ve işlevsel bağımlılıkları koruyan
ayrıştırma üretir.
BCNF ayrıştırma algoritması ile her zaman
işlevsel bağımlılıkları koruyan bir ayrıştırma
bulmak mümkün değildir.
3NF ayrıştırma algoritması ile her zaman
işlevsel bağımlılıkları koruyan bir ayrıştırma
bulur.
Bir ilişki için işlevsel bağımlılıkları koruyan bir
BCNF ayrıştırma bulunmaya çalışılır.
Eğer BCNF bir ayrıştırma olmuyorsa bir 3NF
ayrıştırma bulunur.
Farklı BCNF ayrıştırmaları bulunabilir.
BCNF ayrıştırmaları yitimsizdir.
Ayrıştırmaların bazıları veya tamamı işlevsel
bağımlılıkları korumayabilir.
3NF ayrıştırma algoritması ile her Fc
için tek
bir ayrıştırma elde edilir.
3NF ayrıştırma yitimsiz ve işlevsel
bağımlılıkları korur.
Birden çok 3NF ayrıştırma elde edilebilmesi
için F' nin birden çok kanonik örtüsünün (Fc)
bulunması gereklidir.
Örnek: R (A,B,C,D,E,G)
F : AB  CD
AC  E
DE  G
 Tek anahtarının AB,
 Geçişli bağımlılıklar nedeniyle 2NF,
 F zaten kanonik biçimdedir (Fc=F).
3NF Ayrıştırma
R1 (A,B,C,D)
R2 (A,C,E)
R3(D,E,G)
D
A C
B E G
R için BCNF ayrıştırması:
F+ yı hesaplanıp ayyıp algoritmayı
uyguladığımızda, aşağıdaki 2 ayrıştırmadan
birini bulabiliriz.
F+ :AB  CDEG
AC  E
DE  G
ACD  G
BCNF Ayrıştırmalar:
1.Ayrıştırma 2.Ayrıştırma
R1 (A,B,C,D) R1 (A,B,C,D)
R2 (A,C,E,) R2 (A,C,E,)
R3 (D,E,G) R3 (A,B,G)
Ayrıştırma 1, işlevsel bağımlılıkları
korumaktadır.
Ayrıştırma 2, DE  G işlevsel bağımlılığı
yitirilmektedir.
7.5 BCNF ve 3NF Normal Biçimlerinin
Karşılaştırılması
1. BCNF, 3NF’ye göre daha sorunsuz,
aykırılıklara yol açmayan ve bakımı daha
kolay ilişkilerdir.
Ancak BCNF, yitimsizliğini koruyabilmekte
işlevsel bağımlılıkların koruyamayabilir. İşlevsel
bağımlılıkların korunmaması ise sakıncalıdır.
BCNF işlevsel bağımlılıkları koruyorsa öncelikle
tercih edilmelidir.
Elde edilemiyorsa, 3NF daha uygun olabilir.
2. 3NF, hem yitimsiz olması hem de işlevsel
bağımlılıkları koruması bir üstünlüktür. Ancak
BCNF koşulunu sağlamayan 3NF ilişkilerin
kimi sakıncaları vardır. Bu sakıncaların bir
bölümü veri tekrarı ve günleme
aykırılıklarıdır.
Diğer bir bölümü ise “null” değeri kullanılarak
aşılabilecek ekleme silme aykırılıklardır.
Öncelik BCNF’tir. Elde edilemiyorsa aşağıdaki
seçeneklerden kullanılmalıdır.
A. İşlevsel bağımlılıkları korumayan(birkaç
işlevsel bağımlılığı yitiren) BCNF ayrıştırma ile
elde edilen BCNF ilişkilerdir.
B. İşlevsel bağımlılıkları koruyan 2NF ayrıştırma
ile elde edilen 3NF ilişkiler.
A seçeneğinde yitirilen işlevsel bağımlılıkların
denetimi yapılamayacaktır.
Mutlaka yapılmak istenirse de bu denetimlerin
yapılması çok güç ve çok pahalı olacaktır.
B seçeneğinde ise günleme, ekleme ve silme
aykırılıkları oluşabilir.
Genel değerlendirmede, B seçeneğinde “null”
değerler kullanılarak ekleme ve silme
aykırılıklarının aşılabileceği günleme
aykırılıklarının oluşmaması içinde gerekli
önlemlerin alınabileceği; böylece B
seçeneğinin sakıncalarının azaltılabileceği ve A
seçeneğine tercih edilebileceği söylenebilir.

Hareket (transaction): veri tabanındaki
verilere erişen ve veriler üzerinde çoğunlukla
değişiklik yapan bir program kesimidir.
Bir banka hesabından bir diğerine para
aktarma, bir rezervasyon işlemi, bir stok
işlemi ve bir öğrenci kayıt işlemi hareket
örnekleri olarak sayılabilir.
Hareket sınırları:
Begin transaction - End transaction
Hareketlerin taşıması gereken özellikler:
Bölünmezlik, Tutarlılık, Ayrılma ve Kalıcılık.
1. Bölünmezlik (Atomicity):
Hareketi oluşturan işlemlerin, uygulama açısından
bölünmemesi gerektiğini gösterir.
Bir hareketi oluşturan işlemlerin ya tümü
gerçekleştirilmeli, ya da hiçbiri gerçekleştirilmemelidir.
Örnek: Bir banka hesabından bir diğerine para aktaran
aşağıdaki hareketi düşünelim.
Begin transaction;
Read (A);
A  A - 100;
Write (A);
Read (B);
B  B + 100;
Write (B);
End transaction;
Bu hareketin bölünmemesi gerekir.
Çünkü, hareketten önce ve sonra A+B
değerinin aynı olmalıdır.
3 komuttan sonra hareket kesilirse:
A değeri azalır.
B değeri artmaz.
Bu bir tutarsızlıktır.
2. Tutarlılık (consistency):
Hareket, veri tabanını tutarlı bir durumdan, tutarlı bir
başka duruma taşımalıdır.
Bir önceki örnek için, hareketin tutarlığı A+B değerinin
değişmemesidir.
3. Ayrılma (isolation):
Birden çok hareket birlikte uygulandığında, hareketlerin
birbirinden bağımsız olarak uygulanabilmelidir.
Örnekte, A eksildiğinde ve B değeri henüz artmadığında
veri tabanı tutarsız bir durumdadır.
Her hareket veri tabanının tutarlı bir durumunu
görmelidir.
Yani, Hi ve Hj hareketleri birlikte uygulanıyorsa, Hi
için
her şey sanki Hj hiç başlamamış ya da tamamlanmış
gibi görünmelidir.
4. Kalıcılık (durability):
Hareketten sonra, değişikliklerin kalıcılığı
sağlanmalıdır.
Bir arıza durumunda, değişikler yok
olmamalıdır.
Kalıcılık özelliği, başarıyla tamamlanan
değişikliklerin kalıcılığının güvencesidir.
Hareket Durumları
Commit (İşetildi): Başarıyla tamamlanan hareket.
Abort (Durudurudu): Başarıyla sonuçlanmayan hareket.
Roll Back (Geri Döndürme): Hareket durdurulursa(abort
edilirse), bölünmezlik için hareketin geri alınması.
Hareket Durumları:
 Çalışır (active): Başlangıç durumudur. Hareket, işletimi
devam ettiği sürece bu durumda kalınır.
 Kısmen işletildi (partially committed): Hareketin son
komutu da uygulandıktan sonraki durum.
 Başarısız oldu (failed):Hareketin normal uygulanmasının
sürdürülemeyeceği anlaşıldığındaki durum.
 İşletildi (commited): Hareket uygulanması başarıyla
sonuçlandıktan sonraki durum.
 Sonlandı (terminated): Hareket başarıyla tamamlandıktan,
ya da yarım kalan hareketin etkileri geriye alındıktan sonraki
durum.
Çalışır
Başarısız Oldu Sonlandı
İşletildi Kısmen
İşletildi
Begin
Transaction
End
Transaction
Abort
Read/Write
Commmit
Abort
Bellekte
Hard Diskte
Hareketlerin Birlikte İşletilmesi
Hareketleri düzenleyen kesime hareket işlem
sistemi (transaction processing system)
denir.
Birden çok hareketin işletimini birlikte
gerçekleştirir.
Tutarlılık için, hareket işlem sisteminin birliktelik
denetimi ile tutarsızlıkların önlenmesi gerekir.
H1 H2
Read (A);
A  A - 500;
Write (A);
Read (B);
B B + 500;
Write (B);
Mik  A / 5;
A A - Mik ;
Write (A);
Read (B);
B B + Mik;
Write (B);
 işletim planı (schedule): Komutların işletim
sırasını gösterir.
 H1 ve H2
için seri işletim planları:
1. P1 İşletim planı: Önce H1 ve Sonra H2
:
Başlangıçta A = 5000, B= 5000 ise,
P1 planı sonunda: A=3600 ve B=6400
2. P2
işletim planı: Önce H2 ve sonra H1
:
Başlangıçta A = 5000, B= 5000 ise,
P2 planı sonunda: A=3500 ve B= 6500
Her ikisi de doğru sonuçlar üreten tutarlı işletim
planlarıdır. Tutarlı olabilmesi için A ve B
değerlerinin toplamının değişmemelidir.
A+B = 10000
P1  P2 ve P2  P2
: A+B = 10000
kısıtlaması sağlanmaktadır.
Seri İşletim Planı: Her hareketin tüm
komutlarının ard arda işletilmesi, aralarına
diğer hareketlerinin komutlarının girmemesi
gerekir.
n hareket, n! farklı seri işletim planı
oluşturulabilir. Tutarlı işletim planlarıdır.
.
Seri işletimde kaynaklar verimli
kullanılamaz. Kaynak verimliği için,
birden çok hareketin komutlarının iç
içe işletildiği işletim planları
oluşturulmak istenir.
Başlangıçta:
A = 5000, B= 5000 ise,
Seri olmayan P3 Sonrası:
A= 4500, B = 6000,
A+B = 10500
Yanlış sonuç, tutarsız.
Serileştirilebilir olma (serializabile):
Plandan sonra tutarlı bir duruma
ulaşacağının;
Kurtarılabilir olma (recoverable):
kurtarma işleminin kolaylıkla
yapılabileceğinin,
güvencesidir.
H1 H2
Read (A);
A  A –
500;
Write (A);
Read (B);
B B +
500;
Write (B);
Read (A);
Mik  A /
5;
A A –
Mik;
Write (A);
Read (B);
B B +
Mik;
Write (B);
Serileştirilebilir İşletim Planı
Eğer seri olmayan bir işletim planı, seri işletim
planlarından birine eşdeğer ise bu işletim
planına serileştirilebilir (serializabile) işletim
planı denir.
Serileştirilebilir planlar da tutarlı planlardır.
Tanımlar:
1. Çelişki tabanlı eşdeğerlik (conflict
equivalence) varsa; çelişki tabanlı
serileştirilebilirlik.
2. Görünüm tabanlı eşdeğerlik (view
equivalence) varsa; görünüm tabanlı
serileştirilebilirlik.
Çelişki tabanlı serileştirilebilir her işletim planı
aynı zamanda görünüm tabanlı
serileştirilebilirdir.
Ancak bunun tersi doğru değildir.
Çelişki tabanlı serileştirilebilirlik daha tutarlıdır.
Birliktelik denetimi ve kurtarma açısından:
read ve write : Birinci derecede önemli,
commit ve abort: İkinci derecede önemli,
İki Komutun Çelişmesi
Çelişen Komutlar: Eğer üç koşul sağlanıyorsa,
1. k1 ve k2 komutları farklı hareketler içinde yer
alan komutlardır.
k1 € Hi, k2 € Hj , i≠j
2. k1 ve k2
, aynı veri üzerinde işlem yapan
komutlardır (k1 ve k2
, yalnız Read ya da
Write komutları olabileceği düşünülebilir.).
3. k1 ve k2 komutlarından en az biri Write
komutudur.
H1
: Read1(A) ve Write1(A)
H2 : Read2(A) ve Write2(A)
Çelişen komut çiftleri:
Read 1(A), Write2(A)
Read2(A), Write1(A)
Write1(A) ,Write2(A)
Read1(A) ve Read2(A) çelişmez.
Serileştirilebilirliğin Tanımı
Çelişmeyen komutların işletim sıraları
değişebilir.
Çelişen komutların işletim sırası değişirse
işletim planı da değişiş olur.
Seri olmayan bir işletim planı (Pi
), çelişmeyen
komutların yer değişimi ile seri bir işletim
planına (Pj
) dönüştürülebiliyorsa, Pi ve Pj
işletim planları eşdeğerdir.
Pi
, işletim planı seri olmayan ancak
serileştirilebilir bir işletim planıdır.
P4 ve P5: H3 ve H4
için seri işletim planları.
P6 ve P7: H3 ve H4
için seri olmayan işletim
planları.
3. ve 4. sırada yer alan komutlar ile 5. ve 6. sırada
yer alan komutlar birbiriyle çelişmemektedir.
P4
H3 H4
1
2
3
4
5
6
Read(A);
Write(A);
Read(B);
Write(B);
Read(A);
Write(A);
P5
H3 H4
1
2
3
4
5
6
Read(A);
Write(A);
Read(B);
Write(B);
Read(A);
Write(A);
P6
H3 H4
1
2
3
4
5
6
Read(A);
Write(A);
Read(B);
Write(B);
Read(A);
Write(A);
P7
H3 H4
1
2
3
4
5
6
Read(A);
Write(A);
Read(B);
Write(B);
Read(A);
Write(A);
P6 için;
 H3
'deki Read (B) komutu ile H4
‘deki Write (A)
komutunun,
 H3
'deki Read (B) komutu ile H4
‘deki Read (A) komutunun,
 H3
'deki Write (B) komutu ile H4
‘deki Write (A)
komutunun,
 H3
'deki Write (B) komutu ile H4
‘deki Read (A)
komutunun,
işletim şıraları değiştirildikten sonra P4 seri işletim planı elde
edilir.
P6
, seri işletim planına (P4
) eşdeğer olduğundan,
serileştirilebilirdir.
P7 için;
H3
’ deki Write (A) komutu ile H4
'deki Read (A) ve Write
(A) komutları çelişmektedir.
Üç komutun işletim sırası değiştirilemez.
P7
işletim planı P4 ve P5 seri işletim planlarından birine
dönüştürülemez.
P7
, serileştirilebilir bir işletim planı değildir.
Serileştirilebilirlik Testi
Serileştirilebilirlik testi için komut incelemek yerine çok daha
pratik bir yöntem olan öncelik çizgesi (precedence graph)
yöntemi kullanılır.
Öncelik Çizgesi Oluşturma Algoritması
1. Hi hareketi için, etiketi Hi olan bir düğüm oluştur.
2.Eğer işletim planında Hi ve Hj hareketlerinde (i ≠ j) yer alan
ki ve kj komutları çelişen komutlarsa (ki
, ve kj aynı A verisi
üzerinde işlem yapan komutlarsa, ve de bu iki komuttan en az
biri Write komutu ise) ve işletim sıralamasında kj ki den sonra
geliyorsa öncelik çizgesinde Hi düğümünden Hj düğümüne
etiketi A olan bir yay çiz.
3. Eğer ve yalnız eğer öncelik çizgesi döngüsüz ise işletim
planı serileştirilebilirdir.
Daha önceki, P1, P2, P3, P4, P5, P6, ve P7
işletim planlarının öncelik
çizgeleri.
P1, P2, P4 ve P5 seri işletim planlarının öncelik çizgeleri doğal olarak
döngüsüzdür.
P5 ve P7
'nin öncelik çizgeleri döngülüdür. Serileştirilemez.
P6
'nın öncelik çizgesi ise döngüsüzdür. P6 seri olmayan ancak
serileştirilebilir.
H1 H2
A,B (P1)
H1 H2
A,B
(P2)
H1 H2
A,B
A,B
(P3) H3 H4
A (P4)
H3 H4
A
(P5)
H3 H4
A
(P6)
H3 H4
A
A
(P7)
 P8
işletim planının öncelik çizgesi döngülü
olduğu için bu işletim planı serileştirilebilir
değildir.
P8
H5 H6 H7
1
2
3
4
5
6
7
8
9
10
11
12
13
Read(A);
Write(A);
Read(B);
Write(B);
Read(C);
Read(B);
Write(B);
Read(A);
Write(A);
Read(B);
Read(C);
Write(B);
Write(C);
H5 H6
A
B,C
(P8)
H7
B
B
 P9
işletim planının öncelik çizgesi ise
döngüsüzdür. P9
işletim planı serileştirilebilirdir
(Seri olmayan P9
işletim planı H7  H5 H6 seri
işletim planına eşdeğerdir).
P9
H5 H6 H7
1
2
3
4
5
6
7
8
9
10
11
12
13
Read(A);
Write(A);
Read(B);
Write(B);
Read(C);
Read(B);
Write(B);
Read(A);
Write(A);
Read(B);
Read(C);
Write(B);
Write(C);
H5 H6
A,B
B,C
(P9)
H7
B
Kurtarılabilir İşletim Planı
Hareketlerin işletimi yarım kalabilir.
Hareketin bölünmezliğini sağlamak için, işletimi
tamamlanmış komutların geri alınmamalıdır.
P10
H8 H9
Read(A);
Write(A);
Read(B);
Write(B);
Commit;
Read(A);
Commit;
H9
: Bir okuma komutu.
H9
, H8 de kullanılan A,
yazılmaktadır.
H9
, Read(A)’dan sonra
«commit» yaparsa sorunlar
yaşanabilir. Çünkü, H8
, A
değerini yazan hareketi
henüz tamamlanmamıştır.
Eğer H8
, Read (B) sonra başarısız olur ve abort
uygulanırsa,
H8
için (roll back) kurtarma işlemi
gerçekleştirilecek ve işletimi tamamlanmış
komutların etkisi geriye alınacaktır.
Bu durumda, H9
tarafından okunan değer de
geçerliğini yitirecek, bu nedenle H9
'un da
kurtarılması gerekecektir.
Oysa H9
'un işletimi daha önce tamamlanmıştır.
Tamamlanmış bir hareketin geriye alınmasının da
söz konusu olmaması gerekir.
P10 kurtarılabilir bir işletim planı değildir.
Eğer bir işletim planında, diğer hareketlerden birinin
başarısız olması nedeniyle, işletimi başarımla
tamamlanan hareketlerin geriye alınması
gerekmiyorsa, bu işletim planına kurtarılabilir
işletim planı denir.
İşletimi tamamlanmamış
hareketler tarafından yazılan
veriler (dirty data) kirli
veridir.
Kirli veriyi yazan her an yarım
kalabilir.
Bu nedenle kirli verilerin diğer
hareketler tarafından
okunmaması; eğer
okunuyorsa da kirli veriyi
okuyan hareketin kirli veriyi
yazan hareketten önce
sonlanmaması gerekir.
P11
H8 H9
Read(A);
Write(A);
Read(B);
Write(B);
Commit;
Read(A);
Commit;
H9
’daki commit, H8 commitinden sonraya alınırsa
kurtarılabilir (P11) olur.
Kurtarılabilir olması için gerekli ve yeterli olan
koşul, işletim planı içindeki her hareketin,
okuduğu verileri yazan hareketlerin tümü
sonlanmadan, sonlanmamasıdır.
P12 kurtarılabilirdir.
Çünkü, diğer hareketlerden birinin başarısız olması
nedeniyle, işletimi tamamlanmış bir hareket için
kurtarma işlemi uygulamasına gerek yoktur.
Ancak bu işletim planının taşıdığı bir başka sakınca
vardır. Bu işletim planında, Read (B)
komutundan sonra bir bozukluk oluşur ve H10 için
kurtarma işlemine gerek duyulursa, zincirleme
olarak H11, H12, H13 ve H14 için de kurtarma
işlemi uygulanması gerekir. Zincirleme kurtarma
çok zaman alacağı için, istenmeyen bir durumdur.
P12
H10 H11 H12 H13 H14
Read(A);
Write(A);
Read(B);
Write(B);
Commit;
Read(A);
Write(A);
Commit;
Read(A);
Write(A);
Commit;
Read(A);
Write(A);
Commit;
Read(A);
Write(A);
Commit;
Zincirleme Kurtarma Gerektiren İşletim Planı
Bir işletim planındaki bir hareketin başarısız
olması, zincirleme olarak, işletim planındaki
diğer hareketlerin de başarısız olmasına yol
açıyorsa, bu işletim planına zincirleme
kurtarma gerektiren (cascading rollback)
işletim planı denir.
Bir işletim planın zincirleme kurtarma
gerektirmemesi için gerekli ve yeterli olan
koşul işletim planındaki her hareketin
okuduğu her verinin, işletimi tamamlanmış
(commit işlemi uygulanmış) bir hareket
tarafından yazılmış olmasıdır.
Zincirleme kurtarma gerektirmeyen işletim
planı, kurtarılabilir işletim planına göre daha
kısıtlayıcı bir işletim planıdır. Zincirleme
kurtarma gerektirmeyen her işletim planı aynı
zamanda kurtarılabilir bir işletim planıdır.
Ancak bunun tersi doğru değildir. Zincirleme
kurtarma gerektirmeyen işletim planından
daha kısıtlayıcı işletim planı türü sıkı işletim
planıdır (strict schedule).

9.4. Birliktelik Denetimi
Birden çok hareketin, bir işletim planı
kapsamında birlikte işletilmesinde, tutarlılık
açısından işletim planının serileştirilebilir
olmasının son derece önemli olduğunu
gördük. Ancak uygulamada bir işletim planının
serileştirilebilir olup olmadığının test edilmesi
son derece güçtür. Çünkü hem işletim
planında yer alacak hareketlerin hangileri
olacağı, hem de komutların hangi sırada
işletileceği önceden belli değildir.
Sisteme sürekli olarak yeni hareketler
katılabilir. Komutların işletim sırası ise, tüm
süreçlere kaynakları atayan işletim sistemi
tarafından belirlenmektedir. İşletim planında
hangi hareketlerin yer alacağı ve komutların
işletim sırasının nasıl olacağı önceden
bilinmediği için, işletim planının serileştirilebilir
olup olmadığını önceden belirlemek de
mümkün değildir.
İşletim planı tamamlandıktan sonra
serileştirilebilirlik testinin yapılması; işletim
planının serileştirilebilir olmadığı anlaşıldığında
da kurtarma işlemi ile tüm hareketlerin geriye
alınması ise uygulama acısından çok verimsiz
bir çözümdür. Bu nedenle, serileştirilebilir
olmasını, serileştirilebilirlik testi yapmaya
gerek kalmadan sağlayan yöntemler önem
kazanmaktadır.
Bu amaçla, ticari Veri Tabanı Yönetim
Sistemlerinin tümü tarafından benimsenen
yöntem, işletim planının serileştirilebilir olması
güvencesini veren protokollerin
kullanılmasıdır. Bu amaçla kullanılan
protokoller arasında, en çok bilinen ve
kullanılanı iki-evreli kilitleme (two-phase
locking).protokolüdür (komutlar kümesidir).
9.4.Birliktelik Denetimi İçin Kilitleme
Teknikleri
Hareketlerin birlikte işletimini denetlemek için
en çok kullanılan teknik veri öğelerinin
kilitlenmesidir. Kilit, bir veri öğesine atanan ve
veri öğesinin durumunu gösteren bir
değişkendir. Kuramsal olarak, veri tabanındaki
her veri öğesine ilişkin bir kilidin bulunduğu ve
bu kilidin veri öğesi üzerinde yapılan
işlemlerin neler olduğunu gösterdiğini
düşünebiliriz. Temel olarak iki tür kilit vardır.
1.Paylaşımlı kilit (shared lock) ya da okuma
kilidi (read lock)
2.Dışlayan kilit (exclusive lock) ya da yazma
kilidi (write lock)
Aynı veri öğesi üzerinde, birden çok hareket
aynı anda okuma işlemi yapabilir. Ancak bir
veri öğesi üzerinde bir hareket yazma işlemi
yapıyorsa, bu veri öğesinin diğer hareketler
tarafından okunmaması ve yazılmaması
gerekir. Buna göre aynı veri öğesi üzerindeki
paylaşımlı kilitler birbiriyle uyumludur. Ancak
bir veri öğesi üzerindeki dışlayan kilit, bu veri
öğesi üzerindeki hem paylaşımlı hem de
dışlayan kilit ile uyumsuzdur.
Çizim 9.13'deki çizelgede kilit türlerinin
birbirleriyle uyumluluğu görülmektedir.
Çizim 9.13. Kilit Türlerinin Birbiriyle
Uyumluluğu
Paylaşımlı kilit Dışlayan kilit
Paylaşımlı kilit Uyumlu --
Paylaşımlı kilit -- --
Veri Tabanı Yönetim Sisteminin bileşenleri
arasında bir kilitleme yöneticisinin (locking
manager) bulunduğu ve kilitleme yöneticisi
tarafından kilitleme bilgilerinin uygun
çizelgelerde tutulduğu düşünülebilir. Bir veri
öğesi üzerinde okuma ya da yazma işlemi
yapmak isteyen hareket, kilitleme
yöneticisinden istemde bulunur.
Kilitleme yöneticisi, veri öğesinin durumunu
inceleyerek, uygunsa istenilen kilidi hemen
karşılar. Veri öğesinin o andaki durumu
istenilen kilidi hemen karşılamak için uygun
değilse, kilitleme istemini bekleme kuyruğuna
gönderir.
Kilitleme tekniği açısından, 3 temel kilitleme
işlemi vardır.
1. LockS(A): A veri öğesinin paylaşımlı türde
kilitlenmesi.
2. LockX(A): A veri öğesinin dışlayan türde
kilitlenmesi.
3. Unlock(A): A veri öğesi üzerindeki kilidin
çözülmesi.
Aslında bu işlemlerden her biri için önce
hareket tarafından istemde bulunulur, daha
sonra da istemin karşılandığı (hemen ya da
belirli bir bekleme süresi sonunda) harekete
bildirilir. Ancak basitlik açısından, örneklerde
bu ayırım yapılmayacak ve her işlem için tek
bir gösterim kullanılacaktır.
Bir işletim planında yer alan hareketlerde
kilitleme tekniğinin kullanılması işletim
planının serileştirilebilir olmasını
güvencelemez. Eğer veri öğeleri üzerine
vurulan kilitler, okuma ve yazma işlemleri
tamamlandıktan hemen sonra çözülürse
tutarsızlıklar oluşabilir. Örnek olarak çizim
9.14’deki P13 işletim planını inceleyelim.
Bu işletim planında yer alan H15 ve H16
hareketlerinde birbiriyle uyumlu biçimde
kilitleme yapılmaktadır. Başlangıçta A= 1000,
B= 2000 olduğunu varsayalım. Seri işletim
planları sonunda:
 önce H15 sonra da H16 işletilirse A=3000,
B=5000
 önce H16 sonra da H15 işletilirse A=4000,
B=3000
olur.
Çizim 9.14’deki P13 işletim planının sonunda
ise A=3000, B=3000 değerleri elde edilir.
Buna göre P13 işletim planı seri işletim
planlarından hiçbirine eşdeğer değil,
dolayısıyla da serileştirilebilir değildir. P13
’ün
serileştirilebilir olmamasının nedeni H15
hareketinde B kilidinin erken çözülmesidir.
H15 tarafından erişilen veri öğesi B üzerindeki
kilidin erken çözülmesi ve bu veri öğesinin H16
tarafından kilitlenerek değerinin değiştirilmesi
tutarsızlığa neden olmaktadır. İşletim planının
serileştirilebilir olmasını güvence altına almak
için, kilitlemeye ek olarak, hareketlerin iki
evreli kilitleme protokolü(kurallar kümesi)
olarak bilinen protokolü sağlaması gerekir.
P13
Çizim 9.14 Kilitleme Yapılmasına Rağmen
Serileştirilebilir Olmayan İşletim Planı
H15 H16
LockS(B);
Read(B);
Unlock(B);
LockX(A);
Read(A);
A  A+B;
Write(A);
Unlock(A);
LockS(A);
Read(A);
Unlock(A);
LockX(B);
Read(B);
B B+A;
Write(B);
Unlock(B);
9.4.1. İki-Evreli Kilitleme Protokolü
İşletim planlarının serileştirilebilir olmasını
sağlayan protokoller arasında en çok bilineni
iki-evreli kilitleme protokolüdür. Bu protokolde
her hareket iki evreye ayrılır.
1.Birinci evre ya da genişleme evresi
(first/expanding phase). Bu evre hareketin
kilitleme isteminde bulunduğu, ancak kurduğu
kilitlerden hiçbirini çözmediği evredir. Başka
bir deyişle, bu evrede LockS ve LockX
komutları bulunabilir, ancak hiçbir Unlock
komutu bulunamaz.
2.İkinci evre ya da küçülme evresi
(shrinking phase). Bu evre hareketin mevcut
kilitleri çözdüğü, ancak yeni kilitleme
isteminde bulunmadığı bir evredir. Başka bir
deyişle, bu evrede Unlock komutları
bulunabilir. Ancak hiçbir LockS ya da LockX
komutu bulunamaz.
İki-evreli kilitleme protokolüne göre her
hareket genişleme evresinde başlar ve
okunacak ya da yazılacak tüm veri öğelerinin
kilitlenmesi bu evrede gerçekleştirilir. İlk
Unlock komutu hareketin küçülme evresine
geçmesine neden olur. Genişleme evresinde
vurulan kilitler bu evrede çözülür.
Eğer bir işletim planındaki hareketlerin tümü
iki-evreli kilitleme protokolünü sağlarsa bu
işletim planı serileştirilebilir bir işletim planıdır.
iki-evreli kilitleme protokolü, işletim planının
serileştirilebilir olmasını sağlarken birliktelik
oranının azalmasına yol açar.
Çizim 9.14'deki P13 işletim planında yer alan
her iki hareket de iki-evreli kilitleme
protokolünü sağlamamaktadır. Dolayısıyla P13
işletim planı serileştirilebilir değildir. Çizim
9,15'deki P14 işletim planında yer alan
hareketlerin her ikisi de iki evreli-kilitleme
protokolünü sağlamaktadır. Dolayısıyla P14
serileştirilebilir bir işletim planıdır.
İki-evreli kilitleme protokolünün de birçok
farklı biçimi vardır. Yukarıda verilen tanım ikievreli kilitleme protokolünün temel biçimidir.
Aşağıda iki-evreli kilitlemenin diğer
biçimlerinden ikisi tanımlanmaktadır.
Tutucu iki-evreli kilitleme (conservative
two-phase commit). Bunun için, temel
kurallara ek olarak, hareketteki işlemler
başlamadan önce, gerekli tüm kilitlerin
vurulması gereklidir.
Sıkı İki-evreli kilitleme (strict two-phase
locking), Bunun için de, temel kurallara ek
olarak, hareket başarılı ya da başarısız olarak
tamamlanıncaya dek dışlayan kilitlerden
hiçbirinin çözülmemesi gerekir. Eğer bir işletim
planındaki hareketler iki-evreli kilitleme
protokolünün bu biçimini sağlıyorsa, bu işletim
planı hem serileştirilebilir hem de sıkı bir
işletim planıdır.
P14
Çizim 9.15. İki-evreli Kilitleme Protokolünü
Sağlayan İşletim Planı
H15 H16
LockS(B);
Read(B);
LockX(A);
Unlock(B);
Read(A);
A A+B;
Write(A);
Unlock(A);
LockX(B);
Read(B);
LockS(A);
Read(A);
B  B+A;
Write(B);
Unlock(B);
Unlock(A);
9.4.2. Kilitlenmeler
Eğer hareketler tarafından vurulan kilitler
okuma/yazma işleminden hemen sonra
çözülürse tutarsız durumların oluşabildiğini
gördük. Tutarsızlıkları önlemek için, iki evreli
kilitleme protokolünde olduğu gibi, kilitlerin
çözülmesi geciktirilir. Ancak bu durumda
kilitlenmeler (deadlockds) oluşabilir.
Örnek olarak, başlangıç kesimi Çizim 9.16'da
görülen P15 işletim planını İnceleyelim. Bu
işletim planına göre, H17 hareketi LockX(A)
komutuna geldiğinde beklemeye başlar. Çünkü
kilitlenmek istenilen A veri öğesi daha önce
H18 tarafından kilitlenmiştir. Benzer biçimde,
H18 hareketi de LockX(B) komutuna
geldiğinde beklemeye başlar.
Çünkü kilitlenmek istenilen B veri öğesi daha
önce H17 tarafından kilitlenmiştir. Böylece H17
ve H18 karşılıklı olarak birbirini beklediğinden
bir kilitlenme oluşmuştur.
Genel olarak, bir işletim planında yer alan
hareketlerden en az ikisinin yer aldığı bir
altkümedeki her hareket, altkümedeki diğer
bir hareket tarafından kilitlenmiş bir veri
öğesini kilitlemeye çalışıyorsa ve bu ilişkiler bir
döngü oluşturuyorsa bir kilitlenme oluştu
denir.
Kilitlenme oluştuğunda, hareketler karşılıklı
olarak birbirini bekleyeceğinden, hiçbir işletim
yapılamayacaktır. Kilitlenmeyi çözmek için
kilitlenmeye neden olan hareketlerden birisi
kurban olarak seçilmeli ve bu hareket geriye
alınmalıdır.
Çizim 9.16. Kilitlenme örneği
H17 H17
LockS(B);
Read(B);
LockX(A);
.
.
.
LockS(A);
Read(A);
LockX(B);
.
.
.
Çok kullanıcılı bir ortamda, birden çok hareket
birlikte işletildiğinde, eğer kilitleme
yapılmazsa, ya da vurulan kilitler
okuma/yazma işleminden hemen sonra
çözülürse tutarsız bir durumla
karşılaşılabilindiğini; tutarsız durumları
önlemek için, iki-evreli kilitleme protokolünde
olduğu gibi, kilitlerin çözülmesi bir miktar
geciktirilirse de kilitlenmeler olabileceğini
gördük.
Kilitleme tekniklerinin kullanılmaması ve
tutarsızlıkların oluşabilmesi ile kilitleme
tekniklerinin kullanılması ve kilitlenmelerin
oluşabilmesi arasında bir tercih yapmak
gerektiğinde genellikle kilitleme tekniklerinin
kullanılması tercih edilir.
Çünkü tutarsız durumların yol açacağı
sorunlar, teknik düzeyde çözülemeyen,
işletme ortamına yansıyan ve VTYS tarafından
onarılamayan sorunlar olabilir. Kilitlenmeler
ise kurtarma işlemi ile VTYS bünyesinde
çözülebilen sorunlardır. Üstelik uygun
protokoller kullanarak kilitlenmeleri önlemek
de mümkündür.
Kilitlenmenin Bulunması
Kilitlenmelere karşı uygulanabilecek iki temel
yaklaşım vardır. Birinci yaklaşım, uygun
protokoller kullanarak kilitlenmeleri
önlemektir. Kilitlenmeleri önleyen protokoller,
birlikteliği de önleyen son derece katı
protokoller olduğundan, genellikle
uygulamada kullanılmazlar.
Kilitlenmelere karşı ikinci yaklaşım ise,
kilitlenmenin oluştuğunun anlaşılması ve
kilitlenmeye neden olan hareketlerden birine
kurtarma işlemi uygulayarak kilitlenmeyi
çözmektir. Uygulamada genellikle bu yaklaşım
kullanılır.
Kuramsal olarak, bir işletim planının
kilitlenmeye yol açıp açmayacağı bekleme
çizgesi (wait-for graph) yöntemiyle
bulunabilir. Yönlü bir çizge olan bekleme
çizgesinde her harekete karşı gelen bir düğüm
bulunur.
Eğer işletim planında Hj hareketi tarafından
kilitlenen bir veri öğesi (A), bu kilit
çözülmeden, Hi
tarafından da kilitlenmek
isteniyorsa, ve bu iki kilit birbiriyle uyumsuz
ise (bu iki kilitten en az biri dışlayan kilit ise)
bekleme çizgesinde Hi düğümünden Hj
düğümüne yönlü bir yay çizilir ve yayın
üzerine veri öğesinin adı (A) yazılır.
Çizgedeki Hi  Hj yayı, kilitleme yapabilmek
için Hi
'nin Hj
'yi beklediğini göstermektedir.
Eğer bir işletim planı için oluşturulan bekleme
çizgesi döngülü ise, bu işletim planının
kilitlenmeye yol açacağı anlaşılır. Çizim
9.17’de P16 işletim planı ve bu işletim planının
çizgesi görülmektedir.
Bekleme çizgisi döngülü olduğu için P16 işletim
planının kilitlenmeye yol açacağı
anlaşılmaktadır. Çizim 9.18’ de yer alan P17
işletim planını bekleme çizgesi döngüsüz
olduğu için de, P17’nin kilitlenmeye yol
açmayacak bir işletim planı olduğu
anlaşılmaktadır.
Eğer bir işletim planı önceden belli ise,
bekleme çizgesi oluşturularak bu planın
uygulanması sırasında kilitlenme oluşup
oluşmayacağı bulunabilir. Ancak, işletim
planlarının önceden belli olmadığı; hem işletim
planında yer alan hareketlerin, hem de
komutların işletim sırasının dinamik biçimde
oluştuğu daha öncede belirtilmişti.
Bu nedenle kilitlenmeler ancak işletim
aşamasında bulunabilir. Kilitlenmeyi bulmak
amacıyla, işletimi gerçekleştiren komutlar için
işletim planı ve işletim planının oluşan kesimi,
bekleme çizgesi tabanlı bir algoritmayla
incelenerek oluşan kilitlenmeler bulmaya
çalışılır. Bir diğer yaklaşım ise kilitlenmelerin
zaman aşımı (time-out) yöntemi ile
çözülmesidir.
Bu yaklaşımda bir hareketin bir veri öğesini
kilitlemek için beklediği süre, önceden
belirlenmiş zaman aşımı süresini geçerse,
beklemeye kilitlenmenin neden olduğu
varsayılarak bu hareketin işletilen kısmı geriye
alınır ve hareket otomatik olarak yeniden
başlar.
İşletim aşamasında kilitlenme olduğu
anlaşıldığında, kilitlenmeyi çözmek için
bekleme çizgesindeki döngüleri yok etmek
gerekir. Bekleme çizgesindeki her döngüyü
yok etmek için de, döngüde yer alan
hareketlerden biri kurban olarak seçilir ve
seçilen hareketin işletimi kesilerek kurtarma
işlemi uygulanır. Böylece kurban edilen
hareketi bekleyen hareket ya da hareketlerin
işletimi başlar ve kilitlenme çözülür.
Kilitlenmeyi çözmek için kurban edilecek
hareketin seçiminde akılcı çözüm, o ana kadar
işletilen kesiminin işletim bedeli en küçük olan
hareketi seçmektir. Ancak en küçük bedel
kavramı tam belirgin olmayan ve değişik
sistemlerde değişik biçimde yorumlanan bir
kavramdır.
Diğer taraftan, kurban edilecek hareketi seçen
algoritma tarafından sadece işletim bedeli
esas alınırsa, peş peşe oluşan kilitlenmelerde,
algoritmanın kurban olarak hep aynı hareketi
seçmesi ve bu hareketin uzunca süre
işletilememesi tehlikesi vardır. Starvation
olarak adlandırılan bu olayın oluşmaması için
kurban edilecek hareketi seçen algoritmanın,
işletim bedeli yanında, örneğin hareketin
sisteme giriş zamanı gibi parametreleri de
gözetmesi gerekir.
Kilitlenen Veri Miktarı
Yukarıdaki kesimlerde, kilitlenen veri biriminin
veri öğesi olduğu ve sistemin her veri öğesi
İçin ayrı bir kilit tuttuğu varsayıldı. Kilitlenen
birimin veri öğesi olması, birliktelik oranının
büyük olmasına yol açar.
Çünkü aynı veri öğesinin, aynı anda birden
çok hareket tarafından okunmak ya da
yazılmak istenmesinin olasılığı çok düşüktür.
Buna karşılık kilitlenen birim veri öğesi
olduğunda, vurulan ve çözülen kilit sayısı çok
büyük olacağından kilitleme yönetimi için çok
zaman harcanır.
Kilitlenen veri birimi (granularity of lock), veri
öğesi yerine daha büyük bir veri birimi olabilir,
örneğin ilişkisel modelde bir satır (ya da
çoklu), bir çizelge, hatta bir şema kilitleme
birimi olarak seçilebilir. Kilitlenen birim
büyüdükçe kilitleme yönetimi kolaylaşır ve
kilitleme için harcanan süre azalır.
Buna göre, gerçekleştirilen işlemlerin türüne
göre, kilitleme biriminin bazen küçük bazen de
büyük olmasında yarar vardır. Bunun içinde
kilitleme sisteminin, kilitlemenin birden çok
düzeyde (multiple granularity) yapabilmesine
izin vermesi gerekir.
Diğer Birliktelik Denetimi Protokolleri
Birliktelik denetimi ile ilgili olarak bu kesimde
daha çok kilitleme tekniği ve iki evreli
kilitleme protokolü üzerinde duruldu. Ancak,
tutarsız durumlara yol açmadan hareketlerin
birlikte işletilmesini sağlamak için
kullanılabilecek daha başka teknikler ve
protokoller de vardır. Bunlardan bir kaçı
aşağıda örnek olarak sıralanmaktadır.
Çizge-tabanlı protokoller (graph-based
protocols). Kilitleme tabanlı, iki-evreli kilitleme
protokolü yerine kullanılan protokoller.
Zaman damgası-tabanlı protokoller
(timestamp-based protocols). Hareketlere
biricik bir zaman damgası atayan ve
hareketlerin işletim sırasını zaman damgasına
göre belirleyen protokoller.
Geçerlik-tabanlı protokoller (validationbased protocols). Birliktelik denetimini
hareketlerin işletimi sırasında yapan, kilitleme
ve zaman damgası tabanlı protokollerden
farklı olarak işletim sırasında herhangi bir
denetim yapmayan, hareketin işletiminin
sonunda geçerlilik denetimi yapan protokoller.
Okuma işleminin çok olduğu ortamlarda
sistem başarımının artmasına neden olan bu
protokoller iyimser protokoller olarak da
adlandırılır.
9.5.Kurtarma Teknikleri
Bir hareket işletilmek üzere VTYS’ye
aktarıldığında, VTYS:
 hareketteki tüm komutların işletiminin
başarıyla tamamlanmasını ve sonuçların
kalıcılığını,
 ya da hareketin veri tabanı ve diğer
hareketler üzerinde hiçbir etkisinin olmamasını
sağlamak zorundadır.
Oysa çok çeşitli bozukluklar(failures)
hareketin işletiminin başarısız olmasına yol
açabilir. Bu durumda, kurtarma (recovery)
işlemleri uygulanarak, o ana kadar işletilen
komutların etkisinin yok edilmesi, veri
tabanının tutarlı bir noktaya dönüştürülmesi
gerekir. hareketlerin yarım kalmasına neden
olan bozuklukların başlıcaları aşağıdaki gibi
sıralanabilir.
1. Hareket bozukluğu(transaction failure).
Hareketteki herhangi bir komutun işletiminin
başarısız olması, bir veri değeri yetersizliği
gibi hareketin tamamlanmasını engelleyen
mantıksal yanlışlar, hareketin işletiminin
durdurulması, .. vb.
2.Birliktelik denetimi zorlaması. Herhangi
bir bozukluk olmasına rağmen kilitleme gibi
bir nedenle hareketin işletiminin
sürdürülememesi.
3. Sistem bozukluluğu(computer failure).
Hareketin işletimi sırasında bilgisayar
sisteminde oluşan bir donanım, yazılım ya da
ağ yanlışı.
4. Disk bozuklukları. Çeşitli nedenlerle disk
alt sisteminde oluşan ve diskin belirli
bloklarının okunmasını/yazılmasını engelleyen
bozukluklar.
5.Diğer sorunlar. Güç kaynağı bozukluğu,
yangın, sabotaj, .. vb.
Yukarıdaki sayılan bozukluk türlerinden ilk üçü
daha sık karşılaşılan bozukluklardır. Bu
bozukluklardan biri oluştuğunda VTYS'nin
kurtarma işlemini başlatması ve gerekli
onarımları yaparak veri tabanını bozukluktan
önceki en yakın tutarlı duruma döndürülmesi
gerekir.
Kurtarma stratejilerini aşağıdaki gibi
özetlemek mümkündür.
1. Eğer 1-3. tür bozukluklardan biri oluştuysa,
veri tabanında Önemli bir bozulma olmamıştır.
Bu durumda kurtarma stratejisi, tutarsızlığa
neden olan işlemleri geri almaya (undo)
dayanır. Bu arada, veri tabanını tutarlı bir
duruma getirmek için işlemlerden bir kısmını
yeniden işletmek (redo) de gerekebilir.
Undo ve redo işlemleri için günlük
kütüğündeki (log file) bilgiler kullanılır. Bu
bölümdeki kurtarma teknikleri iki grupta
toplanabilir. Birinci gruptaki teknikler
ertelemeli günleme, ikinci gruptaki teknikler
ise anında günleme tabanlı tekniklerdir.
2. Eğer 4-5. tür bozukluklardan biri oluştuysa
ve veri tabanında önemli bozulmalar olduysa,
kurtarma stratejisi veri tabanının eski bir
kopyasını kullanmaya dayanır. Günlük kütüğü
(log fite) kullanılarak, Veri tabanı kopyasının
alındığı tarih ile bozukluğun oluştuğu tarih
arasında işletilen ve başarıyla tamamlanan
hareketlere ilişkin komutlar işletilerek veri
tabanı en yakın tutarlı duruma taşınır.
Günlük Kütüğü (Log File)
Herhangi bir bozukluk durumunda kurtarma
işlemlerini gerçekleştirebilmek İçin, VTYS
tarafından bir günlük kütüğü tutulur ve bu
kütükte kurtarma için gerekli bilgiler biriktirilir.
Günlük kütüğü kullanılarak gerçekleştirilen
kurtarma İşlemine günlük kütüğü tabanlı
kurtarma denir.
Günlük kütüğü disk ortamında tutularak bu
kütükteki bilgilerin hareketin yarım kalmasına
neden olan bozukluktan etkilenmemesi
sağlanır. Ayrıca belirli aralıklarla günlük
kütüğü disk ortamından mıknatıslı şerit
ortamına kopyalanarak arşivlenir.
Günlük kütüğünde tutulan bilgileri aşağıdaki
gibi özetlemek mümkündür.
(Ti ve Tj
ile hareketleri, X ve Y ile Veri
Öğelerini, De ve Dy
ile de veri öğesinin eski ve
yeni değerlerini gösterirsek)
< Ti, begin > : Ti
‘nin başladığını gösterir.
< Ti
, read,X,D> : Ti
‘nin bir okuma işlemi İle
X'in değerini okuduğunu gösterir (D:X ‘ in
okunan değeri).
< Ti
, write,X,De
, Dy >: Ti
‘nin bir yazma
işlemi ile X in değerini günlediğini gösterir.(De
ve De : X ‘in eski ve yeni değerleri ).
< Ti
, commit> :Ti
‘nin işletiminin başarıyla
tamamlandığını gösterir.
<Ti , abort> : Ti ‘nin işletiminin başarısız
olduğunu gösterir.
<Checkpoint>: Denetim-noktası.
Günlük kütüğündeki bilgilerin birincil amacı
kurtarma işlemleri, ikincil amacı ise
izlemedir(audit). Günlük kütüğünde hareketin
başladığını, hareketin başarıyla
tamamlandığını, ya da hareketin yarım
kaldığını gösteren kayıtlara her zaman
gereksinim duyulur.
Okuma işlemleri ile ilgili kayıtlar, kurtarmadan
çok izleme amacı ile kullanılır. Kurtarma için
hangi tekniğin kullanıldığına bağlı olarak da,
yazma işlemleri ile ilgili kayıtlarda yazılan veri
öğesinin eski değerine (De
) gerek
duyulmayabilir.
Günlük kütüğünde yer alan bir diğer kayıt türü
denetim-noktası (checkpoint) kaydıdır.
Bilindiği gibi veri tabanından okunan bilgiler
blok ya da sayfa düzeninde VTYS’nin yastık
alanında (buffer) tutulur. Günlenecek bilgilerin
yer aldığı disk bloklarının da önce yastık alana
taşınması gerekir. Günleme işlemleri önce
yastık alanda yapılır, daha sonra da yastık
alanda değişikliğe uğrayan blok ya da sayfalar
diske yazılır.
Uygulama programı düzeyindeki her yazma
komutu, yastık alanının günlenmesine neden
olur. Yastık alanda yapılan değişikliğin veri
tabanına (diske) ne zaman aktarılacağı yastık
alan yönetimi (buffer management) ve
kurtarma yönetimi (recovery management)
için kullanılan tekniklere göre değişir.
Bu söylenenler günlük kütüğü için de
geçerlidir. Günlük kütüğüne yeni tutanak
yazıldığında, bu tutanak günlük kütüğünün
yastık alanına yazılır. Yastık alandaki bilgilerin
diske yazılması için birçok yazma işlemi yapılıp
yatık alanın dolması gerekir. Özetle, gerek veri
tabanı yastık alnındaki, gerekse günlük
kütüğü yastık alanındaki ekleme ve
günlemeler gecikmeli olarak diske
yazılmaktadır.
Kurtarma işlemlerinin güvenliği açısından,
yastık alan dolmadan ya da yastık alan
yönetimi için kullanılan algoritma
gerektirmeden yastık alandaki bilgilerin diske
yazılmasına zorlamalı-yazma (forcewrite)
adı verilir. Günlük kütüğüne yazılan checkpoint
tutanağı bu tür zorlamalı-yazmanın bir
göstergesidir. Bu amaçla VTYS , belirli
aralıklarla aşağıdaki eylemeleri gerçekleştirir.
1. Tüm hareketlerin işletimi geçici olarak
durdurulur.
2. Veri tabanı yastık alanında yer alan ve
değişikliğe uğramış tüm sayfala ya da bloklar
zorlamalı olarak diske yazılır.
3. Günlük kütüğüne bir <Checkpoint> tutanağı
yazılır ve günlük kütüğü yastık alanının
zorlamalı olarak diske yazılması sağlanır.
4. İşletimi geçici olarak durdurulan hareketler
canlandırılır.
Denetim-noktası kavramı kurtarma işlemleri
açısından oldukça önemlidir. Her denetimnoktası, işletimi tamamlanmış hareketlerin
kurtarma kapsamından çıkmasına neden olur.
Herhangi bir bozukluk durumunda da,
kurtarılması gereken işlemler, günlük
kütüğündeki son denetim-noktası
tutanağından sonraki işlemlerle sınırlanır.
Hareketin Geri Alınması
Veri tabanını günleyen bir hareket herhangi
bir nedenle yarım kalırsa hareketin işletilmiş
kesiminin geri alınması gerekir. işletimi geri
alınan hareket tarafından yazılmış kirli veriler,
eğer başka hareketler tarafından okunmuşsa,
bu hareketlerin de geri alınması gerekir.
Böylece geri alınan her hareket başka
hareketlerin de geri alınmasını gerektirebilir
ve geri alma işlemi zincirleme devam edebilir.
Eğer işletim planı zincirleme kurtarma
gerektirmeyen bir işletim planı ise, geri alma
işlemi yalnız yarım kalan hareket için
uygulanır ve diğer hiçbir hareketin geri
alınması gerekmez.
Örnek olarak Çizim 9.19’daki P18 işletim
planını ele alalım. Üç hareketin birlikte
işletildiği bu işletim planı uygulanırken, H25
‘deki Read(A) komutu işletildikten sonra bu
harekette mantıksal bir yanlışın oluştuğunu ve
hareketin yarım kaldığını düşünelim.
Yarım kalan hareket veri tabanında günleme
yaptığı için, bu hareketteki yazma
işleminin(Write(B) )etkisin geri alınması
gerekir. Bir inceleme yapıldığında, geri alınan
yazma işlemi tarafından yazılan kirli verinin
H26 tarafından okunduğu görülür. Bu nedenle
bu hareketteki yazma işlemlerinin (Write(B)
ve Write(D)) etkilerinin de geri alınması
gerekir.
Başka bir deyişle, bu işletim planında H25’in
geri alınması H26’nın da geri alınmasına neden
olmaktadır. Çünkü bu işletim planı zincirleme
kurtarma gerektiren bir işletim planıdır. Dikkat
edilirse geri alma işlemleri yalnız yazma
komutları için gerçekleştirilmemiştir.
Okuma komutları ise, geri alınan yazma
komutları tarafından yazılan kirli verilerin
hangi hareketler tarafından okunduğunu
bulmaya, dolayıyla zincirleme olarak hangi
hareketlerin geri alınacağını belirlemeye
yaramaktadır.
Bu durumda, eğer işletim planının zincirleme
geri alma gerektirmediği biliniyorsa, başka bir
deyişle işletim aşamasında komutların işletim
sırası belirlenirken, zincirleme kurtarmaya
gerek duyulmaması gözetilmemişse, günlük
kütüğünde okuma komutları ile ilgili kayıtların
yer alması da zorunlu değildir.
Normalleştirme
Veri Tabanı Yönetimi
Ders 6
• İlişkisel veri tabanı tasarlanması aşamasında
verinin tekrarlanmasını, kaybını veya
yetersizliğini önlemek için normalleştirme
(normalization) işlemi uygulanır.
• Normalleştirme, aynı zamanda “ilk taslak” veri
tabanı tasarımının üzerinde revizyonlar
yapmanın yolu, taslağı son haline yaklaştırmanın
yöntemlerden birisidir.
• Normalleştirmenin altyapısı da, ilişkisel modelin
altyapısı gibi matematikseldir. Temel alınan
kavram, işlevsel bağımlılık (functional
dependency) (bak slayt 6) denilen bir kavramdır.
Veri Modelini Normalleştirmek
• Sadece bu öğe bile normalleştirme ile uğraşmak için
yeterli bir sebeptir.
• Eğer veri gereksiz yere tekrarlanıyorsa, bu değişik
kopyalar, kopyalardan habersiz olan uygulama kodları
yüzünden bir süre sonra birbirinden farklı değerleri
taşımaya başlayabilirler. Bu, doğruluk ve tutarlılık
açısından çok kötü bir sonuçtur.
• Bu gibi durumlarda ilişkisel veri tabanı yönetim
sisteminin otomatik bütünlük (automatic integrity)
mekanizmaları bile işe yaramaz. Düzeltmenin, uygulama
seviyesinde yapılması gerekir. Fakat bu da uygulama
programlarını daha karmaşıklaştıracak, dolayısıyla
bakımını zorlaştıracaktır.
Normalleştirmenin Amaçları - 1
Veri bütünlüğünü sağlamak
• Normalleştirme, genelde bilinen ve takip edilen
“ilişkisel model, verinin içeriğine göre kurulmalı,
uygulamaya göre değil” kavramını bir adım daha
öne alır.
• Bu sayede veri modeli, üzerinde onu kullanan
uygulama değişse bile daha tutarlı, sabit ve
değişmez olarak kalacaktır.
• Uygulama programının gereksinimlerinin veri
tabanının mantıksal modeli üzerinde herhangi
bir etkisi olmamalıdır.
• Uygulama, mantıksal model üzerinde değil,
fiziksel model üzerinde etki yapar.
Normalleştirmenin Amaçları - 2
Uygulamadan bağımsızlık
• Saklama ihtiyaçlarını en aza indirgemek ve
arama süresini azaltmak.
• Yabancı anahtarların haricinde, tamamıyla
normalleştirilmiş bir veri tabanı gereksiz
(kopyalanmış) veri miktarını en aza indirecektir.
• Kopyalanma miktarı azaldığı için, saklama
yerine olan ihtiyaç ta azalır. Bu sayede, veri
tabanı motorunun arama süresi azalacaktır.
Normalleştirmenin Amaçları - 3
Performansı arttırmak
• R bir ilişki şeması, X ve Y nitelik kümeleri ise
R’nin alt kümeleri olsun (X  R, Y  R).
• Eğer X nitelik kümesinin değerleri Y nitelik
kümesinin değerlerini belirliyorsa (X’in her bir
değeri Y’nin bir değerine karşılık geliyorsa); “Y
niteliği X niteliğine işlevsel bağımlıdır” denir ve
“X  Y” şeklinde gösterilir.
• X’ten bir nitelik çıkarıldığı halde bu bağımlılık
hâlâ geçerli ise kısmi bağımlılık (partial
dependency) söz konusudur.
İşlevsel Bağımlılık
• DAĞITIM (müşteri_no, şehir_kodu, şehir_adı,
parti_no, miktar)
1. müşteri_no  şehir_kodu, şehir_adı
2. (müşteri_no, parti_no)  miktar
3. şehir_adı  şehir_kodu (geçişli bağımlılık)
• İlk ikisi anahtara göre bağımlı, üçüncüsü geçişli
bağımlı (transitive dependent).
• Bir müşteriye birden fazla parti ürün
gönderilebildiği için ikincisinde iki nitelik bir
anahtar oluşturuyor.
İşlevsel Bağımlılık
Normalleştirme Aşamaları
• Birinci Normal Form
• İkinci Normal Form
• Üçüncü Normal Form
• Boyce-Codd Normal Formu
• Dördüncü Normal Form
• …
Normal Olmayan Form
• İlişkisel veri tabanı modelinin temel
kuralına göre bütün niteliklerin aldığı
değerler atomik (tek ve basit) olmalıdır.
• Aşağıdaki DAĞITIM tablosu bu kurala
uymamaktadır, bu yüzden normal değildir.
müşteri_no şehir_kodu şehir_adı parti_no miktar
1 34 İstanbul 1,2,3,4,6 300,200,400,200,100
2 6 Ankara 1,2 300,400
3 6 Ankara 2 200
4 34 İstanbul 2,4,5 200,300,400
Birinci Normal Form
Uygulandığında:
müşteri_no şehir_kodu şehir_adı parti_no miktar
1 34 İstanbul 1 300
1 34 İstanbul 2 200
1 34 İstanbul 3 400
1 34 İstanbul 4 200
1 34 İstanbul 6 100
2 6 Ankara 1 300
2 6 Ankara 2 400
3 6 Ankara 2 200
4 34 İstanbul 2 200
4 34 İstanbul 4 300
4 34 İstanbul 5 400
• Birinci normal formdaki bir tablo bazı
alanlarda tekrarlı verilere sahiptir.
Örneğimizde şehir_kodu ve şehir_adı
alanlarında her müşteri için tekrarlı veriler
vardır.
• Bu tekrarlar ekleme, silme ve güncelleme
işlemlerinde sorunlara neden olacaktır.
Birinci Normal Formun Sorunları
• Başka bir müşterinin bilgilerinin (müşteri_no,
şehir_kodu, şehir_adı) girilmesi için mutlaka o
müşteriye bir dağıtım işleminin yapılması
(parti_no ve miktar değerlerinin girilmiş olması)
gerekiyor.
Satır Ekleme Sorunu
müşteri_no şehir_kodu şehir_adı parti_no miktar
1 34 İstanbul 1 300
… … … … …
4 34 İstanbul 5 400
5 35 İzmir
• Bir müşteriye tek bir dağıtım yapıldıysa (örn. 3
no’lu müşteri), o dağıtım işlemi iptal edildiğinde,
sadece parti_no ve miktarı değil, o dağıtımın
yapıldığı müşteri hakkındaki diğer bilgiler de
(müşteri_no, şehir_kodu, şehir_adı) yok olur.
Satır Silme Sorunu
müşteri_no şehir_kodu şehir_adı parti_no miktar
1 34 İstanbul 1 300
1 34 İstanbul 2 200
… … … … …
3 6 Ankara 2 200
… … … … …
• 1 numaralı müşteri Ankara’ya taşınırsa, bu
müşteri ile ilgili tüm satırların güncelleştirilmesi
gerekecektir. Eğer tablo çok büyük ise, sadece
bir müşteri ile ilgili küçük bir değişiklik bile
binlerce kaydın güncelleştirilmesini gerektirebilir.
Güncelleme Sorunu
müşteri_no şehir_kodu şehir_adı parti_no miktar
1 34 İstanbul 1 300
1 34 İstanbul 2 200
1 34 İstanbul 3 400
1 34 İstanbul 4 200
… … … … …
• Birinci normal formdaki sorunlardan (en azından
güncelleme sorunundan) kurtulmak için nitelikler
arasındaki işlevsel bağımlılıktan yararlanılarak
birinci normal form (1NF) tablolarının birden
fazla tabloya dönüştürülmesi sonucunda ikinci
normal forma (2NF) ulaşılır.
• İkinci normal formda, ilişkisel tablonun her bir
anahtar olmayan sütunu birincil anahtara kısmi
bağımlı değil, tam işlevsel bağımlı olmalıdır.
İkinci Normal Form
• şehir_kodu ve şehir_adı nitelikleri (müşteri_no,
parti_no) birleşik anahtarının sadece müşteri_no
niteliği üzerinde tam işlevsel bağımlıdır.
• O halde şehir_kodu ve şehir_adı nitelikleri
müşteri_no ile beraber ayrı bir tablo
oluşturmalıdır.
– DAĞITIM(müşteri_no, şehir_kodu, şehir_adı,
parti_no, miktar)
– ŞEHİRLER(müşteri_no, şehir_kodu, şehir_adı)
– MİKTARLAR(müşteri_no, parti_no, miktar)
İkinci Normal Form
İkinci Normal Form
Uygulandığında:
müşteri_no parti_no miktar
1 1 300
1 2 200
1 3 400
1 4 200
1 6 100
2 1 300
2 2 400
3 2 200
4 2 200
4 4 300
4 5 400
müşteri_no şehir_kodu şehir_adı
1 34 İstanbul
2 6 Ankara
3 6 Ankara
4 34 İstanbul
ŞEHİRLER
MİKTARLAR
• Birinci normal formdaki güncelleme
sorununu ikinci normal forma dönüştürme
ile ortadan kaldırmış olsak ta, ikinci normal
formda da ekleme ve silme sorunları
olabilmektedir.
İkinci Normal Formun Sorunları
• ŞEHİRLER tablosuna yeni bir müşteri kaydı
girilmediği sürece yeni bir şehir tanımı
yapılamaz. İzmir ilini tabloya dahil edebilmek için
İzmir’de bulunan bir müşteriye ihtiyaç vardır.
Satır Ekleme Sorunu
müşteri_no şehir_kodu şehir_adı
1 34 İstanbul
2 6 Ankara
3 6 Ankara
4 34 İstanbul
35 İzmir
• Tablodan bir müşteri silindiğinde, eğer o
şehirdeki tek müşteri ise, şehir_kodu ve
şehir_adı bilgileri de yok olacaktır.
Satır Silme Sorunu
müşteri_no şehir_kodu şehir_adı
1 34 İstanbul
2 6 Ankara
3 6 Ankara
4 34 İstanbul
5 35 İzmir
• Birinci normal formdaki sorunlardan kurtulmak
için nitelikler arasındaki kısmi işlevsel
bağımlılıkları ortadan kaldırmıştık.
• İkinci normal formdaki sorunlardan kurtulmak
için de nitelikler arasındaki geçişli işlevsel
bağımlılıkları ortadan kaldırmamız gerekir.
• Örneğimizde “şehir_adı  şehir_kodu” işlevsel
bağımlılığının geçişli olduğunu belirtmiştik (bak
slayt 7). Bir anahtara bağlı olmayan bu
bağımlılığı ayrı bir tabloya dönüştürerek üçüncü
normal formu (3NF) elde edebiliriz.
Üçüncü Normal Form
Üçüncü Normal Form
Uygulandığında:
müşteri_no parti_no miktar
1 1 300
1 2 200
1 3 400
1 4 200
1 6 100
2 1 300
2 2 400
3 2 200
4 2 200
4 4 300
4 5 400
şehir_kodu şehir_adı
6 Ankara
34 İstanbul
35 İzmir
ŞEHİRLER MİKTARLAR
müşteri_no şehir_kodu
1 34
2 6
3 6
4 34
5 35
MÜŞTERİLER
Boyce-Codd Normal Formu
ÖğrNo Bölüm Danışman
123 Fizik A. ERCAN
123 Kimya M. AKINCI
456 Biyoloji K. SÖNMEZ
789 Fizik A. ERCAN
999 Kimya B. ÖZKAN
• Her belirleyicinin bir anahtar oluşu halidir.
• Örnek olarak aşağıdaki ilişkiyi düşünelim:
ÖĞRENCİ(ÖğrNo, Bölüm, Danışman)
ÖĞRENCİ
Boyce-Codd Normal Formu
ÖğrNo Bölüm Danışman
123 Fizik A. ERCAN
123 Kimya M. AKINCI
456 Biyoloji K. SÖNMEZ
789 Fizik A. ERCAN
999 Kimya B. ÖZKAN
1NF ?
2NF ?
3NF ?
EVET (bütün niteliklerin aldığı değerler atomik)
EVET (kısmi bağımlılık yok)
EVET (geçişli bağımlılık yok)
Boyce-Codd Normal Formu
ÖğrNo Bölüm Danışman
123 Fizik A. ERCAN
123 Kimya M. AKINCI
456 Biyoloji K. SÖNMEZ
789 Fizik A. ERCAN
999 Kimya B. ÖZKAN
• Her üç normal formu da sağlıyor. Sorun var mı?
• EVET
1. 456 numaralı öğrenci silinirse Biyoloji ve K.SÖNMEZ yok olacak
2. Bir öğrenci Matematik bölümüne kayıt olana kadar bu bölüm var
olmayacak.
Çözüm: Belirleyicileri anahtar yap
• Birincil Anahtar:
– (ÖğrNo, Bölüm)
• Aday Anahtar:
– (ÖğrNo, Danışman)
• İşlevsel Bağımlılıklar:
– (ÖğrNo, Bölüm)  Danışman
– Danışman  Bölüm
ÖğrNo Bölüm Danışman
123 Fizik A. ERCAN
123 Kimya M. AKINCI
456 Biyoloji K. SÖNMEZ
789 Fizik A. ERCAN
999 Kimya B. ÖZKAN
Belirleyiciler
Boyce-Codd Normal Formu
(BCNF) Uygulandığında:
ÖĞRENCİ
ÖğrNo Bölüm Danışman
123 Fizik A. ERCAN
123 Kimya M. AKINCI
456 Biyoloji K. SÖNMEZ
789 Fizik A. ERCAN
999 Kimya B. ÖZKAN
ÖĞRENCİ_DANIŞMAN
ÖğrNo Danışman
123 A. ERCAN
123 M. AKINCI
456 K. SÖNMEZ
789 A. ERCAN
999 B. ÖZKAN
DANIŞMAN_BÖLÜM
Danışman Bölüm
A. ERCAN Fizik
M. AKINCI Kimya
K. SÖNMEZ Biyoloji
B. ÖZKAN Kimya
• NF: Normal olmayan form
• 1NF: Bütün alan değerleri atomik ise R 1NF’de
• 2NF: R 1NF’de ise ve anahtar olmayan tüm
nitelikler anahtara tam bağımlı ise R 2NF’de
• 3NF: R 2NF’de ise ve anahtar olmayan tüm
nitelikler anahtara geçişsiz bağımlı ise R 3NF’de
• BCNF: Her belirleyici bir aday anahtar ise R
BCNF’de
Belirleyici: Başka bir niteliğin tam işlevsel
bağımlı olduğu nitelik
Özet
• Bazı durumlarda BCNF’daki bir ilişkide de
sorunlar görülebilmektedir. Örneğin;
ÖĞRENCİ(ÖğrNo, Bölüm, Spor)
Dördüncü Normal Form
ÖĞRENCİ
ÖğrNo Bölüm Spor
123 Fizik Kayak
123 Kimya Kayak
123 Fizik Tenis
123 Kimya Tenis
999 Kimya Tenis
• Burada bir öğrenci birden çok bölüme kayıt olabilmekte
ve birden çok spor etkinliğine katılabilmektedir.
• Bu nedenle ÖğrNo ile Bölüm ve ÖğrNo ile Spor
arasındaki ilişkiler birer işlevsel bağımlılık değil çokdeğerli bağımlılık (multivalued dependency) halindedir.
Dördüncü Normal Form
ÖĞRENCİ
ÖğrNo Bölüm Spor
123 Fizik Kayak
123 Kimya Kayak
123 Fizik Tenis
123 Kimya Tenis
999 Kimya Tenis
ÖğrNo  Bölüm
ÖğrNo  Spor
çok-değerli bağımlılık
• 123 numaralı öğrencinin bir bölüme daha kayıt
olması yada bir spor etkinliğine daha katılması
halinde iki kayıt daha ilave edilmelidir.
• Bu gibi yineleme sorunlarını ortadan kaldırmak
için ÖĞRENCİ ilişkisi ikiye ayrılırak dördüncü
normal form (4NF) oluşturulur.
Dördüncü Normal Form
ÖĞRENCİ_BÖLÜM
ÖğrNo Bölüm
123 Fizik
123 Kimya
999 Biyoloji
ÖĞRENCİ_SPOR
ÖğrNo Spor
123 Kayak
123 Tenis
999 Yüzme
Örnek 1
Ö.NO Ö.AD Ö.SOYAD DERS_NO DERS_ADI VIZE FINAL H.NO H.AD H.SOYAD
2001001 Ahmet Solmaz 202 Matematik 2 70 60 11 Özlem UÇAR
2001001 Ahmet Solmaz 203 Fizik 2 80 40 11 Özlem UÇAR
2001001 Ahmet Solmaz 204 Bilgisayar Mühendisliğine
Giriş 2 60 45 3 Aydın CARUS
2001001 Ahmet Solmaz 205 Atatürk İlkeleri ve İnkılap
Tarihi 2 90 95 9 Zeki DURMUŞ
2001001 Ahmet Solmaz 206 Türk Dili 2 70 75 12 Nebahat YILDIZ
2001005 Seyhan Gülmez 202 Matematik 2 80 95 11 Özlem UÇAR
2001005 Seyhan Gülmez 203 Fizik 2 80 70 11 Özlem UÇAR
2001005 Seyhan Gülmez 204 Bilgisayar Mühendisliğine
Giriş 2 60 70 3 Aydın CARUS
2001002 Selim Solmaz 702 Veri Tabanı Yönetimi 60 50 6 Altan MESUT
2001003 Ahmet Vardar 702 Veri Tabanı Yönetimi 60 60 6 Altan MESUT
2001004 Sezai Kantar 702 Veri Tabanı Yönetimi 65 55 6 Altan MESUT
• Verilen şema 1. Normal Formda (atomik değerler)
– OKUL (Ö.No, Ö.Ad, Ö.Soyad, Ders_No, Ders_Adı, Vize, Final,
H.No, H.Ad, H.Soyad)
• 2. NF’ye geçerken kısmi bağımlılıklar ortadan kaldırılır
– NOTLAR(Ö.No, Ders_No, Vize, Final)
– ÖĞRENCİLER(Ö.No, Ö.Ad, Ö.Soyad)
– DERSLER(Ders_No, Ders_Adı, H.No, H.Ad, H.Soyad)
• 3. NF’ye geçerken geçişli bağımlılıklar ortadan kaldırılır
– NOTLAR(Ö.No, Ders_No, Vize, Final)
– ÖĞRENCİLER(Ö.No, Ö.Ad, Ö.Soyad)
– DERSLER(Ders_No, Ders_Adı, H.No)
– HOCALAR(H.No, H.Ad, H.Soyad)
Örnek 2
UrunNo UrunAd ParcaNo ParcaAd Miktar UreticiNo UreticiAd UreticiSehir UreticiTel
10026201 Pavilion
DV2620ET 1
Intel Core 2 Duo
T5450 1 100 HP Seattle 123456789
10026201 Pavilion
DV2620ET 2
Kingston 512MB
DDR2 2 100 HP Seattle 123456789
10026201 Pavilion
DV2620ET 3
Samsung 160GB
HDD 1 100 HP Seattle 123456789
10026201 Pavilion
DV2620ET 4
Nvidia GeForce
8400M 1 100 HP Seattle 123456789
10026501 Pavilion
DV2650ET 1
Intel Core 2 Duo
T7500 1 100 HP Seattle 123456789
10026501 Pavilion
DV2650ET 2
Kingston 1024MB
DDR2 2 100 HP Seattle 123456789
10026501 Pavilion
DV2650ET 3
Samsung 160GB
HDD 1 100 HP Seattle 123456789
10026501 Pavilion
DV2650ET 4
Nvidia GeForce
8400M 1 100 HP Seattle 123456789
10220012 Satellite A200-
1N2 1
Intel Core 2 Duo
T5250 1 102 Toshiba Tokyo 335678912
10220012 Satellite A200-
1N2 2
Samsung 1024MB
DDR2 2 102 Toshiba Tokyo 335678912
10220012 Satellite A200-
1N2 3
Maxtor 120GB
HDD 1 102 Toshiba Tokyo 335678912
10220012 Satellite A200-
1N2 4 Intel GMA X3100 1 102 Toshiba Tokyo 335678912
• Verilen şema 1. Normal Formda (atomik değerler)
– Urun_Parca (UrunNo, UrunAd, ParcaNo, ParcaAd, Miktar,
UreticiNo, UreticiAd, UreticiSehir, UreticiTel)
• 1NF → 2NF (kısmi bağımlılıklar giderilir)
– Urun_Parca (UrunNo, ParcaNo, ParcaAd, Miktar)
– Urunler (UrunNo, UrunAd, UreticiNo, UreticiAd, UreticiSehir,
UreticiTel)
• 2NF → 3NF (geçişli bağımlılıklar giderilir)
– Urun_Parca (UrunNo, ParcaNo, ParcaAd, Miktar)
– Urunler (UrunNo, UrunAd, UreticiNo)
– Ureticiler (UreticiNo, UreticiAd, UreticiSehir, UreticiTel)
Örnek 3
SiparisNo Tarih UrunAd UrunNo Adet MusNo MusAd MusSoyad
1 23.11.2007 Nokia 6300 57463 1 875 Ali Korkmaz
1 23.11.2007 Kingston 2 GB USB 73624 2 875 Ali Korkmaz
2 23.11.2007 Samsung D600 72352 1 932 Selin Atasoy
3 24.11.2007 Nokia 5070 71224 1 123 Kamil Sönmez
4 24.11.2007 Philips DVP 5160/12 90876 1 452 Metin Kaplan
5 25.11.2007 Samsung Digimax S850 98123 1 786 Kemal Durukan
6 25.11.2007 Sinbo SBS-4414 Baskül 35465 2 932 Selin Atasoy
7 25.11.2007 Canon Powershot A560 95293 1 875 Ali Korkmaz
7 25.11.2007 Kingston 2 GB SD 37285 1 875 Ali Korkmaz
8 26.11.2007 Nokia 6300 57463 1 321 Ece Çağlayan
• Verilen şema 1. Normal Formda (atomik değerler)
– SIPARIS (SiparisNo, Tarih, UrunAd, UrunNo, Adet, MusNo,
MusAd, MusSoyad)
• 1NF → 2NF (kısmi bağımlılıklar giderilir)
– SIPARIS_URUN (SiparisNo, UrunNo, Adet)
– SIPARIS_MUSTERI (SiparisNo, Tarih, MusNo, MusAd,
MusSoyad)
– URUN (UrunNo, UrunAd)
• 2NF → 3NF (geçişli bağımlılıklar giderilir)
– SIPARIS_URUN (SiparisNo, UrunNo, Adet)
– SIPARIS_ MUSTERI (SiparisNo, Tarih, MusNo)
– MUSTERILER (MusNo, MusAd, MusSoyad)
– URUN (UrunNo, UrunAd)
Vtys-Veri Tabanı Yönetim Sistemleri Dersi
Son
İşletim Sistemleri Dersi
Giriş
Operating System Concepts with Java – 8 1.1 Silberschatz, Galvin and Gagne ©2009 th Edition
İşletim Sistemlerine Genel Bakış
Operating System Concepts with Java – 8 1.2 Silberschatz, Galvin and Gagne ©2009 th Edition
Bölüm 1: Giriş
 İşletim Sistemleri Ne Yapar?
 Bilgisayar Sistemi Organizasyonu
 Bilgisayar Sistemi Mimarisi
 İşletim Sistemi Yapısı
 İşletim Sistemi İşleyişi
 İşlem Yönetimi
 Hafıza Yönetimi
 Depolama Birimi Yönetimi
 Koruma ve Güvenlik
 Dağıtık Sistemler
 Özel Amaçlı Sistemler
 Bilgisayar Ortamları
 Açık Kodlu İşletim Sistemleri
Operating System Concepts with Java – 8 1.3 Silberschatz, Galvin and Gagne ©2009 th Edition
Hedefler
 Temel işletim sistemi bileşenlerini gözden geçirmek
 Temel bilgisayar sistemi organizasyonunu gözden geçirmek
Operating System Concepts with Java – 8 1.4 Silberschatz, Galvin and Gagne ©2009 th Edition
İşletim Sistemi Nedir?
 Bilgisayar donanımı ile bilgisayar kullanıcısı arasında bir ara katman
olarak aracılık etmek
 İşletim sisteminin hedefleri:
 Kullanıcı programlarını çalıştırmak ve kullanıcı problemlerini
çözmeyi kolaylaştırmak
 Bilgisayar sisteminin kullanımını kolaylaştırmak
 Bilgisayar donanımını verimli bir şekilde kullanmak
Operating System Concepts with Java – 8 1.5 Silberschatz, Galvin and Gagne ©2009 th Edition
Bilgisayar Sistemi Yapısı
 Bilgisayar sistemi dört bileşene ayrılabilir:
 Donanım (hardware) – temel bilişim (computing) kaynaklarını
sağlar
 İşlemci (CPU), hafıza, I/O cihazları
 İşletim sistemi (operating system)
 Donanımın pek çok uygulama ve kullanıcı arasında
paylaşımlı kullanımını koordine eder
 Uygulama programları – kullanıcıların bilişim problemlerini
sistem kaynaklarını kullanarak çözmeye yardımcı olan
yazılımlardır
 Kelime işlemciler, derleyiciler (compilers), web tarayıcıları,
veritabanı sistemleri, oyunlar
 Kullanıcılar
 İnsanlar, makinalar, diğer bilgisayarlar
Operating System Concepts with Java – 8 1.6 Silberschatz, Galvin and Gagne ©2009 th Edition
Bilgisayar Sisteminin Dört Bileşeni
Operating System Concepts with Java – 8 1.7 Silberschatz, Galvin and Gagne ©2009 th Edition
İşletim Sistemi Tanımı
 İşletim sistemi kaynak dağıtıcıdır (resource allocator)
 Tüm kaynakları yönetir
 Birbirine aykırı istekler arasında verimli ve adil kullanımı gözeterek
karar verir
 İşletim sistemi bir kontrol programıdır (conrol program)
 Programların çalışmasını hatalara ve uygun olmayan kullanımlara
engel olmak için kontrol eder
Operating System Concepts with Java – 8 1.8 Silberschatz, Galvin and Gagne ©2009 th Edition
İşletim Sistemi Tanımı (Devamı)
 Evrensel kabul gören bir tanım yok
 “İşletim sistemi üreticisinin bir işletim sistemine dahil ettiği
herşeydir” doğruya yakın bir cevap 
 Fakat büyük oranda değişmekte
 Çekirdek (kernel): Bilgisayarda her zaman çalışan tek
programdır
 Diğer her şey ya sistem programıdır (işletim sistemi ile
birlikte gelir) ya da uygulama programıdır
Operating System Concepts with Java – 8 1.9 Silberschatz, Galvin and Gagne ©2009 th Edition
Bilgisayarın Başlatılması
 Bilgisayar yeniden başlatıldığında ya da açıldığında önyükleyici
program (bootstrap program) çalıştırılır
 Tipik olarak ROM veya EPROM’da tutulur ve genellikle aygıt
yazılımı (firmware) olarak adlandırlır
 Sistemi tüm yönleri ile başlatır
 İşletim sistemi çekirdeğini yükler ve çalıştırır
Operating System Concepts with Java – 8 1.10 Silberschatz, Galvin and Gagne ©2009 th Edition
Bilgisayar Sistemi Organizasyonu
 Bilgisayar sistemi işleyişi:
 Bir veya daha fazla işlemci ve cihaz denetleyici (device controller)
ortak bir veri yolu üzerinden paylaşılan hafızaya bağlanır
 Aynı anda çalışan işlemciler ve cihazlar hafızaya erişmek için
birbirleriyle yarışırlar
Operating System Concepts with Java – 8 1.11 Silberschatz, Galvin and Gagne ©2009 th Edition
Bilgisayar Sistemi İşleyişi
 I/O cihazları ve CPU aynı anda çalışabilir
 Her bir cihaz denetleyicisi belli bir tip cihazın kontrolünden sorumludur
 Tüm cihaz denetleyicilerinin bir yerel tampon belleği (local buffer)
vardır
 CPU ana hafıza ile yerel tampon bellekler arasında çift yönlü veri taşır
 I/O işlemi, cihazdan, denetleyicinin yerel tampon belleğine doğrudur
 Cihaz denetleyicisi, işeminin bittiğini, işlemciye kesinti (interrupt)
göndererek bildirir
Operating System Concepts with Java – 8 1.12 Silberschatz, Galvin and Gagne ©2009 th Edition
Kesintilerin Genel Özellikleri
 Kesintiler kontrolü, o kesintiye ait kesinti servis rutinine (interrupt
service routine) yönlendirir
 Servis rutinleri, kesinti sonucu yapılması gereken işi gerçekleştiren
yazılım parçacıklarıdır
 Hangi servis rutininin hangi hafıza adresinde bulunduğu kesinti
vektöründe (interrupt vector) bulunmaktadır
 Bilgisayar, kesinti sonunda yarıda kesilen işleme geri dönebilmek için,
kesilen işlemin işletilen son komutunun adresini saklamalıdır
 Kayıp kesintilere engel olmak için kesinti işletildiği sürece yeni kesinti
gönderimine izin verilmez
 Tuzak (trap) yazılım tarafından oluşturulan kesintilerdir
 Tuzaklara yazılım hataları ya da kullanıcı istekleri neden olur
 İşletim sistemleri kesintilerle yönlendirilirler (interrupt driven)
Operating System Concepts with Java – 8 1.13 Silberschatz, Galvin and Gagne ©2009 th Edition
Kesintilerin İşletilmesi
 İşletim sistemi CPU’nun durumunu kaydeder: yazmaçlar (registers)
ve program sayacı (program counter)
 Hangi tür kesintinin gerçekleştiğini belirler:
 sorgulama (polling) – hangi cihazdan gerçekleştiği bulunmalıdır
 vektör kesinti sistemi (vectored interrupt system) – cihazı
belirten kod, kesinti ile birlikte gönderilir
 Her bir kesinti için hangi işlemin gerçekleştirileceğini ayrı bir kod
parçası belirler
Operating System Concepts with Java – 8 1.14 Silberschatz, Galvin and Gagne ©2009 th Edition
Kesinti Zaman Çizelgesi
Operating System Concepts with Java – 8 1.15 Silberschatz, Galvin and Gagne ©2009 th Edition
Direk Hafıza ErişimYapısı
 Direk Hafıza Erişimi – Direct Memory Access (DMA)
 Hafıza hızına yakın bilgi aktarması yapabilen yüksek hızlı I/O cihazları
için kullanılır
 Cihaz denetleyicisinin, CPU’nun çalışmasını bölmeden, veri bloklarını
cihazın tampon belleğinden direk olarak hafızaya aktarmasıdır
 Her byte için kesinti göndermek yerine, her bir blok için bir kesinti
gönderilir
Operating System Concepts with Java – 8 1.16 Silberschatz, Galvin and Gagne ©2009 th Edition
Depolama Birimi Yapısı
 Ana hafıza (main memory) – CPU’nun direk erişebileceği tek geniş
depolama birimidir
 İkincil depolama birimi (secondary storage) – kalıcı bir şekilde
bilgilerin depolandığı, ana hafızanın uzantısı olan depolama birimidir
 Manyetik diskler (magnetic disks) – manyetik kayıt meteryaliyle
kaplı sert metal veya cam tabakalar
 Disk yüzeyi genellikle mantıksal olarak izlere (tracks) bölünür
 Her bir iz sektörlere (sectors) bölünür
 Disk denetleyicisi (disk controller) bilgisayar ile cihaz
arasındaki mantıksal etkileşimi sağlar
Operating System Concepts with Java – 8 1.17 Silberschatz, Galvin and Gagne ©2009 th Edition
Depolama Birimi Hiyerarşisi
 Depolama birimlere hiyerarşik bir şekilde organize edilirler
 Hız (Speed)
 Maliyet (Cost)
 Gelgeçlik (volatility)
 Ön belleğe alma (caching) – bilgiyi daha hızlı olan depolama birimine
geçici olarak alma işlemidir
 Ana bellek ikincil depolama birimi için en son ön bellek (cache)
birimidir
Operating System Concepts with Java – 8 1.18 Silberschatz, Galvin and Gagne ©2009 th Edition
Depolama Cihazı Hiyerarşisi
Operating System Concepts with Java – 8 1.19 Silberschatz, Galvin and Gagne ©2009 th Edition
Ön Belleğe Alma
 Bir bilgisayarda pek çok seviyede (donanım, işletim sistemi, yazılım)
gerçekleştirilen önemli bir prensip
 Kullanılan bilgi yavaş depolama biriminden hızlı depolama birimine
kopyalanır
 Aranan bilgi öncelikle daha hızlı depolama biriminde mi (ön bellek)
kontrol edilir
 Eğer oradaysa, bilgi direk ön bellekten alnır (hızlı)
 Eğer değilse, ön belleğe alınır ve oradan kullanılır
 Ön bellek, ön belleğe alınacak bilgiden daha küçüktür
 Ön bellek yönetimi önemli bir tasarım problemidir
 Ön bellek boyutu ve yenileme politikası (replacement policy)
Operating System Concepts with Java – 8 1.20 Silberschatz, Galvin and Gagne ©2009 th Edition
Tekli veya Çoklu İşlemciler
 Pek çok sistem tek bir genel amaçlı işlemci kullanır (örn: gömülü
sistemler).
 Aynı zamanda, pek çok sistem de özel amaçlı işlemciler kullanır
 Çokişlemcili sistemler (multiprocessors systems) giderek
yaygınlaşmakta ve önem kazanmaktadır
 Paralel sistemler (parallel systems) ve sıkıca bağlantılı
sistemler (tightly-coupled systems) olarak da bilinirler
 Avantajlar
1. Artan üretilen iş (throughput)
2. Ekonomik olarak katlanma (economy of scale)
3. Artan güvenilirlik (reliability) – graceful degradation veya
fault tolerance
Operating System Concepts with Java – 8 1.21 Silberschatz, Galvin and Gagne ©2009 th Edition
Çoklu İşlemciler
 İki farklı tür
1. Asimetrik Çoklu İşlemciler (Asymmetric Multiprocessing)
2. Simetrik Çoklu İşlemciler (Symmetric Multiprocessing)
 Asimetrik çoklu işlemciler – Görev dağıtan bir işlemci var,
diğerleri görev bekliyor (master-slave)
 Asimetrik çoklu işlemciler özellikle ilk zamanlarda kullanılıyor
 Simetrik Çoklu İşlemciler (SMP) – tüm işlemciler her tür işi
yapıyor
Operating System Concepts with Java – 8 1.22 Silberschatz, Galvin and Gagne ©2009 th Edition
Modern Bilgisayarlar Nasıl Çalışır?
Operating System Concepts with Java – 8 1.23 Silberschatz, Galvin and Gagne ©2009 th Edition
Simetrik Çoklu İşlemci Mimarisi
Operating System Concepts with Java – 8 1.24 Silberschatz, Galvin and Gagne ©2009 th Edition
Çok Çekirdekli Tasarımlar
Avantajlar/Dezavantajlar?
Operating System Concepts with Java – 8 1.25 Silberschatz, Galvin and Gagne ©2009 th Edition
Küme Bilgisayarlar
 Küme Bilgisayarlar (clustered computers)
 Çoklu işlemcili sistemler gibi, fakat birden fazla sistem birlikte
çalışıyor
 Genellikle depolama birimi, storage-area network (SAN) ile
paylaşılıyor
 Arızalara dayanıklı yüksek bulunurluk (high-availability)
sağlayan bir servis
 Asimetrik kümeleme (asymmetric clustering) – bir tane
gözlem makinası, diğerleri çalışıyor
 Simetrik kümeleme (symmetric clustering) – birden fazla
uygulama çalıştıran ve aynı zamanda birbirini gözlemleyen
makinaya (node) sahip
Operating System Concepts with Java – 8 1.26 Silberschatz, Galvin and Gagne ©2009 th Edition
Yüksek Performanslı Hesaplama
 Bazı kümeler yüksek performanslı hesaplama high-performance
computing (HPC) sağlıyor
 Uygulamalar paralelleştirmeyi (parallelization) kullanacak şekilde
yazılmalı
Operating System Concepts with Java – 8 1.27 Silberschatz, Galvin and Gagne ©2009 th Edition
Çoklu Program Desteği
 Çoklu program desteği (multiprogramming) verimlilik için gerekli
 Tek kullanıcı, CPU and I/O cihazlarını her zaman meşgul
edemez
 Çoklu program desteği, işleri (kod ve veri) CPU’nun her zaman
çalıştıracağı bir iş olacak şekilde organize eder
 Sistemdeki tüm işlerin belli bir kısmı hafızada tutulur
 İş zamanlaması (job scheduling) ile bir iş seçilir ve çalıştırılır
 Çalışan iş beklemek zorunda kaldığında (örneğin I/O işlemi için)
işletim sistemi başka bir işe geçer
Operating System Concepts with Java – 8 1.28 Silberschatz, Galvin and Gagne ©2009 th Edition
Zaman Paylaşımı
 Zaman Paylaşımı (timesharing veya multitasking), CPU’nun,
işleri çalıştırırken, işler arasında çok hızlı geçiş sağlayarak
kullanıcıya bilgisayarı interaktif (interactive) şekilde kullanıyormuş
hissi vermesidir
 Cevap süresi (response time) 1 saniyeden az olmalıdır
 Her bir kullanıcı hafızada çalışan en az bir programa sahiptir
 Eğer aynı anda birden fazla iş çalışmak için hazırsa  İşlemci
zamanlaması (CPU scheduling)
 Eğer işlemler hafızaya sığmıyorsa, değiş-tokuş işlemi
(swapping) işlemleri, çalıştırmak gerektiğinde hafızaya alır ya
da gerektiğinde hafızadan çıkarır
 Sanal hafıza (virtual memory) tümüyle hafızada bulunmayan
işlemleri çalıştırmayı sağlar
Operating System Concepts with Java – 8 1.29 Silberschatz, Galvin and Gagne ©2009 th Edition
Çok Programlı Sistemlerde Hafıza Dizilimi
Operating System Concepts with Java – 8 1.30 Silberschatz, Galvin and Gagne ©2009 th Edition
İşleme Sorunları
 Donanım tarafından kesinti gönderilebilir
 Yazılım hataları veya istekleri tuzağa (exception veya trap) neden
olabilir
 Sıfıra bölünme, işletim sistmeleri servislerini çalıştırmaya kalkma
 Diğer işleme sorunları:
 Sonsuz döngü
 İşlemlerin birbirini değiştirmeye çalışması
 İşlemlerin işletim sistemini değiştirmeye çalışması
Operating System Concepts with Java – 8 1.31 Silberschatz, Galvin and Gagne ©2009 th Edition
Çift-Modlu İşleme
 Çift-modlu işleme (dual-mode operation), işletim sistemini ve diğer
sistem bileşenleri korumayı sağlar
 Kullanıcı modu (user mode) ve çekirdek modu (kernel mode)
 Donanım tarafından sağlanan mod biti (mode bit)
 Sistemin kullanıcı kodu mu yoksa çekirdek kodu mu
çalıştırdığını ayırt etmekte kullanılır
 Bazı komutlar ayrıcalıklı (privileged) olarak tanımlıdırlar ve
sadece çekirdek modunda çalıştırılabilirler
 Sistem çağrıları modu, çekirdek moduna çevirir.
 Sistem çağrısı bittiğinde mod, kullanıcı moduna çevrilir
Operating System Concepts with Java – 8 1.32 Silberschatz, Galvin and Gagne ©2009 th Edition
Kullanıcı Moddan Çekirdek Moduna Geçiş
 Zamanlayıcı (timer) sonsuz döngülere ve işlemci kilitlenmelerine
engel olur
 Belli bir zaman diliminden sonra kesme gönderilir
 İşletim sistemi sayacı azaltır
 Sayaç sıfırlandığında kesme oluşturulur
 Zamanlayıcı program devreye girmeden sorun çıkaran işlem devre
dışı bırakılır veya sonlandırılır
Operating System Concepts with Java – 8 1.33 Silberschatz, Galvin and Gagne ©2009 th Edition
İşlem Yönetimi
 İşlem (process) çalışmakta olan programdır
 Program pasif bir şeyken, işlem aktif bir şeydir
 İşlemler görevlerini yerine getirmek için kaynaklara ihtiyaç duyarlar
 CPU, hafıza, I/O, dosyalar
 Başlangıç verisi
 İşlemin sonlandırılması kullanılan kaynakların sisteme iade edilmesini
gerektirir
Operating System Concepts with Java – 8 1.34 Silberschatz, Galvin and Gagne ©2009 th Edition
İş Parçacığı Yönetimi
 İş parçacığı (thread) bir program çalışırıken aynı anda yapılması
gereken başka işler varsa bunları çalıştırmak için kullanılır
 Tek iş parçacıklı (single-threaded) işlemler, çalıştırılacak bir sonraki
komutun hafızadaki konumunu belirten tek bir program sayacına
(program counter) sahiptir
 İşlem sonlanana kadar, komutları tek tek sırayla çalıştırır
 Çok iş parçacıklı (multi-threaded) işlemler her bir iş parçacağı için
ayrı bir program sayacına sahiptir
 Tipik olarak sistemlerde, pek çok işlem, birkaç kullanıcı ve pek çok
işletim sistemi işlemi aynı anda bir veya birden fazla işlemcide
çalıştırılır
 Aynı anda kullanım (concurrency) işlemcilerin birden fazla işlem
veya iş parçacığı arasında ortak kullanımını gerektirir
Operating System Concepts with Java – 8 1.35 Silberschatz, Galvin and Gagne ©2009 th Edition
İşlem Yönetim Faaliyetleri
İşletim sisteminin, işlem yönetimi ile ilişkili faaliyetleri:
 Kullanıcı ve sistem işlemlerinin oluşturulması ve bitirilmesi
 İşlemlerin duraklatılması ve devam ettirilmesi
 İşlemlerin senkronizasyonu için mekanizmalar sağlaması
 İşlemlerin birbiri ile iletişim kurabilmesi için mekanizmalar sağlaması
 Kilitlenmelerin (deadlock) sağlıklı yönetilmesi için mekanizmalar
sağlaması
Operating System Concepts with Java – 8 1.36 Silberschatz, Galvin and Gagne ©2009 th Edition
Hafıza Yönetimi
 Tüm veriler işlem öncesi ve sonrası hafızadadır
 Komutların çalıştırılabilmesi için hafızada olması gerekir
 Hafıza yönetimi
 Neyin hafızada olması gerektiğine karar verir
 Hedefi, işlemci kullanımını ve kullanıcılara verilen yanıtları optimize
etmektir
Operating System Concepts with Java – 8 1.37 Silberschatz, Galvin and Gagne ©2009 th Edition
Hafıza Yönetimi Faaliyetleri
 Hafızanın hangi bölümlerinin kim tarafından kullanıldığını takip etmek
 Hangi işlemlerin ve verilerin hafızaya alınacağına ya da hafızadan
çıkarılacağına karar vermek
 Gerektiğinde yeni hafıza alanı ayırmak ya da kullanılmış alanları iade
etmek
Operating System Concepts with Java – 8 1.38 Silberschatz, Galvin and Gagne ©2009 th Edition
Depolama Birimi Yönetimi
 İşletim sistemi, depolama birimleri için tek ve mantıksal arayüz sunar
 Fiziksel özellikleri mantıksal depolama birimine soyutlar: dosya
(file)
 Tüm birimler cihaz tarafından kontrol edilir (i.e., disk, DVD)
 Değişken özellikler: erişim hızı, kapasite, veri transfer hızı,
erişim yöntemi (sırayla veya direk)
 Dosya sistemi yönetimi
Operating System Concepts with Java – 8 1.39 Silberschatz, Galvin and Gagne ©2009 th Edition
Dosya Sistemi Yönetimi
 Dosyalar dizinler kullanılarak organize edilir
 Pek çok sistemde dizinlere veya dosyalara erişim kontrol edilmelidir:
erişim kontrolu (access control)
 Dosya sistemi ile ilişkili işletim sistemi aktiviteleri
 Dosya ve dizinlerin oluşturulması veya silinmesi
 Dosyaların veya dizinlerin değiştirilmesi için mekanizmanın
sağlanması
 Dosyaların ikincil depolama birimi ile eşleştirilmesi
 Dosyaların kalıcı depolama birimlerine yedeklenmesi
Operating System Concepts with Java – 8 1.40 Silberschatz, Galvin and Gagne ©2009 th Edition
Mass-Storage Management
 Genellikle diskler, hafızaya sığmayan verileri ya da uzun süre tutulacak
verileri tutmakta kullanılır
 Verilerin tutarlı yönetimi çok önemlidir
 Bilgisayarın genel hızı disk altsistemi ve algoritmalarının
performansına çok bağlıdır
 İlgili işletim sistemi faaliyetleri:
 Boş alan yönetimi
 Depolama alanı ayrımı
 Disk zamanlaması
 Bazı depolama birimlerinin hızlı olması gerekmez
 CD, DVD, Manyetik teypler
 Gene de yönetilmelidir
 WORM (write-once, read-many-times) ve RW (read-write) erişim
modlarında çalışabilirler
Operating System Concepts with Java – 8 1.41 Silberschatz, Galvin and Gagne ©2009 th Edition
Depolama Birimi Performansları
 Depolama birimi seviyeleri arasında bilgi aktarımı, kullanıcının
isteğine bağlı ya da kullanıcı isteğinden bağımsız gerçekleşebilir
Operating System Concepts with Java – 8 1.42 Silberschatz, Galvin and Gagne ©2009 th Edition
A Tamsayısının Diskten Yazmaça Aktarımı
 Çok işlemli ortamlar, en güncel değeri kullanmak konusunda dikkatli
olmalıdır (depolama hiyerarşisinin neresinde tutuluyorsa tutulsun)
 Çok işlemcili sistemlerde ön bellek tutarlılığı donanım seviyesinde
sağlanmalı ve tüm işlemciler en güncel değere sahip olmalıdır
 Dağıtık ortamlarda durum daha da karmaşıktır
 Verinin birden fazla kopyası bulunabilir
Operating System Concepts with Java – 8 1.43 Silberschatz, Galvin and Gagne ©2009 th Edition
I/O Alt Sistemi
 İşletim sisteminin amaçlarından biri donanım cihazlarının
karmaşıklıklarını kullanıcıdan gizlemektir
 I/O alt sisteminin sorumlulukları:
 I/O işlemlerinin hafıza yönetimini yapmak
 Tampon bellek işlemleri (buffering) – veriyi bir yerdne diğer
yere aktarırken geçci olarak saklamak
 Ön bellek işlemleri (caching) – veriyi geçici olarak daha hızlı
depolama birimine aktarmak
 Kuyruklama (spooling) – bir işin çıktısını diğer işin girdisi
haline getirmek
 Genel cihaz sürücüsü arayüzü
 Özel donanım cihazları için sürücüler
Operating System Concepts with Java – 8 1.44 Silberschatz, Galvin and Gagne ©2009 th Edition
Koruma ve Güvenlik
 Koruma (protection) – İşlemlerin veya kullanıcıların herhangi bir
kaynağa erişiminin işletim sistemi tarafından kontrol edilmesi
 Güvenlik (security) – sistemin içerden ve dışardan gelen
saldırılara karşı savunulması
 Geniş kapsamlı: DoS saldırıları, virusler, solucanlar, kimlik
bilgileri hırsızlığı
 Sistemler öncelikle kullanıcıları, kimin ne yapabileceğine göre
sınıflandırırlar
 Kullanıcı adı (user IDs, security IDs) her kullanıcı için isim ve
ilişkili numarayı içerir
 Kullanıcı adı daha sonra, erişim kontrolü amacıyla, kullanıcının
sahip olduğu tüm dosya ve işlemlerle ilişkilendirirlir
 Grup adı (group ID) da benzer şekilde bir grup kullanıcıyı belli
işlem ve dosyalarla ilişkilendirmek ve erişim kontrolü sağlamak
amacıyla kullanılır
Operating System Concepts with Java – 8 1.45 Silberschatz, Galvin and Gagne ©2009 th Edition
Bilgisayar Ortamları
 Geleneksel bilgisayarlar
 Sınırlar zamanla değişiyor
 Ofis Ortamı
 Terminaller ana bilgisayarlara bağlı ve ana bilgisayar
kaynakları kullanıcılar arasında paylaştırılıyor
 Kişisel bilgisayarlar bir ağa bağlı,
 Şimdi, portallar ile aynı kaynaklara yerel ağ üzerinden veya
uzaktan erişim mümkün
 Ev Ortamı
 Önceden bağımsız bilgisayarlar
 Daha sonra modemlerle Internet’e bağlılar
 Şimdi, birbirlerine bağlı ve güvenlik duvarına (firewall) sahip
Operating System Concepts with Java – 8 1.46 Silberschatz, Galvin and Gagne ©2009 th Edition
İstemci-Sunucu Sistemleri
 Zamanla akıllı kişisel bilgisayarlar, akılsız terminallerin yerini aldı
 Şu an pek çok sistem sunucu (server) olarak kullanılıyor, ve
istemcilerin (clients) isteklerine cevap veriyor
 İşlem-sunucuları (compute-server) istemcilere çeşitli
servisler sağlayan bir arayüz sunar (örn. veritabanı)
 Dosya sunucuları (file-server) istemcilere dosyaları
kaydetmeyi ve indirmeyi sağlayan bir arayüz sunar
Operating System Concepts with Java – 8 1.47 Silberschatz, Galvin and Gagne ©2009 th Edition
Uçtan-Uca Sistemler
 Uçtan-uca sistemler (Peer-to-Peer Systems, P2P)
 Dağıtık sistemlerin bir başka örneği
 P2P istemci ve sunucu arasında ayrım yapmaz
 Her bir sistem bir uç olarak ele alınır
 Her bir uç istemci, sunucu veya iki şekilde birden davranabilir
 Uçlar öncelikle bir P2P ağına bağlanmalıdır
 Kendini bu ağdaki merkezi kayıt sistemine kaydetmelidir,
veya
 Keşif prokolü (discovery protocol ) ile istekte bulunmalı
veya daha önce bulunulan istekleri karşılamalıdır
 Örnek: Napster ve Gnutella
Operating System Concepts with Java – 8 1.48 Silberschatz, Galvin and Gagne ©2009 th Edition
Web-tabanlı Sistemler
 Artık PC’ler sunucu olarak kullanılabiliyor
 Giderek daha çok cihaz Web’e bağlanıyor
 Web trafiğini yönetmek için yeni tür sunucular ortaya çıkıyor. Örnek:
yük dengeleyiciler (load balancers)
 Yeni işletim sistemleri (örn: Linux, Windows 7) artık sunuculara ait
özellikleri de barındırıyor ve hem istemci hem de sunucu olabiliyor
Operating System Concepts with Java – 8 1.49 Silberschatz, Galvin and Gagne ©2009 th Edition
Açık Kodlu İşletim Sistemleri
 Bu işletim sistemleri, kapalı makine formatı (closed-source)
yerine kaynak kod (source-code) formatında sunuluyor
 Free Software Foundation (FSF) ile başladı - “copyleft” GNU
Public License (GPL)
 Örnekler: GNU/Linux, BSD UNIX (Mac OS X işletim sistemi
temeli), ve Sun Solaris
Operating System Concepts with Java – 8 2.1 Silberschatz, Galvin and Gagne ©2009 th Edition
Bölüm 2
İşletim Sistemi Yapıları
Operating System Concepts with Java – 8 2.2 Silberschatz, Galvin and Gagne ©2009 th Edition
Bölüm 2: İşletim Sistemi Yapıları
 İşletim Sistemi Servisleri
 Kullanıcı İşletim Sistemi Arayüzü
 Sistem Çağrıları
 Sistem Çağrısı Tipleri
 Sistem Programları
 İşletim Sistemi Tasarım ve Gerçekleştirimi
 İşletim Sistemi Yapısı
 Sanal Makinalar
 İşletim Sistemi Oluşturma
 Sistem Önyükleme
Operating System Concepts with Java – 8 2.3 Silberschatz, Galvin and Gagne ©2009 th Edition
Hedefler
 İşletim sisteminin, kullanıcılara, işlemlere ve diğer sistemlere sağladığı
servisleri açıklamak
 Bir işletim sistemini yapılandırmanın farklı şekillerini açıklamak
 İşletim sistemlerinin nasıl kurulduğunu, özelleştirildiğini ve
önyüklendiğini açıklamak
Operating System Concepts with Java – 8 2.4 Silberschatz, Galvin and Gagne ©2009 th Edition
İşletim Sistemi Kullanıcı Servisleri
 İşletim sistemi servislerinin bir grubu kullanıcıya doğrudan faydalı olan
fonksiyonlar sunar:
 Kullanıcı arayüzü – Neredeyse tüm işletim sistemleri bir kullanıcı
arayüzüne (UI) sahiptir
 Değişiklik gösterir: Komut satırı (CLI), Grafiksel Kullanıcı
Arayüzü (GUI)
 Program çalıştırma – Sistem, bir programı hafızaya yükleyebilmeli,
çalıştırabilmeli ve normal veya anormal (hata durumunda) bir
şekilde sonlandırabilmeli
 I/O işlemleri - Çalışan bir program I/O işlemi gerektirebilir – bir
dosyaya ya da I/O cihazını kullanmayı gerektirebilir
Operating System Concepts with Java – 8 2.5 Silberschatz, Galvin and Gagne ©2009 th Edition
Kullanıcı Servisleri – Dosya Sistemi
 Dosya sistemi değişiklikleri – Programlar aracılığıyla
 dosyalar okunabilir,
 dosyalara yazabilir,
 dosyalar/dizinler oluşturulabilir,
 dosyalar/dizinler aranabilir,
 dosyalar/dizinler silinebilir,
 dosyalar/dizinler listelenebilir,
 dosya veya dizinlerin erişim izinleri (permission) değiştirilebilir.
Operating System Concepts with Java – 8 2.6 Silberschatz, Galvin and Gagne ©2009 th Edition
Kullanıcı Servisleri – İletişim ve Hata
 İletişim – İşlemler bilgi alış verişinde bulunabilirler – aynı bilgisayar
üzerinde veya ağ üzerinde bulunan farklı bilgisayarlar üzerinde
 İletişim ortak hafıza (shared memory) ile veya mesaj
gönderimi (message passing) ile sağlanabilir.
 Paketler işletim sistemi tarafından taşınır
 Hata tespiti – İşletim sistemi sürekli olarak olası hataları takip eder
 Hatalar CPU, hafıza donanımı, I/O cihazları veya kullanıcı
programı kaynaklı olabilir
 Her bir hata tipi için, işletim sistemi uygun olan işlemi
gerçekleştirerek bilgisayarın doğru ve tutarlı şekilde
çalışmasına devam etmesini sağlamalıdır
 Hata ayıklamak için sunulan mekanizmalar, sistemin verimli
şekilde kullanımı için kullanıcıya ve programcıya sağlanmalıdır
Operating System Concepts with Java – 8 2.7 Silberschatz, Galvin and Gagne ©2009 th Edition
 İşletim sistemi servislerinin bir diğer grubu kaynakların paylaşımını sağlayarak
bilgisayarın etkili bir şekilde kullanımını sağlar
 Kaynak paylaştırma – Birden fazla kullanıcı ya da birden fazla iş aynı
anda çalıştırıldığında kaynaklar her birine adil şekilde paylaştırılmalıdır
 Perk çok farklı tipte kaynak
– Bazıları özel pay alma kodları kullanır: CPU zamanı, ana hafıza,
dosya kayıt birimi
– Bazıları ise isteme ve iade etme kodları kullanır: I/O cihazları
 Hesap tutma – Hangi kullanıcının hangi tip sistem kaynağının ne
kadarını kullandığını takip etmek
 Koruma ve güvenlik – Çok kullanıcılı bir sistemde bir bilginin sahibi
bu bilginin kim tarafından kullanılabileceğini kontrol etmek ister, aynı
anda çalışan işlemlerin birbirine müdahelesi engellenmelidir
 Koruma - sistem kaynaklarına her tür erişimin kontrol atlında
tutulmasını gerektirir
 Güvenlik - sisteme dışarıdan erişmek isteyenlerin kimlik
doğrulamasını yapmaktan I/O cihazlarının geçersiz erişim
isteklerine engel olunmasına kadar çeşitlilik gösterir
 Bir zincir en fazla en zayıf halkası kadar güçlüdür!
Kaynak Paylaşım Servisleri
Operating System Concepts with Java – 8 2.8 Silberschatz, Galvin and Gagne ©2009 th Edition
İşletim Sistemi Servislerine Genel Bakış
Operating System Concepts with Java – 8 2.9 Silberschatz, Galvin and Gagne ©2009 th Edition
 Komut Satırı Arayüzü - Command Line Interface (CLI)
 Veya komut yorumlayıcısı (command interpreter) direk komut
girişini sağlar
 Bazen çekirdeğin parçası olarak gerçekleştirilir, bazen sistem
programı olarak.
 Bazen farklı özellikleri barındıran farklı versiyonları bulunur –
kabuklar (shells)
 Temel olarak, kullanıcıdan bir komut alır ve bunu çalıştırır
 Bazen komutlar kabuğun bir parçasıdır, bazen programların
adıdır
 Eğer ikincisi ise, yeni komutların eklenmesi kabuğun
güncellenmesini gerektirmez
İşletim Sistemi İşlem Arayüzü- CLI
Operating System Concepts with Java – 8 2.10 Silberschatz, Galvin and Gagne ©2009 th Edition
Kullanıcı İşletim Sistemi Arayüzü - GUI
 Kullanıcı dostu masaüstü (desktop) benzetmesi kullanan arayüz
 Genellikle fare, klavye ve bilgisayar ekranı kullanılır
 Simgeler (icons) dosyaları, programları, eylemleri vs. ifade eder
 Nesneler üzerinde fare tıklamaları pek çok eylemi tetikler: bilgi
sağlama, fonksiyon çalıştırma, dizin açma vs.
 İlk olarak Xerox PARC ile kullanılmıştır
 Pek çok sistem CLI ve GUI arayüzlerini birlikte sunar
 Microsoft Windows grafiksel arayüze ek olarak CLI komut kabuğu
sunar
 Apple Mac OS X “Aqua” GUI arayüzüne ek olarak alt katmanlarda
UNIX çekirdeği ve kabuklarını bulundurur
 Solaris CLI arayüzüne ek olarak opsiyonel olarak GUI arayüzleri
kullanabilir (Java Desktop, KDE)
Operating System Concepts with Java – 8 2.11 Silberschatz, Galvin and Gagne ©2009 th Edition
Bourne Kabuğu – Komut Yorumlayıcısı
Operating System Concepts with Java – 8 2.12 Silberschatz, Galvin and Gagne ©2009 th Edition
The Mac OS X GUI
Operating System Concepts with Java – 8 2.13 Silberschatz, Galvin and Gagne ©2009 th Edition
System Çağrıları
 İşletim sistemi tarafından sunulan servisler için programlama
arayüzüdür
 Genellikle üst seviye dillerde yazılır (C veya C++)
 Genellikle sistem çağrıları direk çağırılmazlar. Bunun yerine üst seviye
Uygulama Programı Arayüzü (Application Program Interface - API)
aracılığıyla kullanılırlar
 En çok kullanılan API’ler:
 Windows için Win32 API
 POSIX tabanlı sistemler için (UNIX, Linux, ve Mac OS X’in hemen
hemen bütün versiyonları) POSIX API
 Java Sanal Makinası (JVM) için Java API
 Sistem çağrıları yerine neden API’ler kullanılır? taşınabilirlik ve basitlik
Operating System Concepts with Java – 8 2.14 Silberschatz, Galvin and Gagne ©2009 th Edition
Sistem Çağrısı Örneği
 Bir dosyanın içeriğini başka bir dosyaya kopyalayan sistem çağrıları
Operating System Concepts with Java – 8 2.15 Silberschatz, Galvin and Gagne ©2009 th Edition
Standart API Örneği
 Win32 API’deki ReadFile() fonksiyonunu ele alalım
 Bir dosyadan okuma yapmak için kullanılan fonksiyondur
 ReadFile() fonksiyonuna gönderilen parametrelerin açıklaması
 HANDLE file — okunacak dosya
 LPVOID buffer — okunan ve yazılacak bilgilerin tutulduğu tampon bellek
 DWORD bytesToRead — tampon bellekten okunacak bilginin kaç byte
olduğu
 LPDWORD bytesRead—en son okumada kaç byte’lık bilgi okunduğu
 LPOVERLAPPED ovl —üst üste bindirilmiş I/O’nun kullanılıp
kullanılmayacağını belirtir
Operating System Concepts with Java – 8 2.16 Silberschatz, Galvin and Gagne ©2009 th Edition
Sistem Çağrısı Gerçekleştirimi
 Genellikle her bir sistem çağrısı ile bir sayı ilişkilendirilir
 Sistem çağrısı arayüzü bu sayılarla indekslenmiş bir tablo tutar
 Sistem çağrısı arayüzü, işletim sistemi kabuğunda gerçekleştirilmiş
sistem çağrısını çağırır ve eğer dönen bir bilgi varsa bu bilgi ile sistem
çağrısı durumunu geri döndürür
 Sistem çağırısını çağıran uygulama sistem çağrısının nasıl
gerçekleştirildiğini bilmelidir
 API’ye uymalı ve işletim sistemnin çağrı ile ne yapacağını bilmelidir
 İşletim sistemi arayüzünün pek çok detayı API ile programcıdan
gizlenir
 Çalışma zamanı destek kütüphanesi ile yönetilir – derleyici ile
birlikte gelen kütüphaneler içine gömülmüş fonksiyonlardır
Operating System Concepts with Java – 8 2.17 Silberschatz, Galvin and Gagne ©2009 th Edition
API – Sistem Çağrısı – OS İlişkisi
Operating System Concepts with Java – 8 2.18 Silberschatz, Galvin and Gagne ©2009 th Edition
Standart C Kütüphanesi Örneği
 printf() kütüphane fonksiyonunu çağıran program örneği – printf
fonksiyonu arka planda write() sistem çağrısını kullanır
Operating System Concepts with Java – 8 2.19 Silberschatz, Galvin and Gagne ©2009 th Edition
Sistem Çağrısına Parametre Gönderimi
 Genellikle, istenen sistem çağrısının numarasından fazlası gönderilir
 Gönderilecek bilginin tipi ve miktarı işletim sistemine ve yapılacak
çağrıya göre değişir
 İşletim sistemine parametre göndermeyi sağlayan üç genel yöntem
 En basiti: parametreleri yazmaçlar (registers) içinde göndermek
 Bazı durumlarda, yazmaç sayısından daha çok parametre
göndermek gerekebilir
 Parametreler hafızada bir blokta veya tabloda tutulur ve blokun
adresi yazmaç ile gönderilir
 Bu yaklaşım Linux ve Solaris tarafından kullanılmaktadır
 Parameterler program tarafından yığına (stack) atılır ve işletim
sistemi tarafından yığından çekilir
 Blok ve yığın yöntemlerinde, gönderilen parametrelerin sayısı ve
büyüklüğü konusunda herhangi bir sınır yoktur
Operating System Concepts with Java – 8 2.20 Silberschatz, Galvin and Gagne ©2009 th Edition
Tablo ile Parametre Gönderimi
Operating System Concepts with Java – 8 2.21 Silberschatz, Galvin and Gagne ©2009 th Edition
Sistem Çağrısı Çeşitleri
 İşlem kontrolü
 Dosya yönetimi
 Cihaz yönetimi
 Bilgi sağlama
 İletişim
 Koruma
Operating System Concepts with Java – 8 2.22 Silberschatz, Galvin and Gagne ©2009 th Edition
Windows ve Unix Sistem Çağrısı Örnekleri
Operating System Concepts with Java – 8 2.23 Silberschatz, Galvin and Gagne ©2009 th Edition
MS-DOS ile Program Çalıştırma
(a) Sistem başlangıcında (b) Bir program çalışırken
Operating System Concepts with Java – 8 2.24 Silberschatz, Galvin and Gagne ©2009 th Edition
FreeBSD ile Çoklu Program Çalıştırma
Operating System Concepts with Java – 8 2.25 Silberschatz, Galvin and Gagne ©2009 th Edition
Sistem Programları
 Sistem programları program geliştirmek ve çalıştırmak için rahat bir
ortam sağlarlar.
 Aşağıdaki gruplara ayrılabilirler
 Dosya manipülasyonu
 Durum bilgisi
 Dosya değiştirme
 Programlama dili desteği
 Program yükleme ve çalıştırma
 İletişim
 Uygulama programları
 İşletim sisteminin pek çok kullanıcısı işletim sistemini, sağlanan
sistem programları aracılığıyla bilir ve sistem çağrılarından
habersizdir
Operating System Concepts with Java – 8 2.26 Silberschatz, Galvin and Gagne ©2009 th Edition
Sistem Programları
 Program geliştirmek ve çalıştırmak için rahat bir ortam sağlamak
 Bazıları sistem çağrıları yapan basit arayüzler
 Bazıları ise çok daha karmaşık programlar
 Dosya yönetimi
 Dosya oluşturma
 Dosya silme
 Dosya kopyalama
 Dosya yeniden adlandırma
 Dosya yazdırma
 Dosyaları listeleme
 Genel olarak dosyaları ve dizinleri değiştirme
Operating System Concepts with Java – 8 2.27 Silberschatz, Galvin and Gagne ©2009 th Edition
Sistem Programları (devam)
 Durum bilgisi
 Bazıları sistemden aşağıdaki bilgileri ister
 Tarih
 Saat
 Kullanılabilir hafıza miktarı
 Kullanılabilir disk alanı
 Kullanıcı sayısı
 Diğerleri performans, kayıtlar (logging) ve hata ayıklama (debugging)
bilgileri ister
 Tipik olarak, bu programlar elde edilen bilgiyi uygun formata getirip
terminale veya diğer çıktı cihazlarına yazdırır
 Bazı sistemler konfigürasyon bilgisini tutmak ve kullanmakl için bir
kayıt ortamı (registry) kullanır
Operating System Concepts with Java – 8 2.28 Silberschatz, Galvin and Gagne ©2009 th Edition
Sistem Programları (devam)
 Dosya değiştirme
 Dosyaları oluşturmak ve değiştirmek için metin düzenleyicileri (text
editors)
 Dosyaların içeriğinde arama yapmak ve dosya içeriklerini
dönüştürmek için özel komutlar
 Programlama dili desteği – derleyiciler, assemblers, hata ayıklayıcılar
(debuggers) and yorumlayıcılar (interpreters) bazen işletim sistemi ile
birlikte sunulur
 Program yükleme ve çalıştırma – çeşitli yükleyiciler, üst seviye diller ve
makina dili için hata ayıklama sistemleri
 İletişim – İşlemler, kullanıcılar ve bilgisayar sistemleri arasında sanal
bağlantılar oluşturmak için mekanizma sunar
 Kullanıcıların birbirlerinin ekranına mesaj yollamasını, web
sayfalarında gezinmesini, elektronik posta göndermesini, uzak
bilgisayarlara bağlanmasını ve makinalar arasında dosya
göndermesini sağlar
Operating System Concepts with Java – 8 2.29 Silberschatz, Galvin and Gagne ©2009 th Edition
İşletim Sistemi Tasarımı ve Gerçekleştirimi
 İdeal işletim sistemi tasarımı ve gerçekleştirimine dair ideal bir çözüm
yok. Ancak başarılı olduğu gözlemlenen yaklaşımlar var
 İşletim sistemlerinin içsel yapısı çok farklılıklar gösteriyor
 Hedefleri ve özellikleri tanımlayarak başla
 Donanım seçimi ve sistem tipi önemli
 Kullanıcı hedefleri ve Sistem hedefleri
 Kullanıcı hedefleri – işletim sistem rahat kullanılmalı, kolayca
öğrenilmeli, tutarlı, güvenli ve hızlı olmalı
 Sistem hedefleri – işletim sistemi kolay tasarlanmalı ve
gerçekleştirilmeli, bakımı kolay yapılmalı. Esnek olmalı, tutarlı,
hatasız ve verimli çalışmalı
Operating System Concepts with Java – 8 2.30 Silberschatz, Galvin and Gagne ©2009 th Edition
İlkeler ve Mekanizma
 İlkeler ve mekanizmayı birbirinden ayırmak önemli bir prensiptir
İlke (policy): Ne yapılmalı?
Mekanizma (Mechanism): Nasıl yapılmalı?
 Mekanizmalar bir şeyin nasıl yapılacağını belirler. İlkeler ise ne
yapılması gerektiğine karar verir
 İlkelerin mekanizmadan ayrılması maksimum esneklik sağlar
 Daha sonra ne ilkeler değişiklik gösterirse sistemin
güncellenmesini kolaylaştırır
Operating System Concepts with Java – 8 2.31 Silberschatz, Galvin and Gagne ©2009 th Edition
Basit Yapı
 MS-DOS – an az alanda en çok fonksiyonu sağlamak için yazılmıştır
 Modüllere ayrılmamıştır
 MS-DOS belli bir yapıya sahip olsa da arayüzleri ve
fonksyionlarının saviyeleri iyi ayrılmamıştır
Operating System Concepts with Java – 8 2.32 Silberschatz, Galvin and Gagne ©2009 th Edition
MS-DOS Katman Yapısı
Operating System Concepts with Java – 8 2.33 Silberschatz, Galvin and Gagne ©2009 th Edition
Katmanlı Yaklaşım
 İşletim sistemi belli sayıda katmana (layers) ayrılır.
 Her katman alt seviyedeki diğer katman(lar)ın üzerine yerleşir.
 En alt katman (layer 0) donanım katmanıdır.
 En üst katman ise (layer N) kullanıcı arayüzüdür.
 Sistemin modüler olması için katmanlar şu kriteri sağlayacak şekilde
seçilirler:
 Üst katmanlar sadece altındaki katman(lar)ın fonksiyonlarını ve
servisleri kullanmalıdır
Operating System Concepts with Java – 8 2.34 Silberschatz, Galvin and Gagne ©2009 th Edition
UNIX
 UNIX sınırlı bir yapılandırmaya sahip: İki tane birbirinden ayrılabilir
parçaya sahip
 Sistem programları
 Çekirdek
 Fiziksel donanımın üstünde ve sistem çağrısı arayüzünün
altında herşey
 Dosya sistemi, CPU zamanlaması, hafıza yönetimi ve diğer
işletim sistemi fonksiyonlarını sağlıyor
 Tek seviyede çok sayıda fonksiyonu barındırıyor
Operating System Concepts with Java – 8 2.35 Silberschatz, Galvin and Gagne ©2009 th Edition
Geleneksel UNIX Sistem Yapısı
Operating System Concepts with Java – 8 2.36 Silberschatz, Galvin and Gagne ©2009 th Edition
Katmanlı İşletim Sistemi
Operating System Concepts with Java – 8 2.37 Silberschatz, Galvin and Gagne ©2009 th Edition
Mikroçekirdek Sistem Yapısı
 Mikro-çekirdek (microkernel) Sistem Yapısı
 Çekirdekte gerçekleşen şeylerden taşınabilir olan herşeyi «kullanıcı»
alanına (moduna) taşıyor
 Modüller arasındaki iletişim mesaj gönderme (message passing)
yoluyla gerçekleşiyor
 Faydalar:
 Mikroçekirdeğin özelliklerini arttırmak daha kolay
 İşletim sistemini yeni mimarilere geçirmek daha kolay
 Daha tutarlı (çekirdek modunda çok daha az kod çalışıyor)
 Daha güvenli
 Zaralar:
 Çekirdek modu ile kullanıcı modu arasında iletişimin getirdiği aşırı
yüklenmenin getirdiği performans sorunu
Operating System Concepts with Java – 8 2.38 Silberschatz, Galvin and Gagne ©2009 th Edition
Mac OS X Yapısı – Hibrit
Operating System Concepts with Java – 8 2.39 Silberschatz, Galvin and Gagne ©2009 th Edition
Modüller
 Perk çok işletim sistemi çekirdek modüllerini kullanır
 Nesneye yönelik yaklaşımı kullanır
 Tüm temel bileşenler ayrıdır
 Birbirleriyle belirli arayüzler üzerinden iletişim kurarlar
 Her biri gerektiğinde çekirdeğe yüklenebilir durumdadır
 Katmanlara benzerler ama daha çok esneklik sağlarlar
Operating System Concepts with Java – 8 2.40 Silberschatz, Galvin and Gagne ©2009 th Edition
Solaris Modüler Yaklaşımı
Operating System Concepts with Java – 8 2.41 Silberschatz, Galvin and Gagne ©2009 th Edition
Sanal Makinalar
 Sanal makinalar (virtual machines) katmanlı yaklaşımı kullanır
 Donanımı ve işletim sistemi çekirdeğini donanım katmanıymış gibi
kullanırlar
 Sanal makinalar alt seviyedeki donanım ne olursa olsun, üst
seviyedeki programlara aynı arayüzü sunarlar
 İşletim sisteminin ev sahibi (host) işlemlere kendi işlemcisi ve sanal
hafızası varmış izlenimi verir
 Tüm konuklara (guest) üzerinde çalışılan bilgisayarın sanal bir
kopyası sağlanır
Operating System Concepts with Java – 8 2.42 Silberschatz, Galvin and Gagne ©2009 th Edition
Sanal Makinalar - Tarihçe ve Faydalar
 İlk olarak IBM anabilgisayarlarında (mainframes) 1972 yılında
kullanılmaya başlandı
 Temel olarak, birden fazla çalıştırma ortamı (farklı işletim sistemi) aynı
donanımı paylaşabilir ve birbirlerinden korunurlar
 Dosya paylaşımı sağlanabilir (kontrollü bir şekilde)
 Bilgisayar ağları aracılığıyla birbirleriyle ve diğer bilgisayar sistemleriyle
etkileşime geçebilirler
 Sistem geliştirmek ve test etmek için kullanışlıdır
 Az kullanılan birden fazla işletim sistemini bir araya getirerek sistem
kaynaklarının daha etkili kullanımını sağlar
 “Açık Sanal makina formatı” (Open Virtual Machine Format) – Sanal
makinaların farklı sanal makine (host) platformlarında çalışabilmesini
sağlayan standart
Operating System Concepts with Java – 8 2.43 Silberschatz, Galvin and Gagne ©2009 th Edition
Sanal Makinalar (devam)
(a) Sanal olmayan makine (b) sanal makina
Operating System Concepts with Java – 8 2.44 Silberschatz, Galvin and Gagne ©2009 th Edition
Java
 Java:
1. Programlama dili spesifikasyonu
2. Uygulama programlama arayüzü (API)
3. Sanal makine spesifikasyonu
Operating System Concepts with Java – 8 2.45 Silberschatz, Galvin and Gagne ©2009 th Edition
Java Sanal Makinası
Operating System Concepts with Java – 8 2.46 Silberschatz, Galvin and Gagne ©2009 th Edition
JVM - Taşınabilirlik
Java’nın farklı platformlarda taşınabilirliği
Operating System Concepts with Java – 8 2.47 Silberschatz, Galvin and Gagne ©2009 th Edition
Java Geliştirme Aracı
Operating System Concepts with Java – 8 2.48 Silberschatz, Galvin and Gagne ©2009 th Edition
İşletim Sistemi Oluşturma
 İşletim Sistemi Oluşturma (Operating System Generation)
 İşletim sistemleri hehrangi bir sınıf bilgisayar sistemi için çalışabilecek
şekilde tasarlanır
 Ancak, her bir bilgisayar sistemi için ayrı konfigüre edilmelidir
 SYSGEN programı donanım sisteminin konfigürasyonuna dair bilgileri
elde eder
 Yükleme (Booting) – çekirdeği yükleyerek bilgisayarı başlatmak
Operating System Concepts with Java – 8 2.49 Silberschatz, Galvin and Gagne ©2009 th Edition
Sistemin Yüklenmesi
 Donanımın işletim sistemini başlatabilmesi için işletim sisteminin
donanım tarafından erişilebilir olması gerekir
 ROM’da tutulan BIOS bilgisayar ile ilgili ön kontrolleri yapar ve
işletim sistemini yükleyecek olan önyükleyici programı
(bootstrap program, bootstrap loader) çalıştırır
 Neden ROM?
 RAM dahi sistem başlangıcında bilinmeyen bir durumda
 ROM’a bilgisayar virüsleri kolay bulaşamaz
 Önyükleyici program – çekirdeği bulup hafızaya yükleyen ve
çekirdeğin çalışmasını başlatan program
 Büyük işletim sistemlerinde yükleme iki adımda gerçekleşir:
 Diskte yeri belirli olan yükleme bloğundan (boot block)
önyükleyici program yüklenir (Örnek: Linux’de GRUB)
 Ön yükleyici program çekirdeği hafızaya yükler ve çalışmasını
başlatır
Operating System Concepts with Java – 8 3.1 Silberschatz, Galvin and Gagne ©2009 th Edition
Bölüm 3: İşlemler
Operating System Concepts with Java – 8 3.2 Silberschatz, Galvin and Gagne ©2009 th Edition
Bölüm 3: İşlemler
 İşlem Kavramı
 İşlem Zamanlaması (Process Scheduling)
 İşlemler Üzerindeki Faaliyetler
 İşlemler Arası İletişim (Interprocess Communication)
 IPC Sistemi Örnekleri
 İstemci-Sunucu Sistemlerde İletişim
Operating System Concepts with Java – 8 3.3 Silberschatz, Galvin and Gagne ©2009 th Edition
Hedefler
 İşlem kavramını (çalışmakta olan bir program) tanıtmak
 İşlemlerin pek çok özelliklerini tanıtmak: zamanlama, oluşturma,
sonlandırma ve iletişim
 İstemci-sunucu sistemlerinde iletişimi açıklamak
Operating System Concepts with Java – 8 3.4 Silberschatz, Galvin and Gagne ©2009 th Edition
İşlem Kavramı
 İşletim sistemleri farklı tipte programlar çalıştırabilir:
 Toplu iş sistemleri - iş
 Zaman paylaşımlı sistemler (time-shared systems) – kullanıcı
programları veya görevleri
 Ders kitabı iş (job) ve işlem (process) kelimelerini kabaca birbirleri
yerine kullanabilmekte
 İşlem – çalışmakta olan bir programdır
 İşlemler aşağıdakileri içermelidir:
 program sayacı (program counter)
 yığın (stack)
 veri bölümü (data section)
Operating System Concepts with Java – 8 3.5 Silberschatz, Galvin and Gagne ©2009 th Edition
Hafızadaki İşlemler
Operating System Concepts with Java – 8 3.6 Silberschatz, Galvin and Gagne ©2009 th Edition
İşlem Durumu
 Bir işlem çalıştırılırken durumunu (state) değiştirir
 yeni (new): İşlem oluşturuldu
 çalışıyor (running): İşlem komutları çalıştırılıyor
 bekliyor (waiting): İşlem bir olayın gerçekleşmesini bekliyor
 hazır (ready): İşlem bir işlemciye atanmayı bekliyor
 sonlandırılmış (terminated): İşlem çalışmayı bitirmiş
Operating System Concepts with Java – 8 3.7 Silberschatz, Galvin and Gagne ©2009 th Edition
İşlem Durumlarını Gösteren Şema
Operating System Concepts with Java – 8 3.8 Silberschatz, Galvin and Gagne ©2009 th Edition
İşlem Kontrol Bloğu (PCB)
Herhangi bir işlem ile ilişkili bilgiler (process control block)
 İşlem durumu
 İşlem sayacı
 CPU yazmaçları (CPU registers)
 CPU zamanlama bilgileri
 Hafıza yönetim bilgileri
 Hesap (accounting) bilgileri
 I/O durum bilgileri
Operating System Concepts with Java – 8 3.9 Silberschatz, Galvin and Gagne ©2009 th Edition
İşlem Kontrol Bloğu (PCB)
Operating System Concepts with Java – 8 3.10 Silberschatz, Galvin and Gagne ©2009 th Edition
CPU İşlemden İşleme Geçiş Yapar
Operating System Concepts with Java – 8 3.11 Silberschatz, Galvin and Gagne ©2009 th Edition
İşlem Zamanlama Kuyrukları
 Process Scheduling Queues
 İş kuyruğu (job queue) – sistemdeki tüm işlemlerin kümesi
 Hazır kuyruğu (ready queue) – ana hafızadaki, tüm işlemlerin
kümesi - çalışmaya hazır ve çalıştırılmayı bekleyen
 Cihaz kuyrukları (device queues) – bir I/O cihazını kullanmayı
bekleyen işlemler kümesi
 İşlemler değişik kuyruklar arasında geçiş yapar
Operating System Concepts with Java – 8 3.12 Silberschatz, Galvin and Gagne ©2009 th Edition
Hazır Kuyruğu ve Bazı I/O Cihaz
Kuyrukları
Operating System Concepts with Java – 8 3.13 Silberschatz, Galvin and Gagne ©2009 th Edition
İşlem Zamanlaması Gösterimi
Operating System Concepts with Java – 8 3.14 Silberschatz, Galvin and Gagne ©2009 th Edition
Zamanlayıcılar
 Uzun vadeli zamanlayıcılar (long-term scheduler)
 veya iş zamanlayıcısı (job scheduler)
 hangi işlemlerin hazır kuruğuna (ready queue) alınması gerektiğine
karar verir
 Kısa vadeli zamanlayıcılar (short-term scheduler)
 veya CPU zamanlayıcısı
 sıradaki hangi işlemin CPU tarafından çalıştırılacağına karar verir
Operating System Concepts with Java – 8 3.15 Silberschatz, Galvin and Gagne ©2009 th Edition
Orta Vadeli Zamanlama
Orta Vadeli Zamanlayıcı (medium-term schedular)
Operating System Concepts with Java – 8 3.16 Silberschatz, Galvin and Gagne ©2009 th Edition
Zamanlayıcılar (devam)
 Kısa vadeli zamanlayıcı çok sık çalıştırılır (milisaniye)  hızlı
çalışmalı
 Uzun vadeli zamanlayıcı çok sık çalıştırılmaz (saniye, sakika) 
yavaş olabilir
 Uzun vadeli zamanlayıcı çokluprogramlamanın (multiprogramming)
seviyesini kontrol eder
 İşlemler aşağıdaki iki kategoriye ayrılabilir:
 I/O ağırlıklı işlemler (I/O-bound process) – CPU üzerinde kısa
süreli işlerler yaparlar ve zamanlarının çoğu I/O işleri yaparak
geçer
 CPU ağırlıklı işlemler (CPU-bound process) – zamanlarının
çoğunu CPU üzerinde uzun işlemler yaparak geçirirler, I/O işleri
çok daha azdır
Operating System Concepts with Java – 8 3.17 Silberschatz, Galvin and Gagne ©2009 th Edition
Ortam Değişikliği
 Context Switch
 CPU başka bir işleme geçerken, sistem eski işlemin durumunu
kaydetmeli ve yeni işlemin kaydedilmiş durumunu yüklemelidir
 Bir işlemin ortamı (context) PCB’de tutulur
 Ortam değişikliği için harcanan zaman ek yüktür. Değişim sırasında
işlemci kullanıcının işine direk yarayan bir iş yapmamaktadır
 Harcanan zaman donanım desteğine bağlıdır
Operating System Concepts with Java – 8 3.18 Silberschatz, Galvin and Gagne ©2009 th Edition
İşlem Oluşturma
 Ana işlem (parent process) çocuk işlemleri (children processes)
oluşturur
 Çocuk işlemlerde yeni işlem oluşturabileceğinden, sistemde işlemlerin
bir ağacı oluşur
 Genellikle işlemler işlem belirteci (process identifier - pid)
kullanılarak birbirlerinden ayrılırlar ve yönetilirler
 Kaynak paylaşımı
 Ana işlem ve çocuklar tüm kaynakları paylaşırlar
 Çocuklar ana işlemin kaynaklarının belli bir alt kümesini paylaşır
 Ana işlem ve çocuklar kaynak paylaşmazlar
 Çalıştırma
 Ana işlem ve çocuklar aynı anda çalışır
 Ana işlem, çocuk işlemler sonlanana kadar bekler
Operating System Concepts with Java – 8 3.19 Silberschatz, Galvin and Gagne ©2009 th Edition
İşlem Oluşturma (devam)
 Hafıza alanı (address space)
 Çocuk ana işlemin kopyasına sahip
 Çocuk adres alanına yeni bir program yükler
 UNIX örnekleri
 fork sistem çağrısı yeni bir işlem oluşturur
 exec sistem çağrısı, fork sistem çağrısı ile yeni işlem
oluşturulduktan sonra, işlemin hafıza alanına yeni bir program
yüklemek için kullanılır
Operating System Concepts with Java – 8 3.20 Silberschatz, Galvin and Gagne ©2009 th Edition
İşlem Oluşturma Şeması
Operating System Concepts with Java – 8 3.21 Silberschatz, Galvin and Gagne ©2009 th Edition
Yeni İşlem Oluşturan C Programı
int main()
{
pid_t pid;
/* fork another process */
pid = fork();
if (pid < 0) { /* error occurred */
fprintf(stderr, "Fork Failed");
exit(-1);
}
else if (pid == 0) { /* child process */
execlp("/bin/ls", "ls", NULL);
}
else { /* parent process */
/* parent will wait for the child to complete */
wait (NULL);
printf ("Child Complete");
exit(0);
}
}
Operating System Concepts with Java – 8 3.22 Silberschatz, Galvin and Gagne ©2009 th Edition
POSIX’te İşlem Oluşturma
Operating System Concepts with Java – 8 3.23 Silberschatz, Galvin and Gagne ©2009 th Edition
Win32’de İşlem Oluşturma
Operating System Concepts with Java – 8 3.24 Silberschatz, Galvin and Gagne ©2009 th Edition
Java’da İşlem Oluşturma
Operating System Concepts with Java – 8 3.25 Silberschatz, Galvin and Gagne ©2009 th Edition
Solaris’te Tipik Bir İşlem Ağacı
Operating System Concepts with Java – 8 3.26 Silberschatz, Galvin and Gagne ©2009 th Edition
İşlem Sonlandırma
 Process Termination
 İşlemler son komutlarını çalıştırdıktan sonra işletim sistemine
kendilerini silmelerini isterler (exit)
 İşlemin dönüş değeri çocuktan ana işleme döndürülür (wait ile)
 İşlemin kaynakları işletim sistemi tarafından geri alınır
 Ana işlem çocuk işlemlerin çalışmasını sonlandırabilir (abort)
 Çocuk kendine ayrılan kaynakları aşmışsa
 Çocuk işleme atanan göreve artık ihtiyaç yoksa
 Eğer ana işlem sonlandırılıyorsa
 Bazı işletim sistemleri ana işlem sonlandırıldıktan sonra
çocuklarının çalışmaya devam etmesine izin vermez
– Peşpeşe sonlandırma (cascading termination ) ile tüm
çocuk işlemler sonlandırılır
Operating System Concepts with Java – 8 3.27 Silberschatz, Galvin and Gagne ©2009 th Edition
İşlemler Arası İletişim
 Interprocess Communication
 Bir sistemdeki işlemler bağımsız (independent ) ya da işbirliği
yapıyor (cooperating) olabilir
 İşbirliği yapan işlemler birbirlerini etkileyebilirler veya veri paylaşabilirler
 Neden işlemler işbirliği yapar?
 Bilgi paylaşımı
 İşlem hızını arttırmak
 Modülerlik sağlamak
 İşbirliği yapan işlemler işlemler arası iletişime (interprocess
communication - IPC) ihtiyaç duyar
 IPC’nin iki modeli
 Paylaşımlı bellek (shared memory)
 Mesaj gönderme (message passing)
Operating System Concepts with Java – 8 3.28 Silberschatz, Galvin and Gagne ©2009 th Edition
İletişim Modelleri
Operating System Concepts with Java – 8 3.29 Silberschatz, Galvin and Gagne ©2009 th Edition
Üretici-Tüketici Problemi
 Producer-Consumer Problem
 İşbirliği yapan işlemler için problem örneği: üretici (producer) işlem
bilgi üretirken, tüketici (consumer) işlem üretilen bilgiyi tüketir
 sınırsız tampon bellek (unbounded-buffer): tampon bellek için
herhangi bir pratik sınır getirmez
 sınırlı tampon bellek (bounded-buffer): sınırlı boyutta bir
tampon bellek kullanıldığını varsayar
Operating System Concepts with Java – 8 3.30 Silberschatz, Galvin and Gagne ©2009 th Edition
Java’da Paylaşımlı Bellek Simülasyonu
Operating System Concepts with Java – 8 3.31 Silberschatz, Galvin and Gagne ©2009 th Edition
Sınırlı Tampon Bellek Çözümü - Arayüz
Operating System Concepts with Java – 8 3.32 Silberschatz, Galvin and Gagne ©2009 th Edition
Sınırlı Tampon Bellek – Üretici
Operating System Concepts with Java – 8 3.33 Silberschatz, Galvin and Gagne ©2009 th Edition
Sınırlı Tampon Bellek – Tüketici
Operating System Concepts with Java – 8 3.34 Silberschatz, Galvin and Gagne ©2009 th Edition
İşlemler Arası İletişim – Mesaj Gönderme
 İşlemlerin iletişim kurması ve eylemlerini senkronize etmelerini
sağlayan mekanizma
 Mesaj sistemi – işlemler birbirleriyle paylaşımlı değişkenlere bağlı
kalmaksızın haberleşir
 IPC mekanizması iki işlemi sağlar:
 send (mesaj gönderme) – mesaj boyutu sabit ya da değişken
olabilir
 receive (mesaj alma)
 Eğer P ve Q işlemleri iletişim kurmak isterse:
 birbirleri arasında bir iletişim bağlantısı (communication link)
sağlamalıdırlar
 send/receive kullanarak mesajlaşmalıdırlar
 İletişim bağlantısının gerçekleştirimi
 fiziksel (e.g., paylaşımlı hafıza, donanım hattı)
 mantıksal (e.g., mantıksal özellikler)
Operating System Concepts with Java – 8 3.35 Silberschatz, Galvin and Gagne ©2009 th Edition
Gerçekleştirim Soruları
 Bağlantılar nasıl sağlanır?
 Bir bağlantı ikiden fazla işlemle ilişkilendirilmeli midir?
 İletişim kuran işlemlerin her bir çifti arasında kaç tane bağlantı olabilir?
 Bağlantının kapasitesi nedir?
 Bağlantının desteklediği mesajların boyutu sabit mi yoksa değişken
midir?
 Bağlantı çift yönlü mü (bi-directional) yoksa tek yönlü (unidirectional)
müdür?
Operating System Concepts with Java – 8 3.36 Silberschatz, Galvin and Gagne ©2009 th Edition
Direk İletişim
 İşlemler birbirlerini açıkça isimlendirmelidir:
 send (P, message) – P işlemine bir mesaj gönder
 receive(Q, message) – Q işleminden bir mesaj al
 İletişim bağlantısının özellikleri
 Bağlantılar otomatik olarak sağlanır
 Bir bağlantı sadece bir çift işlemci arasında oluşturulur
 Her bir çift için sadece bir bağlantı oluşturulur
 Bağlantı tek yönlü olabilir, ama genellikle çift yonlüdür
Operating System Concepts with Java – 8 3.37 Silberschatz, Galvin and Gagne ©2009 th Edition
Dolaylı İletişim
 Mesajlar posta kutusuna (messagebox) yönlendirilir ve post
kutusundan alınır
 Posta kutusu yerine port terimi de kullanılır
 Her bir posta kutusu özgün bir ada sahiptir (unique id)
 İşlemler sadece bir post kutusunu paylaşıyor ise iletişime
geçebilir
 İletişim bağlantısının özellikleri
 Bağlantı sadece işlemler ortak bir posta kutusunu paylaşıyor ise
oluşturulur
 İkiden fazla işlem tek bir posta kutusu ile ilişkilendirilebilir
 Bir işlem çifti birden fazla iletişim bağlantısına sahip olabilir
 Bağlantı tek yönlü veya çift yönlü olabilir
Operating System Concepts with Java – 8 3.38 Silberschatz, Galvin and Gagne ©2009 th Edition
Dolaylı İletişim (devam)
 İşlemler
 yeni bir posta kutusu oluşturma
 posta kutusu aracılığıyla mesaj gönderme veya alma
 posta kutusunun yok edilmesi
 Temel bileşenler:
send(A, message) – A posta kutusuna bir mesaj gönder
receive(A, message) – A posta kutusundan bir mesaj al
Operating System Concepts with Java – 8 3.39 Silberschatz, Galvin and Gagne ©2009 th Edition
Posta Kutusu Paylaşımı
 Posta kutusu paylaşımı
 P1
, P2
, ve P3 A posta kutusunu paylaşıyor
 P1
, meaj gönderir; P2 ve P3 alır
 Mesajı kim alır?
 Çözümler
 Bir bağlantının en fazla iki işlem ile ilişkilendirilmesine izin ver
 Herhangi bir anda sadece bir işlemin mesaj almasına izin ver
 Sistemin herhnagi bir alıcıyı seçmesine izin ver. Gönderici kimin
mesajı aldığı konusunda bilgilendirilir
Operating System Concepts with Java – 8 3.40 Silberschatz, Galvin and Gagne ©2009 th Edition
Senkronizasyon
 Synchronization
 Mesaj gönderme bloklanan (blocking) veya bloklanmayan (nonblocking) şekilde gerçekleşebilir
 Bloklanan mesajlaşma senkrondur (synchronous)
 Bloklanan gönderimde, alıcı taraf mesajı alana kadar, gönderici
taraf bloklanır
 Bloklanan alımda, gönderici taraf mesajı gönderene kadar, alıcı
taraf bloklanır
 Bloklanmayan mesajlaşma asenkrondur (asynchronous)
 Bloklanmayan gönderimde, gönderici taraf mesajı gönderdikten
sonra beklemeksizin çalışmaya devam eder
 Bloklanmayan alımda, alıcı taraf ya geçerli bir mesaj alır ya da
null mesaj alarak çalışmaya devam eder
Operating System Concepts with Java – 8 3.41 Silberschatz, Galvin and Gagne ©2009 th Edition
Tampon Bellek Kullanımı
 Bağlantı ile ilişkilendirilen kuyruk üç farklı şekilde
gerçekleştirilebilir
1. Sıfır kapasite – 0 mesaj
Gönderici alıcıyı beklemelidir: randevu (rendezvous)
2. Sınırlı kapasite – n mesajı alacak şekilde sınırlı kapasite
Gönderici bağlantı kapasitesi dolu ise beklemelidir
3. Sınırsız kapasite
Gönderisi asla beklemez
Operating System Concepts with Java – 8 3.42 Silberschatz, Galvin and Gagne ©2009 th Edition
IPC Sistem Örnekleri - POSIX
 POSIX Paylaşımlı Hafıza
 İşlem öncelikle paylaşımlı hafıza segmentini oluşturur
segment id = shmget(IPC PRIVATE, size, S IRUSR | S
IWUSR);
 Paylaşımlı belleğe erişmek isteyen işlem, bu paylaşım alanı ile
bağlantı kurmalıdır
shared memory = (char *) shmat(id, NULL, 0);
 Şimdi işlem paylaşımlı hafızaya yazabilir
sprintf(shared memory, "Writing to shared memory");
 Paylaşım alanı ile yapacak işi kalmayan işlem,bu paylaşım alanı ile
bağlantısını sonlandırmalıdır
shmdt(shared memory);
Operating System Concepts with Java – 8 3.43 Silberschatz, Galvin and Gagne ©2009 th Edition
IPC Sistem Örnekleri - Mach
 Mach iletişimi mesaj tabanlıdır
 Sistem çağrıları dahi sisteme mesaj olarak gönderilir
 Her bir işlem oluşturulduğunda iki posta kutusuna sahiptir - Kernel
and Notify
 Mesaj transferi için sadece üç sistem çağrısı kullanılır
msg_send(), msg_receive(), msg_rpc()
 İletişim kurmak için gereken posta kutuları aşağıdaki komutla
oluşturulabilir
port_allocate()
Operating System Concepts with Java – 8 3.44 Silberschatz, Galvin and Gagne ©2009 th Edition
IPC Sistem Örnekleri – Windows XP
 Yerel metot çağrımı (LPC) ile mesaj tabanlı iletişim
 Sadece aynı sistemde bulunan işlemler arasında gerçekleşebilir
 İletişim kanalları oluşturmak için portları (posta kutuları gibi)
kullanır
 İletişim şu şekilde çalışır:
 İstemci, iletişim portu nesnesine bir kulp (handle) açar
 İstemci bir bağlantı isteği gönderir
 Sunucu iki özel iletişim portu açar ve bunlardan birini istemciye
gönderir
 İstemci ve sunucu mesaj göndermek, geri arama (callback)
göndermek ve yanıtları dinlemek için ilgili port kulpunu (port
handle) kullanır
Operating System Concepts with Java – 8 3.45 Silberschatz, Galvin and Gagne ©2009 th Edition
Windows XP’de Yerel Metot Çağrımları
Yerel Metot Çağrımları (Local Procedure Calls)
Operating System Concepts with Java – 8 3.46 Silberschatz, Galvin and Gagne ©2009 th Edition
İstemci-Sunucu Sistemlerinde İletişim
 Soketler (Sockets)
 Uzak Prosedür Çağrıları (Remote Procedure Calls)
 Uzak Metot Çağırma (Remote Method Invocation)
Operating System Concepts with Java – 8 3.47 Silberschatz, Galvin and Gagne ©2009 th Edition
Soketler
 Soketler iletişim amaçlı bağlantı noltaları olarak tanımlanır
 IP adresi ve portun birleşimidir
 161.25.19.8:1625 soketi 161.25.19.8 IP’li makinanın 1625
numaralı portuna arşılık gelmektedir
 İletişim bir çift soket arasında gerçekleşir
Operating System Concepts with Java – 8 3.48 Silberschatz, Galvin and Gagne ©2009 th Edition
Soket İletişimi
Operating System Concepts with Java – 8 3.49 Silberschatz, Galvin and Gagne ©2009 th Edition
Java’da Soket İletişimi - Sunucu
Operating System Concepts with Java – 8 3.50 Silberschatz, Galvin and Gagne ©2009 th Edition
Java’da Soket İletişimi - İstemci
Operating System Concepts with Java – 8 3.51 Silberschatz, Galvin and Gagne ©2009 th Edition
Uzak Prosedür Çağrıları (RPC)
 Remote procedure call (RPC)
 Ağa bağlı sistemlerdeki işlemler arasında metot (prosedür, fonksiyon)
çağrımını soyutlar
 Stub – sunucudaki asıl metot için istemci tarafında bulunan vekildir
 İstemci tarafı sunucuyu konumlandırır ve metot parametrelerini
paketler
 Sunucu tarafı mesajı alır, parametreleri açığa çıkarır ve sunucudaki
metotu çalıştırır
Operating System Concepts with Java – 8 3.52 Silberschatz, Galvin and Gagne ©2009 th Edition
RPC’nin Çalıştırılması
Operating System Concepts with Java – 8 3.53 Silberschatz, Galvin and Gagne ©2009 th Edition
Uzak Metot Çağırma (RMI)
 Remote Method Invocation (RMI)
 RPC’ye benzer Java mekanizmasıdır
 RMI, bir Java programının, uzak bir nesnede bulunan bir metotu
çağırmasını sağlar
Operating System Concepts with Java – 8 3.54 Silberschatz, Galvin and Gagne ©2009 th Edition
Parametrelerin Paketlenmesi
Operating System Concepts with Java – 8 3.55 Silberschatz, Galvin and Gagne ©2009 th Edition
RMI Örneği - Arayüz
Operating System Concepts with Java – 8 3.56 Silberschatz, Galvin and Gagne ©2009 th Edition
RMI Örneği – Sunucu Taraf
Operating System Concepts with Java – 8 3.57 Silberschatz, Galvin and Gagne ©2009 th Edition
RMI Örneği – İstemci Taraf
Operating System Concepts with Java – 8 14.1 Silberschatz, Galvin and Gagne ©2009 th Edition
Bölüm 4: İş Parçacıkları
Operating System Concepts with Java – 8 14.2 Silberschatz, Galvin and Gagne ©2009 th Edition
Bölüm 4: İş Parçacıkları
 Genel Bakış
 Çoklu İş Parçacığı Modelleri
 İş Parçacığı Kütüphaneleri
 İş Parçacıkları ile İlgili Meseleler
 İşletim Sistemi Örnekleri
 Windows XP İş Parçacıkları
 Linux İş Parçacıkları
Operating System Concepts with Java – 8 14.3 Silberschatz, Galvin and Gagne ©2009 th Edition
Hedefler
 İş parçacığı kavramını tanıtmak — çok işlemli bilgisayar sistemlerinde
CPU kullanımını sağlayan temel birim
 Pthreads, Win32, ve Java iş parçacığı kütüphanelerinin tanıtımı
 Çok iş parçacıklı programlamada ortaya çıkan meselelerin irdelenmesi
Operating System Concepts with Java – 8 14.4 Silberschatz, Galvin and Gagne ©2009 th Edition
Tek ve Çok İş Parçacıklı İşlemler
Operating System Concepts with Java – 8 14.5 Silberschatz, Galvin and Gagne ©2009 th Edition
Faydalar
 Cevap Verebilirlik (Responsiveness)
 Kaynak Paylaşımı (Resource Sharing)
 Ekonomi (Economy)
 Solaris: thread creation (1/30) ve context switch (1/5)
 Ölçeklenebilirlik (Scalability)
Operating System Concepts with Java – 8 14.6 Silberschatz, Galvin and Gagne ©2009 th Edition
Çok-çekirdekli Programlama
 Çok-çekirdekli sistemler programcıları çok iş parçacıklı uygulamalar
yazmaya zorluyor. Bu konudaki zorluklar:
 Aktiviteleri bölmek (dividing activities)
 Denge (balance)
 Bilgileri Ayırmak (data splitting)
 Veri bağımlılığı (data dependency)
 Test ve Hata Ayıklama (testing and debugging)
Operating System Concepts with Java – 8 14.7 Silberschatz, Galvin and Gagne ©2009 th Edition
Çok İş Parçacıklı Sunucu Mimarisi
Operating System Concepts with Java – 8 14.8 Silberschatz, Galvin and Gagne ©2009 th Edition
Tek Çekirdekli Sistemde Eş Zamanlı Çalıştırma
Operating System Concepts with Java – 8 14.9 Silberschatz, Galvin and Gagne ©2009 th Edition
Çok-çekirdekli Sistemde Paralel Çalıştırma
Operating System Concepts with Java – 8 14.10 Silberschatz, Galvin and Gagne ©2009 th Edition
Kullanıcı İş Parçacıkları
 İş parçacığı yönetimi kullanıcı seviyesinde tanımlı iş parçacığı
kütüphaneleri ile sağlanır
 Üç ana iş parçacığı kütüphanesi:
 POSIX Pthreads
 Win32 iş parçacıkları
 Java iş parçacıkları
Operating System Concepts with Java – 8 14.11 Silberschatz, Galvin and Gagne ©2009 th Edition
Çekirdek İş Parçacıkları
 Çekirdek tarafından desteklenirler
 Örnekler
 Windows XP/2000
 Solaris
 Linux
 Tru64 UNIX
 Mac OS X
Operating System Concepts with Java – 8 14.12 Silberschatz, Galvin and Gagne ©2009 th Edition
Çoklu İş Parçacığı Modelleri
 Çoktan-Teke (Many-to-One)
 Teke-Tek (One-to-One)
 Çoktan-Çoka (Many-to-Many)
Operating System Concepts with Java – 8 14.13 Silberschatz, Galvin and Gagne ©2009 th Edition
Çoktan-Teke (Many-to-One)
 Pek çok kullanıcı seviyesindeki iş parçacığı tek bir çekirdek iş parçacığı
ile eşleşir
 Örnekler:
 Solaris Green Threads
 GNU Portable Threads
Operating System Concepts with Java – 8 14.14 Silberschatz, Galvin and Gagne ©2009 th Edition
Çoktan-Teke (Many-to-One) Model
Operating System Concepts with Java – 8 14.15 Silberschatz, Galvin and Gagne ©2009 th Edition
Teke-Tek (One-to-One)
 Her bir kullanıcı seviyesi iş parçacığı tek bir çekirdek iş parçacığı ile
eşleşir
 Örnekler
 Windows NT/XP/2000
 Linux
 Solaris 9 ve sonrası
Operating System Concepts with Java – 8 14.16 Silberschatz, Galvin and Gagne ©2009 th Edition
Teke-Tek (One-to-One) Model
Operating System Concepts with Java – 8 14.17 Silberschatz, Galvin and Gagne ©2009 th Edition
Çoktan-Çoka (Many-to-Many)
 Pek çok kullanıcı seviyesi iş parçacığı pek çok çekirdek iş parçacığı
ile eşleşir
 İşletim sisteminin yeterince çekirdek iş parçacığı oluşturmasını
sağlar
 Solaris’in version 9’a kadar olan versiyonları
 ThreadFiber paketi ile Windows NT/2000
Operating System Concepts with Java – 8 14.18 Silberschatz, Galvin and Gagne ©2009 th Edition
Çoktan-Çoka (Many-to-Many) Model
Operating System Concepts with Java – 8 14.19 Silberschatz, Galvin and Gagne ©2009 th Edition
İki-seviye Model
 M:M’e benzer. Farklı olarak kullanıcı iş parçacığının çekirdek iş
parçasına bağlanmasına izin verir (bound to kernel thread)
 Örnekler
 IRIX
 HP-UX
 Tru64 UNIX
 Solaris 8 ve öncesi
Operating System Concepts with Java – 8 14.20 Silberschatz, Galvin and Gagne ©2009 th Edition
İki-seviye Model
Operating System Concepts with Java – 8 14.21 Silberschatz, Galvin and Gagne ©2009 th Edition
İş Parçacığı Kütüphaneleri
 İş parçacığı kütüphanesi programcıya iş parçacıklarının
oluşturulmasını ve yönetilmesini sağlayan bir API sunar
 Gerçekleştirim için iki temel yol
 Kütüphane tamamen kullanıcı alanında
 İşletim sistemi tarafından desteklenen çekirdek seviyesinde
kütüphane
Operating System Concepts with Java – 8 14.22 Silberschatz, Galvin and Gagne ©2009 th Edition
Pthreads
 Kullanıcı seviyesinde veya çekirdek seviyesinde sunulabilir
 İş parçacığı oluşturmak ve iş parçacıklarının senkronizasyonunu
sağlamak için bir POSIX standardı (IEEE 1003.1c)
 API iş parçacığı kütüphanesinin davranışını tanımlıyor. Gerçekleştirim
kütüphanenin gerçekleştirimine bağlı
 UNIX işletim sistemlerinde genel olarak kullanılıyor (Solaris, Linux,
Mac OS X)
Operating System Concepts with Java – 8 14.23 Silberschatz, Galvin and Gagne ©2009 th Edition
Java İş Parçacıkları
 Java iş parçacıkları JVM tarafından yönetilir
 Java iş parçacıkları oluşturmanın bir yolu Runnable arayüzünü
gerçekleştirmektir
Operating System Concepts with Java – 8 14.24 Silberschatz, Galvin and Gagne ©2009 th Edition
Java İş Parçacıkları – Örnek Program
Operating System Concepts with Java – 8 14.25 Silberschatz, Galvin and Gagne ©2009 th Edition
Java İş Parçacıkları – Örnek Program
Operating System Concepts with Java – 8 14.26 Silberschatz, Galvin and Gagne ©2009 th Edition
Java İş Parçacığı Durumları
Operating System Concepts with Java – 8 14.27 Silberschatz, Galvin and Gagne ©2009 th Edition
Üretici-Tüketici Problemi Çözümü
Operating System Concepts with Java – 8 14.28 Silberschatz, Galvin and Gagne ©2009 th Edition
Üretici İş Parçacığı
Operating System Concepts with Java – 8 14.29 Silberschatz, Galvin and Gagne ©2009 th Edition
Tüketici İş Parçacığı
Operating System Concepts with Java – 8 14.30 Silberschatz, Galvin and Gagne ©2009 th Edition
İş Parçacıkları ile İlgili Mevzular
 fork() ve exec() sistem çağrılarının anlamı
 Hedef iş parçacığının iptali
 Asenkron veya ertelenen
 Sinyal işleme
 İş parçacığı havuzları
 İş parçacığına özgü veri
Operating System Concepts with Java – 8 14.31 Silberschatz, Galvin and Gagne ©2009 th Edition
fork() ve exec() Sistem Çağrılarının Anlamı
 fork() çağıran iş parçacığının mı yoksa tüm iş parçacıklarının mı
kopyasını oluşturur?
Operating System Concepts with Java – 8 14.32 Silberschatz, Galvin and Gagne ©2009 th Edition
İş Parçacığı İptali
 Bir iş parçacığının işi bitmeden sonlandırılması
 İki genel yaklaşım:
 Asenkron iptal hedef iş parçacığını anında iptal eder
 Ertelenen iptal hedef iş parçacığının düzenli olarak iptal
edilmesi gerekip gerkmediğini kontrol etmesini sağlar
Operating System Concepts with Java – 8 14.33 Silberschatz, Galvin and Gagne ©2009 th Edition
Sinyal İşleme
 Sinyaller UNIX sistemlerde belirli bir işlemi, bir olayın
gerçekleştiğine dair bilgilendirmekte kullanılır
 Sinyalleri işlemek için bir sinyal işleyici (signal handler) kullanılır
1. Belirli bir olaydan dolayı bir sinyal oluşturulur
2. Sinyal işleme iletilir
3. Sinyal işlem tarafından işlenir
 Çok iş parçacıklı sistemlerde seçenekler:
 Sinyali sadece ilgili iş parçacığına ilet
 Sinyali işlemdeki tüm iş parçacıklarına ilet
 Sinyali işlemdeki belli iş parçacıklarına ilet
 Sinyalleri işlemek için belli bir iş parçacığını görevlendir
Operating System Concepts with Java – 8 14.34 Silberschatz, Galvin and Gagne ©2009 th Edition
İş Parçacığı Havuzları
 Bir havuzda, kendilerine atanacak işleri beklemek üzere belli sayıda iş
parçacığı oluştur
 Avantajlar:
 Genellikle varolan bir iş parçacığı ile bir isteği gerçekleştirmek,
yeni bir iş parçacığı oluşturarak gerçekleştirmekten biraz daha
hızlı
 Uygulamalardaki iş parçacıklarının sayısı iş parçacığı havuzunun
boyutu ile sınırlandırılır
Operating System Concepts with Java – 8 14.35 Silberschatz, Galvin and Gagne ©2009 th Edition
İş Parçacığına Özgü Veri
 Her bir iş parçacığının kendi verilerine sahip olmasına izin verir
 İş parçacığı oluşturma sürecinde kontrolünüz olmadığında (örn:
Java’da iş parçacığı havuzu kullanıldığında) işe yarar
Operating System Concepts with Java – 8 14.36 Silberschatz, Galvin and Gagne ©2009 th Edition
İşletim Sistemi Örnekleri
 Windows XP iş parçacıkları
 Linux iş parçacıkları
Operating System Concepts with Java – 8 14.37 Silberschatz, Galvin and Gagne ©2009 th Edition
Windows XP İş Parçacıkları
 Birer-bir modeli çekirdek seviyesinde gerçekleştirir
 Her bir iş parçacığı aşağıdakilere sahiptir
 İş parçacığı numarası (thread id)
 Yazmaç kümesi (register set)
 Ayrı kullanıcı ve çekirdek yığınları (stacks)
 Özel veri saklama alanı
 Yazmaç kümesi, yığınlar ve özel veri saklama alanı iş
parçacıklarının ortamı (context) olarak da bilinir
 Bir iş parçacığının temel veri yapıları:
 ETHREAD (executive thread block)
 KTHREAD (kernel thread block)
 TEB (thread environment block)
Operating System Concepts with Java – 8 14.38 Silberschatz, Galvin and Gagne ©2009 th Edition
Windows XP İş Parçacıkları
Operating System Concepts with Java – 8 14.39 Silberschatz, Galvin and Gagne ©2009 th Edition
Linux İş Parçacıkları
 Linux, iş parçacığı (threads) yerine görev (task) kavramını kullanır
 Yeni iş parçacığı oluşturma clone() sistem çağrısı ile gerçekleştirilir
 clone() çocuk görevin, ana görevin (process) adres uzayını
kullanmasına izin verir
Operating System Concepts with Java – 8 14.40 Silberschatz, Galvin and Gagne ©2009 th Edition
Linux İş Parçacıkları - Flags
Operating System Concepts with Java – 8 5.1 Silberschatz, Galvin and Gagne ©2009 th Edition
Bölüm 5: İşlemci Zamanlaması
Operating System Concepts with Java – 8 5.2 Silberschatz, Galvin and Gagne ©2009 th Edition
İşlemci Zamanlaması
 Temel Kavramlar
 Zamanlama Kriteri
 Zamanlama Algoritmaları
 İş Parçacığı Zamanlaması
 Çok-İşlemci Zamanlaması
 İşletim Sistemi Örnekleri
 Algoritmaların Değerlendirilmesi
Operating System Concepts with Java – 8 5.3 Silberschatz, Galvin and Gagne ©2009 th Edition
Hedefler
 Çok programlı işletim sistemlerinin temelini oluşturan işlemci
zamanlamasının tanıtılması
 Pek çok işlemci zamanlama algoritmasının açıklanması
 Belirli bir sistem için işlemci zamanlama algoritması seçerken
kullanılacak değerlendirme kriterlerinin irdelenmesi
Operating System Concepts with Java – 8 5.4 Silberschatz, Galvin and Gagne ©2009 th Edition
Temel Kavramlar
 Çoklu programlamalı sayesinde CPU kullanımının optimize edilmesi
 CPU–I/O İşlem Döngüsü – Bir işlemin çalıştırılması birbirlerini takip
eden (1) CPU kullanımı ve (2) I/O beklemesi döngüsüden oluşur
 CPU işleme süresi dağılımı
Operating System Concepts with Java – 8 5.5 Silberschatz, Galvin and Gagne ©2009 th Edition
Tekrar Eden CPU ve I/O İşlem Döngüsü
Operating System Concepts with Java – 8 5.6 Silberschatz, Galvin and Gagne ©2009 th Edition
CPU İşleme Süresi Dağılım Eğrisi
Histogram: Dağılım Eğrisi
Operating System Concepts with Java – 8 5.7 Silberschatz, Galvin and Gagne ©2009 th Edition
İşlemci Zamanlayıcısı
 Çalışmaya hazır şekilde hafızada bekleyen işlemlerden birini seçerek
işlemciyi ona ayırır
 İşlemci zamanlaması şu durumlarda gerçekleşebilir:
1. Çalışma durumundan (running state) bekleme durumuna (waiting
state) geçişte
2. Çalışma durumundan hazır durumuna (ready state) geçişte
3. Bekleme durumundan hazır durumuna geçişte
4. İşlem sonlandığında
 1 ve 4 durumlarında zamanlama: kesmeyen (nonpreemptive) – eski
işletim sistemleri (windows 3.x gibi)
 Diğer durumlarda: kesen (preemptive)
Operating System Concepts with Java – 8 5.8 Silberschatz, Galvin and Gagne ©2009 th Edition
Görevlendirici (Dispatcher)
 Görevlendirici modül CPU kontrolünü kısa dönem zamanlayıcı (shortterm scheduler) tarafından seçilen işleme devreder:
 Ortam değiştirme (switching context)
 Kullanıcı moduna geçme
 Kullanıcya ait program yeniden başlatıldığındaprogramdaki
uygun konuma atlama
 Görevlendirme gecikme süresi (dispatch latency) –
Görevlendiricinin bir programı sonlandırıp diğerini başlatması için
gereken süre
Operating System Concepts with Java – 8 5.9 Silberschatz, Galvin and Gagne ©2009 th Edition
Zamanlama Kriterleri
 İşlemci kullanımı (CPU utilization) – İşlemciyi olabildiğince meşgul
tutmak
 Üretilen iş (throughput) – birim zamanda çalışması sonlanan
işlemlerin sayısı
 Devir zamanı (turnaround time) – bir işlem sonlanana kadar geçen
toplam zaman
 Bekleme zamanı (waiting time) – bir işlemin hazır kuyruğunda (ready
queue) toplam bekleme zamanı
 Yanıt süresi (response time) – bir isteğin gönderilmesi ile bu isteğinn
yanıtının verilmesi arasında geçen zaman
Operating System Concepts with Java – 8 5.10 Silberschatz, Galvin and Gagne ©2009 th Edition
Zamanlama Algoritması Optimizasyon Kriterleri
 Maksimum işlemci kullanımı (Max CPU utilization)
 Maksimum üretilen iş (Max throughput)
 Minimum devir zamanı (Min turnaround time)
 Minimum bekleme zamanı (Min waiting time)
 Minimum yanıt süresi (Min response time)
Operating System Concepts with Java – 8 5.11 Silberschatz, Galvin and Gagne ©2009 th Edition
İlk Gelen Önce – İşlemci Zamanlama Algoritması
İşlem İşlem Süresi
P1 24
P2 3
P3 3
 İşlemleri şu sırada geldiğini varsayalım: P1
, P2
, P3
Zamanlama için Gantt şeması:
 Bekleme zamanları: P1 = 0; P2 = 24; P3 = 27
 Ortalama bekleme zamanı: (0 + 24 + 27)/3 = 17
P1 P2 P3
0 24 27 30
First-Come, First-Served (FCFS) Scheduling
Operating System Concepts with Java – 8 5.12 Silberschatz, Galvin and Gagne ©2009 th Edition
İlk Gelen Önce (Devam)
İşlemleri şu sırada geldiğini varsayalım:
P2
, P3
, P1
 Zamanlama için Gantt şeması:
 Bekleme zamanları: P1 = 6; P2 = 0; P3 = 3
 Ortalama bekleme zamanı: (6 + 0 + 3)/3 = 3
 Önceki durumdan çok daha iyi
 Konvoy etkisi (convoy effect): kısa işlemler uzun işlemlerin
arkasında
P2 P3 P1
0 3 6 30
Operating System Concepts with Java – 8 5.13 Silberschatz, Galvin and Gagne ©2009 th Edition
En Kısa İş Önce - İşlemci Zamanlama Algoritması
 Shortest-Job-First (SJF)
 Her işlemi sonraki işlemci kullanım süresi ile ilişkilendirilmeli
 Bu kullanım sürelerini kullanarak en kısa sürecek iş önce seçilmeli
 SJF optimal zamanlama algoritmasıdır – verilen bir iş kümesi için
minimum ortalama bekleme süresini sağlar
 Zorluk, işlemci kullanım sürelerini tahmin etmektir
Operating System Concepts with Java – 8 5.14 Silberschatz, Galvin and Gagne ©2009 th Edition
SJF Örneği
İşlem Arrival Time İşlem Süresi
P1 0.0 6
P2 2.0 8
P3 4.0 7
P4 5.0 3
 SJF zamanlama şeması
 Ortalama bekleme zamanı = (3 + 16 + 9 + 0) / 4 = 7
P4 P1 P3
0 3 9 16
P2
24
Operating System Concepts with Java – 8 5.15 Silberschatz, Galvin and Gagne ©2009 th Edition
İşlemci Kullanım Süresinin Belirlenmesi
 Sadece tahmin edilebilir
 Daha önceki işlemci kullanım süreleri kullanılarak üssel ortalama
(exponential averaging) yöntemiyle tahmin edilebilir
4. Define :
3. , 0 1
2. predicted value for the next CPU burst
1. actual length of CPU burst
 



 
 n 1
th tn n
1  .
n 1 n n
   t   

Operating System Concepts with Java – 8 5.16 Silberschatz, Galvin and Gagne ©2009 th Edition
Üssel Ortalama ile Kullanım Süresi Belirleme
 n1
 t
n
 1 n
 (t
n
 n
)/ 2
Operating System Concepts with Java – 8 5.17 Silberschatz, Galvin and Gagne ©2009 th Edition
Üssel Ortalama Örnekleri
  =0
 n+1 = n
 Yakın zaman bilgisi kullanılmıyor
  =1
 n+1 =  tn
 Sadece son CPU kullanım bilgisi hesaba katılıyor
 Formülü genişletirsek:
n+1 =  tn+(1 - ) tn-1 + …
+(1 -  )
j  tn-j + …
+(1 -  )
n +1 0
 Hem  hem de (1 - ) 1 veya birden küçük olduğundan, her bir takip
eden terim, kendinden önce gelen terimden daha az ağırlığa sahip
Operating System Concepts with Java – 8 5.18 Silberschatz, Galvin and Gagne ©2009 th Edition
Öncelik Tabanlı - İşlemci Zamanlama Algoritması
 Priority Scheduling
 Her bir işleme bir öncelik sayısı (tamsayı) atanır
 İşlemci en öncelikli işleme verilir (en küçük tamsayı  en yüksek
öncelik)
 Kesen (preemptive)
 Kesmeyen (nonpreemptive)
 SJF, öncelik tahmini kullanım süresi olmak kaydıyla, öncelik tabanlı bir
işlemci zamanlaması algoritmasıdır
 Problem  açlık (starvation) – düşük öncelikli işlemler hiçbir zaman
çalışmayabilir
 Çözüm  yaşlandırma (aging) – taman geçtikçe bekleyen işlemlerin
önceliğini arttırma
Operating System Concepts with Java – 8 5.19 Silberschatz, Galvin and Gagne ©2009 th Edition
Zaman Dilimli - İşlemci Zamanlama Algoritması
 Round Robin (RR)
 Her bir işlem işlemci zamanının küçük bir birimini alır: zaman
kuantumu (time quantum)
 Genellikle 10-100 millisaniye
 Bu zaman dolduğunda işlem kesilir ve hazır kuyruğunun sonuna
eklenir
 Eğer hazır kuyruğunda n tane işlem varsa ve zaman kuantumu q
ise, her bir işlem CPU zamanının 1/n kadarını (en fazla q birimlik
zamanlar halinde) ve hiç bir işlem (n-1)q zaman biriminden fazla
beklemez
 Performans
 q büyükse ilk gelen önce (FIFO)
 q küçükse  q ortam değiştirme süresine oranla daha büyük
olmalıdır. Aksi halde sistem verimsiz çalışır
Operating System Concepts with Java – 8 5.20 Silberschatz, Galvin and Gagne ©2009 th Edition
Zaman Kuantum = 4 olduğunda RR
İşlem İşlem Süresi
P1 24
P2 3
P3 3
 Gantt şeması:
 Tipik olarak, SJF’den daha yüksek ortalama devir zamanı, ama
daha iyi yanıt süresi
P1 P2 P3 P1 P1 P1 P1 P1
0 4 7 10 14 18 22 26 30
Operating System Concepts with Java – 8 5.21 Silberschatz, Galvin and Gagne ©2009 th Edition
Zaman Kuantumu ve Ortam Değiştirme Süresi
Operating System Concepts with Java – 8 5.22 Silberschatz, Galvin and Gagne ©2009 th Edition
Devir Zamanı Zaman Kuantumu ile Değişir
Operating System Concepts with Java – 8 5.23 Silberschatz, Galvin and Gagne ©2009 th Edition
Çok kuyruklu - İşlemci Zamanlama Algoritması
 Multilevel Queue
 Hazır kuyruğuReady birden fazla kuyruğa bölünür:
ön plan (foreground – interaktif (interactive)
arka plan (background) – toplu iş (batch)
 Her kuyruk kendine ait işlemci zamanlama algoritmasına sahiptir
 ön plan – RR
 arka plan – FCFS
Operating System Concepts with Java – 8 5.24 Silberschatz, Galvin and Gagne ©2009 th Edition
Çok kuyruklu (devam)
 Zamanlama kuyruklar arasında yapılmalıdır
 Sabit öncelikli zamanlama (fixed priority scheduling)
 Örn: önce tüm ön plan işlerini çalıştırıp ardından arka plan işlerini
çalıştırmak. Olası açlık (starvation)
 Zaman dilimi – her kuyruk CPU’nun belirli bir zamanını kendi
işlemlerine verebilir
 Örn: CPU’nun %80 zamanı RR ile ön plan işlerine %20’si ise FCFS
ile arka plan işlerine ayrılabilir
Operating System Concepts with Java – 8 5.25 Silberschatz, Galvin and Gagne ©2009 th Edition
Çok Kuyruklu Zamanlama
Operating System Concepts with Java – 8 5.26 Silberschatz, Galvin and Gagne ©2009 th Edition
Çok-seviye Geri Besleme Kuyruğu
 Multilevel Feedback Queue
 İşlemler kuyruklar arasında yer değiştirebilir; yaşlanma (aging) bu
şekilde gerçekleştirilebilir
 Çok-seviye geri besleme kuyruğu zamanlayıcısı aşağıdaki
parametrelerle tanımlanır:
 Kuyrukların sayısı
 Her bir kuyruk için zamanlama algoritması
 Bir işlemin üst kuyruğa ne zaman alınacağını belirleme yöntemi
 Bir işlemin alt kuyruğa ne zaman alınacağını belirleme yöntemi
 Bir işlem çalıştırılmak için seçildiğinde hangi kuyruğa alınacağını
belirleyen yöntem
Operating System Concepts with Java – 8 5.27 Silberschatz, Galvin and Gagne ©2009 th Edition
Çok-seviye Geri Besleme Kuyruğu Örneği
 Üç kuyruk:
 Q0 – zaman kuantumu 8 milisaniye olan RR
 Q1 – zaman kuantumu 16 milisaniye olan RR
 Q2 – FCFS
 Zamanlama
 Yeni işler Q0 kuyruğuna eklenir ve FCFS ile yönetilir
 CPU’yu elde ettiğinde bu işe 8 milisaniye verilir. Eğer 8
milisaniyede sonlanmazsa Q1 kuyruğuna alınır
 İş Q1 kuyruğunda yeniden zamanlanır. Sıra ona geldiğinde 16
milisaniye ek süre verilir. Hala sonlanmazsa, çalışması kesilir ve Q2
kuyruğuna alınır ve burada FCFS yöntemiyle zamanlanır
Operating System Concepts with Java – 8 5.28 Silberschatz, Galvin and Gagne ©2009 th Edition
Çok-seviye Geri Besleme Kuyruğu
Operating System Concepts with Java – 8 5.29 Silberschatz, Galvin and Gagne ©2009 th Edition
İş Parçacığı Zamanlaması
 Kullanıcı-seviyesi ve çekirdek-seviyesi iş parçacıkları arasında ayrım
 Çoktan-teke ve çoktan-çoka modellerde, iş parçacaığı kütüphanesi
kullanıcı seviyesi iş parçacıklarını LWP üzerinde sırayla çalışacak
şekilde zamanlar
 İşlem içerisinde zamanlama rekabeti olduğundan işlem-çekişme
alanı olarak adlandırılır
 process-contention scope (PCS)
 Çekirdek seviyesi iş parçacıkları ise sistemdeki tğm diğer iş
parçacıkları ile zamanlama rekabeti içinde olduğundan sistem
çekişme alanı olarak adlandırılır
 system-contention scope (SCS)
Operating System Concepts with Java – 8 5.30 Silberschatz, Galvin and Gagne ©2009 th Edition
Pthread Zamanlaması
 Pthread API’si, iş parçacığı oluşturulurken, zamanlamanın PCS veya
SCS olarak ayarlanmasına izin verir
 PTHREAD_SCOPE_PROCESS, iş parçacıklarını PCS ile
zamanlar
 PTHREAD_SCOPE_SYSTEM ise iş parçacıklarını SCS ile
zamanlar
Operating System Concepts with Java – 8 5.31 Silberschatz, Galvin and Gagne ©2009 th Edition
Pthread Scheduling API
#include <pthread.h>
#include <stdio.h>
#define NUM THREADS 5
int main(int argc, char *argv[])
{
int i;
pthread_t tid[NUM THREADS];
pthread_attr_t attr;
/* get the default attributes */
pthread_attr_init(&attr);
/* set the scheduling algorithm to PROCESS or SYSTEM */
pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
/* set the scheduling policy - FIFO, RT, or OTHER */
pthread_attr_setschedpolicy(&attr, SCHED_OTHER);
/* create the threads */
for (i = 0; i < NUM THREADS; i++)
pthread_create(&tid[i],&attr,runner,NULL);
Operating System Concepts with Java – 8 5.32 Silberschatz, Galvin and Gagne ©2009 th Edition
Pthread Scheduling API
/* now join on each thread */
for (i = 0; i < NUM THREADS; i++)
pthread_join(tid[i], NULL);
}
/* Each thread will begin control in this function */
void *runner(void *param)
{
printf("I am a thread\n");
pthread exit(0);
}
Operating System Concepts with Java – 8 5.33 Silberschatz, Galvin and Gagne ©2009 th Edition
İşletim Sistemi Örnekleri
 Solaris zamanlaması
 Windows XP zamanlaması
 Linux zamanlaması
Operating System Concepts with Java – 8 5.34 Silberschatz, Galvin and Gagne ©2009 th Edition
Solaris Zamanlaması
 Öncelik tabanlı zamanlama kullanılmakta
 Altı zamanlama sınıfı var
 Zaman paylaşımlı – time sharing (TS)
 İnteraktif – interactive (IA)
 Gerçek zamanlı – real time (RT)
 Sistem – system (SYS)
 Adil paylaşım – fair share (FSS)
 Sabit öncelik – fixed priority (FP)
Operating System Concepts with Java – 8 5.35 Silberschatz, Galvin and Gagne ©2009 th Edition
Solaris Zamanlama Sınıfları
Operating System Concepts with Java – 8 5.36 Silberschatz, Galvin and Gagne ©2009 th Edition
Görev Tablosu: Dispatch Table
Solaris’teki interaktif ve zaman paylaşımlı iş parçacıkları için
Operating System Concepts with Java – 8 5.37 Silberschatz, Galvin and Gagne ©2009 th Edition
Windows XP Zamanlaması
 Öncelik tabanlı ve kesen (preemptive) zamanlama algoritması
 En yüksek öncelikli iş parçası her zaman çalışıyor
 Çalışan bir iş parçacığı aşağıdaki şartlardan biri sağlanmadığı
sürece çalışıyor
 Normal şekilde sonlanma
 Zaman kuantumunun bitmesi
 Bloklayan bir sistem çağrısı yapılması (örneğin I/O)
 Yüksek öncelikli bir iş parçacığının çalışmaya hazır olması
Operating System Concepts with Java – 8 5.38 Silberschatz, Galvin and Gagne ©2009 th Edition
Windows XP Zamanlaması
 Çok seviyeli öncelik mekanizması – Yüksek seviye daha fazla
öncelikli
 İki temel sınıfa ayrılıyor
 Değişken öncelik sınıfı (1-15)
 Gerçek-zaman sınıfı (16-31)
 Değişken öncelik sınıfındaki iş parçacıklarının öncelikleri
çalışırken değiştirilebiliyor
 WIN32’de tanımlı öncelik sınıfları:
 REALTIME_PRIORITY_CLASS
 HIGH_PRIORITY_CLASS
 ABOVE_NORMAL_PRIORITY_CLASS
 NORMAL_PRIORITY_CLASS
 BELOW_NORMAL_PRIORITY_CLASS
 IDLE_PRIORITY_CLASS
Operating System Concepts with Java – 8 5.39 Silberschatz, Galvin and Gagne ©2009 th Edition
Windows XP Zamanlaması
 Belli bir öncelik sınıfındaki iş parçacığı aynı zamanda bu sınıf
içerisinde tanımlı bir bağıl önceliğe sahip
 Bağıl öncelik değerleri
 TIME_CRITICAL
 HIGHEST
 ABOVE_NORMAL
 NORMAL
 BELOW_NORMAL
 LOWEST
 IDLE
Operating System Concepts with Java – 8 5.40 Silberschatz, Galvin and Gagne ©2009 th Edition
Windows XP Öncelikleri
Operating System Concepts with Java – 8 5.41 Silberschatz, Galvin and Gagne ©2009 th Edition
Linux Zamanlaması
 Linux çekirdeği 2.5 versiyonla birlikte gelen zamanlayıcı,
sistemdeki iş parçacığı sayısından bağımsız olarak sabit zamanda
çalışıyor - O(1) zamanlama süresi
 Öncelik tabanlı ve kesen (preemptive) zamanlama algoritması
 İki öncelik aralığı: zaman paylaşımlı (time-sharing) ve gerçek
zamanlı (real-time)
 Gerçek zamanlı öncelik aralığı: 0’dan 99’a
 Zaman paylaşımlı (nice) öncelik aralığı: 100’den 140’a
 Diğer işletim sistemlerindeki (örn: solaris ve windows xp)
zamanlayıcılardan farklı olarak
 Düşük öncelikli iş parçacıklarına daha az ve
 Yüksek öncelikli iş parçacıklarını daha çok zaman kuantumu
veriyor
Operating System Concepts with Java – 8 5.42 Silberschatz, Galvin and Gagne ©2009 th Edition
Öncelikler ve Zaman Kuantumu
Operating System Concepts with Java – 8 5.43 Silberschatz, Galvin and Gagne ©2009 th Edition
Aktif ve Süresi Dolmuş Dizileri
 Linux’de çalıştırılabilir işlerden zaman kuantumu dolmamış olanlara
öncelik verilir
 Bu amaçla iki öncelik dizisi kullanılır:
 Aktif (active)
 Süresi dolmuş (expired)
 Aktif dizisinde, zaman kuantumu henüz dolmamış ve çalışmaya
hazır işler tutulmaktadır
 Zamanlayıcı öncelikli işlerden başlayarak bu dizideki işleri çalıştırır
 Zaman kuantumu dolan işler süresi dolmuş dizisine aktarılır
 Aktif dizide çalışmaya hazır iş parçacığı kalmadığında, aktif ve
süresi dolmuş dizileri yer değiştirir
Operating System Concepts with Java – 8 5.44 Silberschatz, Galvin and Gagne ©2009 th Edition
Önceliklere Göre Listelenmiş Görevler
Operating System Concepts with Java – 8 5.45 Silberschatz, Galvin and Gagne ©2009 th Edition
Java İş Parçacığı Zamanlaması
 Java sanal makinası (JVM) da öncelik tabanlı zamanlama algoritması
kullanır
 Spesifikasyon kesen (preemptive) bir algoritma kullanmayı zorunlu
kılmamıştır
 JVM gerçekleştirimine bırakılmıştır
 O nedenle, bazı JVM’lerde az öncelikli bir iş parçacığı, yeni bir
öncelikli iş parçacığı gelse dahi, çalışmaya devam edebilir
 Aynı önceliğie sahip iş parçacıkları, FIFO kuyrukları aracılığı ile
yönetilir
Operating System Concepts with Java – 8 5.46 Silberschatz, Galvin and Gagne ©2009 th Edition
Zaman Dilimleme
 Spesifikasyon zaman dilimlemeyi zorunlu kılmamıştır
 Bu yüzden çalışan iş parçacıklarının CPU kontrolünü devredebilmesi
için yield() metodu sağlanmıştır
while (true) {
// perform CPU-intensive task
. . .
Thread.yield();
}
 Bu metot, CPU kontrolünü aynı önceliğe sahip başka bir iş parçacığına
bırakır
Operating System Concepts with Java – 8 5.47 Silberschatz, Galvin and Gagne ©2009 th Edition
İş Parçacığı Öncelikleri
Öncelik Yorum
Thread.MIN_PRIORITY Minimum İş Parçacığı Önceliği
Thread.MAX_PRIORITY Maksimum İş Parçacığı Önceliği
Thread.NORM_PRIORITY Varsayılan İş Parçacığı Önceliği
Öcelikler setPriority() metodu kullanılarak değiştirilebilir:
Thread.currentThread().setPriority(Thread.NORM_PRIORITY + 2);
Operating System Concepts with Java – 8 5.48 Silberschatz, Galvin and Gagne ©2009 th Edition
Algoritma Değerlendirmesi
 Belli bir sistem için hangi işlemci zamanlama algoritmasını
seçmeliyiz?
 Pek çok algoritma ve bu algoritmaların pek çok parametresi var
 Öncelikle değerlendirme kriteri belirlenmeli – işlemci kullanımı,
bekleme zamanı …
 Örnek: İşlemci kullanımını maksimize ederken, cevap zamanını
bir saniyenin altında tutmak
 Deterministik modelleme (deterministic modeling) – ön tanımlı bir
iş yükünü alıp her bir algoritmanın performansını bu iş yükü
açısından değerlendirmek
 Kuyruklama Modelleri (queueing models)
Operating System Concepts with Java – 8 5.49 Silberschatz, Galvin and Gagne ©2009 th Edition
Kuyruklama Modelleri
 Pek çok sistemde işlem karakteristikleri günden güne değişiklik
gösterir
 Ancak CPU ve I/O işlem sıklıklarının istatistiksel dağılımları
çıkarılabilir
 Bu işlem sıklıkları gerçek sistemlerde ölçülebilir ve dağılımları
belirlenebilir
 Benzer şekilde, işlemlerin sisteme giriş zamanlarının dağılımını da
belirleyebiliriz
 Bu iki dağılımı kullanarak pek çok algoritma için ortalama olarak
 işlemci kullanımı,
 üretilen iş,
 bekleme zamanı hesaplanabilir
 Dezavantaj: Matematiksel olarak analiz edilebilir olan zamanlama
algoritması çok sınırlı
Operating System Concepts with Java – 8 5.50 Silberschatz, Galvin and Gagne ©2009 th Edition
Simülasyonlar
 Simülasyonları çalıştırmak için bilgisayar sisteminin bir modelinin
programlanması gerekir
 Yazılımdaki veri tipleri sistemin temel bileşenlerini gerçekleştirir
 Simülatör, sistem saati fonksiyonunu gören bir değişkene sahiptir
 Bu değişken her arttırıldığında, cihazların, işlemlerin ve
zamanlayıcının aktivitelerine bağlı olarak sistem durumu güncellenir
 Simülasyonun çalışması için gerekli olan veri, aşağıdaki gibi
dağılımları kullanan bir rastgele sayı üreticisi ile üretilir
 Yeni işlem üretim zamanı
 İşlemin CPU ve I/O kullanım süreleri
 Dağılımlar belli istatistiksel dağılımlara (normal veya poisson
dağılımı gibi) uygun şekilde veya deneysel olarak tanımlanabilir
Operating System Concepts with Java – 8 5.51 Silberschatz, Galvin and Gagne ©2009 th Edition
İz Kasetleri
 Yukarıdaki frekans dağılımları her bir olaydan kaç tane oluşacağını
belirtir
 Olayların hangi sırada gerçekleşeceğini belirtmez
 Sırayı belirlemek için iz kasetleri (trace tapes) kullanılır
 İz kasetleri, gerçek sistemlerde gerçekleşen olayların sırası
kaydedilerek oluşturulur
Operating System Concepts with Java – 8 5.52 Silberschatz, Galvin and Gagne ©2009 th Edition
Simülasyon ile Zamanlama Algoritmalarının Değerlendirilmesi
Operating System Concepts with Java – 8 6.1 Silberschatz, Galvin and Gagne ©2009 th Edition
Bölüm 6: İşlem Senkronizasyonu (1)
Operating System Concepts with Java – 8 6.2 Silberschatz, Galvin and Gagne ©2009 th Edition
İşlem Senkronizasyonu
 Arkaplan Bilgisi
 Kritik-kısım Problemi
 Peterson Çözümü
 Senkronizasyon Donanımı
 Semaforlar
 Senkronizasyonun Klasik Problemleri
 Monitörler
 Senkronizasyon Örnekleri
 Atomik İşlemler
Operating System Concepts with Java – 8 6.3 Silberschatz, Galvin and Gagne ©2009 th Edition
Hedefler
 Kritik-kısım problemini tanıtmak
 Kritik-kısım problemine hem yazılım hem de donanım tabanlı çözümler
sunmak
 Kritik-kısım problemi çözümlerinin paylaşılan verinin tutarlılığını nasıl
sağladığını irdelemek
 Atomik işlem kavramını tanıtmak ve atomikliği sağlayan mekanizmaları
açıklamak
Operating System Concepts with Java – 8 6.4 Silberschatz, Galvin and Gagne ©2009 th Edition
Arkaplan Bilgisi
 Paylaşılan veriye aynı anda erişim veride tutarsızlıklara neden
olabilir
 Verinin tutarlılığını korumak, veriye ortak erişen işlemlerin veriye
erişimlerini sıraya sokan bir mekanizmayı gerektirir
 Üretici-tüketici probleminde tüm tampon belleği dolduracak bir
çözüm sunmak istediğimizi varsayalım
 Bunu dolu bellek hücrelerini saymakta kullanacağımız count adında
bir tamsayı sayaç ile sağlayabiliriz
 Başlangıçta count sıfıra eşitlenecektir
 Üretici yeni bir tampon bellek hücresini doldurduğunda count bir
artacaktır
 Tüketici bir tampon bellek hücresindeki veriyi tükettiğinde ise
count bir azalacaktır
Operating System Concepts with Java – 8 6.5 Silberschatz, Galvin and Gagne ©2009 th Edition
Üretici
while (count == BUFFER.SIZE)
; // do nothing
// add an item to the buffer
buffer[in] = item;
in = (in + 1) % BUFFER.SIZE;
++count;
Operating System Concepts with Java – 8 6.6 Silberschatz, Galvin and Gagne ©2009 th Edition
Tüketici
while (count == 0)
; // do nothing
// remove an item from the
buffer item = buffer[out];
out = (out + 1) % BUFFER.SIZE;
--count;
Operating System Concepts with Java – 8 6.7 Silberschatz, Galvin and Gagne ©2009 th Edition
Yarışma Durumu - Örnek
 count++ şu şekilde gerçekleştirilebilir
register1 = count
register1 = register1 + 1
count = register1
 count-- şu şekilde gerçekleştirilebilir
register2 = count
register2 = register2 - 1
count = register2
 “count = 5” iken aşağıdaki işlemlerin gerçekleştiğini varsayın:
T0: üreticinin çalıştırdığı kod: register1 = count {register1 = 5}
T1: üreticinin çalıştırdığu kod: register1 = register1 + 1 {register1 = 6}
T2: tüketicinin çalıştırdığu kod: register2 = count {register2 = 5}
T3: tüketicinin çalıştırdığu kod: register2 = register2 - 1 {register2 = 4}
T4: üreticinin çalıştırdığı kod: count = register1 {count = 6 }
T5: tüketicinin çalıştırdığu kod: count = register2 {count = 4}
Operating System Concepts with Java – 8 6.8 Silberschatz, Galvin and Gagne ©2009 th Edition
Yarışma Durumu - Tanım
 Pek çok işlemin aynı anda bir veriye erişmek ve onu değiştirmek istediği
durumlarda işlemlerin çalışması sonucu elde edilen sonucun işlemlerin
veriye eriştiği sıraya bağlı olduğu durumlara yarışma durumları (race
condition) denir
 Yarışma durumunda tutarlı sonuç elde etmek için, count değişkenine aynı
anda sadece bir işlemin erişmesini sağlamalıyız. Bu da işlemlerin
senkronizasyonu ile mümkündür
 Yarışma durumları işletim sistemlerinde çok karşılaşılan bir durumdur
 Bunun nedeni kaynakların (örn: hafıza, I/O cihazları) pek çok bileşen
tarafından paylaşılıyor olmasıdır
 Çok çekirdekli işlemcilerin ve iş parçacıklarının kullanımı da durumu
giderek daha karmaşık hale getirmektedir
Operating System Concepts with Java – 8 6.9 Silberschatz, Galvin and Gagne ©2009 th Edition
Kritik-kısım Problemi
 n tane işlemin olduğu bir sistem düşünelim
 Her bir işlemin bir kısım kodunun aşağıdaki işlemlerden birini yapan bir
kritik-kısıma sahip olduğunu düşünün
 Ortak bir değişkenin değerini değiştiren
 Ortak bir tabloyu güncelleyen
 Ortak kullanılan bir dosyayı güncelleyen
 Böyle bir sistemin tutarlı sonuç üretmesi için kritik-kısıma erişimi, aynı
anda bir işlemin erişebileceği şekilde sınırlandırmalıyız
Operating System Concepts with Java – 8 6.10 Silberschatz, Galvin and Gagne ©2009 th Edition
Kritik-kısım Problemine Çözüm
Kritik-kısım problemine önerilen çözüm aşağıdaki kriterleri sağlamalıdır:
1.Karşılıklı Dışlama (mutual exclusion) – Eğer işlem Pi kritik kısımda
çalışıyorsa, diğer işlemler kritik kısımda çalışamaz
2.İlerleme (progress) – Eğer kritik kısımda çalışan bir işlem yoksa ve bazı
işlemler kritik kısımda çalışmak istiyorsa, bu işlemlerden birini seçip
çalıştırmak sonsuza kadar ertelenmemelidir
3.Sınırlı Bekleme (bounded waiting) - Kritik kısma girmek isteyen bir
işlemin bekleme süresi sınırlandırılmalıdır. O işlem beklerken, diğer
işlemlerden en fazla belirlenen sayıda işlem kritik kısıma girmelidir.
Ardından bekleyen işlemin kritik kısma girmesine izin verilmelidir.
 Her bir işlemin sıfır dışında bir hızda çalıştığı varsayılmaktadır
 Bu N işlemin bağıl hızları hakkında herhangi bir varsayımımız
yoktur
Operating System Concepts with Java – 8 6.11 Silberschatz, Galvin and Gagne ©2009 th Edition
Tipik Bir İşlemin Yapısı
Operating System Concepts with Java – 8 6.12 Silberschatz, Galvin and Gagne ©2009 th Edition
Peterson’un Çözümü
 İki işlem çözümü
 LOAD ve STORE koutlarının atomik olduğunu varsayın
 Bu iki işlem iki değişken paylaşır:
 int turn;
 boolean flag[2]
 turn değişkeni kritik kısma giriş sırasının kimde olduğunu belirtiyor
 flag dizisi bir işlemin kritik kısma girişe hazır olup olmadığını belirtiyor.
flag[i] = true Pi
işlemininhazır olduğunu gösteriyor
Operating System Concepts with Java – 8 6.13 Silberschatz, Galvin and Gagne ©2009 th Edition
while (true) {
flag[i] = true;
turn = j;
while (flag[j] && turn == j);
critical section
flag[i] = false;
remainder section
}
Pi
İşlemi için Algoritma
Dikkat: j = 1 - i
Operating System Concepts with Java – 8 6.14 Silberschatz, Galvin and Gagne ©2009 th Edition
Kilitleri Kullanarak Kritik-kısım Problemi Çözümü
while (true) {
acquire lock
critical section
release lock
remainder section
}
• Yazılım tabanlı çözümlerin (Peterson’un algoritması gibi)
modern bilgisayar mimarilerinde çalışmasının garantisi yoktur.
• Genel olarak kritik-kısım problemini çözmek için küçük bir
araca ihtiyacımız olduğunu söyleyebiliriz: kilit (lock)
Operating System Concepts with Java – 8 6.15 Silberschatz, Galvin and Gagne ©2009 th Edition
Senkronizasyon Donanımı
 Kritik-kısım problemi icin pek çok sistem donanım desteği
sunmaktadır
 Tek işlemcili sistemler – geçici olarak kesintileri (interrupts) iptal
edebilirler
 O an çalışan kod bölünmeden çalışmaya devam edebilir
 Genel olarak çok işlemcili bilgisayarlarda verimli değildir -
işlemciler arasında mesajlaşma gerektirir
 Bu özelliği kullanan işletim sistemleri ölçeklenebilir değildir
 Modern makinalar özel atomik donanım komutları sağlarlar
 Atomik = kesilmeyen (non-interruptable)
 Hafıza hücresinin değerini değiştirir veya test eder
 Veya iki hafıza hücresinin değiş tokuş eder
Operating System Concepts with Java – 8 6.16 Silberschatz, Galvin and Gagne ©2009 th Edition
Donanım Çözümleri için Veri Yapısı
Operating System Concepts with Java – 8 6.17 Silberschatz, Galvin and Gagne ©2009 th Edition
GetAndSet Komutu ile Çözüm
Operating System Concepts with Java – 8 6.18 Silberschatz, Galvin and Gagne ©2009 th Edition
Swap Komutu ile Çözüm
Operating System Concepts with Java – 8 6.19 Silberschatz, Galvin and Gagne ©2009 th Edition
Semafor (Semaphore)
 Meşgul bekleme (busy waiting) gerektirmeyen senkronizasyon aracı
 Semafor S – tamsayı değişken
 S üzerinde iki standard işlem : acquire() ve release()
 Orijinal olarak P() ve V()
 Daha az karmaşık
 Sadece iki atomik işlem ile erişilebiliyor
Operating System Concepts with Java – 8 6.20 Silberschatz, Galvin and Gagne ©2009 th Edition
Semafor Genel Senkronizasyon Aracı
 Sayaç semaforu (counting semaphore) – tamsayı değeri sınırsız
bir değer aralığına sahiptir
 İkili semafor (binary semaphore) – tamsayı değeri sadece 0 ya da
1 değerlerini alabilir; gerçekleştirimi daha basit olabilir
 mutex lock olarak da bilinir:
Operating System Concepts with Java – 8 6.21 Silberschatz, Galvin and Gagne ©2009 th Edition
Java ile Semafor Kullanımı (1)
Operating System Concepts with Java – 8 6.22 Silberschatz, Galvin and Gagne ©2009 th Edition
Java ile Semafor Kullanımı (2)
Operating System Concepts with Java – 8 6.23 Silberschatz, Galvin and Gagne ©2009 th Edition
Semafor Gerçekleştirimi
 acquire () ve release () komutlarını iki ayrı işlemin aynı anda
çalıştırması engellenmelidir
 Mevcut gerçekleştirim meşgul bekleme (busy waiting) yapıyor
 Uygulamaların kritik kısımda çok fazla zaman harcayabileceğine
dikkat edin
 Böyle bir durumda meşgul bekleme yapan semafor uygun bir
gerçekleştirim değildir
Operating System Concepts with Java – 8 6.24 Silberschatz, Galvin and Gagne ©2009 th Edition
Meşgul Bekleme Yapmayan Semafor
Gerçekleştirimi (1)
 Her bir semafor ile bir bekleme listesi ilişkilendirilir
 Bekleme listesindeki her bir kayıt aşağıdaki verileri içerir:
 değer (tamsayı tipinde)
 listedeki sonraki kayıda işaretçi
 İki işlem:
 block – bu komutu çalıştıran işlemi uygun bekleme listesine
yerleştirir
 wakeup – bekleme listesinde bulunan bir işlemi listeden siler
ve bekleme kuyruğuna (ready queue) yerleştirir
Operating System Concepts with Java – 8 6.25 Silberschatz, Galvin and Gagne ©2009 th Edition
Meşgul Bekleme Yapmayan Semafor
Gerçekleştirimi (2)
 acquire() gerçekleştirimi:
 release() gerçekleştirimi:
Operating System Concepts with Java – 8 6.26 Silberschatz, Galvin and Gagne ©2009 th Edition
Deadlock and Starvation
 Kilitlenme (Deadlock) – iki vea daha fazla işlem, sadece bekleyen bir
işlemin neden olabileceği bir olayı sonsuza kadar bekliyor
 S ve Q ilk değeri 1 olarak belirlenen iki semafor
 Açlık (Starvation) – sınırsız bloklanma. Semafor bekleme listesinde
bekleyen bir işlemin hiçbir zaman listeden silinmemesi. Örnek: listenin
LIFO (last-in first-out) sırasıyla çalışması
Operating System Concepts with Java – 8 6.27 Silberschatz, Galvin and Gagne ©2009 th Edition
Klasik Senkronizasyon Problemleri
 Sınırlı Tampon Bellek Problemi (Bounded-Buffer Problem)
 Okuyucular -Yazıcılar Problemi (Readers-Writers Problem)
 Yemek Yiyen Filozoflar Problemi (Dining-Philosophers Problem)
Operating System Concepts with Java – 8 6.28 Silberschatz, Galvin and Gagne ©2009 th Edition
Sınırlı Tampon Bellek Problemi
 N tampon bellek, her biri bir şey tutabiliyor
 mutex semaforu, başlangıç değeri 1 – karşılıklı dışlamayı
(mutual exclusion) sağlıyor
 full semaforu, başlangıç değeri 0 – dolu tampon belleklerin
sayısını takıp ediyor
 empty semaforu, başlangıç değeri N – boş tampon belleklerin
sayısını takip ediyor
Operating System Concepts with Java – 8 6.29 Silberschatz, Galvin and Gagne ©2009 th Edition
Sınırlı Tampon Bellek - Factory
Operating System Concepts with Java – 8 6.30 Silberschatz, Galvin and Gagne ©2009 th Edition
Sınırlı Tampon Bellek
Operating System Concepts with Java – 8 6.31 Silberschatz, Galvin and Gagne ©2009 th Edition
Sınırlı Tampon Bellek - insert()
Operating System Concepts with Java – 8 6.32 Silberschatz, Galvin and Gagne ©2009 th Edition
Sınırlı Tampon Bellek - remove()
Operating System Concepts with Java – 8 6.33 Silberschatz, Galvin and Gagne ©2009 th Edition
Sınırlı Tampon Bellek - Producer
Operating System Concepts with Java – 8 6.34 Silberschatz, Galvin and Gagne ©2009 th Edition
Sınırlı Tampon Bellek - Consumer
Operating System Concepts with Java – 8 6.35 Silberschatz, Galvin and Gagne ©2009 th Edition
Okuyucular-Yazıcılar Problemi (1)
 Bir veri kümesi, aynı anda çalışan birden fazla işlem arasında
paylaştırılıyor
 Okuyucular – sadece veriyi okuyorlar, veriyi güncellemiyorlar
 Yazıcılar – hem okuyup hem de yazabiliyorlar
 Problem – aynı anda birden fazla okuyucuya okumak için izin
vermek. Aynı anda sadece bir yazıcının paylaşılan veri kümesine
erişimine izin vermek
 Varyasyon 1 (ilk okuyucular – yazıcılar problemi): Bir yazıcı veriye
erişim hakkını çoktan kazanmış olmadığı sürece, hiçbir okuyucu
beklemez
 Varyasyon 2: Bir yazıcı paylaşılan veriye erişmek istiyorsa, hiçbir
yeni okuyucu paylaşılan veriye erişemez. Yazıcılar öncelikli.
Operating System Concepts with Java – 8 6.36 Silberschatz, Galvin and Gagne ©2009 th Edition
Okuyucular-Yazıcılar Problemi (2)
 Varyasyon 1 için Java’da yazılmış bir çözüm
 Paylaşılan veri
 Veri kümesi
 readerCount tamsayısı, başlangıç değeri 0, okuyucu sayısı
 db semaforu, başlangıç değeri 1, ortak veriye erişimi sınırlandırır
 mutex semaforu, başlangıç değeri 1, readerCount’a erişimi
sınırlandırır ve okuyucuları kendi içinde sıraya sokar
Operating System Concepts with Java – 8 6.37 Silberschatz, Galvin and Gagne ©2009 th Edition
Okuyucular-Yazıcılar – Kilit Arayüzü
 Okuma-yazma kilitleri için arayüz
Operating System Concepts with Java – 8 6.38 Silberschatz, Galvin and Gagne ©2009 th Edition
Okuyucular-Yazıcılar - Yazıcı
Operating System Concepts with Java – 8 6.39 Silberschatz, Galvin and Gagne ©2009 th Edition
Okuyucular-Yazıcılar - Okuyucu
Operating System Concepts with Java – 8 6.40 Silberschatz, Galvin and Gagne ©2009 th Edition
Okuyucular-Yazıcılar - Veritabanı
Operating System Concepts with Java – 8 6.41 Silberschatz, Galvin and Gagne ©2009 th Edition
Okuyucular-Yazıcılar - Okuyucu Metotları
Operating System Concepts with Java – 8 6.42 Silberschatz, Galvin and Gagne ©2009 th Edition
Okuyucular-Yazıcılar - Yazıcı Metotları
Bu çözüm açlığa neden olur mu?
• Varyasyon 1: yazıcılar aç kalabilir
• Varyasyon 2: okuyucular aç kalabilir
Operating System Concepts with Java – 8 6.43 Silberschatz, Galvin and Gagne ©2009 th Edition
Yemek Yiyen Filozoflar Problemi
 Paylaşılan veri
 bir kase pilav (veri kümesi)
 chopStick [5] semaforları, ilk değerleri 1 – yemek çubuğu
Operating System Concepts with Java – 8 6.44 Silberschatz, Galvin and Gagne ©2009 th Edition
Yemek Yiyen Filozoflar – Filozof i
 i ’ninci filozofun yapısı:
Operating System Concepts with Java – 8 6.45 Silberschatz, Galvin and Gagne ©2009 th Edition
Semafor Çözümü Problemleri
 Tüm filozoflar acıkıp aynı anda sol çubuğu alırsa ne olur?
 Kilitlenmeyi (deadlock) önlemek için getirilebilecek kısıtlamalar:
 Aynı anda en fazla 4 filozof yemeğe başlayabilir
 Bir filozof, sadece iki çubuk birden hazırsa, çubukları
alabilir (kritik kısımda gerçekleşmeli)
 Asimetrik bir çözüm kullanmak: Tek numaralı filozoflar önce
sol çubuğu daha sonra sağ çubuğu alırken, çift numaralı
filozoflar önce sağ çubuğu daha sonra sol çubuğu alır
 Monitörler ile problemin kilitlenmeyen çözümü anlatılacak
 Kilitlenmeye (deadlock) neden olmayan bir çözümün açlığa
(starvation) neden olmayacağı garanti değil
 Semaforlar zamanlama hatalarına çok açıktır ve bu tür hatalar
çok nadir ortaya çıkabileceğinden hataların ayıklanması zordur
Operating System Concepts with Java – 8 6.1 Silberschatz, Galvin and Gagne ©2009 th Edition
Bölüm 6: İşlem Senkronizasyonu (2)
Operating System Concepts with Java – 8 6.2 Silberschatz, Galvin and Gagne ©2009 th Edition
İşlem Senkronizasyonu
 Arkaplan Bilgisi
 Kritik-kısım Problemi
 Peterson Çözümü
 Senkronizasyon Donanımı
 Semaforlar
 Senkronizasyonun Klasik Problemleri
 Monitörler
 Senkronizasyon Örnekleri
 Atomik İşlemler
Operating System Concepts with Java – 8 6.3 Silberschatz, Galvin and Gagne ©2009 th Edition
Monitörler
 İşlem senkronizasyonu için rahat ve etkili bir mekanizma sunan
üst seviye soyutlama
 Pek çok programlama dili (Örnek: C# ve Java) monitör
kavramını gerçekleştirmiştir
 Belirli bir zamanda, sadece bir işlem monitor içerisinde aktif
olabilir
 Monitörler içerisinde ortak değişkenler ve fonksiyonlar bulunur
 Ortak verilere erişim kontrol altındaki fonksiyonlar aracılığıyla
sağlanabilir
Operating System Concepts with Java – 8 6.4 Silberschatz, Galvin and Gagne ©2009 th Edition
Monitör Kullanımı
Operating System Concepts with Java – 8 6.5 Silberschatz, Galvin and Gagne ©2009 th Edition
Monitörün Şekilsel Gösterimi
Operating System Concepts with Java – 8 6.6 Silberschatz, Galvin and Gagne ©2009 th Edition
Koşul Değişkenleri
 Koşul değişkenleri (condition variable) monitörleri daha güçlü
hale getiren özel değişkenlerdir
 Koşul değişkeni tanımlama: Condition x, y;
 Bir koşul değişkeni üzerinde iki metot tanımlıdır:
 x.wait () – bu metotu çağıran işlem askıya alınır
 x.signal () – wait metodunu çağırmış işlemlerden (eğer
varsa) birini çalışmaya devam ettirir
Operating System Concepts with Java – 8 6.7 Silberschatz, Galvin and Gagne ©2009 th Edition
Koşul Değişkenleri Olan Bir Monitör
Operating System Concepts with Java – 8 6.8 Silberschatz, Galvin and Gagne ©2009 th Edition
Yemek Yiyen Filozoflar - Monitör Çözümü
 Her bir i filozofu takeForks(i) ve returnForks(i) metotlarını aşağıdaki
sırada çağırır:
dp.takeForks (i) // çubukları al
YEMEK YE (EAT)
dp.returnForks (i) // çubukları bırak
Operating System Concepts with Java – 8 6.9 Silberschatz, Galvin and Gagne ©2009 th Edition
Yemek Yiyen Filozoflar - Monitör Çözümü
Operating System Concepts with Java – 8 6.10 Silberschatz, Galvin and Gagne ©2009 th Edition
Java Senkronizasyonu
 Java dil seviyesinde senksronizasyon sağlar
 Her Java nesnesi ilişkili bir kilite (lock) sahiptir
 Bu kilit synchronized bir metot çağırıldığında elde edilir.
 synchronized metottan çıkıldığındabu kilit iade edilir
 Böylece bir nesne üzerindeki senksronize metotlardan, aynı anda
sadece biri çağırılabilir. Diğer iş parçacıkları bu metot bitmeden önce
senkronize (synchronized) metotlardan birini çalıştıramaz
 Nesne kilitini elde etmek isteyen iş parçacıkları, nesne kilidi için
tanımlı giriş kümesine (entry set) eklenirler.
Operating System Concepts with Java – 8 6.11 Silberschatz, Galvin and Gagne ©2009 th Edition
Java Senkronizasyonu – Giriş Kümesi
 Her bir nesne giriş kümesi (entry set) ile ilişkilendirilir.
Operating System Concepts with Java – 8 6.12 Silberschatz, Galvin and Gagne ©2009 th Edition
Java Senkronizasyonu - Bounded Buffer
Operating System Concepts with Java – 8 6.13 Silberschatz, Galvin and Gagne ©2009 th Edition
BoundedBuffer – Yanlış insert/remove
 Senkronize insert() ve remove() metotları – Yanlış!
Operating System Concepts with Java – 8 6.14 Silberschatz, Galvin and Gagne ©2009 th Edition
insert/remove Neden Yanlış?
 Meşgul bekleme (busy waiting) yok, ancak canlı-kilite (livelock) neden
olabilir
 Üretici, tampon bellek dolu olduğunda veya
 Tüketici, tampon bellek boş olduğunda
 Canlı-kilit, kilitlenmeye (deadlock) benzer. Her ikisi de iki veya daha
fazla iş parçacığının çalışmaya devam etmesine engel olur
 Kilitlenme, bir küme iş parcağındaki tüm iş parçacıklarının, aynı
kümedeki bir iş parçacığının sonuç üretmesini bekleyerek
kilitlenmesidir
 Canlı kilit (livelock) ise bir iş paracığının devamlı olarak çalışmak
istemesi ama bunu başaramamasıdır
Operating System Concepts with Java – 8 6.15 Silberschatz, Galvin and Gagne ©2009 th Edition
Canlı Kilit Senaryosu
 Hatırlatma: JVM iş parçacıklarını öncelik tabanlı olarak (priority based)
zamanlar
 Daha çok öncelikli iş parçacıklarına, daha az öncelikli iş
parçacıklarına göre daha fazla iltimas gösterir
 Eğer üretici (tüketiciye göre) daha fazla öncelikli ise ve tampon bellek
doluysa
 Üretici, while döngüsüne girdiğinde, count değişkeni değeri
azalana kadar yield komutunu çalıştırır
 Ancak üretici daha az öncelikli olduğu için, JVM kontrlü üretici
yerine yeniden tüketiciye verip
 Tüketiciye hiç bir zaman kontrolü devretmeyebilir
 Bu durumda üretici canlı kilit durumunda, tüketicinin tampon belleği
boşaltmasını bekleyecektir
Operating System Concepts with Java – 8 6.16 Silberschatz, Galvin and Gagne ©2009 th Edition
insert/remove Neden Yanlış?
 Üretici ve tüketici tarafından paylaşılan count değişkeni, synchronized
anahtar kelimesi sayesinde yarışma durumuna (race condition) neden
olmamakta – değişkene erişim kontrollü
 Ancak synchronized, kilitlenmeye (deadlock) neden olabilir
 Tampon belleğin dolu olduğunu ve tüketicinin de uyuduğunu
varsayın
 Üretici insert() metotunu çağırırsa, kilit müsait olduğundan, nesne
kilitine sahip olacaktır
 Ancak tampon belleğin dolu olduğunu gördüğünde yield()
metotunu çağırıp CPU kontrolünü elinden bırakacaktır
 Ancak nesne kilidine halen sahiptir
 Tüketici, zamanı geldiğinde remove() metotunu çağırdığında ise,
nesne kilidi sahipli olduğundan bloklanacaktır
 Böylece hem üretici hem de tüketici çalışmaya devam
edemeyecektir: kilitlenme
Operating System Concepts with Java – 8 6.17 Silberschatz, Galvin and Gagne ©2009 th Edition
Java Senkronizasyonu - wait/notify()
 wait() ve notify() metotları bu tür problemlerı çözmemizi sağlar
 Bir iş parçacığı wait() metotunu çağırdığında:
1. İş parçacığı nesne kilidini serbest bırakır;
2. İş parçacığının durumu Blocked’a çevrilir;
3. İş parçacığı nesne içi kullanılan bekleme kümesine (wait set) alınır.
 Bir iş parçacığı notify() metotunu çağırdığında:
1. Bekleme kümesinden herhangi bir iş parçacığı (T) seçilir;
2. T, bekleme kümesinden, giriş kümesine (entry set) alınır;
3. T iş parçacığının durumu Runnable durumuna getirilir.
Operating System Concepts with Java – 8 6.18 Silberschatz, Galvin and Gagne ©2009 th Edition
Giriş ve Bekleme Kümeleri
Operating System Concepts with Java – 8 6.19 Silberschatz, Galvin and Gagne ©2009 th Edition
Wait/notify() Örneği – insert()
 Senkronize insert() metotu – Doğru!
Operating System Concepts with Java – 8 6.20 Silberschatz, Galvin and Gagne ©2009 th Edition
Wait/notify() Örneği – remove()
 Senkronize remove() metotu – Doğru!
Operating System Concepts with Java – 8 6.21 Silberschatz, Galvin and Gagne ©2009 th Edition
Notify() ve notifyAll()
 notify() çağrısı bekleme kümesinden herhangi bir iş parçacığını
seçer
 Seçilen iş parçacığının, beklenilen/istenilen iş parçacığı olmama
ihtimali vardır
 notifyAll() çağrısı bekleme kümesindeki tüm iş parçacıklarını giriş
kümesine taşır
 Genel olarak, notifyAll(), notify()’a göre daha konservatif
(korumalı) bir metottur.
Operating System Concepts with Java – 8 6.22 Silberschatz, Galvin and Gagne ©2009 th Edition
notifyAll Örneği
notify() doğru iş
parcağını
çalıştırmayabilir!
Operating System Concepts with Java – 8 6.23 Silberschatz, Galvin and Gagne ©2009 th Edition
Okuyucular-Yazıcılar - Veritabanı
Operating System Concepts with Java – 8 6.24 Silberschatz, Galvin and Gagne ©2009 th Edition
Okuyucular-Yazıcılar – Okuyucu Metotları
Operating System Concepts with Java – 8 6.25 Silberschatz, Galvin and Gagne ©2009 th Edition
Okuyucular-Yazıcılar – Yazıcı Metotları
Operating System Concepts with Java – 8 6.26 Silberschatz, Galvin and Gagne ©2009 th Edition
Blok Senkronizasyonu
 Blok senskronizasyonu, tüm metodu senkronize yapmak
yerine, kod bloklarını senkronize yapabilmemizi sağlar
Operating System Concepts with Java – 8 6.27 Silberschatz, Galvin and Gagne ©2009 th Edition
Blok Senskronizasyonu – wait/notify
wait()/notify() kullanarak blok senkronizasyonu
Operating System Concepts with Java – 8 6.28 Silberschatz, Galvin and Gagne ©2009 th Edition
Java 5’deki Aynı Anda Kullanım Özellikleri
 Java 5’e kadar, tek aynı anda kullanım (concurrency)
özellikleri synchronized/wait/notify mekanizmalarıydı.
 Java 5 ile birlikte, API’ye yeni özellikler de eklendi:
 Yeniden Girişli Kilitler (reentrant locks)
 Semaforlar (semaphores)
 Koşul değişkenleri (condition variables)
Operating System Concepts with Java – 8 6.29 Silberschatz, Galvin and Gagne ©2009 th Edition
Yeniden Girişli Kilitler
 Synchronized mekanizmasina benzer
 Ancak ek özellikleri vardır – Örneğin adillik (fairness) parametresi
 Adillik parametresi en çok bekleyen iş parçacığına kilitin verilmesini sağlar
 lock() çağırıldığında eğer iş parçacığı kilite zaten sahipse (reenterant!)
veya kilite sahip başka bir iş parçacığı yoksa, çalışmaya devam eder
 Kilit başkasına aitse kilidin serbest bırakılmasını bekler
Operating System Concepts with Java – 8 6.30 Silberschatz, Galvin and Gagne ©2009 th Edition
Semaforlar
Java 5’te sayaç semaforu (counting semaphore)
gerçekleştirilmiştir
Operating System Concepts with Java – 8 6.31 Silberschatz, Galvin and Gagne ©2009 th Edition
Koşul Değişkenleri
 wait/notify mekanizmasına benzer bir mekanizma sunar
 Öncelikle yeniden girişli bir kilit (reentrant lock) oluşturulmalıdır
 Daha sonra bu kilit üzerinden newCondition() metotu
çağırılarak yeni bir koşul değişkeni oluşturulabilir
 Koşul değişkeni oluşturulduktan sonra bu koşul değişkeni
üzerinden await() ve signal() metotları çağırılabilir
Operating System Concepts with Java – 8 6.32 Silberschatz, Galvin and Gagne ©2009 th Edition
Koşul Değişkenleri - Örnek
Operating System Concepts with Java – 8 6.33 Silberschatz, Galvin and Gagne ©2009 th Edition
Senkronizasyon Örnekleri
 Solaris
 Windows XP
 Linux
 Pthreads
Operating System Concepts with Java – 8 6.34 Silberschatz, Galvin and Gagne ©2009 th Edition
Solaris Senkronizasyonu
 İşlem senkronizasyonu için pek çok mekanizmayı desteklemektedir
 Semaforlar
 Uyarlanabilir muteksler (adaptive mutexes) etkin bir şekilde kısa
kod bölümlerini korumak için kullanılır
 Koşul değişkenleri (condition variables) ve okuyucu yazıcı kilitleri
(readers-writers) daha uzun kod bölümlerini korumak gerektiğinde
kullanılır
 Turnstiles: uyarlanabilir muteksleri ve koşul değişkenlerini bekleyen
iş parçacıklarını sıraya sokmak için kullanılan kuyruklardır
Operating System Concepts with Java – 8 6.35 Silberschatz, Galvin and Gagne ©2009 th Edition
Windows XP Senkronizasyonu
 Tek işlemcili sistemlerde, genel kaynaklara erişimi korumak için
kesinti maskelerini (interrupt masks) kullanır
 Spin kilitleri (spinlocks): çok işlemcili sistemlerde senkronizasyonu
sağlayan bir mekanizmadır
 Dağıtıcı nesneler (dispatcher objects): muteks veya semafor gibi
davranabilirler
 Dağıtıcı nesneler olayları (events) da sağlayabilir
 Olaylar aslında koşullu değişkenlerin davranışına benzer
Operating System Concepts with Java – 8 6.36 Silberschatz, Galvin and Gagne ©2009 th Edition
Linux Senkronizasyonu
 Linux:
 Çekirdeğin 2.6 verisyonuna kadar, kısa kritik bölümler için kesintiler
kapatılmaktaydı (iptal edilmekteydi)
 Versiyon 2.6 ve sonrasında sistem tamamen kesilebilir (preemptive)
hale getirildi
 Linux’un sağladığı mekanizmalar:
 semaforlar
 spin kilitleri (spin locks)
Operating System Concepts with Java – 8 6.37 Silberschatz, Galvin and Gagne ©2009 th Edition
Pthreads Senkronizasyonu
 Pthreads API’si işletim sistemi bağımlı
 Aşağıdaki özellikleri sağlar:
 mutex kilitler (mutex locks)
 koşul değişkenleri (condition variables)
 Taşınabilir olmayan (non-portable) eklentiler:
 okuma yazma kilitleri (read-write locks)
 spin kilitleri
Operating System Concepts with Java – 8 6.38 Silberschatz, Galvin and Gagne ©2009 th Edition
Atomik İşlemler
 Sistem Modeli
 Log-tabanlı Log-based Kurtarma
 Kontrol Noktaları (checkpoints)
 Aynı Anda Çalışan Atomik İşlemler
Operating System Concepts with Java – 8 6.39 Silberschatz, Galvin and Gagne ©2009 th Edition
Atomik Faaliyetli Hafıza (Transactional Memory)
 Atomik Faaliyet (transaction): Tek bir mantıksal fonksiyonu atomik
olarak gerçekleştiren komut kümesidir
 Hafıza Atomik Faaliyeti (memory transaction): atomik olan bir dizi
okuma-yazma işlemi.
 Soldaki kod parçasını, sağdaki ile değiştiriyoruz:
 atomic{S} satırı S in bir faaliyet olarak gerçekleşmesini garantiler
Operating System Concepts with Java – 8 6.40 Silberschatz, Galvin and Gagne ©2009 th Edition
Sistem Modeli
 İşlemlerin tek mantıksal iş birimi olarak çalışmasını ya da hiç
çalışmamasını garanti eder
 Veritabanı sistemleri ile ilişkilidir
 Amaç bilgisayar sistemi hatalarına rağmen atomikliği garantilemektir
 Atomik Faaliyet (transaction) - Tek bir mantıksal fonksiyonu
atomik olarak gerçekleştiren komut kümesidir
 Kalıcı kayıt birimine (disk) olan değişikliklerle ilgileniliyor
 Atomik faaliyet bir dizi okuma ve yazma işleminden oluşuyor
 commit (atomik faaliyet başarılı) işlemiyle veya abort (atomik
faaliyet başarısız) işlemiyle sonlanıyor
 Roll back - atomik faaliyet başarısız olduğunda gerçekleşen
değişiklikler geri alınır
Operating System Concepts with Java – 8 6.41 Silberschatz, Galvin and Gagne ©2009 th Edition
Kayıt Birimi Çeşitleri
 Geçici kayıt birimi (volatile storage) – information stored here does not
survive system crashes
 Example: ana hafıza, önbellek
 Kalıcı kayıt birimi (nonvolatile storage) – bilgi genellikle sistem
çakılmalarından başarıyla kurtulur
 Örnek: disk and kaset (tape)
 Güvenilir kayıt birimi (stable storage) – bilgi hiç bir zaman kaybolmaz
 Aslında mümkün değil. RAID cihazları ile veya Not actually possible,
so approximated via kopyalayarak çoğaltma (replication) yoluya
yaklaşık olarak elde edilir
Amaç, atomik faaliyetlerin atomikliğini sistem sorunlarının kalıcı kayıt
biriminde bilgi kaybına neden olduğu durumlarda sağlamaktır
Operating System Concepts with Java – 8 6.42 Silberschatz, Galvin and Gagne ©2009 th Edition
Kayıt (Log) Tabanlı Kurtarma
 Bir atomik faaliyet tarafından yapılan bütün değişiklikler hakkında
bilgiler güvenilir kayıt birimine kaydedilir
 En çok kullanılan: write-ahead logging
 Her bir kayıt atomik faaliyetin tek bir yazma işlemini açıklar
 Atomik faaliyet adı
 Veri elemanı adı
 Eski değer
 Yeni değer
 <Ti starts> Ti başladığında kayıda geçilir
 <Ti commits> Ti
teslim edildiğinde (commit) kayıda geçilir
 Veri üzerindeki asıl işleme başlanmadan önce kayıt girişi yapılmalıdır
Operating System Concepts with Java – 8 6.43 Silberschatz, Galvin and Gagne ©2009 th Edition
Kayıt Tabanlı Kurtarma Algoritması
 Kayıt birimini kullanarak, sistem herhangi bir geçici kayıt birimi hatasını
çözebilir
 Undo(Ti
) Ti
tarafından gerçekleştirilen her tür veri güncellemesini
geri alabilir
 Redo(Ti
) Ti
içerisindeki tüm veri güncellemelerini yeniden
gerçekleştirebilir
 Undo(Ti
) ve redo(Ti
) must be eş kuvvetli (idempotent) olmalıdır
 Çoklu çalıştırmalar tek bir çalıştırmayla aynı sonucu üretmelidir
 Eğer sistem çökerse, güncellenen tüm verileri kayıtları kullanarak eski
haline getir
 Eğer kayıt <Ti commits> olmaksızın <Ti starts> içeriyorsa, undo(Ti
)
 Eğer kayıt <Ti starts> ve <Ti commits> içeriyorsa, redo(Ti
): atomik
faaliyet yeniden gerçekleştirilmeli
Operating System Concepts with Java – 8 6.44 Silberschatz, Galvin and Gagne ©2009 th Edition
Kontrol Noktaları (Checkpoints)
 Kayıtlar çok artarsa, kurtarma çok zaman alabilir
 Kontrol noktaları kayıt sayısını azaltır ve kurtarma zamanını kısaltır
 Kontrol noktası mekanizması:
1. Geçici kayıt birimindeki tüm kayıtları güvenilir kayıt birimine aktar
2. Değişiklik olmuş tüm veriyi geçici kayıt biriminden güvenilir kayıt
birimine aktar
3. <checkpoint> isimli kaydı güvenilir kayıt birimine aktar
 Bu noktada, kurtarma sadece sadece en yakın kontrol noktasından
hemen önce başlayan Ti atomik faaliyetinden başlar ve ondan sonraki
tğm atomik faaliyetleri kapsar.
 Diğer tüm atomik faaliyetler çoktan güvenilir kayıt birimindedir
Operating System Concepts with Java – 8 6.45 Silberschatz, Galvin and Gagne ©2009 th Edition
Atomik Faaliyetlerin Aynı Anda Kullanımı
 Atomik faaliyetlerin aynı anda kullanımı ile sırasıyla kullanımı arasında
sonuç olarak fark olmamalıdır – serileştirilebilirlik (serializability)
 Tüm atomik faaliyetler kritik kısım içerisinde gerçekleştirilebilir
 Verimsiz ve çok fazla kısıtlanmış bir çözüm
 Aynı anda kullanım kontrol algoritmaları (concurrency-control
algorithms) serileştirilebilirliği sağlar
Operating System Concepts with Java – 8 6.46 Silberschatz, Galvin and Gagne ©2009 th Edition
Serileştirilebilirlik
 A ve B adında iki veriyi ele alalım
 T0 ve T1 adında iki atomik faaliyeti ele alalım
 T0 ve T1
‘i atomik olarak çalıştıralım
 Çalışma sırasına tarife (schedule) denir
 Atomik olarak çalıştırılan atomik faaliyet sırasına seri tarife (serial
schedule) denir
 Bir sistemde N atomik faaliyet bulunursa, bu sistemde N! adet geçerli
seri tarife bulunur
Operating System Concepts with Java – 8 6.47 Silberschatz, Galvin and Gagne ©2009 th Edition
Seri Tarife
Operating System Concepts with Java – 8 6.48 Silberschatz, Galvin and Gagne ©2009 th Edition
Seri Olmayan Tarife
Operating System Concepts with Java – 8 6.49 Silberschatz, Galvin and Gagne ©2009 th Edition
Kilitleme Protokolü
 Serileştirilebilirliği her bir veriye bir kilit atayarak sağlamak
 Erişim kontrolü için kilitleme protokolünü takip et
 Kilitler
 Paylaşımlı (Shared) – Ti
, Q verisi üzerinde S paylaşımlı kilidine
sahip. Ti
, Q verisini okuyabiliyor ama Q’ya yazamıyor
 Dışlayıcı (Exclusive) – Ti , Q verisi üzerinde X dışlayıcı kilidine
sahip. Ti
, Q verisini okuyabiliyor ve Q’ya yazabiliyor
 Q üzerindeki her atomik faaliyet, bu faaliyete uygun kilidi elde etmeyi
gerektirir
 Eğer kilit başka bir atomik faaliyet tarafından kullanılıyorsa, yeni istek
beklemelidir
 Okuyucular-yazıcılar algoritmasına benzer şekilde
Operating System Concepts with Java – 8 6.50 Silberschatz, Galvin and Gagne ©2009 th Edition
İki Aşamalı Kilitleme Protokolü
 Two-phase Locking Protocol
 Tüm atomik faaliyetler kilitleme ve kilit açma işlemlerini iki aşamada
gerçekleştirirler
 Growing – kilidi elde etmek
 Shrinking – kilidi iade etmek
 Kilitlenmeyi engellemez
Operating System Concepts with Java – 8 6.51 Silberschatz, Galvin and Gagne ©2009 th Edition
Zaman-etiketi Tabanlı Protokoller
 Timestamp-based Protocols
 Atomik faaliyetler arasındaki srıa baştan belirlenir – zaman etiketi
sıralaması (timestamp-ordering)
 Ti atomik faaliyeti başlamadan önce bu faaliyete TS(Ti
) zaman etiketi
verilir
 Eğer Ti, Tj ’den önce sisteme girmişse: TS(Ti
) < TS(Tj
)
 TS sistem saatinden veya sisteme atomik faaliyetler geldikçe
arttırılan bir sayaçtan elde edilebilir
 Zaman etiketleri serileştirilebilirlik sırasını belirler
 Eğer TS(Ti
) < TS(Tj
) ise, sistem serileştirilmiş tarifede Ti
‘nin Tj
‘den
önce gözükmesini sağlar
Operating System Concepts with Java – 8 7.1 Silberschatz, Galvin and Gagne ©2009 th Edition
Bölüm 7: Kilitlenmeler
Operating System Concepts with Java – 8 7.2 Silberschatz, Galvin and Gagne ©2009 th Edition
Bölüm 7: Kilitlenmeler
 Kilitlenme Problemi
 Sistem Modeli
 Kilitlenme Tarifi
 Kilitlenmeler için Çözüm Yöntemleri
 Kilitlenme Önleme
 Kilitlenmeden Kaçınma
 Kilitlenme Tespiti
 Kilitlenmeden Kurtulma
Operating System Concepts with Java – 8 7.3 Silberschatz, Galvin and Gagne ©2009 th Edition
Hedefler
 Aynı anda çalışan işlemlerin görevlerini tamamlamasına engel olan
kilitlenmelerin açıklanması
 Bir bilgisayar sistemindeki kilitlenmelerin oluşmasını engelleyen veya
bu kilitlenmelerden kurtulmayı sağlayan yöntemlerin açıklanması
Operating System Concepts with Java – 8 7.4 Silberschatz, Galvin and Gagne ©2009 th Edition
Kilitlenme Problemi
 Her biri bir kaynağı tutan işlemlerden oluşan bir kümede, aynı
işlemlerin bu kümedeki bir başka işleme ait kaynağı elde etmek için
beklemesi sonucu bloklanmaları
 Örnek
 Sistem 2 disk sürücüsüne sahip
 P1 ve P2
işlemlerinin her biri bir diski kullanıyor ve her biri diğer
diske ihtiyaç duyuyor
 A ve B semaforları (ilk değerleri 1) ile örnek
P0 P1
wait (A); wait (B);
wait (B); wait (A);
Operating System Concepts with Java – 8 7.5 Silberschatz, Galvin and Gagne ©2009 th Edition
Köprüden Karşıya Geçme Örneği
 Köprü üzerinde trafik tek yöne akabilir
 Köprü bir kaynak gibi görülebilir
 Eğer kilitlenme olursa, araçlardan biri geriye giderse sorun
çözülebilir
 Eğer kilitlenme olursa birden fazla aracın geri çekilmesi
gerekebilir
 Açlık (starvation) mümkündür
 Not: Pek çok işletim sistemleri kilitlenmelere engel olmaz
veya kilitlenmeleri tespit edip çözmeye çalışmaz
Operating System Concepts with Java – 8 7.6 Silberschatz, Galvin and Gagne ©2009 th Edition
Sistem Modeli
 Kaynak tipleri R1
, R2
, . . ., Rm
CPU döngüleri (CPU cycles), hafıza alanı, I/O cihazları
 Her Ri kaynak tipi Wi örneklerine sahiptir
 İşlemler bir kaynağı aşağıdaki şekilde kullanırlar:
 istek (request)
 kullanım (use)
 iade etme (release)
Operating System Concepts with Java – 8 7.7 Silberschatz, Galvin and Gagne ©2009 th Edition
Kilitlenme Tarifi
 Birbirini dışlama (mutual exclusion): belli bir anda sadece bir
işlem, bir kaynağı kullanmalıdır
 Tutma ve Bekleme (hold and wait): en az bir kaynağı tutan bir
işlem başka işlemler tarafından tutulan ek kaynaklar için
beklemelidir
 Kesinti Yokluğu (no preemption): bir kaynak ancak o kaynağı
tutan işlem, kayanğı isteyerek bırakırsa serbest kalmalıdır
 Dairesel Bekleme (circular wait): öyle bir bekleyen işlem
kümesi olmalıdır ki {P0
, P1
, …, Pn
}, P0
, P1
tarafından tutlan bir
kaynağı beklemeli, P1
, P2
tarafından tutlan bir kaynağı beklemeli,
…, Pn–1
, Pn
tarafından tutlan bir kaynağı beklemeli ve Pn
, P0
tarafından tutulan bir kaynağı beklemelidir
Kilitlenme dört şartın aynı anda sağlanması durumunda ortaya çıkar.
Operating System Concepts with Java – 8 7.8 Silberschatz, Galvin and Gagne ©2009 th Edition
Kaynak-Ayırım Çizgesi (1/2)
 V iki farklı tipe bölünüyor:
 P = {P1
, P2
, …, Pn
}, sistemdeki tüm işlemlerin kümesi
 R = {R1
, R2
, …, Rm}, sistemdeki tüm kaynakların kümesi
 İstek kenarı (request edge) – Pi  Rj yönlü kanar
 Atama kenarı (assignment edge) – Rj  Pi yönlü kenar
Resource-Allocation Graph
V noktalar kümesi ve E kenarlar kümesi
Operating System Concepts with Java – 8 7.9 Silberschatz, Galvin and Gagne ©2009 th Edition
Kaynak-Ayırım Çizgesi (2/2)
 İşlem
 4 örneği olan kaynak tipi
 Pi
, Rj örneğini istiyor
 Pi
, Rj örneğini tutuyor
Pi
Pi
Rj
Rj
Operating System Concepts with Java – 8 7.10 Silberschatz, Galvin and Gagne ©2009 th Edition
Örnek Kaynak-Ayırım Çizgesi
Operating System Concepts with Java – 8 7.11 Silberschatz, Galvin and Gagne ©2009 th Edition
Kilitlenme İçeren Kaynak-Ayırım Çizgesi
Operating System Concepts with Java – 8 7.12 Silberschatz, Galvin and Gagne ©2009 th Edition
Döngü İçeren Fakat Kilitlenme İçermeyen Çizge
Operating System Concepts with Java – 8 7.13 Silberschatz, Galvin and Gagne ©2009 th Edition
Kaynak-Ayırım Çizgesi Temel Bilgileri
 Eğer çizge döngü içermiyorsa  kilitlenme yok
 Eğer çizge döngü içeriyorsa 
 Her bir kaynak tipi için bir örnek varsa, kilitlenme var
 Her bir kaynak için birden fazla örnek varsa, kilitlenme olma
olasılığı var
Operating System Concepts with Java – 8 7.14 Silberschatz, Galvin and Gagne ©2009 th Edition
Java Kilitlenme Örneği (1/2)
Thread A Thread B
Operating System Concepts with Java – 8 7.15 Silberschatz, Galvin and Gagne ©2009 th Edition
Java Kilitlenme Örneği (2/2)
Eğer aşağıdaki senaryo gerçekleşirse kilitlenme mümkün:
threadA -> lockY -> threadB -> lockX -> threadA
Operating System Concepts with Java – 8 7.16 Silberschatz, Galvin and Gagne ©2009 th Edition
Kilitlenmeler İçin Çözüm Yöntemleri
1. Problemi yok say: Sistemde kilitlenmelerin hiç bir zaman
oluşmayacağını varsay. Pek çok işletim sistemi bu yöntemi kullanır:
UNIX ve Java gibi
2. Kilitlenmeyi Önleme: Sistemin asla kilitilenme durumuna geçmesine
izin verme.
3. Kilitlenmeyi Çözme: Sistemin kilitlenmesine izin ver. Ardından
kilitlenme durumunu algılayıp kilitlenmeyi çöz.
Operating System Concepts with Java – 8 7.17 Silberschatz, Galvin and Gagne ©2009 th Edition
Kilitlenmeyi Önleme (1/3)
 Birbirini dışlama (mutual exclusion) – paylaşılamaz kaynaklar
için şart (örn: yazıcı), paylaşılabilir kaynaklar için gerekli değil (örn:
sadece okunabilir dosyalar)
 Tutma ve Bekleme (hold and wait) – bir işlem, bir kaynak için
istekte bulunduğunda, başka bir kaynağı tutmadığının
garantilenmesi gerekir. Örnek bir protokol:
 İşlemin, ancak sahip olduğu kaynağı iade ettikten sonra yeni
kaynak istemesine izin verilebilir
 Problemler
 Düşük performanslı kaynak kullanımı
 Açlığın (starvation) mümkün olması
 Deadlock Prevention
 Daha önce belirtildiği gibi, kilitlenme olması için dört gerekli şart sağlanmalıdır.
 Bu şartlardan en az birinin sağlanmazsa, kilitlenmenin önüne geçilir.
Operating System Concepts with Java – 8 7.18 Silberschatz, Galvin and Gagne ©2009 th Edition
Kilitlenmeyi Önleme (2/3)
 Kesinti Yokluğu (no preemption) –
 Eğer bazı kaynaklara sahip bir işlem, direk elde edemeyeceği bir
kaynağı isterse, tüm sahip olduğu kaynakları elinden alınır ve
bekleme moduna alınır
 Geri alınan kaynaklar, bu kaynakları bekleyen işleme verilir
 Kaynakları alınan işlem, ancak eski kaynaklarını ve yeni istediği
kaynakları alabileceği zaman yeniden başlatılır
 Bu protokol, genellikle, durumu kolayca kaydedilip eski haline
gelebilecek kaynaklar için kullanılır (yazmaçlar ve hafıza alanı gibi)
 Dairesel Bekleme (circular wait) – kaynaklara erişimi impose a total
ordering of all resource types, and require that each process requests
resources in an increasing order of enumeration
Operating System Concepts with Java – 8 7.19 Silberschatz, Galvin and Gagne ©2009 th Edition
Kilitlenmeyi Önleme (3/3)
 Dairesel Bekleme (circular wait) – kaynaklara erişimi tam anlamıyla
sıraya koyarak ve işlemlerin kaynakları bu sıraya uygun şekilde elde
etmesini sağlayarak engellenebilir
F(teyp sürücüsü) = 1
F(disk sürücüsü) = 5
F(yazıcı) = 12
 Hem yazıcıyı hem de teyp sürücüsünü elde etmek isteyen işlemci,
önce teyp sürücüsünü, ardından yazıcıyı istemelidir
Operating System Concepts with Java – 8 7.20 Silberschatz, Galvin and Gagne ©2009 th Edition
Kilitlenmeden Kaçınma (1/2)
 Deadlock Avoidance
 Önceki slaytlarda anlatılan kilitlenme önleme algoritmaları,
kilitlenmenin dört ön şartından en az birinin oluşmasını engelleyerek
çalışıyordu
 Bu ise sistemin ve cihazın kullanım performasının düşmesine neden
olmaktaydı
 Kilitlenme önlemede alternatif bir yöntem, kaynakların nasıl
isteneceğine dai ek önbilgi gerektirir
 İhtiyaç duyulan önbilginin miktarına ve tipine göre farklı algoritmalar
bulunmaktadır
Operating System Concepts with Java – 8 7.21 Silberschatz, Galvin and Gagne ©2009 th Edition
Kilitlenmeden Kaçınma (2/2)
 En basit ve en kullanışlı model, işlemlerin her bir tip kaynaktan en
fazla kaç tane ihtiyaç duyabileceğini belirtmesini gerektirir
 Bu bilgileri elde eden kilitlenme kaçınma algoritması dinamik olarak
kaynak atama durumunu inceler ve dairesel-bekleme (circularwait) durumunun oluşmasına izin vermez
 Kaynak atama durumu, kullanılabilir ve boştaki kaynak sayısı ile
işlemlerin maksimum istekleri ile belirlenir
Operating System Concepts with Java – 8 7.22 Silberschatz, Galvin and Gagne ©2009 th Edition
Güvenli Durum (Safe State)
 Bir işlem boştaki bir kaynağı istediğinde, sistem kaynağın bu işleme
verilmesi durumunun sistemi kilitlenmeye neden olmayacak güvenli
durumda bırakıp bırakmayacağına karar vermelidir
 Eğer sistem kaynakları tüm işlemlere kilitlenme olmaksızın belirli bir
işlem sırasında sağlayabiliyorsa, sistem güvenli durumdadır
 Sistemdeki <P1
, P2
, …, Pn> işlem sırasını ele alalım
 j < i iken, Pi ’nin istediği tüm kaynaklar, boştaki kaynaklar ve tüm Pj
işlemlerinin tuttuğu kaynaklar tarafından sağlanıyorsa sistem güvenli
durumdadır
 Bu şart sağlanmazsa sistem güvenilmez (unsafe) durumdadır
 Her güvenilmez durum kilitlenmeye neden olmak zorunda değildir,
ancak kilitlenmeye neden olabilir
Operating System Concepts with Java – 8 7.23 Silberschatz, Galvin and Gagne ©2009 th Edition
Güvenli Durum (Safe State)
 Genel mantık:
 Eğer Pi kaynak istekleri o an için karşılanamıyorsa, Pi
, Pj
işlemlerinin tümünün sonlanmasını bekleyebilir
 Pj sonlandığında, Pi
ihtiyaç duyduğu kaynakları elde edebilir,
çalışır ve normal şekilde sonlanır
 Pi sonlandığında, Pi +1 ihtiyaç duyduğu kaynakları elde edip
çalışmaya devam eder ...
Operating System Concepts with Java – 8 7.24 Silberschatz, Galvin and Gagne ©2009 th Edition
Güvenli Durum – Temel Bilgiler
 Eğer sistem güvenli durumdaysa  kilitlenme olmaz
 Eğer sistem güvenilmez durumdaysa  kilitlenme ihtimali vardır
 Kilitlenmeden kaçınma  sistemin hiç bir zaman güvenilmez
duruma geçmemesi sağlanarak gerçekleştirilebilir
Operating System Concepts with Java – 8 7.25 Silberschatz, Galvin and Gagne ©2009 th Edition
Güvenilir, Güvenilmez ve Kilitlenme Durumları
Operating System Concepts with Java – 8 7.26 Silberschatz, Galvin and Gagne ©2009 th Edition
Kilitlenmeden Kaçınma Algoritmaları
 Belirli bir kaynak tipinden bir tane örnek bulunması
 Kaynak-Ayırım Çizgesi kullanımı
 Belirli bir kaynak tipinden birden fazla örnek bulunması
 Banker algoritması kullanımı
Operating System Concepts with Java – 8 7.27 Silberschatz, Galvin and Gagne ©2009 th Edition
Kaynak-Ayırım Çizgesi Yaklaşımı
 Niyet kenarı (claim edge) Pi  Rj
, Pi
işleminin ileride bir zamanda
Rj kaynağını isteyebileceğini gösteriyor ve çizge üzerinde nokta
nokta çizgi (dashed line) şeklinde gösteriliyor
 Niyet kenarı, işlem, kaynağı istediğinde istek kenarına (request
edge) dönüştürülüyor
 İstek kenarı, kaynak işleme atandığında atanma kenarına
(assignment edge) dönüştürülüyor
 Bir kaynak işlem tarafından iade edildiğinde, atanma kenarı iddia
kenarına döüştürülüyor
 İşlemler, sistemdeki kaynaklar için önceden niyetlerini bildirmelidir
Operating System Concepts with Java – 8 7.28 Silberschatz, Galvin and Gagne ©2009 th Edition
Kaynak-Ayırım Çizgesi
Operating System Concepts with Java – 8 7.29 Silberschatz, Galvin and Gagne ©2009 th Edition
Kaynak-Ayırım Çizgesi – Güvenilmez Durum
Operating System Concepts with Java – 8 7.30 Silberschatz, Galvin and Gagne ©2009 th Edition
Kaynak-Ayırım Çizgesi Algoritması
 Pi
işleminin Rj kaynağını istediğini varsayalım: istek kenarı
 Eğer istek kenarının atanma kenarına dönüşümü, kaynak-ayırım
çizgesinde bir döngünün oluşmasına neden olmuyorsa istek
karşılanır
 Aksi halde istek karşılanmaz
Operating System Concepts with Java – 8 7.31 Silberschatz, Galvin and Gagne ©2009 th Edition
Banker Algoritması
 Belirli bir kaynak tipinden birden fazla örnek bulunması
 Her bir işlem maksimum kullanım tahminini, kullanım niyeti olarak
bildiriyor
 Bir işlem kaynak talebinde bulunduğunda beklemek zorunda kalabilir
 Bir işlem istediği tüm kaynaklara sahip olduğunda, bu kaynakları
sınırlı bir zaman içinde iade etmelidir
Operating System Concepts with Java – 8 7.32 Silberschatz, Galvin and Gagne ©2009 th Edition
Banker Algoritması için Veri Yapıları
 Available (uygun): m boyutunda vektör. Eğer Available [j] = k ise,
Rj
tipinde k örnek kullanıma uygun durumda
 Max (maksimum): n x m matrisi. Eğer Max [i,j] = k ise, Pi
işlemi Rj
tipinde kaynaklardan en fazla k tanesini isteyebilir
 Allocation (ayırım): n x m matrisi. Eğer Allocation[i,j] = k ise, Pi
işlemi şu anda Rj
tipindeki kaynaklardan k tanesine sahiptir
 Need (ihtiyaç): n x m matrisi. Eğer Need[i,j] = k ise, Pi
işleminin
son bulması için Rj kaynak tipinden k tanesine daha ihtiyaç
duyabilir
Need [i,j] = Max[i,j] – Allocation [i,j]
n = işlem sayısı
m = kaynak tipi sayısı
Operating System Concepts with Java – 8 7.33 Silberschatz, Galvin and Gagne ©2009 th Edition
Güvenlik Algoritması
1. Work ve Finish vektörleri sırasıyla m ve n uzunlukta olsun. İlk değer
ataması:
Work = Available
Finish [i] = false, i = 0, 1, …, n- 1
2. Aşağıdaki şartları sağlayan i değerini bul:
(a) Finish [i] = false
(b) Needi  Work
Böyle bir i bulunmazsa, 4. adıma git
3. Work = Work + Allocationi
Finish[i] = true
2. Adıma git
4. Tüm i değerleri için Finish [i] == true ise sistem güvenli durumdadır
Operating System Concepts with Java – 8 7.34 Silberschatz, Galvin and Gagne ©2009 th Edition
Pi
İşlemi için Kaynak-İstek Algoritması
Request = Pi
işleminin istek vektörü. Eğer Requesti
[j] = k ise Pi
işlemi Rj kaynak tipinden k tane istiyor
1. Eğer Requesti  Needi
ise 2. adıma git. Değilse hata ver çünkü
işlem belirlemiş olduğu maksimum istek sayısını aştı
2. Eğer Requesti  Available ise, 3. adıma git. Değilse, Pi
beklemeli, çünkü yeterli kaynak yok
3. Kaynak-atama durumunu aşağıdaki gibi değiştirerek Pi ’nin
istediği kaynakları Pi
’ye verir gibi yap:
Available = Available – Request;
Allocationi = Allocationi + Requesti
;
Needi = Needi – Requesti
;
 Eğer güvenli ise  kaynaklar Pi ’ye verilir
 Güvenli değilse  Pi beklemelidir ve kaynak-atama durumu
eski haline getirilmelidir
Operating System Concepts with Java – 8 7.35 Silberschatz, Galvin and Gagne ©2009 th Edition
Banker Algoritması Örneği
 P0 ... P4
; 5 işlem
3 kaynak tipi:
A (10 örnek), B (5 örnek), and C (7 örnek)
T0 anındaki sistem durumu:
Allocation Max Available
A B C A B C A B C
P0 0 1 0 7 5 3 3 3 2
P1 2 0 0 3 2 2
P2 3 0 2 9 0 2
P3 2 1 1 2 2 2
P4 0 0 2 4 3 3
Operating System Concepts with Java – 8 7.36 Silberschatz, Galvin and Gagne ©2009 th Edition
Örnek (devamı)
 Need matrisinin içeriği (Max – Allocation) olarak tanımlanmıştır:
Need
A B C
P0 7 4 3
P1 1 2 2
P2 6 0 0
P3 0 1 1
P4 4 3 1
 Sistem güvenli durumdadır çünkü < P1
, P3
, P4
, P2
, P0> sırası güvenlilik
kriterini sağlamaktadır
Operating System Concepts with Java – 8 7.37 Silberschatz, Galvin and Gagne ©2009 th Edition
Örnek: P1
İsteği (1,0,2)
 P1 , (1,0,2) isteğinde bulunmuş olsun
 Request  Available şartının kontrolü: (1,0,2)  (3,3,2)  true
 İstek karşılandıktan sonra, kaynak-atama durumunun güncel hali:
Allocation Need Available
A B C A B C A B C
P0 0 1 0 7 4 3 2 3 0
P1 3 0 2 0 2 0
P2 3 0 1 6 0 0
P3 2 1 1 0 1 1
P4 0 0 2 4 3 1
 Güvenlik çalıştırıldığında < P1
, P3
, P4
, P0
, P2> sırasının güvenlik şartını
sağladığı görülür
Operating System Concepts with Java – 8 7.38 Silberschatz, Galvin and Gagne ©2009 th Edition
Örnek: Diğer İstekler
Allocation Need Available
A B C A B C A B C
P0 0 1 0 7 4 3 2 3 0
P1 3 0 2 0 2 0
P2 3 0 1 6 0 0
P3 2 1 1 0 1 1
P4 0 0 2 4 3 1
 P4 ‘ün (3,3,0) isteği karşılanabilir mi?
 Yeterli kaynak yok
 P0
‘ın (0,2,0) isteği karşılanabilir mi?
 Kaynaklar yeterli fakat yeni sistem durumu güvenli değil
Operating System Concepts with Java – 8 7.39 Silberschatz, Galvin and Gagne ©2009 th Edition
Kilitlenme Tespiti ve Kurtarma
Kitilenmeyi önleme ve kilitlenmeden kaçınma çözümlerini kullanmayan
sistemlerde:
 Sistemin kilitlenme durumuna girmesine izin verilir
 Kilitlenme tespit algoritması
 Kilitlenmeden kurtarma mekanizması
Operating System Concepts with Java – 8 7.40 Silberschatz, Galvin and Gagne ©2009 th Edition
Tüm Kaynak Tipleri için Birer Örnek
 Bekleme çizgesini (wait-for graph) düzenli olarak göncelle
 Çizge nodları işlemlerdir
 Eğer Pi
, Pj
‘yi bekliyorsa Pi  Pj
 Belirli zaman aralıklarında, bekleme çizgesinde döngü arayan
algoritmayı çalıştır. Eğer döngü varsa, kilitlenme vardır
 Bir çizgede döngü tespit eden algoritma n
2
işlem gerektirir
 Burada n, çizgedeki nodların sayısıdır
Operating System Concepts with Java – 8 7.41 Silberschatz, Galvin and Gagne ©2009 th Edition
Kaynak-Ayırım Çizgesi ve Bekleme Çizgesi
Kaynak-Ayırım Çizgesi Karşılık gelen Bekleme Çizgesi
Operating System Concepts with Java – 8 7.42 Silberschatz, Galvin and Gagne ©2009 th Edition
Kaynak Tiplerinden Birden Fazla Örnek Bulunması
 Available (uygun): m uzunluğunda vektör. Her bir tip kaynak için
kaynaktan kaç tanesinin boşta ve kullanılabilir olduğunu belirtiyor
 Allocation (ayırım): n x m boyutlu matris. Her bir tip kaynağın her bir
işlem tarafından kadarının kullanıldığını belirtir.
 Request (istek): n x m boyutlu matris. Her bir işlemin o anki isteklerini
gösterir. Eğer Request [i,j] = k ise, Pi
işlemi Rj
tipinde kaynaktan k tane
daha istiyor demektir
Operating System Concepts with Java – 8 7.43 Silberschatz, Galvin and Gagne ©2009 th Edition
Kilitlenme Tespit Algoritması
1. Work ve Finish vektörleri sırasıyla m ve n uzunluğunda olsun. . İlk
değer ataması:
(a) Work = Available
(b) i = 1,2, …, n, eğer Allocationi  0 ise, Finish[i] = false; değilse,
Finish[i] = true
2. Aşağıdaki şartları sağlayan i indeksini bul:
(a) Finish[i] == false
(b) Requesti  Work
Eğer bu şartları sağlayan i değerini bulamazsan, 4. adıma git
Operating System Concepts with Java – 8 7.44 Silberschatz, Galvin and Gagne ©2009 th Edition
Kilitlenme Tespit Algoritması (Devam)
3. Work = Work + Allocationi
Finish[i] = true
2. adıma git
4. Eğer herhangi bir i değeri için, 1  i  n, Finish[i] == false, şartı
sağlanıyorsa sistem kilitlenmiştir. Dahası Finish[i] == false ise, Pi
işlemi
kilitlenmiştir
Bu algoritma sistemin kilitlenme durumunda olup olmadığını bulmak
için O(m x n2) işlem gerektirir
Operating System Concepts with Java – 8 7.45 Silberschatz, Galvin and Gagne ©2009 th Edition
Tespit Algoritması Örneği
 P0
... P4
; 5 işlem,
Üç kaynak tipi: A (7 örnek), B (2 örnek), ve C (6 örnek)
 T0 anına sistem durumu:
Allocation Request Available
A B C A B C A B C
P0 0 1 0 0 0 0 0 0 0
P1 2 0 0 2 0 2
P2 3 0 3 0 0 0
P3 2 1 1 1 0 0
P4 0 0 2 0 0 2
 <P0
, P2
, P3
, P1
, P4> sırası ile çalıştırılırlarsa will tüm i değerleri için
Finish[i] = true olur
Operating System Concepts with Java – 8 7.46 Silberschatz, Galvin and Gagne ©2009 th Edition
Tespit Algoritması Örneği (Devam)
 P2
‘nin C tipinde ek bir kaynak daha istediğini düşünelim
Request
A B C
P0 0 0 0
P1 2 0 1
P2 0 0 1
P3 1 0 0
P4 0 0 2
 Sistemin durumu?
 P0
’ın bırakığı kaynaklar geri iade edilir ama diğer işlemlerin
isteklerini karşılayacak miktarda kaynak bulunmamaktadır
 P1
, P2
, P3
, ve P4
işlemlerinin dahil olduğu bir kilitlenme oluşur
Operating System Concepts with Java – 8 7.47 Silberschatz, Galvin and Gagne ©2009 th Edition
Tespit Algoritması Kullanımı
 Tespit algoritmasının ne zaman ve hangi sıklıkta çalıştırılacağı
aşağıdaki faktörlere bağlıdır:
 Kilitlenme hangi sıklıkta gerçekleşir?
 Kaç tane işlemin durumu geriye alınmalıdır?
 Her bir ayrık döngü (disjoint cycle) için bir tane
 Eğer tespit algoritması rastgele çağırılırsa, kaynak çizgesinde pek çok
döngü bulunur ve kilitlenmiş pek çok işlem arasında hangi işlemlerin
kilitlenmeye neden olduğunu tespit edemeyiz
Operating System Concepts with Java – 8 7.48 Silberschatz, Galvin and Gagne ©2009 th Edition
Kilitlenmeden Kurtarma: İşlemin Sonlandırılması
 Tüm kilitlenen işlemleri sonlandır
 Kilitlenme döngüsü ortadan kalkana kadar, işlemleri teker teker
sonlandır
 İşlemleri hangi sırada sonlandırmalıyız?
 İşlemin önceliğine göre
 İşlem ne kadar süredir çalışıyor ve sonlanması için ne kadar
süreye ihtiyacı var?
 İşlemin kullandığı kaynaklar?
 İşlemin tamamlanması için ne kadar kaynağa ihtiyacı var?
 Kaç tane işlemin sonlandırılması gerekiyor?
 Işlem interktif mi yoksa sıralı (batch) işlem mi?
Operating System Concepts with Java – 8 7.49 Silberschatz, Galvin and Gagne ©2009 th Edition
Kilitlenmeden Kurtarma: Kaynak İadesi
 Kurban (victim) seçimi – hangi işleme ait hangi kaynaklar geri
alınmalıdır
 Geriye sarma (rollback) – Bir işlemden bir kaynağı geri aldığımızda
ne yapacağız? Açık bir şekilde işlem çalışmaya normal şekilde
çalışmaya devam edemez.
 İşlemi durduruğ yeniden başlatmak
 Açlık (starvation) – bazı işlemler her zaman kurban olarak
seçilebilir
 geriye alınma sayısı seçimin bir parametresi olarak kullanılabilir
Operating System Concepts with Java – 8 8.1 Silberschatz, Galvin and Gagne ©2009 th Edition
Bölüm 8: Ana Bellek
Operating System Concepts with Java – 8 8.2 Silberschatz, Galvin and Gagne ©2009 th Edition
Bölüm 8: Ana Bellek
 Arka Plan Bilgisi
 Yer Değiştirme (Swapping)
 Bitişik Bellek Yerleşimi (Contiguous Memory Allocation)
 Sayfalama (Paging)
 Sayfa Tablosunun (Page Table) Yapısı
 Bölütleme (Segmentation)
 Örnek: Intel Pentium
Operating System Concepts with Java – 8 8.3 Silberschatz, Galvin and Gagne ©2009 th Edition
Hedefler
 Hafıza donanımının farklı şekillerde nasıl organize edilebileceğini
detaylı bir şekilde anlatmak
 Sayfalama (paging) ve bölütleme (segmentation) gibi pek çok hafıza
yönetim mekanizmasının açıklanması
 Hem saf bölütleme hem de sayfalama ile bölütleme desteği sunan
Intel Pentium’un incelenmesi
Operating System Concepts with Java – 8 8.4 Silberschatz, Galvin and Gagne ©2009 th Edition
Arka Plan Bilgisi
 Çalıştırılmak istenen program öncelikle diskten belleğe alınmalı ve
bir işleme dönüştürülmelidir
 CPU’nun direk olarak erişebileceği kayıt birimleri yalnızca ana
bellek (main memory) ve yazmaçlardır (registers)
 CPU’nun yazmaçlara erişimi bir CPU birim zamanı (veya daha az)
sürer
 Ana belleğe erişim pek çok CPU birim zamanı sürebilir
 Ön bellek (cache) ana bellek ile CPU yazmaçları arasında yer
almaktadır
 Ana belleğin korunması sistemin doğru çalışması için şarttır
Operating System Concepts with Java – 8 8.5 Silberschatz, Galvin and Gagne ©2009 th Edition
Taban ve Sınır Yazmaçları
 Taban (base) ve sınır (limit) yazmaçları mantıksal adres uzayını
tanımlar
Operating System Concepts with Java – 8 8.6 Silberschatz, Galvin and Gagne ©2009 th Edition
Komutların ve Verilerin Hafızaya Bağlanması
 Programlardaki komutların ve verilerin adreslerinin hafızadaki
adreslere bağlanması üç farklı aşamada gerçekleşebilir
 Derleme zamanı (compile time): Eğer ana bellekteki pozisyon
önceden biliniyorsa, mutlak kod (absolute code) oluşturulabilir.
Başlangıç adresi değişirse kodun yeniden derlenmesi gerekir
 Yükleme zamanı (load time): Eğer derleme zamanında ana
bellek pozisyonu bilinmiyorsa, yeniden yerleştirilebilir kod
(relocatable code) oluşturulmalıdır
 Çalışma zamanı (execution time): Eğer işlem çalışırken bir
hafıza bölümünden diğerine taşınabiliyorsa, bağlama çalışma
zamanına kadar ertelenir
 Adres haritaları (address maps) için donanım desteği gerekir
(örn., taban ve sınır yazmaçları)
Operating System Concepts with Java – 8 8.7 Silberschatz, Galvin and Gagne ©2009 th Edition
Kullanıcı Programının Çok Adımlı İşletimi
Operating System Concepts with Java – 8 8.8 Silberschatz, Galvin and Gagne ©2009 th Edition
Mantıksal veya Fiziksel Adres Uzayı
 Mantıksal bir adres uzayının ayrı bir fiziksel adres uzayına bağlanması
düzgün bir hafıza yönetimi için önşarttır
 Mantıksal adres (logical address) –CPU tarafından oluşturulur.
Sanal adres (virtual address) olarak da adlandırılır
 Fiziksel adres (physical address) – hafıza birimi tarafından bilinen
adrestir
 Derleme-zamanı ve Yükleme-zamanı adres bağlama yaklaşımlarında
mantıksal ve fiziksel adresler aynıdır
 Çalışma zamanı adres bağlama yaklaşımında mantıksal ve fiziksel
adresler farklılık gösterir
Operating System Concepts with Java – 8 8.9 Silberschatz, Galvin and Gagne ©2009 th Edition
Hafıza Yönetim Birimi (MMU)
 Sanal adresleri fiziksel adreslere çeviren donanım
 MMU birimine kullanıcı programı tarafından gönderilen her adrese
yeniden yerleştirme yazmacındaki (relocation register) değer eklenir
 Elde edilen adres hafızaya gönderilir
 Kullanıcı programları mantıksal adresleri kullanırlar; gerçek fiziksel
adresleri asla görmezler
Operating System Concepts with Java – 8 8.10 Silberschatz, Galvin and Gagne ©2009 th Edition
Yeniden Yerleştirme Yazmacını Kullanarak
Dinamik Yeniden Yerleştirme
Operating System Concepts with Java – 8 8.11 Silberschatz, Galvin and Gagne ©2009 th Edition
Dinamik Yükleme (Dynamic Loading)
 Metot çağırılmadığı sürece yüklenmez
 Daha iyi hafıza uzayı yönetimi; kullanılmayan metot asla yüklenmez
 Nadiren gerçekleşen durumlara karşılık gelen büyük miktarda kod
olduğunda faydalı
 İşletim sisteminden özel destek gerektirmiyor – program tasarımına
dikkat edilmesi yeterli
Operating System Concepts with Java – 8 8.12 Silberschatz, Galvin and Gagne ©2009 th Edition
Dinamik Bağlama (Dynamic Linking)
 Bağlama çalışma zamanına kadar ertelenir
 Dinamik bağlama özellikle kütüphaneler için faydalıdır
 Stub: hafızadaki kütüphane metodunun yerini bulmakta kullanılan
küçük kod parçası
 Stub kendini kütüphane metodunun adresi ile değiştirir ve metodu
çalıştırır
 İşletim sistemi, kütüphane metodunun, işlemin bellek adresi içinde
olduğunu kontrol etmelidir
 Bu mekanizma aynı zamanda paylaşımlı kütüphane (shared
libraries) olarak bilinmektedir
Operating System Concepts with Java – 8 8.13 Silberschatz, Galvin and Gagne ©2009 th Edition
Yer Değiştirme (Swapping) (1/2)
 Bir işlem geçici olarak hafızadan çıkarılıp ikincil bir kayıt birimine
alınabilir
 İşlem daha sonra çalışmaya devam etmek üzere yeniden ana belleğe
alınabilir
 Roll out, roll in – öncelik tabanlı zamanlama algoritmaları tarafından
kullanılan yer değiştirme varyasyonu
 Düşük öncelikli işlemler, daha yüksek öncelikli işlemlerin yüklenip
çalıştırılabilmesi için geçici olarak hafıza dışına alınır
Operating System Concepts with Java – 8 8.14 Silberschatz, Galvin and Gagne ©2009 th Edition
Yer Değiştirme (Swapping) (2/2)
 Yer değiştirme zamanının önemli bir kısmı verinin transferinde
kullanılır. Toplam transfer zamanı yer değiştirilen hafıza boyutu ile
orantılıdır
 Yer değiştirmenin farklı varyasyonları pek çok işletim sisteminde
bulunur (örn: UNIX, Linux ve Windows)
 Sistem öalışmaya hazır olan ancak kodu hafızada olmayan işlemleri
hazır kuyruğunda (ready queue) tutar ve bu kuyruğu günceller
Operating System Concepts with Java – 8 8.15 Silberschatz, Galvin and Gagne ©2009 th Edition
Yer Değiştirme
Operating System Concepts with Java – 8 8.16 Silberschatz, Galvin and Gagne ©2009 th Edition
Bitişik Bellek Yerleşimi
 Contiguous Memory Allocation
 Ana bellek genellikle iki bölüme ayrılır:
 İşletim sistemi, genellikle kesinti vektörü ile birlikte hafızanın alt
kısmında yer alır
 Kullanıcı işlemleri, hafızanın üst kısmında yer alır
 Yeniden yerleştirme yazmaçları kullanıcı işlemlerini birbirinden
korumak, işletim sistemi kodu ve verilerinin değiştirilmesini önlemek
için kullanılır
 Taban yazmacı, en küçük fiziksel adresin değerini tutar
 Sınır yazmacı, mantıksal adreslerin sınır değerini tutar – tüm
mantıksal adresler sınır yazmacında tutlan değerden daha
küçüktür
 MMU mantıksal adresleri dinamik olarak çevirir
Operating System Concepts with Java – 8 8.17 Silberschatz, Galvin and Gagne ©2009 th Edition
Yeniden Yerleştirme ve Sınır Yazmaçları
için Donanım Desteği
Operating System Concepts with Java – 8 8.18 Silberschatz, Galvin and Gagne ©2009 th Edition
Bitişik Bellek Yerleşimi (Devam)
 Çoklu-bölüm ayırımı
 Boşluk (Hole) – kullanılabilir bellek bloğu; hafıza üzerinde çeşitli
boyutlarda boşluklar dağınık bir şekilde bulunur
 Bir işlem geldiğinde, bu işlemi tutabilecek kadar büyük bir hafıza
boşluğuna yerleştirilir
 İşletim sistemi şu bilgileri tutup günceller:
a) işlemlere ayrılmış bölümler b) boş bölümler (boşluklar)
OS
process 5
process 8
process 2
OS
process 5
process 2
OS
process 5
process 2
OS
process 5
process 9
process 2
process 9
process 10
Operating System Concepts with Java – 8 8.19 Silberschatz, Galvin and Gagne ©2009 th Edition
Dinamik Kayıt Birimi Ayırım Problemi
 İlk-uyum (first-fit): yeterince büyük olan ilk boşluğa ata
 En-iyi-uyum (best-fit): yeterince büyük olan en küçük boşluğa ata
 boyuta göre sıralı değilse, tüm liste aranmalıdır
 geriye en küçük boşluğu bırakır
 En-kötü-uyum (worst-fit): mevcut en büyük boşluğa ata
 gene, tüm liste aranmalıdır
 geriye en büyük boşluğu bırakır
Bir boş bölümler listesi elimizdeyken, n boyutunda bir işlemi nasıl
bir boşluğa atayabiliriz?
İlk-uyum ve en-iyi-uyum, hız ve kayıt biriminin verimli kullanımı
açısılarından en-kötü-uyum‘a göre daha iyi sonuç verir
Operating System Concepts with Java – 8 8.20 Silberschatz, Galvin and Gagne ©2009 th Edition
Parçalanma (Fragmentation) (1/2)
 Dışsal Parçalanma (External Fragmentation) – isteği karşılamak
için hafıza alanı mevcut fakat bitişik değil
 İçsel Parçalanma (Internal Fragmentation) – işleme ayrılan hafıza
gerekenden biraz fazla
 boyut farkı işleme ayrılan hafıza alanında oluşuyor ve bu alan
kullanılamıyor
Operating System Concepts with Java – 8 8.21 Silberschatz, Galvin and Gagne ©2009 th Edition
Parçalanma (Fragmentation) (2/2)
 Dışal parçalanmayı sıkıştırma (compaction) ile azalt
 Hafıza bloklarını, tüm boş blokları biraraya getirecek şekilde
yeniden düzenle
 Sıkıştırma sadece, yeniden yerleştirme dinamik ise, çalışma
zamanında gerçekleştirilir
 I/O problemi
 İşlemler I/O gerçekleştirirken hafızadaki yerlerini sabitle
 I/O işlemlerini sadece işletim sistemine ait tampon bellekler
üzerinde gerçekleştir
Operating System Concepts with Java – 8 8.22 Silberschatz, Galvin and Gagne ©2009 th Edition
Sayfalama (Paging) (1/2)
 Sayfalama, bir işleme ayrılan fiziksel adres uzayının bitişik olmamasına
(noncontiguous) izin veren bir hafıza yönetim şeklidir
 Fiziksel hafıza sabit büyüklükte bloklara, çerçevelere (frames), bölünür
(belirlenen boyut 2’nin katları halindedir, 512 bayt ile 8,192 bayt arası)
 Mantıksal hafıza alanı da aynı boyutta bloklara, sayfalara (pages),
bölünür
 Tüm boş çerçeveler takip edilir: çerçeve tablosu (frame table)
 n sayfalık bir programı çalıştırmak için, n tane boş çerçevenin bulunması
ve bu çerçevelere programın yüklenmesi gerekir
 Mantıksal adreslerin fiziksel adreslere dönüştürülmesi için bir sayfa
tablosuna (page table) ihtiyaç duyulur
Operating System Concepts with Java – 8 8.23 Silberschatz, Galvin and Gagne ©2009 th Edition
Sayfalama (Paging) (2/2)
 Dışsal parçalanma yok fakat içsel parçalanma var
 İçsel parçalanmayı azaltmak için, sayfa boyutu küçültülmelidir
 Sayfa tablosuna her erişim sistem kaynaklarını kullanmayı
gerektirdiğinden, sayfa tablosuna erişim sayısını azaltmak için sayfa
boyutu olabildiğince büyük olmalıdır
 Ayrıca, disk I/O işlemleri genellikle daha büyük miktarlarda veri transfer
edildiğinde daha verimli çalışır
 Ödünleşme (tradeoff)
 İşlem boyutları arttıkça, sayfa boyutları da zamanla artmıştır
 Günümüzde tipik olaraksayfa boyutları 4KB ile 8KB arasındadır
 Bazı sistemler çok daha büyük sayfa boyutlarını desteklerler
 Solaris: 8KB ve 4MB
Operating System Concepts with Java – 8 8.24 Silberschatz, Galvin and Gagne ©2009 th Edition
Adres Dönüşüm Mekanizması
 CPU tarafından üretilen adresle ikiye bölünür:
 Sayfa numarası (page number) (p) – fiziksel hafızadaki her bir
sayfanın temel adresini içeren sayfa tablosunun indeksi olarak
kullanılır
 Sayfa ofseti (page offset) (d) – temel adres ile birleştirilerek
hafıza birimine gönderilecek fiziksel hafıza adresi elde edilir
 2
m mantıksal adres uzayı ve 2
n sayfa boyutu ile
page number page offset
p d
m - n n
Operating System Concepts with Java – 8 8.25 Silberschatz, Galvin and Gagne ©2009 th Edition
Sayfalama Donanımı
Operating System Concepts with Java – 8 8.26 Silberschatz, Galvin and Gagne ©2009 th Edition
Mantıksal ve Fiziksel Hafızanın
Sayfalama Modeli
Operating System Concepts with Java – 8 8.27 Silberschatz, Galvin and Gagne ©2009 th Edition
Sayfalama Örneği
32 bayt hafıza ve 4 baytlık sayfalar (n=2, m=4): 8 sayfa
Operating System Concepts with Java – 8 8.28 Silberschatz, Galvin and Gagne ©2009 th Edition
Boş Çerçeveler (Free Frames)
Ayrım öncesi Ayrım sonrası
Operating System Concepts with Java – 8 8.29 Silberschatz, Galvin and Gagne ©2009 th Edition
Sayfa Tablosunun Gerçekleştirimi
 Sayfa tabloları hafızada tutulur
 Pek çok işletim sistemi her bir işlem için ayrı bir sayfa tablosu tutar ve
tablonun adres detayları kayıtçı değerleri (register value) olarak
işleme ait PCB’nin içerisinde saklanır
 Sayfa tablosu temel sayacı - Page-table base register (PTBR)
 Sayfa tablosunun başlangıç adresini tutar
 Page-table length register (PRLR)
 Sayfa tablosunun boyutunu tutar
 Bu yöntemde her tür veri veya komut erişimi hafızaya iki defa erişmeyi
gerektirir. Bir erişim sayfa tablosu için, diğer erişim veri veya komuta
erişim için
Operating System Concepts with Java – 8 8.30 Silberschatz, Galvin and Gagne ©2009 th Edition
Sayfa Tablosunun Gerçekleştirimi
 Hafızaya iki kere erişim problemi, hızlı erişimi sağlayan özel
önbellekler sayesinde çözülebilir:
 çağrışımlı bellek (associative memory)
 veya translation look-aside buffers (TLBs)
 TLB’deki her bir satır iki bileşenden oluşur: abahtar ve değer
 TLB üzerinde belirli bir sorgu yapıldığında, sorgulanan anahtar aynı
anda tüm satırlardaki anahtarlar üzerinde aranır
 Sorgulanan anahtar TLB’lerde sayfa numarasıdır ve değer olarak
çerçeve numarası döndürülür
 Arama hızlı ve donanım pahalı. Tipik olarak TLB’deki giriş sayısı 64 ve
1024 arasında
Operating System Concepts with Java – 8 8.31 Silberschatz, Galvin and Gagne ©2009 th Edition
Çağrışımlı Bellek
 Çağırışımlı bellek:
 Adres dönüşümü (p, d)
 Eğer sayfa numarası (page #) çağrışımlı bellekte bulunduysa,
çerçeve numarasını (frame #) al
 Bulunmazsa, çerçeve numarasını hafızada tutulan sayfa
tablosundan elde et
 Bazı TLB’ler her bir girişte adres uzayı belirleyicilerini de tutar –
Böylece farklı işlemlere ait adres uzayları birbirlerinden korunmuş
olur: address-space identifiers (ASIDs)
Page # Frame #
Operating System Concepts with Java – 8 8.32 Silberschatz, Galvin and Gagne ©2009 th Edition
TLB ile Sayfalama Donanımı
Operating System Concepts with Java – 8 8.33 Silberschatz, Galvin and Gagne ©2009 th Edition
Geçerli Erişim Zamanı
 Effective Access Time
 Çağrışımlı arama (associative lokup) =  mikrosaniye
 Hafıza erişim süresi:1 mikrosaniye
 Yakalama Oranı (hit ratio) – bir sayfanın çağrışımlı bellekte bulunma
olasılığı. Belirli sayıda erişim için, sayfanın çağrışımlı bellekte toplam
bulunma sayısı bölü toplam erişim sayısı
 Yakalama oranı = 
 Effective Access Time (EAT)
EAT = (1 + )  + (2 + )(1 – )
= 2 +  – 
Operating System Concepts with Java – 8 8.34 Silberschatz, Galvin and Gagne ©2009 th Edition
Hafıza Koruma
 Hafıza koruması, her bir tablo girişi ile bir koruma bitinin
ilişkilendirilmesi ile mümkündür
 Gçerli-Geçersiz biti (Valid-invalid bit):
 “geçerli” (valid), ilişkili sayfanın işlemin mantıksal adres uzayında
olduğunu ve erişim hakkının geçerli olduğunu gösterir
 “geçersiz” (invalid), ilişkili sayfanın işlemin mantıksal adres
uzayında olmadığını gösterir
Operating System Concepts with Java – 8 8.35 Silberschatz, Galvin and Gagne ©2009 th Edition
Sayfa Tablosundaki Geçerli (v) veya Geçersiz (i) Bitler
Operating System Concepts with Java – 8 8.36 Silberschatz, Galvin and Gagne ©2009 th Edition
Paylaşımlı Sayfalar
 Kod paylaşımı
 Sadece okunabilir olan kodun bir kopyası işlemler arasında
paylaştırılır (örn: metin editörleri, derleyiciler, pencere sistemleri)
 Paylaşılan kod, tüm işlemlerin mantıksal adres uzaylarında aynı
konumda bulunmalıdır
 Özel kod ve veri
 Her bir işlem kod ve verilerin ayrı bir kopyasını tutarlar
 Özel kod ve veriye ait sayfalar mantıksal adres uzayının herhangi
bir yerinde bulunabilir
Operating System Concepts with Java – 8 8.37 Silberschatz, Galvin and Gagne ©2009 th Edition
Paylaşımlı Sayfa Örneği
Operating System Concepts with Java – 8 8.38 Silberschatz, Galvin and Gagne ©2009 th Edition
Sayfa Tablosunun Yapısı
 Hierarchical Paging
 Hashed Page Tables
 Inverted Page Tables
Operating System Concepts with Java – 8 8.39 Silberschatz, Galvin and Gagne ©2009 th Edition
Hiyerarşik Sayfa Tabloları
 Break up the logical address space into multiple page tables
 A simple technique is a two-level page table
Operating System Concepts with Java – 8 8.40 Silberschatz, Galvin and Gagne ©2009 th Edition
İki Seviyeli Sayfa Tabloları
Two-Level Page-Table
Operating System Concepts with Java – 8 8.41 Silberschatz, Galvin and Gagne ©2009 th Edition
İki Seviyeli Sayfalama Örneği
 A logical address (on 32-bit machine with 1K page size) is divided
into:
 a page number consisting of 22 bits
 a page offset consisting of 10 bits
 Since the page table is paged, the page number is further divided
into:
 a 12-bit page number
 a 10-bit page offset
 Thus, a logical address is as follows:
where pi
is an index into the outer page table, and p2
is the
displacement within the page of the outer page table
pi
p2 d
page number page offset
12 10 10
Operating System Concepts with Java – 8 8.42 Silberschatz, Galvin and Gagne ©2009 th Edition
Adres Çevrimi
Operating System Concepts with Java – 8 8.43 Silberschatz, Galvin and Gagne ©2009 th Edition
Üç Seviyeli Sayfalama
Three-level Paging
Operating System Concepts with Java – 8 8.44 Silberschatz, Galvin and Gagne ©2009 th Edition
Hashed Page Tables
 Common in address spaces > 32 bits
 The virtual page number is hashed into a page table.
 This page table contains a chain of elements hashing to the same
location.
 Virtual page numbers are compared in this chain searching for a
match.
 If a match is found, the corresponding physical frame is extracted.
Operating System Concepts with Java – 8 8.45 Silberschatz, Galvin and Gagne ©2009 th Edition
Hashed Page Table
Operating System Concepts with Java – 8 8.46 Silberschatz, Galvin and Gagne ©2009 th Edition
Inverted Page Table
 One entry for each real page of memory.
 Entry consists of the virtual address of the page stored in that real
memory location, with information about the process that owns
that page.
 Decreases memory needed to store each page table, but
increases time needed to search the table when a page reference
occurs.
 Use hash table to limit the search to one — or at most a few —
page-table entries.
Operating System Concepts with Java – 8 8.47 Silberschatz, Galvin and Gagne ©2009 th Edition
Inverted Page Table Architecture
Operating System Concepts with Java – 8 8.48 Silberschatz, Galvin and Gagne ©2009 th Edition
Segmentation
 Memory-management scheme that supports user view of memory
 A program is a collection of segments
 A segment is a logical unit such as:
 main program
procedure
function
method
object
local variables, global variables
common block
stack
symbol table
arrays
Operating System Concepts with Java – 8 8.49 Silberschatz, Galvin and Gagne ©2009 th Edition
User’s View of a Program
Operating System Concepts with Java – 8 8.50 Silberschatz, Galvin and Gagne ©2009 th Edition
Logical View of Segmentation
1
3
2
4
1
4
2
3
user space physical memory space
Operating System Concepts with Java – 8 8.51 Silberschatz, Galvin and Gagne ©2009 th Edition
Segmentation Architecture
 Logical address consists of a two tuple:
<segment-number, offset>,
 Segment table – maps two-dimensional physical addresses; each
table entry has:
 base – contains the starting physical address where the
segments reside in memory
 limit – specifies the length of the segment
 Segment-table base register (STBR) points to the segment table’s
location in memory
 Segment-table length register (STLR) indicates number of
segments used by a program;
segment number s is legal if s < STLR
Operating System Concepts with Java – 8 8.52 Silberschatz, Galvin and Gagne ©2009 th Edition
Segmentation Architecture (Cont.)
 Protection
 With each entry in segment table associate:
 validation bit = 0  illegal segment
 read/write/execute privileges
 Protection bits associated with segments; code sharing occurs at
segment level.
 Since segments vary in length, memory allocation is a dynamic
storage-allocation problem.
 A segmentation example is shown in the following diagram.
Operating System Concepts with Java – 8 8.53 Silberschatz, Galvin and Gagne ©2009 th Edition
Segmentation Hardware
Operating System Concepts with Java – 8 8.54 Silberschatz, Galvin and Gagne ©2009 th Edition
Example of Segmentation
Operating System Concepts with Java – 8 8.55 Silberschatz, Galvin and Gagne ©2009 th Edition
Example: The Intel Pentium
 Supports both segmentation and segmentation with paging
 CPU generates logical address
 Given to segmentation unit
 Which produces linear addresses
 Linear address given to paging unit
 Which generates physical address in main memory
 Paging units form equivalent of MMU
Operating System Concepts with Java – 8 8.56 Silberschatz, Galvin and Gagne ©2009 th Edition
Logical to Physical Address
Translation in Pentium
Operating System Concepts with Java – 8 8.57 Silberschatz, Galvin and Gagne ©2009 th Edition
Intel Pentium Segmentation
Operating System Concepts with Java – 8 8.58 Silberschatz, Galvin and Gagne ©2009 th Edition
Pentium Paging Architecture
Operating System Concepts with Java – 8 8.59 Silberschatz, Galvin and Gagne ©2009 th Edition
Linear Address in Linux
Broken into four parts:
Operating System Concepts with Java – 8 8.60 Silberschatz, Galvin and Gagne ©2009 th Edition
Three-level Paging in Linux
Operating System Concepts with Java – 8 9.1 Silberschatz, Galvin and Gagne ©2009 th Edition
Chapter 9: Virtual Memory
Operating System Concepts with Java – 8 9.2 Silberschatz, Galvin and Gagne ©2009 th Edition
Chapter 9: Virtual Memory
 Background
 Demand Paging
 Copy-on-Write
 Page Replacement
 Allocation of Frames
 Thrashing
 Memory-Mapped Files
 Allocating Kernel Memory
 Other Considerations
 Operating-System Examples
Operating System Concepts with Java – 8 9.3 Silberschatz, Galvin and Gagne ©2009 th Edition
Objectives
 To describe the benefits of a virtual memory system
 To explain the concepts of demand paging, page-replacement
algorithms, and allocation of page frames
 To discuss the principle of the working-set model
Operating System Concepts with Java – 8 9.4 Silberschatz, Galvin and Gagne ©2009 th Edition
Background
 Virtual memory – separation of user logical memory from physical
memory.
 Only part of the program needs to be in memory for execution
 Logical address space can therefore be much larger than physical
address space
 Allows address spaces to be shared by several processes
 Allows for more efficient process creation
 Virtual memory can be implemented via:
 Demand paging
 Demand segmentation
Operating System Concepts with Java – 8 9.5 Silberschatz, Galvin and Gagne ©2009 th Edition
Virtual Memory That is Larger Than
Physical Memory
Operating System Concepts with Java – 8 9.6 Silberschatz, Galvin and Gagne ©2009 th Edition
Virtual-address Space
Operating System Concepts with Java – 8 9.7 Silberschatz, Galvin and Gagne ©2009 th Edition
Shared Library Using Virtual Memory
Operating System Concepts with Java – 8 9.8 Silberschatz, Galvin and Gagne ©2009 th Edition
Demand Paging
 Bring a page into memory only when it is needed
 Less I/O needed
 Less memory needed
 Faster response
 More users
 Page is needed  reference to it
 invalid reference  abort
 not-in-memory  bring to memory
 Lazy swapper – never swaps a page into memory unless page will be
needed
 Swapper that deals with pages is a pager
Operating System Concepts with Java – 8 9.9 Silberschatz, Galvin and Gagne ©2009 th Edition
Transfer of a Paged Memory to
Contiguous Disk Space
Operating System Concepts with Java – 8 9.10 Silberschatz, Galvin and Gagne ©2009 th Edition
Valid-Invalid Bit
 With each page table entry a valid–invalid bit is associated
(v  in-memory, i  not-in-memory)
 Initially valid–invalid bit is set to i on all entries
 Example of a page table snapshot:
 During address translation, if valid–invalid bit in page table entry
is I  page fault
….
v
v
v
v
i
i
i
Frame # valid-invalid bit
page table
Operating System Concepts with Java – 8 9.11 Silberschatz, Galvin and Gagne ©2009 th Edition
Page Table When Some Pages Are
Not in Main Memory
Operating System Concepts with Java – 8 9.12 Silberschatz, Galvin and Gagne ©2009 th Edition
Page Fault
 If there is a reference to a page, first reference to that page will trap to
operating system:
page fault
1. Operating system looks at another table to decide:
 - Invalid reference  abort
- Just not in memory
2. Get empty frame
3. Swap page into frame
4. Reset tables
5. Set validation bit = v
6. Restart the instruction that caused the page fault
Operating System Concepts with Java – 8 9.13 Silberschatz, Galvin and Gagne ©2009 th Edition
Page Fault (Cont.)
 Restart instruction
 block move
 auto increment/decrement location
Operating System Concepts with Java – 8 9.14 Silberschatz, Galvin and Gagne ©2009 th Edition
Steps in Handling a Page Fault
Operating System Concepts with Java – 8 9.15 Silberschatz, Galvin and Gagne ©2009 th Edition
Performance of Demand Paging
 Page Fault Rate 0  p  1.0
 if p = 0 no page faults
 if p = 1, every reference is a fault
 Effective Access Time (EAT)
EAT = (1 – p) x memory access
+ p (page fault overhead
+ swap page out
+ swap page in
+ restart overhead
)
Operating System Concepts with Java – 8 9.16 Silberschatz, Galvin and Gagne ©2009 th Edition
Demand Paging Example
 Memory access time = 200 nanoseconds
 Average page-fault service time = 8 milliseconds
 EAT = (1 – p) x 200 + p (8 milliseconds)
= (1 – p x 200 + p x 8,000,000
= 200 + p x 7,999,800
 If one access out of 1,000 causes a page fault, then
EAT = 8.2 microseconds.
This is a slowdown by a factor of 40!!
Operating System Concepts with Java – 8 9.17 Silberschatz, Galvin and Gagne ©2009 th Edition
Process Creation
 Virtual memory allows other benefits during process creation:
- Copy-on-Write
- Memory-Mapped Files (later)
Operating System Concepts with Java – 8 9.18 Silberschatz, Galvin and Gagne ©2009 th Edition
Copy-on-Write
 Copy-on-Write (COW) allows both parent and child processes to
initially share the same pages in memory
If either process modifies a shared page, only then is the page copied
 COW allows more efficient process creation as only modified pages
are copied
 Free pages are allocated from a pool of zeroed-out pages
Operating System Concepts with Java – 8 9.19 Silberschatz, Galvin and Gagne ©2009 th Edition
Before Process 1 Modifies Page C
Operating System Concepts with Java – 8 9.20 Silberschatz, Galvin and Gagne ©2009 th Edition
After Process 1 Modifies Page C
Operating System Concepts with Java – 8 9.21 Silberschatz, Galvin and Gagne ©2009 th Edition
What happens if there is no free frame?
 Page replacement – find some page in memory, but not
really in use, swap it out
 algorithm
 performance – want an algorithm which will result in
minimum number of page faults
 Same page may be brought into memory several times
Operating System Concepts with Java – 8 9.22 Silberschatz, Galvin and Gagne ©2009 th Edition
Page Replacement
 Prevent over-allocation of memory by modifying page-fault service
routine to include page replacement
 Use modify (dirty) bit to reduce overhead of page transfers – only
modified pages are written to disk
 Page replacement completes separation between logical memory and
physical memory – large virtual memory can be provided on a smaller
physical memory
Operating System Concepts with Java – 8 9.23 Silberschatz, Galvin and Gagne ©2009 th Edition
Need For Page Replacement
Operating System Concepts with Java – 8 9.24 Silberschatz, Galvin and Gagne ©2009 th Edition
Basic Page Replacement
1. Find the location of the desired page on disk
2. Find a free frame:
- If there is a free frame, use it
- If there is no free frame, use a page replacement
algorithm to select a victim frame
3. Bring the desired page into the (newly) free frame; update the page
and frame tables
4. Restart the process
Operating System Concepts with Java – 8 9.25 Silberschatz, Galvin and Gagne ©2009 th Edition
Page Replacement
Operating System Concepts with Java – 8 9.26 Silberschatz, Galvin and Gagne ©2009 th Edition
Page Replacement Algorithms
 Want lowest page-fault rate
 Evaluate algorithm by running it on a particular string of memory
references (reference string) and computing the number of page faults
on that string
 In all our examples, the reference string is
1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5
Operating System Concepts with Java – 8 9.27 Silberschatz, Galvin and Gagne ©2009 th Edition
Graph of Page Faults Versus
The Number of Frames
Operating System Concepts with Java – 8 9.28 Silberschatz, Galvin and Gagne ©2009 th Edition
First-In-First-Out (FIFO) Algorithm
 Reference string: 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5
 3 frames (3 pages can be in memory at a time per process)
 4 frames
 Belady’s Anomaly: more frames  more page faults
1
2
3
1
2
3
4
1
2
5
3
4
9 page faults
1
2
3
1
2
3
5
1
2
4
5 10 page faults
4 4 3
Operating System Concepts with Java – 8 9.29 Silberschatz, Galvin and Gagne ©2009 th Edition
FIFO Page Replacement
Operating System Concepts with Java – 8 9.30 Silberschatz, Galvin and Gagne ©2009 th Edition
FIFO Illustrating Belady’s Anomaly
Operating System Concepts with Java – 8 9.31 Silberschatz, Galvin and Gagne ©2009 th Edition
Optimal Algorithm
 Replace page that will not be used for longest period of time
 4 frames example
1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5
 How do you know this?
 Used for measuring how well your algorithm performs
1
2
3
4
6 page faults
4 5
Operating System Concepts with Java – 8 9.32 Silberschatz, Galvin and Gagne ©2009 th Edition
Optimal Page Replacement
Operating System Concepts with Java – 8 9.33 Silberschatz, Galvin and Gagne ©2009 th Edition
Least Recently Used (LRU) Algorithm
 Reference string: 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5
 Counter implementation
 Every page entry has a counter; every time page is referenced
through this entry, copy the clock into the counter
 When a page needs to be changed, look at the counters to
determine which are to change
5
2
4
3
1
2
3
4
1
2
5
4
1
2
5
3
1
2
4
3
Operating System Concepts with Java – 8 9.34 Silberschatz, Galvin and Gagne ©2009 th Edition
LRU Page Replacement
Operating System Concepts with Java – 8 9.35 Silberschatz, Galvin and Gagne ©2009 th Edition
LRU Algorithm (Cont.)
 Stack implementation – keep a stack of page numbers in a double link
form:
 Page referenced:
 move it to the top
 requires 6 pointers to be changed
 No search for replacement
Operating System Concepts with Java – 8 9.36 Silberschatz, Galvin and Gagne ©2009 th Edition
Use Of A Stack to Record
the Most Recent Page References
Operating System Concepts with Java – 8 9.37 Silberschatz, Galvin and Gagne ©2009 th Edition
LRU Approximation Algorithms
 Reference bit
 With each page associate a bit, initially = 0
 When page is referenced bit set to 1
 Replace the one which is 0 (if one exists)
 We do not know the order, however
 Second chance
 Need reference bit
 Clock replacement
 If page to be replaced (in clock order) has reference bit = 1
then:
 set reference bit 0
 leave page in memory
 replace next page (in clock order), subject to same
rules
Operating System Concepts with Java – 8 9.38 Silberschatz, Galvin and Gagne ©2009 th Edition
Second-Chance (clock)
Page-Replacement Algorithm
Operating System Concepts with Java – 8 9.39 Silberschatz, Galvin and Gagne ©2009 th Edition
Counting Algorithms
 Keep a counter of the number of references that have been made to
each page
 LFU Algorithm: replaces page with smallest count
 MFU Algorithm: based on the argument that the page with the
smallest count was probably just brought in and has yet to be used
Operating System Concepts with Java – 8 9.40 Silberschatz, Galvin and Gagne ©2009 th Edition
Allocation of Frames
 Each process needs minimum number of pages
 Example: IBM 370 – 6 pages to handle SS MOVE instruction:
 instruction is 6 bytes, might span 2 pages
 2 pages to handle from
 2 pages to handle to
 Two major allocation schemes
 fixed allocation
 priority allocation
Operating System Concepts with Java – 8 9.41 Silberschatz, Galvin and Gagne ©2009 th Edition
Fixed Allocation
 Equal allocation – For example, if there are 100 frames and 5
processes, give each process 20 frames.
 Proportional allocation – Allocate according to the size of
process
m
S
s
a p
m
S s
s p
i
i i
i
i i
  

 

allocation for
total number of frames
size of process
64 59
137
127
64 5
137
10
127
10
64
2
1
2
  
  



a
a
s
s
m
i
Operating System Concepts with Java – 8 9.42 Silberschatz, Galvin and Gagne ©2009 th Edition
Priority Allocation
 Use a proportional allocation scheme using priorities rather than size
 If process Pi generates a page fault,
 select for replacement one of its frames
 select for replacement a frame from a process with lower priority
number
Operating System Concepts with Java – 8 9.43 Silberschatz, Galvin and Gagne ©2009 th Edition
Global vs. Local Allocation
 Global replacement – process selects a replacement frame from the
set of all frames; one process can take a frame from another
 Local replacement – each process selects from only its own set of
allocated frames
Operating System Concepts with Java – 8 9.44 Silberschatz, Galvin and Gagne ©2009 th Edition
Thrashing
 If a process does not have “enough” pages, the page-fault rate is
very high. This leads to:
 low CPU utilization
 operating system thinks that it needs to increase the degree of
multiprogramming
 another process added to the system
 Thrashing  a process is busy swapping pages in and out
Operating System Concepts with Java – 8 9.45 Silberschatz, Galvin and Gagne ©2009 th Edition
Thrashing (Cont.)
Operating System Concepts with Java – 8 9.46 Silberschatz, Galvin and Gagne ©2009 th Edition
Demand Paging and Thrashing
 Why does demand paging work?
Locality model
 Process migrates from one locality to another
 Localities may overlap
 Why does thrashing occur?
 size of locality > total memory size
Operating System Concepts with Java – 8 9.47 Silberschatz, Galvin and Gagne ©2009 th Edition
Locality In A Memory-Reference Pattern
Operating System Concepts with Java – 8 9.48 Silberschatz, Galvin and Gagne ©2009 th Edition
Working-Set Model
   working-set window  a fixed number of page references
Example: 10,000 instruction
 WSSi
(working set of Process Pi
) =
total number of pages referenced in the most recent  (varies in time)
 if  too small will not encompass entire locality
 if  too large will encompass several localities
 if  =   will encompass entire program
 D =  WSSi  total demand frames
 if D > m  Thrashing
 Policy if D > m, then suspend one of the processes
Operating System Concepts with Java – 8 9.49 Silberschatz, Galvin and Gagne ©2009 th Edition
Working-set model
Operating System Concepts with Java – 8 9.50 Silberschatz, Galvin and Gagne ©2009 th Edition
Keeping Track of the Working Set
 Approximate with interval timer + a reference bit
 Example:  = 10,000
 Timer interrupts after every 5000 time units
 Keep in memory 2 bits for each page
 Whenever a timer interrupts copy and sets the values of all
reference bits to 0
 If one of the bits in memory = 1  page in working set
 Why is this not completely accurate?
 Improvement = 10 bits and interrupt every 1000 time units
Operating System Concepts with Java – 8 9.51 Silberschatz, Galvin and Gagne ©2009 th Edition
Page-Fault Frequency Scheme
 Establish “acceptable” page-fault rate
 If actual rate too low, process loses frame
 If actual rate too high, process gains frame
Operating System Concepts with Java – 8 9.52 Silberschatz, Galvin and Gagne ©2009 th Edition
Working Sets and Page Fault Rates
Operating System Concepts with Java – 8 9.53 Silberschatz, Galvin and Gagne ©2009 th Edition
Memory-Mapped Files
 Memory-mapped file I/O allows file I/O to be treated as routine memory
access by mapping a disk block to a page in memory.
 A file is initially read using demand paging. A page-sized portion of the
file is read from the file system into a physical page. Subsequent
reads/writes to/from the file are treated as ordinary memory accesses.
 Simplifies file access by treating file I/O through memory rather than
read() write() system calls.
 Also allows several processes to map the same file allowing the pages
in memory to be shared.
Operating System Concepts with Java – 8 9.54 Silberschatz, Galvin and Gagne ©2009 th Edition
Memory Mapped Files
Operating System Concepts with Java – 8 9.55 Silberschatz, Galvin and Gagne ©2009 th Edition
Memory-Mapped Shared Memory
in Windows
Operating System Concepts with Java – 8 9.56 Silberschatz, Galvin and Gagne ©2009 th Edition
Memory-Mapped Files in Java
Operating System Concepts with Java – 8 9.57 Silberschatz, Galvin and Gagne ©2009 th Edition
Allocating Kernel Memory
 Treated differently from user memory
 Often allocated from a free-memory pool
 Kernel requests memory for structures of varying sizes
 Some kernel memory needs to be contiguous
Operating System Concepts with Java – 8 9.58 Silberschatz, Galvin and Gagne ©2009 th Edition
Buddy System
 Allocates memory from fixed-size segment consisting of physicallycontiguous pages
 Memory allocated using power-of-2 allocator
 Satisfies requests in units sized as power of 2
 Request rounded up to next highest power of 2
 When smaller allocation needed than is available, current chunk
split into two buddies of next-lower power of 2
 Continue until appropriate sized chunk available
Operating System Concepts with Java – 8 9.59 Silberschatz, Galvin and Gagne ©2009 th Edition
Buddy System Allocator
Operating System Concepts with Java – 8 9.60 Silberschatz, Galvin and Gagne ©2009 th Edition
Slab Allocator
 Alternate strategy
 Slab is one or more physically contiguous pages
 Cache consists of one or more slabs
 Single cache for each unique kernel data structure
 Each cache filled with objects – instantiations of the data structure
 When cache created, filled with objects marked as free
 When structures stored, objects marked as used
 If slab is full of used objects, next object allocated from empty slab
 If no empty slabs, new slab allocated
 Benefits include no fragmentation, fast memory request satisfaction
Operating System Concepts with Java – 8 9.61 Silberschatz, Galvin and Gagne ©2009 th Edition
Slab Allocation
Operating System Concepts with Java – 8 9.62 Silberschatz, Galvin and Gagne ©2009 th Edition
Other Issues -- Prepaging
 Prepaging
 To reduce the large number of page faults that occurs at process
startup
 Prepage all or some of the pages a process will need, before
they are referenced
 But if prepaged pages are unused, I/O and memory was wasted
 Assume s pages are prepaged and α of the pages is used
 Is cost of s * α save pages faults > or < than the cost of
prepaging
s * (1- α) unnecessary pages?
 α near zero  prepaging loses
Operating System Concepts with Java – 8 9.63 Silberschatz, Galvin and Gagne ©2009 th Edition
Other Issues – Page Size
 Page size selection must take into consideration:
 fragmentation
 table size
 I/O overhead
 locality
Operating System Concepts with Java – 8 9.64 Silberschatz, Galvin and Gagne ©2009 th Edition
Other Issues – TLB Reach
 TLB Reach - The amount of memory accessible from the TLB
 TLB Reach = (TLB Size) X (Page Size)
 Ideally, the working set of each process is stored in the TLB
 Otherwise there is a high degree of page faults
 Increase the Page Size
 This may lead to an increase in fragmentation as not all
applications require a large page size
 Provide Multiple Page Sizes
 This allows applications that require larger page sizes the
opportunity to use them without an increase in fragmentation
Operating System Concepts with Java – 8 9.65 Silberschatz, Galvin and Gagne ©2009 th Edition
Other Issues – Program Structure
 Program structure
 Int[128,128] data;
 Each row is stored in one page
 Program 1
for (j = 0; j <128; j++)
for (i = 0; i < 128; i++)
data[i,j] = 0;
128 x 128 = 16,384 page faults
 Program 2
for (i = 0; i < 128; i++)
for (j = 0; j < 128; j++)
data[i,j] = 0;
128 page faults
Operating System Concepts with Java – 8 9.66 Silberschatz, Galvin and Gagne ©2009 th Edition
Other Issues – I/O interlock
 I/O Interlock – Pages must sometimes be locked into memory
 Consider I/O - Pages that are used for copying a file from a device
must be locked from being selected for eviction by a page
replacement algorithm
Operating System Concepts with Java – 8 9.67 Silberschatz, Galvin and Gagne ©2009 th Edition
Reason Why Frames Used For I/O
Must Be In Memory
Operating System Concepts with Java – 8 9.68 Silberschatz, Galvin and Gagne ©2009 th Edition
Operating System Examples
 Windows XP
 Solaris
Operating System Concepts with Java – 8 9.69 Silberschatz, Galvin and Gagne ©2009 th Edition
Windows XP
 Uses demand paging with clustering. Clustering brings in pages
surrounding the faulting page.
 Processes are assigned working set minimum and working set
maximum.
 Working set minimum is the minimum number of pages the process is
guaranteed to have in memory.
 A process may be assigned as many pages up to its working set
maximum.
 When the amount of free memory in the system falls below a threshold,
automatic working set trimming is performed to restore the amount
of free memory.
 Working set trimming removes pages from processes that have pages
in excess of their working set minimum.
Operating System Concepts with Java – 8 9.70 Silberschatz, Galvin and Gagne ©2009 th Edition
Solaris
 Maintains a list of free pages to assign faulting processes
 Lotsfree – threshold parameter (amount of free memory) to begin paging
 Desfree – threshold parameter to increasing paging
 Minfree – threshold parameter to being swapping
 Paging is performed by pageout process
 Pageout scans pages using modified clock algorithm
 Scanrate is the rate at which pages are scanned. This ranges from
slowscan to fastscan
 Pageout is called more frequently depending upon the amount of free
memory available
Operating System Concepts with Java – 8 9.71 Silberschatz, Galvin and Gagne ©2009 th Edition
Solaris 2 Page Scanner
Operating System Concepts with Java – 8 9.72 Silberschatz, Galvin and Gagne ©2009 th Edition
End of Chapter 9
Operating System Concepts with Java – 8 10.1 Silberschatz, Galvin and Gagne ©2009 th Edition
Chapter 10: File-System Interface
Operating System Concepts with Java – 8 10.2 Silberschatz, Galvin and Gagne ©2009 th Edition
Chapter 10: File-System Interface
 File Concept
 Access Methods
 Directory Structure
 File-System Mounting
 File Sharing
 Protection
Operating System Concepts with Java – 8 10.3 Silberschatz, Galvin and Gagne ©2009 th Edition
Objectives
 To explain the function of file systems
 To describe the interfaces to file systems
 To discuss file-system design tradeoffs, including access methods, file
sharing, file locking, and directory structures
 To explore file-system protection
Operating System Concepts with Java – 8 10.4 Silberschatz, Galvin and Gagne ©2009 th Edition
File Concept
 Contiguous logical address space
 Types:
 Data
 numeric
 character
 binary
 Program
Operating System Concepts with Java – 8 10.5 Silberschatz, Galvin and Gagne ©2009 th Edition
File Structure
 None - sequence of words, bytes
 Simple record structure
 Lines
 Fixed length
 Variable length
 Complex Structures
 Formatted document
 Relocatable load file
 Can simulate last two with first method by inserting appropriate control
characters
 Who decides:
 Operating system
 Program
Operating System Concepts with Java – 8 10.6 Silberschatz, Galvin and Gagne ©2009 th Edition
File Attributes
 Name – only information kept in human-readable form
 Identifier – unique tag (number) identifies file within file system
 Type – needed for systems that support different types
 Location – pointer to file location on device
 Size – current file size
 Protection – controls who can do reading, writing, executing
 Time, date, and user identification – data for protection, security, and
usage monitoring
 Information about files are kept in the directory structure, which is
maintained on the disk
Operating System Concepts with Java – 8 10.7 Silberschatz, Galvin and Gagne ©2009 th Edition
File Operations
 File is an abstract data type
 Create
 Write
 Read
 Reposition within file
 Delete
 Truncate
 Open(Fi
) – search the directory structure on disk for entry Fi
, and move
the content of entry to memory
 Close (Fi
) – move the content of entry Fi
in memory to directory
structure on disk
Operating System Concepts with Java – 8 10.8 Silberschatz, Galvin and Gagne ©2009 th Edition
Open Files
 Several pieces of data are needed to manage open files:
 File pointer: pointer to last read/write location, per process that
has the file open
 File-open count: counter of number of times a file is open – to allow
removal of data from open-file table when last processes closes it
 Disk location of the file: cache of data access information
 Access rights: per-process access mode information
Operating System Concepts with Java – 8 10.9 Silberschatz, Galvin and Gagne ©2009 th Edition
Open File Locking
 Provided by some operating systems and file systems
 Mediates access to a file
 Mandatory or advisory:
 Mandatory – access is denied depending on locks held and
requested
 Advisory – processes can find status of locks and decide what to
do
Operating System Concepts with Java – 8 10.10 Silberschatz, Galvin and Gagne ©2009 th Edition
File Locking Example – Java API
import java.io.*;
import java.nio.channels.*;
public class LockingExample {
public static final boolean EXCLUSIVE = false;
public static final boolean SHARED = true;
public static void main(String arsg[]) throws IOException {
FileLock sharedLock = null;
FileLock exclusiveLock = null;
try {
RandomAccessFile raf = new RandomAccessFile("file.txt", "rw");
// get the channel for the file
FileChannel ch = raf.getChannel();
// this locks the first half of the file - exclusive
exclusiveLock = ch.lock(0, raf.length()/2, EXCLUSIVE);
/** Now modify the data . . . */
// release the lock
exclusiveLock.release();
Operating System Concepts with Java – 8 10.11 Silberschatz, Galvin and Gagne ©2009 th Edition
File Locking Example – Java API (Cont.)
// this locks the second half of the file - shared
sharedLock = ch.lock(raf.length()/2+1, raf.length(),
SHARED);
/** Now read the data . . . */
// release the lock
sharedLock.release();
} catch (java.io.IOException ioe) {
System.err.println(ioe);
}finally {
if (exclusiveLock != null)
exclusiveLock.release();
if (sharedLock != null)
sharedLock.release();
}
}
}
Operating System Concepts with Java – 8 10.12 Silberschatz, Galvin and Gagne ©2009 th Edition
File Types – Name, Extension
Operating System Concepts with Java – 8 10.13 Silberschatz, Galvin and Gagne ©2009 th Edition
Access Methods
 Sequential Access
read next
write next
reset
no read after last write
(rewrite)
 Direct Access
read n
write n
position to n
read next
write next
rewrite n
n = relative block number
Operating System Concepts with Java – 8 10.14 Silberschatz, Galvin and Gagne ©2009 th Edition
Sequential-access File
Operating System Concepts with Java – 8 10.15 Silberschatz, Galvin and Gagne ©2009 th Edition
Simulation of Sequential Access on
Direct-access File
Operating System Concepts with Java – 8 10.16 Silberschatz, Galvin and Gagne ©2009 th Edition
Example of Index and Relative Files
Operating System Concepts with Java – 8 10.17 Silberschatz, Galvin and Gagne ©2009 th Edition
Directory Structure
 A collection of nodes containing information about all files
F 1 F 2 F 3
F 4
F n
Directory
Files
Both the directory structure and the files reside on disk
Backups of these two structures are kept on tapes
Operating System Concepts with Java – 8 10.18 Silberschatz, Galvin and Gagne ©2009 th Edition
Disk Structure
 Disk can be subdivided into partitions
 Disks or partitions can be RAID protected against failure
 Disk or partition can be used raw – without a file system, or formatted
with a file system
 Partitions also known as minidisks, slices
 Entity containing file system known as a volume
 Each volume containing file system also tracks that file system’s info in
device directory or volume table of contents
 As well as general-purpose file systems there are many specialpurpose file systems, frequently all within the same operating system
or computer
Operating System Concepts with Java – 8 10.19 Silberschatz, Galvin and Gagne ©2009 th Edition
A Typical File-System Organization
Operating System Concepts with Java – 8 10.20 Silberschatz, Galvin and Gagne ©2009 th Edition
Operations Performed on Directory
 Search for a file
 Create a file
 Delete a file
 List a directory
 Rename a file
 Traverse the file system
Operating System Concepts with Java – 8 10.21 Silberschatz, Galvin and Gagne ©2009 th Edition
Organize the Directory (Logically) to Obtain
 Efficiency – locating a file quickly
 Naming – convenient to users
 Two users can have same name for different files
 The same file can have several different names
 Grouping – logical grouping of files by properties, (e.g., all Java
programs, all games, …)
Operating System Concepts with Java – 8 10.22 Silberschatz, Galvin and Gagne ©2009 th Edition
Single-Level Directory
 A single directory for all users
Naming problem
Grouping problem
Operating System Concepts with Java – 8 10.23 Silberschatz, Galvin and Gagne ©2009 th Edition
Two-Level Directory
 Separate directory for each user
 Path name
 Can have the same file name for different user
 Efficient searching
 No grouping capability
Operating System Concepts with Java – 8 10.24 Silberschatz, Galvin and Gagne ©2009 th Edition
Tree-Structured Directories
Operating System Concepts with Java – 8 10.25 Silberschatz, Galvin and Gagne ©2009 th Edition
Tree-Structured Directories (Cont.)
 Efficient searching
 Grouping Capability
 Current directory (working directory)
 cd/spell/mail/prog
 type list
Operating System Concepts with Java – 8 10.26 Silberschatz, Galvin and Gagne ©2009 th Edition
 Absolute or relative path name
 Creating a new file is done in current directory
 Delete a file
rm <file-name>
 Creating a new subdirectory is done in current directory
mkdir <dir-name>
Example: if in current directory /mail
mkdir count
mail
prog copy prt exp count
Deleting “mail”  deleting the entire subtree rooted by “mail”
Tree-Structured Directories (Cont.)
Operating System Concepts with Java – 8 10.27 Silberschatz, Galvin and Gagne ©2009 th Edition
Acyclic-Graph Directories
 Have shared subdirectories and files
Operating System Concepts with Java – 8 10.28 Silberschatz, Galvin and Gagne ©2009 th Edition
Acyclic-Graph Directories (Cont.)
 Two different names (aliasing)
 If dict deletes list  dangling pointer
Solutions:
 Backpointers, so we can delete all pointers
Variable size records a problem
 Backpointers using a daisy chain organization
 Entry-hold-count solution
 New directory entry type
 Link – another name (pointer) to an existing file
 Resolve the link – follow pointer to locate the file
Operating System Concepts with Java – 8 10.29 Silberschatz, Galvin and Gagne ©2009 th Edition
General Graph Directory
Operating System Concepts with Java – 8 10.30 Silberschatz, Galvin and Gagne ©2009 th Edition
General Graph Directory (Cont.)
 How do we guarantee no cycles?
 Allow only links to file not subdirectories
 Garbage collection
 Every time a new link is added use a cycle detection
algorithm to determine whether it is OK
Operating System Concepts with Java – 8 10.31 Silberschatz, Galvin and Gagne ©2009 th Edition
File System Mounting
 A file system must be mounted before it can be accessed
 A unmounted file system (i.e. Fig. 11-11(b)) is mounted at a mount
point
Operating System Concepts with Java – 8 10.32 Silberschatz, Galvin and Gagne ©2009 th Edition
(a) Existing. (b) Unmounted Partition
Operating System Concepts with Java – 8 10.33 Silberschatz, Galvin and Gagne ©2009 th Edition
Mount Point
Operating System Concepts with Java – 8 10.34 Silberschatz, Galvin and Gagne ©2009 th Edition
File Sharing
 Sharing of files on multi-user systems is desirable
 Sharing may be done through a protection scheme
 On distributed systems, files may be shared across a network
 Network File System (NFS) is a common distributed file-sharing method
Operating System Concepts with Java – 8 10.35 Silberschatz, Galvin and Gagne ©2009 th Edition
File Sharing – Multiple Users
 User IDs identify users, allowing permissions and protections to be
per-user
 Group IDs allow users to be in groups, permitting group access rights
Operating System Concepts with Java – 8 10.36 Silberschatz, Galvin and Gagne ©2009 th Edition
File Sharing – Remote File Systems
 Uses networking to allow file system access between systems
 Manually via programs like FTP
 Automatically, seamlessly using distributed file systems
 Semi automatically via the world wide web
 Client-server model allows clients to mount remote file systems from
servers
 Server can serve multiple clients
 Client and user-on-client identification is insecure or complicated
 NFS is standard UNIX client-server file sharing protocol
 CIFS is standard Windows protocol
 Standard operating system file calls are translated into remote calls
 Distributed Information Systems (distributed naming services) such as
LDAP, DNS, NIS, Active Directory implement unified access to
information needed for remote computing
Operating System Concepts with Java – 8 10.37 Silberschatz, Galvin and Gagne ©2009 th Edition
File Sharing – Failure Modes
 Remote file systems add new failure modes, due to network failure,
server failure
 Recovery from failure can involve state information about status of
each remote request
 Stateless protocols such as NFS include all information in each
request, allowing easy recovery but less security
Operating System Concepts with Java – 8 10.38 Silberschatz, Galvin and Gagne ©2009 th Edition
File Sharing – Consistency Semantics
 Consistency semantics specify how multiple users are to access a
shared file simultaneously
 Similar to Ch 7 process synchronization algorithms
 Tend to be less complex due to disk I/O and network latency
(for remote file systems
 Andrew File System (AFS) implemented complex remote file
sharing semantics
 Unix file system (UFS) implements:
 Writes to an open file visible immediately to other users of the
same open file
 Sharing file pointer to allow multiple users to read and write
concurrently
 AFS has session semantics
 Writes only visible to sessions starting after the file is closed
Operating System Concepts with Java – 8 10.39 Silberschatz, Galvin and Gagne ©2009 th Edition
Protection
 File owner/creator should be able to control:
 what can be done
 by whom
 Types of access
 Read
 Write
 Execute
 Append
 Delete
 List
Operating System Concepts with Java – 8 10.40 Silberschatz, Galvin and Gagne ©2009 th Edition
Access Lists and Groups
 Mode of access: read, write, execute
 Three classes of users
RWX
a) owner access 7  1 1 1
RWX
b) group access 6  1 1 0
RWX
c) public access 1  0 0 1
 Ask manager to create a group (unique name), say G, and add
some users to the group.
 For a particular file (say game) or subdirectory, define an
appropriate access.
owner group public
chmod 761 game
Attach a group to a file
chgrp G game
Operating System Concepts with Java – 8 10.41 Silberschatz, Galvin and Gagne ©2009 th Edition
Windows XP Access-control List Management
Operating System Concepts with Java – 8 10.42 Silberschatz, Galvin and Gagne ©2009 th Edition
A Sample UNIX Directory Listing
Operating System Concepts with Java – 8 10.43 Silberschatz, Galvin and Gagne ©2009 th Edition
End of Chapter 10
Operating System Concepts with Java – 8 11.1 Silberschatz, Galvin and Gagne ©2009 th Edition
Chapter 11:
File System Implementation
Operating System Concepts with Java – 8 11.2 Silberschatz, Galvin and Gagne ©2009 th Edition
Chapter 11: File System Implementation
 File-System Structure
 File-System Implementation
 Directory Implementation
 Allocation Methods
 Free-Space Management
 Efficiency and Performance
 Recovery
 NFS
 Example: WAFL File System
Operating System Concepts with Java – 8 11.3 Silberschatz, Galvin and Gagne ©2009 th Edition
Objectives
 To describe the details of implementing local file systems and directory
structures
 To describe the implementation of remote file systems
 To discuss block allocation and free-block algorithms and trade-offs
Operating System Concepts with Java – 8 11.4 Silberschatz, Galvin and Gagne ©2009 th Edition
File-System Structure
 File structure
 Logical storage unit
 Collection of related information
 File system organized into layers
 File system resides on secondary storage (disks)
 Provides efficient and convenient access to disk by allowing data to
be stored, located retrieved easily
 File control block – storage structure consisting of information about
a file
 Device driver controls the physical device
Operating System Concepts with Java – 8 11.5 Silberschatz, Galvin and Gagne ©2009 th Edition
Layered File System
Operating System Concepts with Java – 8 11.6 Silberschatz, Galvin and Gagne ©2009 th Edition
File-System Implementation
 Boot control block contains info needed by system to boot OS from
that volume
 Volume control block contains volume details
 Directory structure organizes the files
 Per-file File Control Block (FCB) contains many details about the file
Operating System Concepts with Java – 8 11.7 Silberschatz, Galvin and Gagne ©2009 th Edition
A Typical File Control Block
Operating System Concepts with Java – 8 11.8 Silberschatz, Galvin and Gagne ©2009 th Edition
In-Memory File System Structures
 The following figure illustrates the necessary file system structures
provided by the operating systems.
 Figure 12-3(a) refers to opening a file.
 Figure 12-3(b) refers to reading a file.
Operating System Concepts with Java – 8 11.9 Silberschatz, Galvin and Gagne ©2009 th Edition
In-Memory File System Structures
Operating System Concepts with Java – 8 11.10 Silberschatz, Galvin and Gagne ©2009 th Edition
Virtual File Systems
 Virtual File Systems (VFS) provide an object-oriented way of
implementing file systems.
 VFS allows the same system call interface (the API) to be used for
different types of file systems.
 The API is to the VFS interface, rather than any specific type of file
system.
Operating System Concepts with Java – 8 11.11 Silberschatz, Galvin and Gagne ©2009 th Edition
Schematic View of Virtual File System
Operating System Concepts with Java – 8 11.12 Silberschatz, Galvin and Gagne ©2009 th Edition
Directory Implementation
 Linear list of file names with pointer to the data blocks.
 simple to program
 time-consuming to execute
 Hash Table – linear list with hash data structure.
 decreases directory search time
 collisions – situations where two file names hash to the same
location
 fixed size
Operating System Concepts with Java – 8 11.13 Silberschatz, Galvin and Gagne ©2009 th Edition
Allocation Methods
 An allocation method refers to how disk blocks are allocated for files:
 Contiguous allocation
 Linked allocation
 Indexed allocation
Operating System Concepts with Java – 8 11.14 Silberschatz, Galvin and Gagne ©2009 th Edition
Contiguous Allocation
 Each file occupies a set of contiguous blocks on the disk
 Simple – only starting location (block #) and length (number of blocks)
are required
 Random access
 Wasteful of space (dynamic storage-allocation problem)
 Files cannot grow
Operating System Concepts with Java – 8 11.15 Silberschatz, Galvin and Gagne ©2009 th Edition
Contiguous Allocation
 Mapping from logical to physical
LA/512
Q
R
Block to be accessed = ! + starting address
Displacement into block = R
Operating System Concepts with Java – 8 11.16 Silberschatz, Galvin and Gagne ©2009 th Edition
Contiguous Allocation of Disk Space
Operating System Concepts with Java – 8 11.17 Silberschatz, Galvin and Gagne ©2009 th Edition
Extent-Based Systems
 Many newer file systems (i.e., Veritas File System) use a modified
contiguous allocation scheme
 Extent-based file systems allocate disk blocks in extents
 An extent is a contiguous block of disks
 Extents are allocated for file allocation
 A file consists of one or more extents
Operating System Concepts with Java – 8 11.18 Silberschatz, Galvin and Gagne ©2009 th Edition
Linked Allocation
 Each file is a linked list of disk blocks: blocks may be scattered
anywhere on the disk.
block = pointer
Operating System Concepts with Java – 8 11.19 Silberschatz, Galvin and Gagne ©2009 th Edition
Linked Allocation (Cont.)
 Simple – need only starting address
 Free-space management system – no waste of space
 No random access
 Mapping
Block to be accessed is the Qth block in the linked chain of
blocks representing the file.
Displacement into block = R + 1
 File-allocation table (FAT) – disk-space allocation used by MSDOS and OS/2.
LA/511
Q
R
Operating System Concepts with Java – 8 11.20 Silberschatz, Galvin and Gagne ©2009 th Edition
Linked Allocation
Operating System Concepts with Java – 8 11.21 Silberschatz, Galvin and Gagne ©2009 th Edition
File-Allocation Table
Operating System Concepts with Java – 8 11.22 Silberschatz, Galvin and Gagne ©2009 th Edition
Indexed Allocation
 Brings all pointers together into the index block
 Logical view
index table
Operating System Concepts with Java – 8 11.23 Silberschatz, Galvin and Gagne ©2009 th Edition
Example of Indexed Allocation
Operating System Concepts with Java – 8 11.24 Silberschatz, Galvin and Gagne ©2009 th Edition
Indexed Allocation (Cont.)
 Need index table
 Random access
 Dynamic access without external fragmentation, but have overhead of
index block
 Mapping from logical to physical in a file of maximum size of 256K
words and block size of 512 words. We need only 1 block for index
table
LA/512
Q
R
Q = displacement into index table
R = displacement into block
Operating System Concepts with Java – 8 11.25 Silberschatz, Galvin and Gagne ©2009 th Edition
Indexed Allocation – Mapping (Cont.)
 Mapping from logical to physical in a file of unbounded length
(block size of 512 words)
 Linked scheme – Link blocks of index table (no limit on size)
LA / (512 x 511)
Q1
R1
Q1 = block of index table
R1
is used as follows:
R1
/ 512
Q2
R2
Q2 = displacement into block of index table
R2 displacement into block of file:
Operating System Concepts with Java – 8 11.26 Silberschatz, Galvin and Gagne ©2009 th Edition
Indexed Allocation – Mapping (Cont.)
 Two-level index (maximum file size is 5123
)
LA / (512 x 512)
Q1
R1
Q1 = displacement into outer-index
R1
is used as follows:
R1
/ 512
Q2
R2
Q2 = displacement into block of index table
R2 displacement into block of file:
Operating System Concepts with Java – 8 11.27 Silberschatz, Galvin and Gagne ©2009 th Edition
Indexed Allocation – Mapping (Cont.)

outer-index
index table file
Operating System Concepts with Java – 8 11.28 Silberschatz, Galvin and Gagne ©2009 th Edition
Combined Scheme:
UNIX UFS (4K bytes per block)
Operating System Concepts with Java – 8 11.29 Silberschatz, Galvin and Gagne ©2009 th Edition
Free-Space Management
 Bit vector (n blocks)
…
0 1 2 n-1
bit[i] =

0  block[i] free
1  block[i] occupied
Block number calculation
(number of bits per word) *
(number of 0-value words) +
offset of first 1 bit
Operating System Concepts with Java – 8 11.30 Silberschatz, Galvin and Gagne ©2009 th Edition
Free-Space Management (Cont.)
 Bit map requires extra space
 Example:
block size = 212 bytes
disk size = 230 bytes (1 gigabyte)
n = 230/212 = 218 bits (or 32K bytes)
 Easy to get contiguous files
 Linked list (free list)
 Cannot get contiguous space easily
 No waste of space
 Grouping
 Counting
Operating System Concepts with Java – 8 11.31 Silberschatz, Galvin and Gagne ©2009 th Edition
Free-Space Management (Cont.)
 Need to protect:
 Pointer to free list
 Bit map
 Must be kept on disk
 Copy in memory and disk may differ
 Cannot allow for block[i] to have a situation where bit[i] =
1 in memory and bit[i] = 0 on disk
 Solution:
 Set bit[i] = 1 in disk
 Allocate block[i]
 Set bit[i] = 1 in memory
Operating System Concepts with Java – 8 11.32 Silberschatz, Galvin and Gagne ©2009 th Edition
Directory Implementation
 Linear list of file names with pointer to the data blocks
 simple to program
 time-consuming to execute
 Hash Table – linear list with hash data structure
 decreases directory search time
 collisions – situations where two file names hash to the same
location
 fixed size
Operating System Concepts with Java – 8 11.33 Silberschatz, Galvin and Gagne ©2009 th Edition
Linked Free Space List on Disk
Operating System Concepts with Java – 8 11.34 Silberschatz, Galvin and Gagne ©2009 th Edition
Efficiency and Performance
 Efficiency dependent on:
 disk allocation and directory algorithms
 types of data kept in file’s directory entry
 Performance
 disk cache – separate section of main memory for frequently used
blocks
 free-behind and read-ahead – techniques to optimize sequential
access
 improve PC performance by dedicating section of memory as
virtual disk, or RAM disk
Operating System Concepts with Java – 8 11.35 Silberschatz, Galvin and Gagne ©2009 th Edition
Page Cache
 A page cache caches pages rather than disk blocks using virtual
memory techniques
 Memory-mapped I/O uses a page cache
 Routine I/O through the file system uses the buffer (disk) cache
 This leads to the following figure
Operating System Concepts with Java – 8 11.36 Silberschatz, Galvin and Gagne ©2009 th Edition
I/O Without a Unified Buffer Cache
Operating System Concepts with Java – 8 11.37 Silberschatz, Galvin and Gagne ©2009 th Edition
Unified Buffer Cache
 A unified buffer cache uses the same page cache to cache both
memory-mapped pages and ordinary file system I/O
Operating System Concepts with Java – 8 11.38 Silberschatz, Galvin and Gagne ©2009 th Edition
I/O Using a Unified Buffer Cache
Operating System Concepts with Java – 8 11.39 Silberschatz, Galvin and Gagne ©2009 th Edition
Recovery
 Consistency checking – compares data in directory structure with
data blocks on disk, and tries to fix inconsistencies
 Use system programs to back up data from disk to another storage
device (magnetic tape, other magnetic disk, optical)
 Recover lost file or disk by restoring data from backup
Operating System Concepts with Java – 8 11.40 Silberschatz, Galvin and Gagne ©2009 th Edition
Log Structured File Systems
 Log structured (or journaling) file systems record each update to
the file system as a transaction.
 All transactions are written to a log.
 A transaction is considered committed once it is written to the log.
 However, the file system may not yet be updated.
 The transactions in the log are asynchronously written to the file
system.
 When the file system is modified, the transaction is removed from
the log.
 If the file system crashes, all remaining transactions in the log must
still be performed.
Operating System Concepts with Java – 8 11.41 Silberschatz, Galvin and Gagne ©2009 th Edition
The Sun Network File System (NFS)
 An implementation and a specification of a software system for
accessing remote files across LANs (or WANs).
 The implementation is part of the Solaris and SunOS operating
systems running on Sun workstations using an unreliable datagram
protocol (UDP/IP protocol and Ethernet.
Operating System Concepts with Java – 8 11.42 Silberschatz, Galvin and Gagne ©2009 th Edition
NFS (Cont.)
 Interconnected workstations viewed as a set of independent machines
with independent file systems, which allows sharing among these file
systems in a transparent manner.
 A remote directory is mounted over a local file system directory.
 The mounted directory looks like an integral subtree of the
local file system, replacing the subtree descending from the
local directory.
 Specification of the remote directory for the mount operation is
nontransparent; the host name of the remote directory has to be
provided.
 Files in the remote directory can then be accessed in a
transparent manner.
 Subject to access-rights accreditation, potentially any file system
(or directory within a file system), can be mounted remotely on top
of any local directory.
Operating System Concepts with Java – 8 11.43 Silberschatz, Galvin and Gagne ©2009 th Edition
NFS (Cont.)
 NFS is designed to operate in a heterogeneous environment of
different machines, operating systems, and network architectures; the
NFS specifications independent of these media.
 This independence is achieved through the use of RPC primitives built
on top of an External Data Representation (XDR) protocol used
between two implementation-independent interfaces.
 The NFS specification distinguishes between the services provided by
a mount mechanism and the actual remote-file-access services.
Operating System Concepts with Java – 8 11.44 Silberschatz, Galvin and Gagne ©2009 th Edition
Three Independent File Systems
Operating System Concepts with Java – 8 11.45 Silberschatz, Galvin and Gagne ©2009 th Edition
Mounting in NFS
Mounts Cascading mounts
Operating System Concepts with Java – 8 11.46 Silberschatz, Galvin and Gagne ©2009 th Edition
NFS Mount Protocol
 Establishes initial logical connection between server and client
 Mount operation includes name of remote directory to be mounted and
name of server machine storing it
 Mount request is mapped to corresponding RPC and forwarded to
mount server running on server machine
 Export list – specifies local file systems that server exports for
mounting, along with names of machines that are permitted to
mount them
 Following a mount request that conforms to its export list, the server
returns a file handle—a key for further accesses
 File handle – a file-system identifier, and an inode number to identify
the mounted directory within the exported file system
 The mount operation changes only the user’s view and does not affect
the server side
Operating System Concepts with Java – 8 11.47 Silberschatz, Galvin and Gagne ©2009 th Edition
NFS Protocol
 Provides a set of remote procedure calls for remote file operations.
The procedures support the following operations:
 searching for a file within a directory
 reading a set of directory entries
 manipulating links and directories
 accessing file attributes
 reading and writing files
 NFS servers are stateless; each request has to provide a full set of
arguments
(NFS V4 is just coming available – very different, stateful)
 Modified data must be committed to the server’s disk before results are
returned to the client (lose advantages of caching)
 The NFS protocol does not provide concurrency-control mechanisms
Operating System Concepts with Java – 8 11.48 Silberschatz, Galvin and Gagne ©2009 th Edition
Three Major Layers of NFS Architecture
 UNIX file-system interface (based on the open, read, write, and close
calls, and file descriptors)
 Virtual File System (VFS) layer – distinguishes local files from remote
ones, and local files are further distinguished according to their filesystem types
 The VFS activates file-system-specific operations to handle local
requests according to their file-system types
 Calls the NFS protocol procedures for remote requests
 NFS service layer – bottom layer of the architecture
 Implements the NFS protocol
Operating System Concepts with Java – 8 11.49 Silberschatz, Galvin and Gagne ©2009 th Edition
Schematic View of NFS Architecture
Operating System Concepts with Java – 8 11.50 Silberschatz, Galvin and Gagne ©2009 th Edition
NFS Path-Name Translation
 Performed by breaking the path into component names and performing
a separate NFS lookup call for every pair of component name and
directory vnode
 To make lookup faster, a directory name lookup cache on the client’s
side holds the vnodes for remote directory names
Operating System Concepts with Java – 8 11.51 Silberschatz, Galvin and Gagne ©2009 th Edition
NFS Remote Operations
 Nearly one-to-one correspondence between regular UNIX system
calls and the NFS protocol RPCs (except opening and closing files)
 NFS adheres to the remote-service paradigm, but employs buffering
and caching techniques for the sake of performance
 File-blocks cache – when a file is opened, the kernel checks with the
remote server whether to fetch or revalidate the cached attributes
 Cached file blocks are used only if the corresponding cached
attributes are up to date
 File-attribute cache – the attribute cache is updated whenever new
attributes arrive from the server
 Clients do not free delayed-write blocks until the server confirms that
the data have been written to disk
Operating System Concepts with Java – 8 11.52 Silberschatz, Galvin and Gagne ©2009 th Edition
Example: WAFL File System
 Used on Network Appliance “Filers” – distributed file system appliances
 “Write-anywhere file layout”
 Serves up NFS, CIFS, http, ftp
 Random I/O optimized, write optimized
 NVRAM for write caching
 Similar to Berkeley Fast File System, with extensive modifications
Operating System Concepts with Java – 8 11.53 Silberschatz, Galvin and Gagne ©2009 th Edition
The WAFL File Layout
Operating System Concepts with Java – 8 11.54 Silberschatz, Galvin and Gagne ©2009 th Edition
Snapshots in WAFL
Operating System Concepts with Java – 8 11.55 Silberschatz, Galvin and Gagne ©2009 th Edition
End of Chapter 11
Operating System Concepts with Java – 8 13.1 Silberschatz, Galvin and Gagne ©2009 th Edition
Chapter 13: I/O Systems
Operating System Concepts with Java – 8 13.2 Silberschatz, Galvin and Gagne ©2009 th Edition
Chapter 13: I/O Systems
 I/O Hardware
 Application I/O Interface
 Kernel I/O Subsystem
 Transforming I/O Requests to Hardware Operations
 STREAMS
 Performance
Operating System Concepts with Java – 8 13.3 Silberschatz, Galvin and Gagne ©2009 th Edition
Objectives
 Explore the structure of an operating system’s I/O subsystem
 Discuss the principles of I/O hardware and its complexity
 Provide details of the performance aspects of I/O hardware and software
Operating System Concepts with Java – 8 13.4 Silberschatz, Galvin and Gagne ©2009 th Edition
I/O Hardware
 Incredible variety of I/O devices
 Common concepts
 Port
 Bus (daisy chain or shared direct access)
 Controller (host adapter)
 I/O instructions control devices
 Devices have addresses, used by
 Direct I/O instructions
 Memory-mapped I/O
Operating System Concepts with Java – 8 13.5 Silberschatz, Galvin and Gagne ©2009 th Edition
A Typical PC Bus Structure
Operating System Concepts with Java – 8 13.6 Silberschatz, Galvin and Gagne ©2009 th Edition
Device I/O Port Locations on PCs (partial)
Operating System Concepts with Java – 8 13.7 Silberschatz, Galvin and Gagne ©2009 th Edition
Polling
 Determines state of device
 command-ready
 busy
 Error
 Busy-wait cycle to wait for I/O from device
Operating System Concepts with Java – 8 13.8 Silberschatz, Galvin and Gagne ©2009 th Edition
Interrupts
 CPU Interrupt-request line triggered by I/O device
 Interrupt handler receives interrupts
 Maskable to ignore or delay some interrupts
 Interrupt vector to dispatch interrupt to correct handler
 Based on priority
 Some nonmaskable
 Interrupt mechanism also used for exceptions
Operating System Concepts with Java – 8 13.9 Silberschatz, Galvin and Gagne ©2009 th Edition
Interrupt-Driven I/O Cycle
Operating System Concepts with Java – 8 13.10 Silberschatz, Galvin and Gagne ©2009 th Edition
Intel Pentium Processor Event-Vector Table
Operating System Concepts with Java – 8 13.11 Silberschatz, Galvin and Gagne ©2009 th Edition
Direct Memory Access
 Used to avoid programmed I/O for large data movement
 Requires DMA controller
 Bypasses CPU to transfer data directly between I/O device and
memory
Operating System Concepts with Java – 8 13.12 Silberschatz, Galvin and Gagne ©2009 th Edition
Six Step Process to Perform DMA Transfer
Operating System Concepts with Java – 8 13.13 Silberschatz, Galvin and Gagne ©2009 th Edition
Application I/O Interface
 I/O system calls encapsulate device behaviors in generic classes.
 Device-driver layer hides differences among I/O controllers from
kernel.
 Devices vary in many dimensions.
 Character-stream or block
 Sequential or random-access
 Sharable or dedicated
 Speed of operation
 read-write, read only, or write only
Operating System Concepts with Java – 8 13.14 Silberschatz, Galvin and Gagne ©2009 th Edition
A Kernel I/O Structure
Operating System Concepts with Java – 8 13.15 Silberschatz, Galvin and Gagne ©2009 th Edition
Characteristics of I/O Devices
Operating System Concepts with Java – 8 13.16 Silberschatz, Galvin and Gagne ©2009 th Edition
Block and Character Devices
 Block devices include disk drives
 Commands include read, write, seek
 Raw I/O or file-system access
 Memory-mapped file access possible
 Character devices include keyboards, mice, serial ports
 Commands include get(), put()
 Libraries layered on top allow line editing
Operating System Concepts with Java – 8 13.17 Silberschatz, Galvin and Gagne ©2009 th Edition
Network Devices
 Varying enough from block and character to have own interface
 Unix and Windows NT/9x/2000 include socket interface
 Separates network protocol from network operation
 Includes select() functionality
 Approaches vary widely (pipes, FIFOs, streams, queues, mailboxes)
Operating System Concepts with Java – 8 13.18 Silberschatz, Galvin and Gagne ©2009 th Edition
Clocks and Timers
 Provide current time, elapsed time, timer
 Programmable interval timer used for timings, periodic interrupts
 ioctl() (on UNIX) covers odd aspects of I/O such as clocks and
timers
Operating System Concepts with Java – 8 13.19 Silberschatz, Galvin and Gagne ©2009 th Edition
Blocking and Nonblocking I/O
 Blocking - process suspended until I/O completed
 Easy to use and understand
 Insufficient for some needs
 Nonblocking - I/O call returns as much as available
 User interface, data copy (buffered I/O)
 Implemented via multi-threading
 Returns quickly with count of bytes read or written
 Asynchronous - process runs while I/O executes
 Difficult to use
 I/O subsystem signals process when I/O completed
Operating System Concepts with Java – 8 13.20 Silberschatz, Galvin and Gagne ©2009 th Edition
Two I/O Methods
Synchronous Asynchronous
Operating System Concepts with Java – 8 13.21 Silberschatz, Galvin and Gagne ©2009 th Edition
Kernel I/O Subsystem
 Scheduling
 Some I/O request ordering via per-device queue
 Some OSs try fairness
 Buffering - store data in memory while transferring between devices
 To cope with device speed mismatch
 To cope with device transfer size mismatch
 To maintain “copy semantics”
Operating System Concepts with Java – 8 13.22 Silberschatz, Galvin and Gagne ©2009 th Edition
Device-status Table
Operating System Concepts with Java – 8 13.23 Silberschatz, Galvin and Gagne ©2009 th Edition
Sun Enterprise 6000 Device-Transfer Rates
Operating System Concepts with Java – 8 13.24 Silberschatz, Galvin and Gagne ©2009 th Edition
Kernel I/O Subsystem
 Caching - fast memory holding copy of data
 Always just a copy
 Key to performance
 Spooling - hold output for a device
 If device can serve only one request at a time
 i.e., Printing
 Device reservation - provides exclusive access to a device
 System calls for allocation and deallocation
 Watch out for deadlock
Operating System Concepts with Java – 8 13.25 Silberschatz, Galvin and Gagne ©2009 th Edition
Error Handling
 OS can recover from disk read, device unavailable, transient write
failures
 Most return an error number or code when I/O request fails
 System error logs hold problem reports
Operating System Concepts with Java – 8 13.26 Silberschatz, Galvin and Gagne ©2009 th Edition
I/O Protection
 User process may accidentally or purposefully attempt to disrupt
normal operation via illegal I/O instructions.
 All I/O instructions defined to be privileged.
 I/O must be performed via system calls.
 Memory-mapped and I/O port memory locations must be
protected too.
Operating System Concepts with Java – 8 13.27 Silberschatz, Galvin and Gagne ©2009 th Edition
Use of a System Call to Perform I/O
Operating System Concepts with Java – 8 13.28 Silberschatz, Galvin and Gagne ©2009 th Edition
Kernel Data Structures
 Kernel keeps state info for I/O components, including open file tables,
network connections, character device state.
 Many, many complex data structures to track buffers, memory
allocation, “dirty” blocks.
 Some use object-oriented methods and message passing to implement
I/O.
Operating System Concepts with Java – 8 13.29 Silberschatz, Galvin and Gagne ©2009 th Edition
UNIX I/O Kernel Structure
Operating System Concepts with Java – 8 13.30 Silberschatz, Galvin and Gagne ©2009 th Edition
I/O Requests to Hardware Operations
 Consider reading a file from disk for a process:
 Determine device holding file
 Translate name to device representation
 Physically read data from disk into buffer
 Make data available to requesting process
 Return control to process
Operating System Concepts with Java – 8 13.31 Silberschatz, Galvin and Gagne ©2009 th Edition
Life Cycle of An I/O Request
Operating System Concepts with Java – 8 13.32 Silberschatz, Galvin and Gagne ©2009 th Edition
STREAMS
 STREAM – a full-duplex communication channel between a user-level
process and a device in Unix System V and beyond.
 A STREAM consists of:
- STREAM head interfaces with the user process
- driver end interfaces with the device
- zero or more STREAM modules between them.
 Each module contains a read queue and a write queue.
 Message passing is used to communicate between queues.
Operating System Concepts with Java – 8 13.33 Silberschatz, Galvin and Gagne ©2009 th Edition
The STREAMS Structure
Operating System Concepts with Java – 8 13.34 Silberschatz, Galvin and Gagne ©2009 th Edition
Performance
 I/O a major factor in system performance:
 Demands CPU to execute device driver, kernel I/O code
 Context switches due to interrupts
 Data copying
 Network traffic especially stressful
Operating System Concepts with Java – 8 13.35 Silberschatz, Galvin and Gagne ©2009 th Edition
Intercomputer Communications
Operating System Concepts with Java – 8 13.36 Silberschatz, Galvin and Gagne ©2009 th Edition
Improving Performance
 Reduce number of context switches
 Reduce data copying
 Reduce interrupts by using large transfers, smart controllers, polling
 Use DMA
 Balance CPU, memory, bus, and I/O performance for highest
throughput
Operating System Concepts with Java – 8 13.37 Silberschatz, Galvin and Gagne ©2009 th Edition
Device-Functionality Progression
Operating System Concepts with Java – 8 13.38 Silberschatz, Galvin and Gagne ©2009 th Edition
End of Chapter 13
İşletim Sistemleri Dersi
Son
Bilgi Güvenliği Dersi
Giriş
æ
UYGULAMALI MATEMAT˙IK ENST˙ITUS¨ U, ¨ Kriptografi B¨olum¨ u¨
ODTU, ¨ TURK ¨ ˙IYE
KR˙IPTOLOJ˙IYE G˙IR˙IS¸ DERS NOTLARI

Kriptolojiye Giri¸s Ders Notları,
Prof. Dr. Ersan Akyıldız
Do¸c. Dr. Ali Do˘ganaksoy
Yrd. Do¸c. Ebru Keyman
Dr. Muhiddin U˘guz
g¨ozetimi altında a¸sa˘gıda adı ge¸cen ki¸siler tarafından hazırlanmı¸stır:
Kadir Altan
Kerem Ka¸skalo˘glu
Nihal Kındap
C¸ i˘gdem Ozakın ¨
Zulf ¨ uk¨ ar Saygı
Elif Yıldırım
Murat Yıldırım
Senay Yıldız
Derleyenler: Ebru Keyman - Murat Yıldırım
2
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
˙IC¸ ˙INDEK˙ILER
1 G˙IR˙IS¸ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
2 BLOK S¸˙IFRELER . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
2.1 Blok S¸ifre Sistemlerinin Parametreleri . . . . . . . . . . . . . . . . . . . . 7
2.1.1 Blok Uzunlu˘gu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
2.1.2 Anahtar ve Ger¸cek Anahtar Uzunlu˘gu . . . . . . . . . . . . . . . . 7
2.2 Blok S¸ifre Sistemlerinin Tasarım Ol¸ ¨ cutleri ¨ . . . . . . . . . . . . . . . . . . 8
2.2.1 Yayılma . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
2.2.2 Nufuz ¨ Etme . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
2.3 D¨ongul ¨ u¨ (Iterated) Blok S¸ifre Sistemleri . . . . . . . . . . . . . . . . . . . 9
2.4 Feistel Yapılar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
3 DES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
3.1 DES Algoritması . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
3.1.1 Ba¸slangı¸c Permutasy ¨ onu . . . . . . . . . . . . . . . . . . . . . . . . 12
3.1.2 Ba¸slangı¸c Permutasy ¨ onun Tersi . . . . . . . . . . . . . . . . . . . . 12
3.1.3 Anahtar Permutasy ¨ onu ve D¨ongu¨ Anahtarının Uretilmesi ¨ . . . . . . 13
3.1.4 f fonksiyonu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
3.2 DES’in Tasarım Ozellikleri ¨ . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
4 RIJNDAEL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
3
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
4.1 Matematiksel Ozellikler ¨ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
4.1.1 Toplama ˙I¸slemi . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
4.1.2 C¸ arpma ˙I¸slemi . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
4.2 Algoritma . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
4.2.1 Byte Sub . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
4.2.2 Shift Row . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
4.2.3 Mix Column . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
4.2.4 Anahtarla XOR’lama . . . . . . . . . . . . . . . . . . . . . . . . . . 27
4.3 Anahtar Algoritması . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.4 ALGOR˙ITMANIN TERS˙I . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
4.4.1 Mix Column . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
4.4.2 Byte Sub . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
5 AKAN S¸˙IFRELER. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
5.1 One Time Pad Sistemi . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
5.1.1 Sistemin Avantajları . . . . . . . . . . . . . . . . . . . . . . . . . . 33
5.1.2 Sistemin Dezavantajları . . . . . . . . . . . . . . . . . . . . . . . . 33
5.2 Dizi Ureticiler ¨ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
5.3 Geri Beslemeli KaydırmalıYazdırga¸c (Feedback Shift Register) . . . . . . . 37
5.4 Uretecinin ¨ Sahip Olması Gereken Ozellikler ¨ . . . . . . . . . . . . . . . . . 41
5.4.1 ˙Istatistiksel Ozellikler ¨ . . . . . . . . . . . . . . . . . . . . . . . . . . 41
5.5 Do˘grusal Geri Beslemeli KaydırmalıYazdırga¸c (LFSR) . . . . . . . . . . . . 44
5.5.1 Dizinin Periyodu . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
5.6 Do˘grusal Karma¸sıklık (Linear Complexity) . . . . . . . . . . . . . . . . . . 49
4
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
5.6.1 Do˘grusal Karma¸sıklık Profili (Linear Complexity Profile) . . . . . . 50
5.6.2 Berleckamp Massey Algoritması . . . . . . . . . . . . . . . . . . . . 51
5.7 LFSR Kullanılarak Yapılan Akan S¸ifre Sistemleri . . . . . . . . . . . . . . 52
6 SAYILAR TEOR˙IS˙I . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
6.1 Tamsayılar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
6.1.1 B¨olunebilirlik: ¨ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
6.1.2 B¨olunebilirlik ¨ Ozellikleri ¨ . . . . . . . . . . . . . . . . . . . . . . . . 58
6.1.3 Tamsayılar i¸cin B¨olum¨ Algoritması: . . . . . . . . . . . . . . . . . . 59
6.1.4 En Buy¨ uk¨ Ortak B¨olen (Greatest Common Divisor) . . . . . . . . . 59
6.1.5 En Ku¸¨cuk¨ Ortak Kat (Least common Multiple) . . . . . . . . . . . 60
6.1.6 Asal Sayı . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
6.1.7 Aralarında Asal Sayı . . . . . . . . . . . . . . . . . . . . . . . . . . 61
6.1.8 Aritmeti˘gin Esas Teoremi . . . . . . . . . . . . . . . . . . . . . . . 61
6.1.9 Oklid ¨ Algoritması(Euclidean Algorithm) . . . . . . . . . . . . . . . 61
6.2 Asal Sayılar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
6.2.1 Eratosthenes Kalburu(The Sieve of Eratosthenes) . . . . . . . . . . 64
6.3 Eratosthenes Metodu (Method of Eratosthenes) . . . . . . . . . . . . . . . 65
6.4 Denklik Teorisi(Theory of Congruence (Modularity)) . . . . . . . . . . . . 66
6.4.1 Teoremler: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
6.4.2 Aritmetik Tersi . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67
6.5 Euler Fi(φ) Fonksiyonu (Euler Phi Function) . . . . . . . . . . . . . . . . . 68
7 AC¸ IK ANAHTARLI S˙ISTEMLER . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
5
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
7.1 MERKLE-HELLMAN KNAPSACK
KR˙IPTOS˙ISTEM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
7.1.1 Sup¨ erartan dizi (Superincreasing sequence) . . . . . . . . . . . . . . 71
7.1.2 Sup¨ erartan Altkume ¨ Toplama Problemini c¨¸ozme Algoritması . . . . 71
7.1.3 Merkle-HellmanKnapsack S¸ifrelemesinde Anahtar Olu¸sturma Algoritması . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
7.1.4 Basit Merkle-Hellman Knapsack A¸cık Anahtar S¸ifreleme Algoritması 73
7.2 RSA Kriptosistem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75
7.3 RSA ˙Imza S¸eması . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
7.3.1 ˙Imzalama . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
7.3.2 ˙Imzayı Do˘grulama . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
7.4 Ayrık Logaritma(Discrete Logarithm) . . . . . . . . . . . . . . . . . . . . . 81
7.5 El-Gamal A¸cık Anahtarlı Kriptosistem . . . . . . . . . . . . . . . . . . . . 81
7.6 ElGamal A¸cık Anahtarlı S¸ifrelemede Anahtar Olu¸sturma Algoritması . . . 82
7.6.1 ElGamal A¸cık Anahtarlı S¸ifreleme
Algoritması . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82
7.6.2 ElGamal ˙Imzası . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
7.6.3 ˙Imza Algoritması . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
7.6.4 Do˘grulama . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
7.7 Diffie-Hellman Anahtar Anl¸sması (Diffie-Hellman Key Agreement) . . . . . 86
7.7.1 Diffie-Hellman Anahtar Anla¸sması Algoritması: . . . . . . . . . . . 86
8 KR˙IPTANAL˙IZ. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
8.1 Kriptanalitik Atakların Ama¸cları . . . . . . . . . . . . . . . . . . . . . . . 90
8.2 Kriptanaliz Metodları(Methods of Cryptanalysis) . . . . . . . . . . . . . . 91
6
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
8.3 Akan S¸ifrelerin Analizi . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
8.4 Blok S¸ifrelerin Analizi . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97
8.4.1 Difransiyel Kriptanaliz . . . . . . . . . . . . . . . . . . . . . . . . . 97
8.4.2 Do˘grusal Kriptanaliz . . . . . . . . . . . . . . . . . . . . . . . . . . 105
9 HASH FONKS˙IYONLARI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108
10 TEST YONTEMLER ¨ ˙I . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
11 KR˙IPTOGRAF˙IK PROTOKOLLER . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
7
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
BOL¨ UM¨ 1
G˙IR˙IS¸
S¸ifre sistemleri a¸cık anahtarlı ve gizli anahtarlı (simetrik) olmak uzere ¨ ikiye ayrılır. A¸cık
anahtarlı sistemlerde her ki¸si, biri a¸cık di˘geri gizli olmak uzere ¨ bir cift ¸ anahtar edinir. A¸cık
anahtar di˘ger kullanıcıların eri¸simine a¸cıkken; gizli anahtar sadece sahibinin eri¸sebilece˘gi
¸sekilde saklanmalıdır. A¸cık anahtarı kullanarak herhangi bir ki¸si ¸sifreli mesaj g¨onderebilir,
ancak g¨onderilen ¸sifreli mesajı sadece kullanılan a¸cık anahtarın e¸si olan gizli anahtar
a¸cabilir. A¸cık anahtarlı ¸sifre sistemleri sadece ¸sifreli mesaj g¨ondermek amacıyla de˘gil,
kimlik denetimi yani sayısal imza ve daha bir¸cok teknik i¸cin kullanılır. A¸cık anahtarlı
sistemlerde, her zaman gizli anahtarın a¸cık anahtarla matematiksel bir ba˘gıntısı vardır.
Bu anahtarları olu¸sturmak i¸cin c¨¸ozulememi ¨ ¸s matematik problemleri kullanıldı˘gından, a¸cık
anahtarı kullananarak gizli anahtarı elde etme i¸slemi de imkansız kabul edilir.
Ornek ¨ 1.0.1 A, B kullanıcılar, KA, KB kullanıcıların a¸cık anahtarları ve K0
A, K0
B kullanıcıların gizli anahtarları olsun. Her bir kullanıcı di˘gerlerinin a¸cık anahtarını bilir. B
kullanıcısı A kullanıcısına bir mesajı g¨ondermek i¸cin mesajı KA ile ¸sifreleyip g¨onderir, A
kullanıcısı ¸sifrelenmi¸s mesajı K0
A ile de¸sifre eder.
A¸cık anahtarlı sistemleri ayrıntılı olarak ilerki konularda o˘¨grenece˘giz. Oncelikle ¨ gizli
anahtarlı yani simetrik sistemlerden bahsedelim. Simetrik sistemlerde tek bir anahtar,
hem ¸sifreleme hem de de¸sifre amacıyla kullanılır. Guv¨ enli bir ¸sekilde ileti¸sim kur1
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
madan once ¨ g¨onderici ile alıcının gizli anahtar olarak adlandırılan bir anahtar uzerinde ¨
uzla¸smaları gerekir.
Simetrik sistemlerde temel problem, g¨ondericinin ve alıcının u¸¨cunc ¨ u¨ bir ki¸sinin eline
ge¸cmesini engelleyerek ortak bir anahtar uzerinde ¨ anla¸smalarıdır. Ancak simetrik sistemlerin avantajı da, a¸cık anahtarlı sistemlere g¨ore daha hızlı olmalarıdır.
Bir sistemin guv¨ enli˘gi anahtarda yatar. S¸ifre c¨¸ozmeye y¨onelik ataklar anahtarı bulmaya
y¨oneliktir. Kriptanalist sahip oldu˘gu on¨ bilgiye g¨ore farklı saldırı ce¸ ¸sitleri uygular. Bunlar:
Sadece S¸ifreli Metin Saldırısı : Kriptanalist, aynı ¸sifreleme algoritması kullanılarak
¸sifrelenmi¸s ce¸ ¸sitli a¸cık metinlerin ¸sifreli metinlerine sahiptir. Kriptanalist mumk ¨ un¨
oldu˘gunca cok ¸ sayıdaki ¸sifreli metinin a¸cık metnini bulmaya calı ¸ ¸sır. Asıl onemli ¨ olan
ise a¸cık metinleri ¸sifrelemek i¸cin kullanılan anahtarı ya da anahtarları, aynı anahtarla
¸sifrelenen ba¸ska mesajları c¨¸ozmek i¸cin bulmaktır.
Bilinen A¸cık Metin Saldırısı : Kriptanalist sadece ce¸ ¸sitli a¸cık metinlerin ¸sifrelenmi¸s
haline de˘gil, bu mesajların a¸cık metinlerine de eri¸sebilmektedir.
Se¸cilmi¸s A¸cık Metin Saldırısı : Kriptanalist sadece ce¸ ¸sitli a¸cık metinlerin ¸sifreli
metinlerine ve bunlarla ili¸skilendirilmi¸s a¸cık metinlere eri¸smekle kalmayıp, aynı zamanda
da ¸sifrelenmi¸s a¸cık metinleri se¸cebilmektedir. Bu atak bilinen a¸cık metin ata˘gından daha
gu¸¨clu¨ bir ataktır. C¸unk ¨ u¨ kriptanalist ¸sifrelemek i¸cin a¸cık metinin belirli bloklarını yani
anahtar hakkında daha fazla bilgi sa˘glayabilecek olanları se¸cebilmektedir.
Simetrik sistemler Blok S¸ifre Sistemleri ve Akan S¸ifre Sistemleri olarak ikiye ayrılır.
2
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
BOL¨ UM¨ 2
BLOK S¸˙IFRELER
Blok ¸sifrelemenin en basit tanımı, a¸cık metni biti¸sik bloklara b¨olme, her blo˘gu ¸sifreleyerek
¸sifreli metin bloklarına d¨onu¨¸sturme, ¨ bu ¸sifreli blokları ¸sifreli metin cıkı ¸ ¸sı olarak gruplamaktır. Blok ¸sifre sistemini ¸sekille g¨ostermek istersek, M1, M2, . . . , Mn a¸cık metnin blokları, yani her biri k bitten olu¸san ardı¸sık par¸caları, C1, C2, . . . ,Cn bu bloklara kar¸sılık gelen ¸sifrelenmi¸s metinler ve E ¸sifreleme i¸slemi olmak uzere, ¨ blok ¸sifre sistemlerini a¸sa˘gıdaki
¸semayla g¨osterebiliriz.
Blok ¸sifre Sistemlerinde ¸sifreleme
C¸ o˘gu blok ¸sifre sistemlerinde blok uzunlu˘gu 64 bittir. ˙I¸slemcilerin hızı arttık¸ca blok
uzunlu˘gu da artabilmektedir. Son yıllarda uretilen ¨ sistemler 128 bit blok uzunlu˘gu kullanılmaya ba¸slanmı¸stır.
3
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Bir blok ¸sifre sisteminde, ¸sifreli metin bloklarından birinin kaybolması, di˘ger blokların
de¸sifre i¸sleminde bir yanlı¸slı˘ga neden olmaz. Bu blok ¸sifre sistemlerinin en buy¨ uk¨ avantajıdır. Blok ¸sifre sistemlerinin en buy¨ uk¨ dezavantajı ise ¸sifreli metindeki birbirinin aynısı
olan blokların, a¸cık metinde de birbirinin aynı olmasıdır.
Ornek ¨ 2.0.2 ”Senay’a kitabı sen ver” cumlesini, ¨ blok uzunlu˘gu 3 olacak ¸sekilde b¨olup¨
¸sifrelersek,
A¸cık Metin: sen-aya-kit-abı-sen-ver
S¸ifreli Metin: axk-bcg-xkt-ase-axk-hyt
birinci ve be¸sinci blokların aynı ¸sekilde ¸sifrelendi˘gini g¨oruy¨ oruz.
B¨oyle bir sorunun ustesinden ¨ gelmek i¸cin ¸sifreleme i¸slemini de˘gi¸sik modellerle yapabiliriz. Mi−1, Mi
, Mi+1 a¸cık metnin ardı¸sık 3 blo˘gu, E ¸sifreleme i¸slemi, Ci−1,Ci
,Ci+1
Mi−1, Mi
, Mi+1 ardı¸sık bloklarının ¸sifreli halleri olsun.
1. Elektronik Kod Modeli (Electronic Code Mode)
4
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Elektronik Kod Modeli
Ornekteki ¨ gibi i¸sler.
2. Kapalı Metin Zincirleme Modeli (Cipher Block Chaining Mode)
Kapalı Metin Zincirleme Modeli
5
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Aslında bu modelde yaptı˘gımız i¸slemleri, buy¨ uk¨ bloklar uzerinde ¨ akan ¸sifre sistemini
uygulamak olarak g¨orebiliriz.
3. C¸ ıktıyı Geribesleme Modeli (Output Feedback Mode)
C¸ ıktıyı Geribesleme Modeli
4. Girdiyi Geribesleme Modeli (Input Feedback Mode)
Girdiyi Geribesleme Modeli
Bir blok ¸sifre sisteminin matematiksel olarak ¸s¨oyle tanımlayabiliriz. Z2 = {0 1}, Z
n
2 =
Z2×. . .×Z2 = {(xn−1, . . . , x0) : xi ∈ Z2} ve K ise anahtar uzayı olsun. E : Z
n
2 ×K → Z
n
2
6
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
ve her k ∈ K i¸cin E (p, k) tersi alınabilir bir fonksiyondur. Bu fonksiyona ¸sifreleme
fonksiyonu denir. Blok ¸sifre sistemi ile ¸sifrelenen bir mesajı de¸sifre ederken aynı sistemi
¸sifreli mesaja aynı anahtar ile uygulamak gerekir. Bunun i¸cin ¸sifreleme i¸sleminin tersinin
olması gerekir. S¸ifreleme fonksiyonunun tersine de de¸sifreleme fonksiyonu denir ve D (c, k)
ile g¨osterilir.
2.1 Blok S¸ifre Sistemlerinin Parametreleri
2.1.1 Blok Uzunlu˘gu
Bir blok ¸sifre sisteminin guv¨ enli olabilmesi i¸cin, blok uzunlu˘gunun bazı blokların
di˘gerlerinden daha fazla g¨orunmey ¨ ece˘gi ¸sekilde uzun olması gerekir. Orne˘ ¨ gin bir blok
¸sifreleme sistemi olan DES’teki 64 bit uzunluk, sıklık analizine kar¸sı DES’i gu¸¨clu¨
kılmaktadır. Aynı zamanda blok uzunlu˘gu n olan bir blok i¸cin, sabit bir anahtarla saldırı
yapan ki¸sinin elde edebilece˘gi a¸cık metin-¸sifreli metin ciftlerinin ¸ sayısı buy¨ uk¨ olmalıdır
(bu sayı 2
n yi ge¸cemez). Blok uzunlu˘gu buy¨ ud¨ uk¸ ¨ ce sistemin uygulaması da daha karı¸sık
hale gelmektedir.
2.1.2 Anahtar ve Ger¸cek Anahtar Uzunlu˘gu
Bir blok ¸sifre sisteminin anahtarı deneme-yanılma (exhaustive key search) ile bulunamamalıdır. Bunun i¸cin de anahtar uzun olmalıdır. Di˘ger taraftan da anahtar uzunlu˘gu
uretim, ¨ da˘gıtım ve saklama i¸cin uygun ve guv¨ enilir olmalıdır. Orne˘ ¨ gin DES her zaman anahtar uzunlu˘gunun kısa olmasından dolayı ele¸stirilmi¸stir. Diffie ve Hellman
7
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
DES’in anahtar deneme-yanılma yolu ile 20 milyon dolara mal olacak bir sistemle 12
saatte kırılabilece˘gini one ¨ surd ¨ uler. ¨ Gelen oneriler ¨ do˘grultusunda, DES’in ger¸cek anahtar
uzunlu˘gu 128 bite cık ¸ arıldı ve u¸¨clu¨ ¸sifreleme ile DES daha guv¨ enli bir ¸sekilde kullanılabilir
hale getirildi.
2.2 Blok S¸ifre Sistemlerinin Tasarım Ol¸ ¨ cutleri ¨
Guv¨ enli bir blok ¸sifre sisteminin kırılması zor ama uygulaması kolay olmalıdır. S¸ifreleme
ve de¸sifreleme fonksiyonlarının kolay uygulanabilir olması gerekirken, C = E(P, k) ve
P = D(C, k) e¸sitliklerinden k yı bulmanın zor olması gerekir. ilk defa Claude Shannon
tarafından onerilen ¨ tasarım ol¸ ¨ cutleri ¨ yayılma (confusion) ve nufuz ¨ etme (diffusion)dir.
2.2.1 Yayılma
Bir blok ¸sifre sistemini ya da genel olarak bir ¸sifreleme sistemini yayılma ol¸ ¨ cut ¨ une ¨ g¨ore
tasarlamak demek, ¸sifreli metinle anahtar arasındaki ili¸skiyi mumk ¨ un¨ oldu˘gunca karı¸sık
yapmaktır. Daha a¸cık bir tanım verirsek, yayılma, anahtarın a¸cık ve ¸sifreli metne
ba˘glılı˘gının kriptanaliz i¸cin faydalı olmayacak kadar karı¸sık olması demektir. Yani blok
¸sifre sistemini tanımlayan e¸sitliklerin do˘grusal olmaması ve karı¸sık olması ve b¨oylece
C = E(P, k) denkleminden anahtarı bulmanın imkansız olması gerekir.
8
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
2.2.2 Nufuz ¨ Etme
Bu ol¸ ¨ cute ¨ g¨ore her anahtar i¸cin ¸sifreleme fonksiyonu oyle ¨ olmalı ki, a¸cık metin ve ¸sifreli
metin arasındaki yapılar arasında istatiksel ba˘glılık olmamalıdır. Bu ol¸ ¨ cut ¨ un¨ olabilmesi
i¸cin anahtarın ve a¸cık metinin her bitinin ¸sifreli metini etkilemesi gerekir.
2.3 D¨ongul ¨ u¨ (Iterated) Blok S¸ifre Sistemleri
Aynı fonksiyonu belli d¨onguler ¨ i¸cinde uygulayan sistemlere d¨ongul ¨ u¨ blok ¸sifre sistemleri
denir.
D¨ongul ¨ u¨ (Iterated) Blok S¸ifre Sistemleri
Fonksiyonun ilk kullanım hari¸c girdisi; bir onceki ¨ d¨ongun¨ un¨ cıktısıdı ¸ ve anahtar ureten ¨ algoritmadan elde edilen d¨ongu¨ anahtarıdır. Orne˘ ¨ gin DES’te 16 d¨ongu¨ vardır. Algoritmada
9
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
kullanılan f fonsiyonu basit bir fonksiyon olursa uygulamada bize hız y¨onunden ¨ kolaylık
sa˘glar. D¨ongu¨ sayısı uygun ¸sekilde se¸cilirse, sistemde gereken yayılma ve nufuz ¨ etme
sa?lanır. Bu tur ¨ sistemlerde d¨ongu¨ sayısı, sistem tasarlandıktan sonra belli saldırılara
kar¸sı dayanıklılı˘gı hesaplanarak belirlenmektedir.
2.4 Feistel Yapılar
Horst Feistel tarafından ilk defa tasarlanan sistem gun¨ um¨ uzde ¨ bir¸cok modern sistemde
kullanılmaktadır.
k1, k2, . . . , kn: D¨ongu¨ Anahtarları olmak ko¸suluyla , Feistel yapılarını a¸sa˘gıdaki gibi
g¨osterebiliriz.
Feistel Yapısı
S¸ifreleme yapılırken L blo˘gu uzerine, ¨ de¸sifreleme yapılırken R blo˘gu uzerine ¨ i¸slem
yapılmaktadır. Ancak de¸sifreleme i¸sleminde d¨ongu¨ anahtarları, ters sırada kullanılmaktadır.
10
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
BOL¨ UM¨ 3
DES
3.1 DES Algoritması
DES (Data Encryption Standard) algoritması, 1970 yılında IBM tarafından geli¸stirilen
Lucifer algoritmasının biraz daha geli¸stirilmi¸s halidir. 1974’te IBM’in NSA ile birlikte
geli¸stirdi˘gi algoritma olan DES’in yayınlanmasından itibaren DES algoritması uzerinde ¨
geni¸s ol¸ ¨ cude ¨ calı ¸ ¸smalar yapılmı¸stır.
˙Ilk tasarladı˘gında donanım uygulamalarında kullanılması ama¸clanmı¸stır. ˙Ileti¸sim ama¸clı
kullanımda hem g¨onderen, hem de alıcı ¸sifreleme ve de¸sifrelemede kullanılan aynı gizli
anahtar uzerinde ¨ anla¸smı¸s olmalıdır. Gizli anahtarın guv¨ enli bir bi¸cimde da˘gıtımı i¸cin a¸cık
anahtarlı sistem kullanılabilir. DES aynı zamanda sabit diskte veri saklamak gibi tek kullanıcılı ¸sifreleme ama¸clı da kullanılabilir. DES’in en buy¨ uk¨ zayıflı˘gı 56 bitlik anahtarıdır.
Geli¸stirildi˘gi zamanlarda cok ¸ iyi bir ¸sifreleme algoritması olmasına ra˘gmen modern bilgisayarlar tarafından yapılan anahtar saldırılarına kar¸sı yetersiz kalmı¸stır. DES’in di˘ger
bir zayıflı˘gı da yava¸s olmasıdır.
DES algoritması Feistel yapısındadır. DES’i 16 d¨onguden ¨ olu¸san bir d¨onguy¨ e benzetebiliriz. ˙Ilk d¨onguy¨ e girmeden once ¨ ba¸slangı¸c permutasy ¨ onu ve son d¨onguden ¨ sonra
da ba¸slangı¸c permutasy ¨ onunun tersi uygulanır. DES algoritmasını a¸sa˘gıdaki ¸sekilde
g¨osterilebilir.
11
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
DES Algoritması
Her d¨ongu¨ bir onceki ¨ d¨onguden ¨ gelen mesajı ikiye ayırır: Li ve Ri
,i = 1, 2, . . . , 16. ˙I¸slemler
Ri uzerinde ¨ yapılır. Her d¨ongu¨ i¸cin anahtardan d¨ongu¨ anahtarları uretilir. ¨ De¸sifreleme
i¸sleminde de aynı algoritma kullanılır. Ancak anahtarların kullanım sırası tersten olur.
S¸imdi algoritmanın bile¸senlerinin tek tek inceleyelim.
3.1.1 Ba¸slangı¸c Permutasy ¨ onu
Ba¸slangı¸c permutasy ¨ onu DES’e hi¸cbir kuvvet katmamaktadır.Ba¸slangı¸c permutasy ¨ onunu
a¸sa˘gıda verilmi¸stir.
58 50 42 34 26 18 10 02 60 52 44 36 28 20 12 04
62 54 46 38 30 22 14 06 64 56 48 40 32 24 16 08
57 49 41 33 25 17 09 01 59 51 43 35 27 19 11 03
61 53 45 37 29 21 13 05 63 55 47 39 31 23 15 07
G¨oruld ¨ u˘¨gu¨ uzere, ¨ ba¸slangı¸c permutasy ¨ onunda 58. bit 1. bit yerine, 50.bit 2. bit yerine,. . . gelmektedir.
3.1.2 Ba¸slangı¸c Permutasy ¨ onun Tersi
Ba¸slangı¸c permutasy ¨ onunun tersi olan permutasy ¨ on son rounddan sonra uygulanır.Bu
permutasy ¨ on a¸sa˘gıda verilmi¸stir.
40 08 48 16 56 24 64 32 39 07 47 15 55 23 63 31
12
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
38 06 46 14 54 22 62 30 37 05 45 13 53 21 61 29
36 04 44 12 52 20 60 28 35 03 43 11 51 19 59 27
34 02 42 10 50 18 58 26 33 01 41 09 49 17 57 25
3.1.3 Anahtar Permutasy ¨ onu ve D¨ongu¨ Anahtarının Uretilmesi ¨
Anahtar uzerine ¨ ilk i¸slem 64 bitten 56 bite indirgemektir.Bunun i¸cin her 8. bit
do˘gruluk kontrolu(parit ¨ y check)i¸cin atılır. Daha sonra 56 bitlik anahtar a¸sa˘gıda verilen
permutasy ¨ ona girer.
57 49 41 33 25 17 09
01 58 50 42 34 26 18
10 02 59 51 43 35 27
19 11 03 60 52 44 36
63 55 47 39 31 23 15
07 62 54 46 38 30 22
14 06 61 53 45 37 29
21 13 05 28 20 12 04
Bu permutasy ¨ ondan sonra 56 bitlik anahtar 28 bitlik sa˘g ve sol olmak uzere ¨ iki par¸caya
ayrılır. D¨ondurme(rotation) ¨ olarak adlandırdı˘gımız kısımda, 28 bitlik par¸calar her d¨ongu¨
i¸cin 1 yada 2 bit sola kayar.Bu kaydırma d¨ondurme ¨ olarak adlandırılır c¸unk ¨ u¨ kayan bitler
sona eklenir.
D¨ongu¨ 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16
Kayma Miktarı 1 1 2 2 2 2 2 2 1 2 2 2 2 2 2 1
13
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Daha sonra anahtarı d¨onguy¨ e g¨ondermeden once ¨ tekrar bir permutasy ¨ on ger¸cekle¸sir. Bu
permutasy ¨ on sonucu 56 bit 48 bite iner. Bu permutasy ¨ on a¸sa˘gıda verilmi¸stir.
14 17 11 24 01 05
03 28 15 06 21 10
23 19 12 04 26 08
16 07 27 20 13 02
41 52 31 37 47 55
30 40 51 45 33 48
44 49 39 56 34 53
46 42 50 36 29 32
3.1.4 f fonksiyonu
Onceden ¨ de bahsedildi˘gi uzere ¨ her d¨ongude ¨ sa˘g 32 bitlik kısım (Ri) uzerine ¨ i¸slemler yapılır.
Oncelikle ¨ bu 32 bitlik kısım a¸sa˘gıdaki gibi 48 bite geni¸sletilir.
32 01 02 03 04 05 04 05 06 07 08 09
08 09 10 11 12 13 12 13 14 15 16 17
16 17 18 19 20 21 20 21 22 23 24 25
24 25 26 27 28 29 28 29 30 31 32 01
48 bitlik bu kısım d¨ongu¨ anahtarı ile x-or i¸slemine (⊕) g¨onderilir. Sonra 48 bit, 6 bitlik
8 gruba b¨olun¨ ur ¨ ve her bir grup ayrı bir S-kutusuna g¨onderilir. S-kutularında 6 bitler 4
bite cevrilir. ¸ 8 S-kutusu a¸sa˘gıda verilmi¸stir.
14
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
1. S-kutusu
00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15
0 14 04 13 01 02 15 11 08 03 10 06 12 05 09 00 07
1 00 15 07 04 14 02 13 01 10 06 12 11 09 05 03 08
2 04 01 14 08 13 06 02 11 15 12 09 07 03 10 05 00
3 15 12 08 02 04 09 01 07 05 11 03 14 10 00 06 13
Ornek ¨ 3.1.1 girdi = 101110 satır = 10(ilk ve son bitler) = 2 , sutun ¨ = 0111(ortada
kalan bitler) = 7 cıktı ¸ = 11 (onbir) = 1011
2. S-kutusu
00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15
0 15 01 08 14 06 11 03 04 09 07 02 13 12 00 05 10
1 03 13 04 07 15 02 08 14 12 00 01 10 06 09 11 05
2 00 14 07 11 10 04 13 01 05 08 12 06 09 03 02 15
3 13 08 10 01 03 15 04 02 11 06 07 12 00 05 14 09
3. S-kutusu
00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15
0 10 00 09 14 06 03 15 05 01 13 12 07 11 04 02 08
1 13 07 00 09 03 04 06 10 02 08 05 14 12 11 15 01
2 13 06 04 09 08 15 03 00 11 01 02 12 05 10 14 07
3 01 10 13 00 06 09 08 07 04 15 14 03 11 05 02 12
4. S-kutusu
00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15
0 07 13 14 03 00 06 09 10 01 02 08 05 11 12 04 15
1 13 08 11 05 06 15 00 03 04 07 02 12 01 10 14 09
2 10 06 09 00 12 11 07 13 15 01 03 14 05 02 08 04
3 03 15 00 06 10 01 13 08 09 04 05 11 12 07 02 14
5. S-kutusu
15
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15
0 02 12 04 01 07 10 11 06 08 05 03 15 13 00 14 09
1 14 11 02 12 04 07 13 01 05 00 15 10 03 09 08 06
2 04 02 01 11 10 13 07 08 15 09 12 05 06 03 00 14
3 11 08 12 07 01 14 02 13 06 15 00 09 10 04 05 03
6. S-kutusu
00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15
0 12 01 10 15 09 02 06 08 00 13 03 04 14 07 05 11
1 10 15 04 02 07 12 09 05 06 01 13 14 00 11 03 08
2 09 14 15 05 02 08 12 03 07 00 04 10 01 13 11 06
3 04 03 02 12 09 05 15 10 11 14 01 07 06 00 08 13
7. S-kutusu
00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15
0 04 11 02 14 15 00 08 13 03 12 09 07 05 10 06 01
1 13 00 11 07 04 09 01 10 14 03 05 12 02 15 08 06
2 01 04 11 13 12 03 07 14 10 15 06 08 00 05 09 02
3 06 11 13 08 01 04 10 07 09 05 00 15 14 02 03 12
8. S-kutusu
00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15
0 13 02 08 04 06 15 11 01 10 09 03 14 05 00 12 07
1 01 15 13 08 10 03 07 04 12 05 06 11 00 14 09 02
2 07 11 04 01 09 12 14 02 00 06 10 13 15 03 05 08
3 02 01 14 07 04 10 08 13 15 12 09 00 03 05 06 11
S-kutuları blok ¸sifrelerin do˘grusal olmayan kısımlarıdır. Hi¸cbir S-kutusu girdinin do˘grusal
yada afin fonksiyonu de˘gildir.
S-kutularından cık ¸ an 4 bitlik par¸calar yanyana gelerek birle¸sir ve a¸sa˘gıdaki permutasy ¨ ona
gider.
16 07 20 21
29 12 28 17
16
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
01 15 23 26
05 18 31 10
02 08 24 14
32 27 03 09
19 13 30 06
22 11 04 25
Permutasy ¨ ondan cık ¸ an 32 bitlik kısım d¨ongun¨ un¨ ba¸saında ayrılan 32 bitlik kısımla XOR
i¸slemi uygulanır.
3.2 DES’in Tasarım Ozellikleri ¨
DES’in en onemli ¨ ozelli˘ ¨ gi yayılma(confusion) ve nufuz ¨ etme(diffusion)¨ozellikleridir.
DES’te her blo˘gun her biti di˘ger bitlere ve anahtarın her bitine ba˘gımlıdır. Bunun iki
amacı vardır:Oncelikle, ¨ anahtar uzerindeki ¨ bilinmezlik(uncertanity)artmaktadır. ˙Ikinci
olaraksa, a¸cık metindeki veya anahtardaki 1 bitin de˘gi¸smesi but ¨ un¨ ¸sifreli metinin
de˘gi¸smesine sebep olur ki bu bizim ileride o˘¨grenece˘gimiz diffrensiyel kriptanalizde i¸se
yaramaktadır.
17
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
18
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
BOL¨ UM¨ 4
RIJNDAEL
4.1 Matematiksel Ozellikler ¨
8 bitten olu¸san bir byte 16’lık tabanda yazılabildi˘gi gibi polinom olarak ifade ediliyor. ˙Iki
byte’ı toplamak, carpmak ¸ ve bir byte’ın tersini almak polinomlarca ifade edilecektir.Buna
g¨ore bir b = (b7 b6 b5 b4 b3 b2 b1 b0) bytının polinom g¨osterimi:
p(a) = b7x
7 + b6x
6 + b5x
5 + b4x
4 + b3x
3 + b2x
2 + b1x + b0
Bir byte’ın de˘geri 10’luk tabanda kendisine kar¸sılık gelen sayıdır.
Ornek ¨ 4.1.1 (53)16 byte’ının de˘geri: (53)16 = ‘53‘ = 3 + 5.16 = 83
B˙It olarak ifadesi yani ikilik duzende: ¨ 83 = (0 1 0 1 0 1 1 1)
pa(x) = x
6 + x
4 + x
2 + x + 1
4.1.1 Toplama ˙I¸slemi
Byte’ların polinomlarını modulo 2’de toplamaktır. Bu i¸slem aynı zamanda iki byte’ı
XOR’lamaya da denktir.
19
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Ornek ¨ 4.1.2
a = (1 0 0 1 1 0 1 0) ⇒ pa(x) = x
7 + x
4 + x
3 + x
b = (1 0 1 0 1 0 1 1) ⇒ pb(x) = x
7 + x
5 + x
3 + x + 1
pa(x) + pb(x) = x
7 + x
4 + x
3 + x + x
7 + x
5 + x
3 + x + 1 mod 2
= x
5 + x
4 + 1 ⇒ (0 0 1 1 0 0 0 1)
a ⊕ b = (0 0 1 1 0 0 0 1)
4.1.2 C¸ arpma ˙I¸slemi
1. ˙Iki Byte’ı C¸ arpma:
carpma ¸ i¸sleminde, iki byte polinom olarak ifade edilir. ˙Iki polinom carpılır, ¸
carpma ¸ i¸slemi mod m(x) = x
8 + x
4 + x
3 + x + 1 de yapılır. m(x) modulo 2’de
carpanlarına ¸ ayrılamayan bir polinomdur. Modulo 2’de carpanlarına ¸ ayrılamamak
demek katsayıları 1 veya 0 olan polinomların carpımı ¸ ¸seklinde yazılamamak demektir. Bir polinomun modulo m(x)’deki de˘geri polinomun m(x)’e b¨olum¨ unden ¨ kalana
denktir.
Bir polinomun m(x)’e b¨olum¨ unden ¨ kalanı bulmak i¸cin polinomda x
8+x
4+x
3+x+1
g¨orulen ¨ yere 0 koymaktır. Bu aynı zamanda x
8 g¨orulen ¨ yere x
4+x
3+x+1 koymakla
aynıdır.
Bir byte’ın polinom g¨osteriminde en fazla yedinci dereceden bir terim olaca˘gından
iki byte’ın carpımının ¸ yine bir byte olabilmesi polinom ifadesinde derecesi sekiz ve
sekizden buy¨ uk¨ terimlerin yok edilmesi gerekiyor. Bu nedenle carpma ¸ i¸slemi modulo
20
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
2’de carpanlarına ¸ ayrılamamyan bir polinom olan mod m(x) de yapılıyor
Not: Bu i¸slem i¸cin derecesi 8 olan ve modulo 2’de carpanlarına ¸ ayrılamamyan ba¸ska
bir polinom da se¸cilebilirdi.
Kısaca:
a → pa(x)
b → pb(x)
(a).(b) = pa(x).pb(x) mod m(x)
Ornek ¨ 4.1.3
a = (0 1 0 1 0 1 0 1) ⇒ pa(x) = x
6 + x
4 + x
2 + 1
b = (1 0 0 0 0 0 1 1) ⇒ pb(x) = x
7 + x + 1
21
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
(a).(b) = pa(x).pb(x) mod m(x) = x
8 + x
4 + x
3 + x + 1
= (x
6 + x
4 + x
2 + 1)(x
7 + x + 1)
= x
13 + x
7 + x
6 + x
11 + x
5 + x
4 + x
9 + x
3 + x
2 + x
7 + x + 1
= x
13 + x
11 + x
9 + x
6 + x
5 + x
4 + x
3 + x
2 + x + 1
= x
5x
8 + x
3x
8 + x + x
8 + x
6 + x
5 + x
4 + x
3 + x
2 + x + 1
= x
5
(x
4 + x
3 + x + 1) + x
3
(x
4 + x
3 + x + 1) + x(x
4 + x
3 + x + 1)
+x
6 + x
5 + x
4 + x
3 + x
2 + x + 1
= x
9 + x
8 + x
6 + x
5 + x
7 + x
6 + x
4 + x
3 + x
5 + x
4 + x
2 + x
+x
6 + x
5 + x
4 + x
3 + x
2 + x + 1
= x
9 + x
8 + x
7 + x
6 + x
5 + x
4 + 1
= xx8 + x
8 + x
7 + x
6 + x
5 + x
4 + 1
= x(x
4 + x
3 + x + 1) + x
4 + x
3 + x + 1 + x
7 + x
6 + x
5 + x
4 + 1
= x
5 + x
4 + x
2 + x + x
4 + x
3 + x + 1 + x
7 + x
6 + x
5 + x
4 + 1
= x
7 + x
6 + x
4 + x
3 + x
2
⇒ (a)(b) = (1 1 0 1 1 1 0 0)
2. 4 Byte’lık Vekt¨orleri C¸ arpma:
4 byle’lık bir vekt¨or olan ~a = (a3, a2, a1, a0) polinom olarak ifade edilir.
p~a(x) = a3x
3 + a2x
2 + a1x + a0
Burada a3, a2, a1, a0’ın byte oldukları unutulmamalıdır.
22
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
~a ve
~b = (b3, b2, b1, b0) vekt¨orleri i¸cin:
~a.~b = p~a(x).p~b
(x) mod M(x) = x
4 + 1
Aynı zamanda








c0
c1
c2
c3








=








a0 a3 a2 a1
a1 a0 a3 a2
a2 a1 a0 a3
a3 a2 a1 a0








.








b0
b1
b2
b3








Not: 4 byte’lık bir ~b = (b3, b2, b1, b0)vekt¨orun¨ u¨ ~a = (‘00‘, ‘00‘, ‘01‘, ‘00‘) ⇒ p~a(x) = x
ile carpmak ¸ bir sola kaydırmaya denktir. Yani
(b3b2b1b0).(0010) = (b2b1b0b3)
3. a = (a7 a6 a5 a4 a3 a2 a1 a0) byte’ının carpma ¸ ya g¨ore tersi
pa(x).pb(x) = 1 mod m(x) = x
8 + x
4 + x
3 + x + 1
e¸sitli˘gini sa˘glayan pb(x) polinomuna kar¸sılık gelen byte’tır.
p
−1
a
(x) = pb(x) mod m(x) = x
8 + x
4 + x
3 + x + 1.
Buna g¨ore a = (0 0 0 0 0 0 0 0) nın tersi kendisidir.
4. 4 byte’lık ~a = (a3, a2, a1, a0) vekt¨orun¨ un¨ carpma ¸ ya g¨ore tersi
p~a(x).p~b
(x) = 1 mod M(x) = x
4 + 1
e¸sitli˘gini sa˘glayan p~b
(x) polinomuna kar¸sılık gelen 4 byte’lık ~b vekt¨orud¨ ur. ¨
p
−1
~a
(x) = p~b
(x) mod M(x) = x
4 + 1.
23
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
4.2 Algoritma
Rijndael Algoritması
Metin uzunlu˘gu: 128,192,256 bit olabilir.
Anahtar uzunlu˘gu: 128,192,256 bit olabilir.
D¨ongu¨ (round) sayısı: Anahtar uzunlu˘gu ve metin uzunlu˘guna g¨ore de˘gi¸siklik
g¨ostermektedir. A¸sa˘gıdaki tabloda g¨osterilmi¸stir. Satırlar metin uzunluklarını, sut ¨ unlar ¨
anahtar uzunlukarını g¨ostermektedir.
128 192 256
128 10 12 14
192 12 12 14
256 14 14 14
Her d¨ongude ¨ u¸¨c ayrı b¨olum¨ vardır.
1. Do˘grusal (linear) i¸slemlerin oldu˘gu b¨olum. ¨ Bu katmanlarda (layer ) difuzy ¨ on
sa˘glanmaktadır.
2. Do˘grusal olmayan b¨olum. ¨ S kutularından (S-box ) olu¸smaktadır.
3. Anahtarın XOR’landı˘gı katman.
Bit olarak ifade edilen mesajı byte’lara ayrılır.
a00 a10 a20 a30 a01 a11 a21 a31 a02 a12 a22 a32 a03 a13 a23 a33 . . .
24
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Metin 4 byte’lık sut ¨ un¨ vekt¨orleri ¸seklinde, yani 128 bit i¸cin 4 × 4, 192 bit i¸cin 4 × 6, 256
bit i¸cin 4 × 8’lik matrislerle ifade edilir. 128 bitlik bir metin i¸cin a¸sa˘gıdaki gibidir.








a00 a01 a02 a03
a10 a11 a12 a13
a20 a21 a22 a23
a30 a31 a32 a33








4.2.1 Byte Sub
S-kutusunun oldu˘gu katmandır. Matristeki her byte’ın modulo m(x) = x
8+x
4+x
3+x+1’e
g¨ore tersi bulunur. a −→ a
−1 = b = (b7 b6 b5 b4 b3 b2 b1 b0) S-kutusunun cıktısı ¸
y = (y7 y6 y5 y4 y3 y2 y1 y0) olmak uzere: ¨





















y0
y1
y2
y3
y4
y5
y6
y7





















=





















1 1 1 1 1 0 0 0
0 1 1 1 1 1 0 0
0 0 1 1 1 1 1 0
0 0 0 1 1 1 1 1
1 0 0 0 1 1 1 1
1 1 0 0 0 1 1 1
1 1 1 0 0 0 1 1
1 1 1 1 0 0 0 1










































x0
x1
x2
x3
x4
x5
x6
x7





















⊕





















0
1
1
0
0
0
1
1





















Burdaki 8 × 8’lik matrisin ozelli˘ ¨ gi modulo 2’de tersi olan bir matris olmasıdır.
25
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
4.2.2 Shift Row
128 bit i¸cin:
1 5 9 13
2 6 10 14
3 7 11 15
4 8 12 16
−→
1 5 9 13
6 10 14 2
11 15 3 7
16 4 8 12
Bu permutasy ¨ ona g¨ore 6. pozisyondaki byte 2. pozisyona, 3. pozisyondaki byte 11.
pozisyona ge¸cmi¸s.
192 bit i¸cin:
1 5 9 13 17 21
2 6 10 14 18 22
3 7 11 15 19 23
4 8 12 16 20 24
−→
1 5 9 13 17 21
6 10 14 18 22 2
11 15 19 23 3 7
16 20 24 4 8 12
256 bit i¸cin:
1 5 9 13 17 21 25 29
2 6 10 14 18 22 26 30
3 7 11 15 19 23 27 31
4 8 12 16 20 24 28 32
−→
1 5 9 13 17 21 25 29
6 10 14 18 22 26 30 2
15 19 23 27 31 3 7 11
20 24 28 32 4 8 12 16
4.2.3 Mix Column
Byte Sub ve Shift Row i¸slemlerinden cık ¸ an, her sut ¨ un¨ u¨ 4 bytle’lık vekt¨or olan matris, bu
katmanda modulo M(x) = x
4 + 1’de c(x) = ‘03‘x
3 + ‘01‘x
2 + ‘01‘x + ‘02‘ polinomuyla
26
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
carpılır. ¸ Buna g¨ore:








b00 b01 b02 b03
b10 b11 b12 b13
b20 b21 b22 b23
b30 b31 b32 b33








=








‘02‘ ‘03‘ ‘01‘ ‘01‘
‘01‘ ‘02‘ ‘03‘ ‘01‘
‘01‘ ‘01‘ ‘02‘ ‘03‘
‘03‘ ‘01‘ ‘01‘ ‘02‘
















a00 a01 a02 a03
a10 a11 a12 a13
a20 a21 a22 a23
a30 a31 a32 a33








4.2.4 Anahtarla XOR’lama
Anahtarlar da aynı ¸sekilde matrislerle ifade edilir, anahtarla metnin kar¸sılıklı byte’ları
XOR’lanır.








a00 a01 a02 a03
a10 a11 a12 a13
a20 a21 a22 a23
a30 a31 a32 a33








⊕








k00 k01 k02 k03
k10 k11 k12 k13
k20 k21 k22 k23
k30 k31 k32 k33








=








a00 ⊕ k00 a01 ⊕ k01 a02 ⊕ k02 a03 ⊕ k03
a10 ⊕ k10 a11 ⊕ k11 a12 ⊕ k12 a13 ⊕ k13
a20 ⊕ k20 a21 ⊕ k21 a22 ⊕ k22 a23 ⊕ k23
a30 ⊕ k30 a31 ⊕ k31 a32 ⊕ k32 a33 ⊕ k33








27
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
4.3 Anahtar Algoritması
Anahtar olarak uretilen ¨ toplam bit sayısı (blok uzunlu˘gu) × (D¨ongu¨ sayısı+1) kadardır.
E˘ger 4 bytle’lık vekt¨orlerin her birine kelime (1 kelime=32 bit) dersek, kelime olarak
uretilen ¨ anahtar sayısı (bloktaki kelime sayısı) × (d¨ongu¨ sayısı+1) dir.
Nb = 1 bloktaki kelime sayısı
Nk = Anahtardaki kelime sayısı
Nr = D¨ongu¨ sayısı
Bu anahtar algoritmasından cık ¸ an her kelimeye








w0i
w1i
w2i
w3i








dersek,
0 ≤ i < Nk i¸cin








w0i
w1i
w2i
w3i








=








k0i
k1i
k2i
k3i








Nk ≤ i < Nb(Nr + 1) i¸cin
Nk | i ise
wi = wi−Nk ⊕ Subbyte(RotByte(wi−1)) ⊕ RoundConstant[i/Nk]
28
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Nk - i ise
wi = wi−Nk ⊕ wi−1
Subbyte: Byte sub katmanındaki i¸slemlerden olu¸sur.
Rotbyte: Rotbyte((a,b,c,d))=(b,c,d,a).
Round Constant:
RC[1]=‘01‘
RC[j]=x.RC[j-1]
RoundConstant[j] =








RC[j]
‘00‘
‘00‘
‘00‘








Anahtar algoritmasında ilk alınan anahtar 32 bitlik kelimeler halinde hi¸c de˘gi¸sikli˘ge
u˘gramadan kullanılır. E˘ger algoritmadan cık ¸ an anahtar kelimeler (32 bit uzunlu˘gunda
4 byte’lık vekt¨orler) w0 w1 w2 w3 w4 w5 . . . ise 128 bitlik blok uzunlu˘gu i¸cin:
w0 w1 w2 w3 → Round 0 Round’a girmeden
w4 w5 w6 w7 → Round 1
w8 w9 w10 w11 → Round 2
.
.
.
29
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
192 bitlik blok uzunlu˘gu i¸cin:
w0 w1 w2 w3 w4 w5 → Round 0 Round’a girmeden
w6 w7 w8 w9 w10 w11 → Round 1
w12 w13 w14 w15 w16 w17 → Round 2
.
.
.
256 bitlik blok uzunlu˘gu i¸cin:
w0 w1 w2 w3 w4 w5 w6 w7 → Round 0 Round’a girmeden
w8 w9 w10 w11 w12 w13 w14 w15 → Round 1
w16 w17 w18 w19 w20 w21 w22 w23 → Round 2
.
.
.
30
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
4.4 ALGOR˙ITMANIN TERS˙I
Algoritmaın Tersi
Algoritmanın tersinde katmanların tersi uygulanır.
4.4.1 Mix Column
Mix Column’da kullanılan polinomun tersi kullanılır. c
−1
(x) = d(x) = ‘0B‘x
3 + ‘0D‘x
2 +
‘09‘x + ‘0E‘ carpma ¸ i¸slemi yine modulo M(x) = x
4 + 1’de yapılır.
4.4.2 Byte Sub
Byte Sub katmanında yapılan i¸slemlerin tersi yapılır.





















x0
x1
x2
x3
x4
x5
x6
x7





















=





















0 1 0 1 0 0 1 0
0 0 1 0 1 0 0 1
1 0 0 1 0 1 0 0
0 1 0 0 1 0 1 0
0 0 1 0 0 1 0 1
1 0 0 1 0 0 1 0
0 1 0 0 1 0 0 1
1 0 1 0 0 1 0 0












































y0
y1
y2
y3
y4
y5
y6
y7





















⊕





















0
1
1
0
0
0
1
1























Bulunan x = (x7 x6 x5 x4 x3 x2 x1 x0)’in modulo m(x) = x
8 +x
4 +x
3 +x+1’de tersi alınır.
31
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
BOL¨ UM¨ 5
AKAN S¸˙IFRELER
Akan ¸sifre sistemleri, mesajın her karakterini (bitini) ayrı ayrı ¸sifreler. S¸ifreleme i¸slemi
mesaj uzunlu˘gunda bir anahtar kullanılarak yapılır. Anahtarın her biti mesajın her bitiyle
mod 2’de kar¸sılıklı toplanır. Bu i¸sleme XOR i¸slemi denir ve ⊕ ile g¨osterilir.
S¸ifreleme :
A¸cık metin m = m1 m2 . . . mn
Anahtar k = k1 k2 . . . kn
Kapalı metin c = c1 c2 . . . cn
Burada her i i¸cin ci = mi ⊕ ki dir.
S¸ifreleme i¸sleminde kullanılan iki tip anahtar dizisi vardır.
1. Tam Rastgele (true random) Dizi : Dizideki her bit birbirinden ba˘gımsız olarak
uretilir. ¨ Buna bir ornek ¨ olarak yazı tura atı¸sı verilebilir.
2. Pseudo Rastgele (pseudo random) Dizi : Dizinin her biti kendinden once ¨ gelen
bitlere ba˘glıdır. Aynı zamanda her bit kendinden sonra gelen biti etkiler.
32
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
5.1 One Time Pad Sistemi
S¸ifrelenecek mesajın uzunlu˘gunda tam rastgele bir anahtar dizisi se¸cilir. Mesaj ve
anahtara XOR i¸slemi uygulanır.
Ornek ¨ 5.1.1
m = 11010001011010110
k = 01110100101101000
m ⊕ k = 10100101110111110
Mesajı a¸cmak i¸cin aynı anahtara ve kapalı metine tekrar XOR i¸slemi uygulanır.
5.1.1 Sistemin Avantajları
Uzunlu˘gu n bit olan bir mesaj i¸cin n bitlik bir anahtar dizisi se¸cilir. Mesaj ¸sifrelenir ve
g¨onderilir. Mesajı ele ge¸ciren birisi olası but ¨ un¨ anahtarları (2n
tane) denese bile mesajı
bulamaz. C¸unk ¨ u¨ bu i¸slemin sonunda n bitlik but ¨ un¨ kelimeleri bulur. Elinde birden fazla
anlamlı mesaj olaca˘gıi¸cin bu mesajların i¸cinden ger¸cek mesajı tahmin etmek imkansızdır.
Bu a¸cıdan ko¸sulsuz guvenli ¨ bir sistemdir.
5.1.2 Sistemin Dezavantajları
Uzun bir mesaj ¸sifrelemek i¸cin uzun bir anahtar uretmek ¨ gerekir. Bu sistem tam rastgele bir anahtar dizisi kullandı˘gından, uzun bir anahtar uretmek, ¨ bu anahtarı guv¨ enli bir
33
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
¸sekilde kar¸sı tarafa iletmek ve saklamak zor olur. Ayrıca kullanılan anahtar tekrar kullanılamayaca˘gı i¸cin, her seferinde ba¸ska bir anahtar uretilmesi ¨ gerekir. Bu nedenlerden
dolayı sistemin kullanımı zordur.
5.2 Dizi Ureticiler ¨
Ger¸cekten rastgele dizilerin uretilmesi ¨ ve iletilmesi gibi zordur. Bu nedeniyle pseudo
rastgele diziler kullanılr. Bu diziler kısa bir anahtar kullanılarak bir dizi uretici ¨ tarafından
uretilir. ¨
Dizi ureticiler ¨ a¸cısından akan ¸sifreleri ikiye ayırabiliriz.
1. Senkronize (Synchronous) Akan S¸ifre :
fs: Faz fonksiyonu, bir sonraki fazı belirleyen fonksiyon.
f : Ureticinin ¨ fazına g¨ore bit ureten ¨ fonksiyon.
h : S¸ifreleme algoritması (XOR i¸slemi)
σi
: Ureticinin ¨ i zamandaki fazı
σ0: Ureticinin ¨ calı ¸ ¸smaya ba¸slaması i¸cin belirlenen ilk faz. Gizlidir, genellikle anahtar
ilk fazın ne olaca˘gını belirler.
S¸ifreleme :
34
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Resim 1: Senkronize sistemlerde ¸sifreleme
f(k, σi) = zi
fs(k, σi) = σi+1
h(mi
, zi) = ci
De¸sifreleme :
Resim 2: Senkronize sistemlerde de¸sifreleme
35
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
f(k, σi) = zi
fs(k, σi) = σi+1
h
−1
(ci
, zi) = mi
2. Oto-Senkronize (Self Synchronous) Akan S¸ifre :
fs: Faz fonksiyonu, bir sonraki fazı belirleyen fonksiyon.
f : Ureticinin ¨ fazına g¨ore bit ureten ¨ fonksiyon.
h : S¸ifreleme algoritması
σi
: (ci−t
, ci−t+1, . . . , ci−1)
σ0: (c−t
, c−t+1, . . . , c−1)
S¸ifreleme :
Resim 3: Oto-Senkronize sistemlerde ¸sifreleme
f(k, σi) = zi
h(mi
, zi) = ci
36
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
De¸sifreleme :
Resim 4: Oto-Senkronize sistemlerde de¸sifreleme
f(k, σi) = zi
h
−1
(ci
, zi) = mi
5.3 Geri Beslemeli Kaydırmalı Yazdırga¸c (Feedback Shift Register)
Kısaca FSR olarak adlandırılan bir geri beslemeli kaydırmalı yazdırga¸cın nasıl calıS ¸ ¸tı˘gı
aS¸a˘gıdaki S¸ekilde g¨osterilmektedir.
37
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Resim 5: Geri Beslemeli Kaydırmalı Yazdırga¸c (FSR)
f : Z
n
2 → Z2
Z2 = {0, 1} Z
n
2 = {(x1, x2, . . . , xn) | xi ∈ Z2}
L: Yazdırgacın boyu
Bir sonraki fazda her bit sa˘ga kayar. f fonksiyonu yeni bir bit uretir, ¨ uretilen ¨ bit en
sa˘gdaki g¨oze yazılır.
z = z0z1z2z3 . . . dizisinde her i ∈ N i¸cin zi = zi+p e¸sitli˘gini sa˘glayan en ku¸¨cuk¨ p sayısı
dizinin periyodudur. Yani bu diziyi ureten ¨ FSR p adım sonra ba¸slangı¸c fazına geri d¨oner.
Ornek ¨ 5.3.1 f(x1, x2, x3, x4, x5) = x1 ⊕ x2x3 ⊕ x4x5
38
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Resim 6: Fonksiyonu f(x1, x2, x3, x4, x5) = x1 ⊕ x2x3 ⊕ x4x5 olan FSR
σ0 = 0 1 0 1 1 f(σ0) = 1 ⊕ 1.0 ⊕ 1.0 = 1
σ1 = 1 0 1 1 1 f(σ1) = 1 ⊕ 1.1 ⊕ 0.1 = 0
σ2 = 0 1 1 1 0 f(σ2) = 0 ⊕ 1.1 ⊕ 1.0 = 1
σ3 = 1 1 1 0 1 f(σ3) = 1 ⊕ 0.1 ⊕ 1.1 = 0
σ4 = 1 1 0 1 0 f(σ4) = 0 ⊕ 1.0 ⊕ 1.1 = 1
σ5 = 1 0 1 0 1 f(σ5) = 1 ⊕ 0.1 ⊕ 0.1 = 1
σ6 = σ0 = 0 1 0 1 1
B¨oylece periyodu 6 olan z = (010111)∞ dizisi uretilir. ¨
Ornek ¨ 5.3.2 Aynı fonksiyon kullanılarak periyodik olmayan bir dizi uretebiliriz. ¨ E˘ger
ba¸slangı¸c fazını σ0 = (01010) se¸cersek:
39
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
x5 x4 x3 x2 x1
σ0 0 1 0 1 0
σ1 1 0 1 0 0
σ2 0 1 0 0 0
σ3 1 0 0 0 0
σ4 0 0 0 0 0
σ5 0 0 0 0 0
uretilen ¨ dizi z = 0101000 . . ., periyodik de˘gildir.
Ornek ¨ 5.3.3 f(x1, x2, x3) = x1 ⊕ x3
x3 x2 x1
σ0 1 0 1
σ1 0 1 0
σ2 1 0 0
σ3 0 0 1
σ4 0 1 1
σ5 1 1 1
σ6 1 1 0
σ0 = σ7 1 0 1
Periyodu 7 olan z = (1010011)∞ dizisi uretildi. ¨
Bir f fonksiyonu, ai ∈ {0, 1} olmak uzere, ¨ f(x1, x2, . . . , xL) = a1x1 ⊕ a2x2 ⊕ . . . ⊕ aLxL
¸seklinde yazılabiliyorsa, bu fonksiyona do˘grusal denir. FSR’nin kullandı˘gı fonksiyon
do˘grusalsa bu uretece ¨ do˘grusal geri beslemeli kaydırmalı yazdırga¸c veya LFSR (linear
feedback shift register) denir.
40
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
5.4 Uretecinin ¨ Sahip Olması Gereken Ozellikler ¨
1. Uretti˘ ¨ gi dizi iyi istatistikler ozellikler ¨ g¨ostermelidir.
2. Periyodu buy¨ uk¨ olan bir dizi uretmelidir. ¨
3. Uretti˘ ¨ gi dizinin do˘grusal karma¸sıklı˘gı(linear complexity) buy¨ uk¨ olmalıdır.
5.4.1 ˙Istatistiksel Ozellikler ¨
Anahtar olarak kullanılacak dizinin tesadufi¨ ve kuralsız olması tercih edilir. Belirgin ozellikleri ¨ olan bir dizi genellikle anahtar olarak kullanılmaz. Orne˘ ¨ gin, z =
(10100100010000100000 . . .) dizisi kuralsız g¨ozukmemektedir. ¨
Dizinin kuralsız olmasını veya kuralsız bir diziye yakın olup olmadı˘gını ol¸ ¨ cen bir cok ¸ test
vardır. AS¸a˘gıdaki u¸¨c testi LFSR’lar sa˘glar.
1. Dizinin bir tam periyodunda 1 ve 0 ların sayısı e¸sit olmalı, ya da aralarındaki fark
1 olmalıdır. Yani
0 ≤ |(1 ’lerin sayısı) − (0 ’ların sayısı)| ≤ 1.
Ornek ¨ 5.4.1 n = 21 bit uzunlu˘gunda z = 000110101110010001101 dizisinde 10
tane 1 ve 11 tane 0 vardır. Dolayısıyla aranan ko¸sul sa˘glanır.
Ornek ¨ 5.4.2 n = 14 bit uzunlu˘gunda ki z = 10101010101010 dizisinde
0 ve 1 yedi kere g¨ozuk¨ urler ¨ ama bu dizi tesadufi¨ bir dizi de˘gildir.
41
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
2. Tek ce¸ ¸sit karakterden olu¸san bloklara run denir.
n bitlik bir dizide toplam n+1
2
tane run olması beklenir. Bunlardan
uzunlu˘gu 1 olanların sayısının n+1
2
2
,
uzunlu˘gu 2 olanların sayısının n+1
2
3
,
uzunlu˘gu 3 olanların sayısının n+1
2
4
,
.
.
.
uzunlu˘gu k olanların sayısının n+1
2
k+1 olması beklenir.
Ornek ¨ 5.4.3 z = 00110001101, n=11
Beklenen run sayısı 11+1
2 = 6
Uzunlu˘gu 1 olan run sayısı 11+1
2
2 = 3
Dizinin run sayısı beklendi˘gi gibi 6 dır, ancak uzunlu˘gu 1 olan runların sayısı bekledi˘gi gibi 3 de˘gil, 2 dir. Dolayısıyla, bu dizi run sayısı testini ge¸cemez.
Ornek ¨ 5.4.4 z = 1000010111011000111110011010010, n=31
42
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Beklenen run sayısı 31+1
2 = 16 X
Uzunlu˘gu 1 olan run sayısı 31+1
2
2 = 8 X
Uzunlu˘gu 2 olan run sayısı 31+1
2
3 = 4 X
Uzunlu˘gu 3 olan run sayısı 31+1
2
4 = 2 X
Uzunlu˘gu 4 olan run sayısı 31+1
2
5 = 1 X
Uzunlu˘gu 5 olan run sayısı 31+1
2
6 = 0.5 ∼= 1 X
Bu dizi beklenen but ¨ un¨ de˘gerleri sa˘glar ve run sayısı testinden ge¸cer.
3. Periyodu p olan bir dizinin otokorelasyon fonksiyonu C(τ ), dizinin kendisinin τ
kadar kaydırılmasıyla oluS¸an diziye ne kadar uydu˘gunu g¨osterir. Periyodu p olan
{ai} dizisinin otokorelasyon fonksiyonunu
C(τ ) =
1
p
X
p
i=1
(−1)ai
(−1)ai+τ
¸seklinde ifade edilir. Her dizi i¸cin
C(0) =
1
p
X
p
i=1
(−1)ai
(−1)ai =
1
p
X
p
i=1
(−1)ai⊕ai =
1
p
X
p
i=1
1 = 1 dir.
Bir dizinin rastgele olup olmadı˘gına karar vermekte aranılan bir ba¸ska ko¸sul da C(τ )
fonksiyonunun
C(1) = C(2) = . . . = C(p − 1) e¸sitli˘gini sa˘glamasıdır.
43
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Ornek ¨ 5.4.5
ai = 0 0 0 1 0 1 1 C(0) = 1, p = 7
(−1)ai = 1 1 1 − 1 1 − 1 − 1
(−1)ai+1 = 1 1 1 1 −1 −1 1 C(1) =
1
7
(1 + 1 − 1 − 1 − 1 + 1 − 1) =
−1
7
(−1)ai+2 = 1 −1 1 −1 −1 1 1 C(2) =
1
7
(1 − 1 − 1 − 1 + 1 − 1 + 1) =
−1
7
(−1)ai+3 = −1 1 −1 −1 1 1 1 C(3) =
1
7
(−1 + 1 − 1 + 1 + 1 − 1 − 1) =
−1
7
(−1)ai+4 = 1 −1 −1 1 1 1 −1 C(4) =
1
7
(1 − 1 − 1 − 1 + 1 − 1 + 1) =
−1
7
(−1)ai+5 = −1 1 1 1 1 −1 1 C(5) =
1
7
(1 + 1 − 1 − 1 − 1 + 1 − 1) =
−1
7
(−1)ai+6 = −1 1 1 1 −1 1 −1 C(6) =
1
7
(1 + 1 − 1 − 1 − 1 + 1 − 1) =
−1
7
C(1) = C(2) = C(3) = C(4) = C(5) = C(6) =
−1
7
oldu˘gu i¸cin bu dizi testten ge¸cer.
5.5 Do˘grusal Geri Beslemeli Kaydırmalı Yazdırga¸c (LFSR)
Resim 7: LFSR
44
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
L: LFSR’ın boyu
Ba¸slangı¸c fazı σ0 : a−L, a−L+1, . . . , a−2, a−1
Geri besleme katsayıları (feedback coefficients): c1, c2, . . . , cL−1, cL ∈ Z2 = {0, 1}
LFSR’ın do˘grusal fonksiyonu:
f(x1, x2 . . . xL) = c1x1 ⊕ c2x2 ⊕ . . . ⊕ cLxL
Buna g¨ore:
a0 = cLa−L ⊕ cL−1a−L+1 ⊕ . . . c2a−2 ⊕ c1a−1
⇒ σ1 : a−L+1, a−L+2, . . . , a−1, a0
a1 = cLa−L+1 ⊕ cL−1a−L+2 ⊕ . . . c2a−1 ⊕ c1a0
Genel olarak:
an = cLan−L ⊕ cL−1an−L+1 ⊕ . . . c2an−2 ⊕ c1an−1.
Bu recursive ba˘gıntının karakteristik polinomu aynı zamanda LFSR’ın karakteristik polinomudur. Buna g¨ore karakteristik polinom:
m(x) = x
L + c1x
L−1 + c2x
L−2
. . . + cL−1x + cL.
LFSR’ın ba˘glayıcı polinomu (connection polynomial):
C(D) = 1 + c1D + c2D
2 + . . . + cL−1D
L−1 + cLD
L
.
Ba˘glayıcı polinom ile karakteristik polinom arasındaki ba˘gıntı a¸sa˘gıdaki gibidir:
m(x) = x
LC
 
1
x
 
.
Bir LFSR, boyu L ve ba˘glayıcı polinomu C(D) ile belirlenir:
LFSR = hL,C(D)i.
45
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Ornek ¨ 5.5.1 LFSR=h4,C(D) = 1 + D + D4
i
c1 = 1, c2 = c3 = 0, c4 = 1 ⇒ f(x1, x2, x3, x4) = x1 ⊕ x4
Resim 8: h4,C(D) = 1 + D + D4
i
Bu LFSR’ı calı ¸ ¸stırmak i¸cin ba¸slangı¸c fazı olarak σ0 = (0 0 1 1) alınırsa, periyodu 5 olan
z = (001111010110010)∞ dizisi uretilir. ¨
46
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
x1 x2 x3 x4 x1 ⊕ x4
0 0 1 1 1
0 1 1 1 1
1 1 1 1 0
1 1 1 0 1
1 1 0 1 0
1 0 1 0 1
0 1 0 1 1
1 0 1 1 0
0 1 1 0 0
1 1 0 0 1
1 0 0 1 0
0 0 1 0 0
0 1 0 0 0
1 0 0 0 1
0 0 0 1 1
0 0 1 1 = σ0
LFSR’ın fonksiyonu do˘grusal oldu˘gundan f(0, 0, . . . , 0) = 0 dır. Dolayısıyla ba¸slangı¸c
fazını 0 vekt¨oru¨ alınırsa 0 geri beslenir. 0 vekt¨orunden ¨ ba¸ska bir faz g¨orulmez. ¨ 0’dan
farklı bir vekt¨orle ba¸slanırsa 0 vekt¨oru¨ faz olarak hi¸c g¨orulmez. ¨
5.5.1 Dizinin Periyodu
Boyu L olan bir LFRS’ın uretti˘ ¨ gi dizinin periyodu en fazla 2
L −1 olabilir c¸unk ¨ u¨ LFSR’da
faz olarak L uzunlu˘gunda vekt¨orler g¨ozuk¨ ur. ¨ L uzunlu˘gunda 2
L − 1 tane vekt¨or vardır.
LFSR da 0 vekt¨orun¨ u¨ g¨orulmezse ¨ en fazla 2
L − 1 tane de˘gi¸sik vekt¨or g¨orulebilir. ¨ Yani
LFSR en fazla 2
L − 1 adım sonra ba¸slangı¸c noktasına geri d¨oner.
47
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
hL,C(D)i LFSR’ının uretti˘ ¨ gi dizinin periyodu C(D) polinomunun carpanlarına ¸ ayrılabilir
olup olmamasıyla ve ba¸slangı¸c fazıyla iliS¸kilidir.
• E˘ger C(D) carpanlarına ¸ ayrılıyorsa uretilen ¨ dizinin periyodu ba¸slangı¸c fazına g¨ore
de˘gi¸sir.
Ornek ¨ 5.5.2 hL,C(D) = 1 + D2 + D4
i
⇒ c1 = 0, c2 = 1, c3 = 0, c4 = 1 ⇒ f(x1, x2, x3, x4) = x2 ⊕ x4 ve C(D) =
1 + D2 + D4 = (1 + D + D2
)
2
x1 x2 x3 x4
σ0 1 0 0 0
0 0 0 1
0 0 1 0
0 1 0 1
1 0 1 0
0 1 0 0
σ0 1 0 0 0
x1 x2 x3 x4
σ0 1 1 1 1
1 1 1 0
1 1 0 0
1 0 0 1
0 0 1 1
0 1 1 1
σ0 1 1 1 1
x1 x2 x3 x4
σ0 1 0 1 1
0 1 1 0
1 1 0 1
σ0 1 0 1 1
Periyod = 6 Periyod = 6 Periyod = 3
• Maksimum periyodda dizi uretmek ¨ i¸cin C(D) polinomunun carpanlarına ¸ ayrılamaz
olması gerekir. E˘ger C(D) carpanlarına ¸ ayrılamayan bir polinomsa dizinin periyodu
ba¸slangı¸c fazına ba˘glı de˘gildir ve C(D) polinomunun b¨oldu˘¨gu¨ 1+Dp polinomlarından
en ku¸¨cuk¨ dereceli olanın derecesi, uretilen ¨ dizinin periyoduna e¸sittir. Buradaki p
sayısı 2
L − 1 sayısının bir b¨olenidir. Orne˘ ¨ gin C(D) | 1 + D5 ve C(D), 1 + Dk
, k =
1, 2, 3, 4, polinomlarını b¨olmuy¨ orsa uretilen ¨ dizinin periyodu 5 tir.
• Dizinin periyodunun maksimum yani 2
L −1 olması i¸cin C(D) polinomunun b¨oldu˘¨gu¨
48
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
en ku¸¨cuk¨ dereceli polinom 1 + D2
L−1 olmalıdır. Bunu sa˘glayan C(D) polinomuna
ilkel polinom(primitive polynomial) denir.
Maksimum periyodda dizi ureten ¨ bir LFSR’a maksimum uzunlukta LFSR denir.
5.6 Do˘grusal Karma¸sıklık (Linear Complexity)
Bir dizinin do˘grusal karma¸sıklı˘gı (L.C.) onu uretebilecek ¨ LFSR’lardan en kısa olanın
boyuna e¸sittir.
z = 0000 . . . 0 . . . dizisinin do˘grusal karma¸sıklı˘gı 0 ’dır.
z = 1111 . . . 1 . . . dizisinin do˘grusal karma¸sıklı˘gı 1 ’dir.
z = 0000 . . . 1
| {z }
n
dizisinin do˘grusal karma¸sıklı˘gı n ’dir.
z L.C C(D)
0 0 0
1 1 1 + D
01 2 1 + D2
001 3 1 + D3
011 2 1 + D + D2
100 1 1
101 2 1 + D2
110 2 1 + D + D2
111 1 1 + D
Do˘grusal karma¸sıklık ile ilgili bazı ozellikler: ¨
• z = z0z1z2z3 . . . dizisi i¸cin, bu diziden alınan her n bitlik z
n dizisinin do˘grusal
karma¸sıklı˘gı en fazla n olabilir. Yani 0 ≤ L.C.(z
n
) ≤ n dir. Bu nedenle bir dizinin
49
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
do˘grusal karma¸sıklı˘gı en fazla dizinin boyu kadardır.
• E˘ger dizinin periyodu N ise L.C.(z) ≤ N dir.
• s ve t birer dizi olmak uzere ¨ L.C.(s ⊕ t) ≤ L.C.(s) + L.C.(t) dir.
5.6.1 Do˘grusal Karma¸sıklık Profili (Linear Complexity Profile)
s = s0s1s2 . . . bir dizi olsun. N ≥ 1 i¸cin s
N sonlu dizisi s
N = s0s1s2 . . . sN−1 ¸seklinde
tanımlanır. O zaman her N ≥ 1 i¸cin LN = L.C.(s
N ) ¸seklinde tanımlanan L1,L2, . . . ,LN
dizisine s
N dizisinin do˘grusal karma¸sıklık profili denir. Bu dizi a¸sa˘gıdaki ozellikleri ¨
g¨osterir:
• E˘ger j ≥ i ise Lj ≥ Li dir.
• LN+1 > LN olması i¸cin LN ≤ N/2 olması gerekir.
• E˘ger LN+1 > LN ise LN+1 + LN = N + 1 dir.
Profilde onemli ¨ noktalar LN ≤ N/2 oldu˘gu yerlerdir. Bu noktalarda LN+1 artabilir.
Boyu LN olan hi¸c bir LFSR s
N+1 dizisini uretmezse ¨ LN+1 > LN dir, dolayısıyla LN+1 =
LN − N − 1 dir.
Kriptografik anlamda iyi bir LFSR’ın uretti˘ ¨ gi bir dizinin, do˘grusal karma¸sıklık profilinin
grafi˘gi y = N/2 do˘grusuna yakın olmalıdır. Bu do˘grudan fazla sapmamalıdır.
50
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
5.6.2 Berleckamp Massey Algoritması
Berleckamp Massey Algoritması sonlu bir dizinin do˘grusal karma¸sıklı˘gını ve onu
uretebilecek ¨ en kısa LFSR’ın ba˘glayıcı polinomu C(D) yi bulmak i¸cin kullanılır.
s
N+1 = s0s1 . . . sN−1sN dizisi verilsin. hK,C(D)i LFSR’ı s
N = s0s1 . . . sN−1 dizisini
uretsin. ¨ s
N+1 dizisinin ve hK,C(D)i LFSR’ının uretti˘ ¨ gi dizinin (N +1). terimi arasındaki
farka uymazlık sayısı (next discrepancy) denir. Bu sayı
dN = sN +
X
L
i=1
cisN−i (mod 2)
¸seklinde hesaplanır. dN = 0 olması i¸cin bu LFSR’ın s
N+1 dizisinin (N + 1). terimini
uretmesi ¨ gerekir.
Berleckamp Massey Algoritmasının i¸sleyi¸si a¸sa˘gıdaki gibidir:
Girdi olarak s
n = s0s1s2 . . . sn−1 dizisini alır.
1. BaS¸langı¸c konumu: C(D) = 1, L = 0, m = −1, B(D) = 1, N = 0
2. N < n durumunda
(a) d = sN +
PL
i=1 cisN−i (mod 2).
(b) d = 1 ise
T(D) ←− C(D)
C(D) ←− C(D) + B(D)DN−m
E˘ger L ≤ N/2 ise L ←− N + 1 − L
51
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
m ←− N
B(D) ←− T(D)
(c) N ←− N + 1
5.7 LFSR Kullanılarak Yapılan Akan S¸ifre Sistemleri
Bir dizinin do˘grusal karma¸sıklı˘gı en fazla onu ureten ¨ LFSR’ın boyu kadar olabilir.
Maksimum uzunlukta bir LFSR, do˘grusal karma¸sıklı˘gı en fazla kendi boyuna e¸sit bir
dizi uretebilir. ¨ Bu da do˘grusal karma¸sıklık i¸cin ku¸¨cuk¨ bir sayıdır. Dizinin do˘grusal
karma¸sıklı˘gını arttırmak i¸cin ce¸ ¸sitli yollar vardır:
• LFSR’a do˘grusal olmayan bir filtre ba˘glanır. Bu filtre do˘grusal olmayan yani derecesi en az iki olan bir fonksiyondur.
Resim 9: Do˘grusal olmayan filtre
52
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Do˘grusal olmayan bir filtre: f(xL, xL−1, . . . , x2, x1) : Z
L
2 → Z2
Ornek ¨ 5.7.1 h3, 1 + D + D2
i ve do˘grusal olmayan filtre f(x3, x2, x1) = x1⊕x1x2⊕
x2x3
x3 x2 x1 f(x3, x2, x1)
σ0 1 0 1 1
0 1 0 0
1 0 0 0
0 0 1 1
0 1 1 0
1 1 1 1
1 1 0 1
σ0 1 0 1
z = (1001011)∞
• Birden fazla LFSR do˘grusal olmayan bir fonksiyonla ba˘glanabilir.
Resim 10: Birden fazla LFSR’ın do˘grusal olmayan bir fonksiyonla ba˘glanması
53
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
F : (z1, z2, . . . , zn) : Z
n
2 → Z2 do˘grusal olmayan bir fonksiyon.
z dizisinin periyodu: T(z) = okek(T1, T2, . . . , Tn) dir.
E˘ger LFSR’lar maksimum uzunlukta ise ve urettikleri ¨ dizilerin periyodu ikiden
buy¨ uk¨ ve birbirlerinden farklı ise z dizisinin do˘grusal karma¸sıklı˘gı
F(L1,L2, . . . ,Ln) dir.
Ornek ¨ 5.7.2 Geffe Ur ¨ eteci: U¸ ¨ c tane LFSR kullanır.
F(x1, x2, x3) = x1x2 ⊕ (1 ⊕ x2)x3.
Resim 11: Geffe Ureteci ¨
• Saat Kontrollu¨ Urete¸ ¨ cler (Clock Controlled Generators):
– De˘gi¸sen Adımlı Urete¸ ¨ c (Alternating Step Generator ): U¸ ¨ c tane LFSR kullanılır.
54
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Resim 12: De˘gi¸sen Adımlı Urete¸ ¨ c
LFSR1 = hL1,C1(D)i
LFSR2 = hL2,C2(D)i
LFSR3 = hL3,C3(D)i
LFSR1 calı ¸ ¸stırılır;
x1 = 1 ise LFSR2 calı ¸ ¸stırılır. LFSR3’un¨ bir once ¨ uretti˘ ¨ gi bit tekrar eder, LFSR3
daha once ¨ calı ¸ ¸smamı¸ssa 0 alınır.
x1 = 0 ise LFSR3 calı ¸ ¸stırılır. LFSR2’nin bir once ¨ uretti˘ ¨ gi bit tekrar eder,
LFSR2 daha once ¨ calı ¸ ¸smamı¸ssa 0 alınır.
LFSR2 ve LFSR3 XOR i¸slemine tabi tutulur. E˘ger LFSR1 periyodu 2
L1 olan
bir dizi uretiy ¨ orsa LFSR2 ve LFSR3 maksimum periyodda diziler uretiy ¨ orsa ve
o.b.e.b.(L1,L2) ise uretilecek ¨ z dizisinin
1. periyodu 2
L1 (2L2 − 1)(2L3 − 1),
2. do˘grusal karma¸sıklı˘gı (L2 + L3)2L1−1 < L.C.(z) ≤ (L2 + L3)2L1 dir.
55
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Ornek ¨ 5.7.3 LFSR2 → 1, 1, 0, 0, 1, 1, 0, 1, . . .
LFSR1 → 0, 1, 1, 1, 0, 0, 1, 1, . . .
LFSR3 → 0, 0, 1, 1, 0, 1, 1, 0, . . .
x2 0 1 1 0 0 0 0
x1 0 ↓ 1 ↑ 1 ↑ 1 ↑ 0 ↓ 0 ↓ 1 ↑
x3 0 0 0 0 0 1 1
z 0 1 1 0 0 1 1
– Ku¸¨culen ¨ Urete¸ ¨ c (Shrinking Generator ): ˙Iki tane LFSR kullanılır. ˙Ikisi de aynı
anda calı ¸ ¸sır.
Resim 13: Ku¸¨culen ¨ Urete¸ ¨ c
x = 1 ise y ’den al.
x = 0 ise y ’den alma.
LFSR1=hL1,C1(D)i ⇒ T(x) = 2
L1 − 1
LFSR2=hL2,C2(D)i ⇒ T(y) = 2
L2 − 1
56
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
1. L1 ve L2 aralarında asal ise olu¸san dizinin periyodu
(2L1−1
)2L2 − 1,
2. do˘grusal karma¸sıklı˘gı ise L2(2L1−2
) < L.C.(z) ≤ L2(2L1−1
) dir.
Ornek ¨ 5.7.4 LFSR1 → (101)∞
LFSR2 → (0101101)∞
x 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1
y 0 1 0 1 1 0 1 0 1 0 1 1 0 1 0 1 0 1 1 0 1
z 0 0 1 0 1 1 0 1 0 0 1 1 1 1
z = (00101101101111)∞
57
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
BOL¨ UM¨ 6
SAYILAR TEOR˙IS˙I
6.1 Tamsayılar
Tamsayılar kumesi ¨ {· · · , −3, −2, −1, 0, 1, 2, 3, · · · } sayılarından olu¸sur ve Z sembolu¨ ile
g¨osterilir.
6.1.1 B¨olunebilirlik: ¨
a ve b verilen tamsayılar olsun. E˘ger b = a · d e¸sitli˘gini sa˘glayan bir d sayısı varsa a b’yi
b¨oler(b, a tarafından b¨olun¨ ur ¨ ya da a, b nin bir carpanı) ¸ denir ve a|b ¸seklinde g¨osterilir.
Her b > 1 tamsayısı en azından iki pozitif b¨olene sahiptir; bunlar 1 ve b dir.
Ornek ¨ 6.1.1 1. −5|15, c¸unk ¨ u¨ 15 = 5 · 3.
2. 256|0, c¸unk ¨ u¨ 0 = 256 · 0.
3. 16|48, c¸unk ¨ u¨ 48 = 16 · 3.
6.1.2 B¨olunebilirlik ¨ Ozellikleri ¨
But ¨ un¨ a, b, c ∈ Z i¸cin, a¸sa˘gıdakiler do˘grudur.
58
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
1. a|a.
2. E˘ger a|b ve b|c ise a|c.
3. E˘ger a|b ve a|c ise but ¨ un¨ x, y ∈ Z i¸cin a|bx + cy ifadesi do˘grudur.
4. E˘ger a|b ve b|a ise a = ±b.
6.1.3 Tamsayılar i¸cin B¨olum¨ Algoritması:
E˘ger a ve b, b ≥ 1 olmak ko¸sulu ile, tamsayılar ise a’nın b’ye b¨olum¨ u¨ q tamsayısı gibi bir
b¨olum¨ ve r tamsayısı gibi bir kalan verir.
a = qb + r, 0 ≤ r < b.
Ustelik ¨ q ve r tektir. Bu b¨olum¨ un¨ kalanı a mod b olarak g¨osterilir.
Ornek ¨ 6.1.2 E˘ger a = 73, b = 17 ise q = 4 ve r = 5 tir. B¨oylece 73 mod 17 ≡ 5 tir.
6.1.4 En Buy¨ uk¨ Ortak B¨olen (Greatest Common Divisor)
a ve b her ikisi birlikte 0 olmamak ko¸sulu ile iki tamsayı olsun. a ve b nin en buy¨ uk¨ ortak
b¨oleni, a ve b yi b¨olen en buy¨ uk¨ d tamsayısıdır. a ve b nin en buy¨ uk¨ ortak b¨oleni gcd(a, b)
ya da kısaca (a, b) ile g¨osterilir.
Ornek ¨ 6.1.3 1. gcd(7, 11) = 1, c¸unk ¨ u¨ 7 = 7 · 1, 11 = 11 · 1
59
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
2. gcd(48, 40) = 8, c¸unk ¨ u¨ 48 = 2
4
· 3, 40 = 2
3
· 5
6.1.5 En Ku¸¨cuk¨ Ortak Kat (Least common Multiple)
a ve b her ikisi birlikte 0 olmamak ko¸sulu ile iki tamsayı olsun. a ve b nin en ku¸¨cuk¨ ortak
katı a ve b nin her ikisinin de b¨oldu˘¨gu¨ en ku¸¨cuk¨ tamsayıdır ve lcm(a, b) ile g¨osterilir.
Ornek ¨ 6.1.4 lcm(8, 12) = 24 c¸unk ¨ u¨ 8 = 2
3
ve 12 = 2
2
· 3 tur. ¨
Teorem 6.1.5 a ve b her ikiside birlikte 0 olmayacak ¸sekilde tamsayılar olsun. gcd(a, b) =
ax + by e¸sitli˘gini sa˘glayan x ve y tamsayılar her zaman vardır.
6.1.6 Asal Sayı
1 den buy¨ uk, ¨ 1 ve kendisinden ba¸ska b¨oleni olmayan tamsayılara asal sayı denir.Asal
olmayan sayılara da b¨olunebilir ¨ sayı denir.
Ornek ¨ 6.1.6 2, 3, 5, 7, 11, 13, 17, 19, 23, · · · sayıları bazı asal sayılara ornektir. ¨
NOT: Asal sayılarla ilgili bazı ozellikler: ¨
• E˘ger p sayısı asal sayı ve p|ab ise p|a’yi veya p|b’yi b¨oler.
• Sonsuz sayıda asal sayı vardır.
60
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
6.1.7 Aralarında Asal Sayı
a ve b iki tamsayısı gcd(a, b) = 1 ko¸sulunu sa˘glıyorsa bu sayılara aralarında asal denir.
gcd(12, 5) = 1 oldu˘gu i¸cin 2 ve 5 sayıları aralarında asaldır.
6.1.8 Aritmeti˘gin Esas Teoremi
n ≥ 2 olan her tamsayı asal sayıların carpımları ¸ ¸seklinde tek olarak yazılır. Yani,
n = p
e1
1
· p
e2
2
· · · p
ek
k
sayısında pk lar farklı asal sayıları ek lar da pozitif tamsayıları g¨ostermektedir.
Ornek ¨ 6.1.7 4200 = 2
3
· 3 · 5
2
· 7.
6.1.9 Oklid ¨ Algoritması(Euclidean Algorithm)
a ve b ¸seklinde olan iki tamsayının en buy¨ uk¨ ortak b¨olenini aritmeti˘gin esas teoreminde
bahsedildi˘gi gibi carpanlarına ¸ ayırarak ve ortak carpanların en buy¨ u˘¨gun¨ u¨ alarak bulabiliriz. E˘ger a ve b buy¨ uk¨ sayılarsa bunların asal carpanlarını ¸ bulmak zor olur; bunun sonucunda da en buy¨ uk¨ ortak b¨oleni bulmak da zorla¸sır. Sayılar teorisinin onemli ¨ bir ara¸stırma
alanı da buy¨ uk¨ tamsayıları daha cabuk ¸ carpanlarına ¸ ayırma uzerine ¨ ara¸stırmadır. E˘ger a
ve b nin asal carpanları ¸ bilinmiyorsa, gcd(a, b) yi bulmak i¸cin cabuk ¸ bir yol vardır. O da
Oklid ¨ algoritmasıdır.
Oklid ¨ Algoritması ¸s¨oyle calı ¸ ¸sır.
61
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
• a > b olmak uzere, ¨ a, b ’ye b¨olun¨ ur. ¨ B¨olum¨ q1, kalan r1 olsun
a = b · q1 + r1
•
˙Ikinci b¨olme i¸slemi ger¸cekle¸stirilir. b, r1 ’e b¨olun¨ ur ¨ ve b¨olum¨ q2, kalan ise r2 olur.
b = q2 · r1 + r2
• U¸ ¨ cunc ¨ u¨ olarak r1, r2 ’ye b¨olun¨ ur ¨ ve b¨olum¨ q3, kalan ise r3 olur.
r1 = q3 · r2 + r3
.
.
.
• Son olarak rn−1, rn ’e b¨olun¨ ur ¨ ve b¨olum¨ qn+1, kalan ise rn+1 = 0 olur.
rn−1 = qn+1 · rn + rn+1
• rn+1 = 0 oldu˘gu i¸cin rn de˘geri a ve b tamsayılarının en buy¨ uk¨ ortak b¨oleni olur.
Yani gcd(a, b) = rn dir.
Bu algoritmadaki i¸slemler sonsuza kadar gitmez, c¸unk ¨ u¨ 0 ile a tamsayısı arasında sonlu
sayıda tamsayı vardır.
Ornek ¨ 6.1.8 • gcd(24, 138) ’in sonucu ka¸ctır? gcd(24, 138) = ax + by ifadesinde x
ve y sayıları ka¸c olur?
138 = 5 · 24 + 18
24 = 1 · 18 + 6 ise gcd(24, 138) = 6 dır.
18 = 3 · 6 + 0
62
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
x ve y a¸sa˘gıdaki ¸sekilde bulunur. gcd(24, 138) = 6
6 = 24 − 1 · 18 = 24 − 1 · (138 − 5 · 24)
= 24 − 1 · 138 + 5 · 24 = 6 · 24 − 1 · 138
Yani,
6 = 6 · 24 + (−1) · 138. Buradan x = 6 ve y = −1 bulunur.
• gcd(1547, 560) ’ın sonucu ka¸ctır? gcd(1547, 560) = ax+by ifadesinde x ve y sayıları
ka¸c olur?
1547 = 2 · 560 + 427
560 = 1 · 427 + 133 ise gcd(1547, 560) = 7 dir.
427 = 3 · 133 + 28
133 = 4 · 28 + 21
28 = 1 · 21 + 7
21 = 3 · 7 + 0
x ve y a¸sa˘gıdaki ¸sekilde bulunur. gcd(1547, 560) = 7
7 = 28 − 1 · 21
= 28 − 1 · (133 − 4 · 28) = 28 − 1 · 133 + 4 · 28
= 5 · 28 − 1 · 133 = 5 · (427 − 3 · 133) − 1 · 133
= 5 · 427 − 15 · 133 − 1 · 133 = 5 · 427 − 16 · 133
= 5 · 427 − 16 · (560 − 1 · 427) = 5 · 427 − 16 · 560 + 16 · 427
= 21 · 427 − 16 · 560 = 21 · (1547 − 2 · 560) − 16 · 560
= 21 · 1547 − 42 · 560 − 16 · 560 = 21 · 1547 − 58 · 560
63
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Yani,
7 = 21 · 1547 + (−58) · y. Buradan x = 21 ve y = −58 bulunur.
6.2 Asal Sayılar
Tanım 6.2.1 1 den buy¨ uk¨ olan, 1 ve kendisinden ba¸ska b¨oleni olmayan sayılara asal sayı
denir.
Soru: Verilen bir tamsayının asal sayı olup olmadı˘gı nasıl anla¸sılır?
6.2.1 Eratosthenes Kalburu(The Sieve of Eratosthenes)
Verilen bir tamsayının asal sayı olup olmadı˘gı Eratosthenes Kalburu metodu ile bulunabilir. Verilen tamsayı kendisinden once ¨ gelen her pozitif tamsayıyla b¨olun¨ ur. ¨ E˘ger hi¸c
bir sayıya b¨olunemiy ¨ or ise bu sayıya asal sayı denir.
Metod:
a > 1 bir tamsayı olsun.Bu sayı e˘ger b¨olunebilir ¨ bir sayı ise 1 < b < a , 1 < c < a olmak
uzere ¨ a = b·c ¸seklinde yazılabilir.But ¨ unl ¨ u˘¨gu¨ bozmadan b ≤ c oldu˘gu farzedilsin. O zaman,
b
2 ≤ b · c = a ⇒ b ≤
√
a
Aritmeti˘gin esas teoremini kullanarak b yi b¨olen ve p ≤ b ≤
√
a ko¸sulunu sa˘glayan bir p
sayısı bulunur. Oyle ¨ ki bu p sayısı b yi b¨oldu˘¨gu¨ ve b de a yı b¨oldu˘¨gu¨ i¸cin p a yı da b¨olmu¨¸s
64
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
olur.
Ornek ¨ 6.2.2 • a = 173. a asal mıdır? 13 <
√
173 < 14. 173 sayısını b¨olebilecek asal
sayılar 2, 3, 5, 7, 9, 11, 13 olabilir. Bu sayıların 173 u¨ b¨olup¨ b¨olmedi˘gi kontrol edilir.
Hi¸c birisi 173 sayısını b¨olmedi˘gi i¸cin sayı asal sayıdır.
• 701 ve1009 sayıları asal mıdır? 26 < 701 < 27. 701 sayısını b¨olebilecek asal sayılar
2, 3, 5, 7, 9, 11, 13, 17, 19, 23 olabilir. Bu sayıların 173 u¨ b¨olup¨ b¨olmedi˘gi kontrol edilir.
Hi¸c birisi 701 sayısını b¨olmedi˘gi i¸cin sayı asal sayıdır.
31 < 1009 < 32. 1009 sayısını b¨olebilecek
asal sayılar 2, 3, 5, 7, 9, 11, 13, 17, 19, 23, 29, 31 olabilir. Bu sayıların 1009 u¨ b¨olup¨
b¨olmedi˘gi kontrol edilir. Hi¸c birisi 1009 sayısını b¨olmedi˘gi i¸cin sayı asal sayıdır.
6.3 Eratosthenes Metodu (Method of Eratosthenes)
Bu metod, verilen bir tamsayının altında kalan but ¨ un¨ asal sayıları bulmak i¸cin kullanılır.
Oncelikle ¨ 2 den n ye kadar olan tamsayılar sırasıyla yazılır ve
√
n den ku¸¨cuk¨ ve e¸sit
olan asalların carpanları ¸ (2p, 3p, · · ·) elimine edilir. Listede geri kalan sayılar asal sayıları
g¨osterir.
Ornek ¨ 6.3.1 49 u a¸smayan but ¨ un¨ asalları bulunuz.
65
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
2 3 4 5 6 7 8 9 10
11 12 13 14 15 16 17 18 19 20
21 22 23 24 25 26 27 28 29 30
31 32 33 34 35 36 37 38 39 40
41 42 43 44 45 46 47 48 49
√
49 = 7. B¨oylelikle cevap:2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47 asal sayılarıdır.
6.4 Denklik Teorisi(Theory of Congruence (Modularity))
Tanım 6.4.1 n sabit pozitif bir tamsayı olsun. E˘ger n|a − b ya da bir k tamsayısı i¸cin
a − b = nk e¸sitli˘gi sa˘glanırsa, a b ye mod n e g¨ore denktir denir ve a ≡ b mod n ile
g¨osterilir.
Ornek ¨ 6.4.2 • 1 ≡ 5 mod 4, c¸unk ¨ u¨ 1 − 5 = −4 ve 4| − 4.
• −2 ≡ 9 mod 11, c¸unk ¨ u¨ −2 − 9 = −11 ve 11| − 11.
6.4.1 Teoremler:
1. a ≡ b mod n ⇔ a = bk + n esitli˘gini sa˘glayan bir k vardır.
2. Her tamsayı mod n ye g¨ore 0, 1, 2, · · · , n − 1 sayılarından sadece birine denktir.
3. a ≡ b mod n ⇔ a ve b, n ile b¨olund ¨ u˘¨gunde ¨ aynı kalanı verir.
4. a ≡ a mod n
66
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
5. a ≡ b mod n ⇒ b ≡ a mod n
6. a ≡ b mod n ve b ≡ c mod n ⇒ a ≡ c mod n
7. a ≡ b mod n ve c ≡ d mod n ⇒ a + c ≡ b + d mod n
8. a ≡ b mod n ⇒ a
k ≡ b
k mod n
6.4.2 Aritmetik Tersi
a 6= 0 herhangi bir tamsayı olmak uzere,e˘ ¨ ger a · a
∗ ≡ 1 mod n denkli˘gini sa˘glayan bir a
∗
tamsayısı var ise bu a
∗
sayısına a nın mod n ye g¨ore aritmetik tersi denir.
Teorem 6.4.3 E˘ger gcd(a, n) = 1 ⇒ a nın aritmetik tersi vardır.
Ornek ¨ 6.4.4 gcd(4, 9) = 1 c¸unk ¨ u¨ Oklid ¨ algoritmasına g¨ore, 9 = 4 · 2 + 1 b¨oylece 1 =
4 · 2 − 1 · 9 bulunur.
1 = 4 · 2 + (−1) · 9 ⇒ 4 · 2 ≡ 1 mod 9
Neticede 4 un¨ mod 9 a g¨ore tersi 2 dir.
NOT: a · b ≡ 1 mod m e¸sitli˘ginin sa˘glanması gcd(a, m) = 1 olmasıyla mumk ¨ und ¨ ur. ¨
Teorem 6.4.5 (Fermat’s Little Theorem) E˘ger p asal bir sayı ise ve gcd(a, p) = 1
ko¸sulunu sa˘glıyor ise
a
p−1 ≡ 1 (mod p) denkli˘gi her zaman do˘grudur.
67
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
NOT: a
p−1 ≡ 1 (mod p) ⇒ a
p ≡ a (mod p)
Tanım 6.4.6 E˘ger p ve q, a
p ≡ a (mod p) ile a
q ≡ a (mod q) denkliklerini sa˘glayan farklı
asal sayılar ise a
pq ≡ a (mod pq) dur.
Ornek ¨ 6.4.7 • 2
1000000 ≡ ? (mod 7)
p = 7 p − 1 = 6
1000000 = 6 · 166666 + 4 yani 1000000 ≡ 4(mod6)
B¨oylece
2
1000000 = (26
)
166666
· 2
4 ≡ 1 · 2
4 = 16 ≡ 2 mod 7
• 2
340 ≡ ? (mod 341)
2
11 = 2 · 2
10 ≡ 2 · 1 ≡ 2 mod 31
2
31 = 2 · (210)
3 ≡ 2 · 1
3 ≡ 2 mod 11
⇒ a = 2, p = 11, q = 31
2
11·31 ≡ 2 mod 341
2
341 ≡ 2 mod 341 ⇒ 2
340 ≡ 1 mod 341
6.5 Euler Fi(φ) Fonksiyonu (Euler Phi Function)
Tanım 6.5.1 n ≥ 1 bir tamsayı olsun. φ(n) fonksiyonu, 1 ≤ a ≤ n ve gcd(a, n) =
1 ko¸sulunu sa˘glayan a tamsayılarının sayısını g¨osterir, yani n ye kadar olan ve n ile
68
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
aralarında asal olan sayıların sayısını verir.
Ornek ¨ 6.5.2
Φ(1) = 1
Φ(2) = 1 c¸unk ¨ u¨ gcd(1, 2) = 1
Φ(3) = 2 c¸unk ¨ u¨ gcd(1, 3) = gcd(2, 3) = 1
Φ(4) = 2 c¸unk ¨ u¨ gcd(1, 4) = gcd(3, 4) = 1
Φ(5) = 4 c¸unk ¨ u¨ gcd(1, 5) = gcd(2, 5) = gcd(3, 5) = gcd(4, 5) = 1
NOT: φ(n) = n − 1 ⇔ n bir asal sayı olursa.
Teorem 6.5.3 E˘ger p asal bir sayı ise ve k > 0 ise φ(p
k
) = p
k − p
k−1 = p
k
(1 −
1
p
) dir.
Teorem 6.5.4 (Euler Teoremi) n > 1 ve gcd(a, n) = 1 ise a
φ(n) ≡ 1 mod n
Ornek ¨ 6.5.5 3
φ(8) ≡ 1 mod 8 oldu˘gunu g¨osterin.
• φ(8) = φ(23
) = 2
3 − 2
2 = 4
3
φ(8) = 3
4 = 81 ≡ 1 mod 8
69
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
BOL¨ UM¨ 7
AC¸ IK ANAHTARLI S˙ISTEMLER
Farzedin ki siz e-mail yoluyla ba¸ska bir ki¸siyle haberle¸smek istiyorsunuz ve mesajlarınızın
¸sifreli olmasını istiyorsunuz. Ornek ¨ vermek gerekirse, du¨¸sun¨ un¨ ki ¸sifreleme metodunuz
u¸¨c harf anahtarlı Vigenere olsun. 26 sayı sistemi taban alındı˘gında, bu anahtar 0 ile
262 = 676; 2 lik sistemde 0 ile 1010100100 arasındadır. Sizinle haberle¸sti˘giniz ki¸si
arasındaki bilgisayar a˘gı, internet ve fiber optik kanallar guv¨ enli olmadı˘gı i¸cin, siz anahtarlarınızı e-mail yoluyla de˘gi¸stirmek istemezsiniz. 2 lik anahtarlarınızı a¸cık kanal uzerinden ¨
guv¨ enli bir ¸sekilde de˘gi¸stirme yolları vardır. Algoritma ve karma¸sıklık teorisinde uzmanlar belirli matematik problemlerin c¨¸ozum¨ u¨ i¸cin a¸sırı zaman gerekti˘gine inanıyorlar. A¸cık
anahtarlı kriptosistemler de bu mantı˘ga g¨ore geli¸stirilmi¸stir ; oyle ¨ ki bu kriptosistemlerin
birini kırmak bu zor matematik problemleri c¨¸ozmekle e¸sde˘gerdir.C¸ ok hızlı bilgisayarlar da
programlanmı¸s olan c¨¸ozum¨ metodları bile haftalar, aylar, yuzyıllar ¨ hatta evrenin sonuna
kadar olan hayatı bile kapsayabilir.
7.1 MERKLE-HELLMAN KNAPSACK
KR˙IPTOS˙ISTEM
Knapsack a¸cık anahtarlı ¸sifreleme sistemleri alt kume ¨ toplama problemleri temeline
dayanır. Buradaki temel du¨¸sunce, ¨ c¨¸ozum¨ u¨ kolay olan bir alt kume ¨ toplam problemi
orne˘ ¨ gini se¸cip, onu c¨¸ozum¨ u¨ zor olan bir alt kume ¨ toplama problemi orne˘ ¨ gine cevirerek ¸
70
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
gizlemektir. ˙Ilk(orjinal) knapsack kumesi ¨ gizli anahtarı, d¨onu¨¸stur ¨ ulm¨ u¨¸s(gizlenmi¸s) knapsack kumesi ¨ de kapalı anahtarı olu¸sturur.
Merkle-Helman a¸cık anahtarlı ¸sifreleme ¸seması, sup¨ erartan alt kume ¨ toplama problemi
olarak da adlandırılan kolayca c¨¸ozulebilen ¨ bir alt kume ¨ toplama problemi orne˘ ¨ gini moduler ¨
carpım ¸ ve permutasy ¨ on yoluyla gizleme giri¸simidir.
7.1.1 Sup¨ erartan dizi (Superincreasing sequence)
B = (b1, b2, · · · , bn) dizisinde e˘ger her sayı kendisinden once ¨ gelen sayıların toplamından
buy¨ uk¨ ise ,yani
bi =
Pi−1
j=1 bj oyleki ¨ 2 ≤ i ≤ n,
bu diziye sup¨ erartan dizi denir.
7.1.2 Sup¨ erartan Altkume ¨ Toplama Problemini c¨¸ozme Algoritması
G˙IRD˙I: (b1, b2, · · · , bn) ¸seklinde olan sup¨ erartan bir dizi ve bi
lerin altkumesinin ¨ toplamını
ifade eden s tamsayısı algoritmamızın girdileri olsun.
C¸ IKTI: Elemanları xi ∈ {0, 1} olan ve
Pn
i=n
xibi = s ko¸sulunu sa˘glayan (x1, x2, · · · , xn)
dizi a¸sa˘gıdaki ¸sekilde hesaplanır:
1. i ← n.
2. i ≥ 1 ise a¸sa˘gıdakiler yapılır:
71
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
• E˘ger s ≥ bi
, xi = 1 yazılır ve s ← s−bi uygulanır. Aksi taktirde xi = 0 yazılır.
• i ← i − 1 i¸slemi i = 1 olana kadar surer. ¨
3. Bulunan xi
ler (x1, x2, · · · , xn) dizisini olu¸sturur.
7.1.3 Merkle-HellmanKnapsack S¸ifrelemesinde Anahtar Olu¸sturma Algoritması
Bu kriptosistemde her ki¸si kendi a¸cık anahtarını ve buna ba˘glı gizli anahtarını ¸su ¸sekilde
olu¸sturur:
1. Sistem parametresi olarak sabit bir n tamsayısı alınır.
2. Her A ki¸sisi a¸sa˘gıdaki 3 − 7. adımları uygular.
3. Bir tane sup¨ erartan (b1, b2, · · · , bn) dizisi ve M > b1 + b2 + · · · + bn ¸sartını sa˘glayan
bir M mod sayısı se¸cer.
4. 1 ≤ W ≤ M − 1 ve gcd(W, M) = 1 ko¸sullarını sa˘glayan rastgele bir W tamsayısı
se¸cer.
5. {1, 2, · · · , n} tamsayılarıyla ifade edilen rastgele bir π permutasy ¨ onu se¸cer.
6. i = 1, 2, · · · , n de˘gerleri i¸cin ai = Wbπi mod M ifadelerini hesaplar.
7. A’nın a¸cık anahtarı (a1, a2, · · · , an); A’nın kapalı anahtarı ise
(π, M, W,(b1, b2, · · · , bn)) olur.
72
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
7.1.4 Basit Merkle-Hellman Knapsack A¸cık Anahtar S¸ifreleme Algoritması
B ¸sahsı A i¸cin m mesajını ¸sifreliyor olsun.
1. S¸ifreleme: B, ¸sunları yapar:
• A’nın a¸cık anahtarı (a1, a2, · · · , an) i alır.
• m mesajını n uzunlu˘gundaki 2 lik dizi,m = m1m2 · · · mn, olarak ifade eder
• Daha sonra c = m1a1 + m2a2 + · · · + mnan de˘gerini hesaplar.
• Olu¸san kapalı metni A’ya g¨onderir.
2. De¸sifreleme: c kapalı metnine kar¸sılık gelen m a¸cık metnini c¨¸ozmek i¸cin A ¸sunları
yapar:
• Oncelikle ¨ d = W−1
c mod M de˘gerini hesaplar.
• Sup¨ erartan altkume ¨ toplam problemini c¨¸ozerek, d = r1b1 + r2b2 + · · · + rnbn
e¸sitli˘gini sa˘glayan r1, r2, · · · , rn ri ∈ {0, 1} tamsayılarını bulur.
• Mesaj bitleri mi = rπ(i)
, i = 1, 2, · · · , n dir.
Ornek ¨ 7.1.1 Anahtar Olu¸sturma: n = 6 olsun. A ¸sahsı (12, 17, 33, 74, 157, 316)
sup¨ erartan bir dizi ve M = 737 > 12 + 17 + 33 + 74 + 157 + 316 = 609 tamsayısı
se¸cer. Daha sonra gcd(W = 635, M = 737) = 1 ko¸sulunu sa˘glayan bir W = 635 sayısını
se¸cer. Son olarakta {1, 2, · · · , 6} sayılarından olu¸sup π(1) = 3, π(2) = 6, π(3) = 1,
π(4) = 2, π(5) = 5, π(6) = 4 leri sa˘glayan bir π permutasyonunu ¨ alır. A a¸cık anahtarını
73
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
ai = Wbπi mod M e¸sitli˘gini kullanarak ¸su ¸sekilde olu¸sturur:
a1 = Wbπ(1) = Wb3 = 635 · 33 mod 737 ≡ 319
a2 = Wbπ(2) = Wb6 = 635 · 316 mod 737 ≡ 196
a3 = Wbπ(3) = Wb1 = 635 · 12 mod 737 ≡ 250
a4 = Wbπ(4) = Wb2 = 635 · 17 mod 737 ≡ 477
a5 = Wbπ(5) = Wb5 = 635 · 157 mod 737 ≡ 200
a6 = Wbπ(6) = Wb4 = 635 · 74 mod 737 ≡ 559
B¨oylece A’nın a¸cık anahtarı (319, 196, 250, 477, 200, 559) knapsack dizisidir. A’nın gizli
anahtarı ise (π, M, W,(12, 17, 33, 74, 157, 316)) dır.
S¸ifreleme: B, m = 101101 mesajını ¸s¨oyle ¸sifreler:
c = 1 · 319 + 0 · 196 + 1 · 250 + 1 · 477 + 0 · 200 + 1 · 559
= 319 + 250 + 477 + 559 = 1605
ve bunu A’ya g¨onderir.
De¸sifreleme: Mesajı c¨¸ozmek i¸cin A, d = W−1
c mod M de˘gerini hesaplar ve sup¨ erartan
altkume ¨ toplama problemini c¨¸ozer. Onc ¨ elikle W−1 = 635−1 ≡ 513 mod 737, ikinci olarak
d = W−1
c = 513 · 1605 ≡ 136 mod 737 de˘gerlerini bulur.
136 = 12 · r1 + 17 · r2 + 33 · r3 + 74 · r4 + 157 · r5 + 316 · r6
= 12 + 17 + 33 + 74
B¨oylelikle r1 = 1, r2 = 1, r3 = 1, r4 = 1, r5 = 0, r6 = 0 ve π nin permutasyonunun ¨
uygulanmasıyla mesaj bitleri m1 = r3 = 1, m2 = r6 = 0, m3 = r1 = 1, m4 = r2 = 1,
m5 = r5 = 0, m6 = r4 = 1 bulunur.
74
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
7.2 RSA Kriptosistem
RSA kriptosistem, 1978 yılında ” Dijital imza elde etme metodu ve a¸cık anahtarlı kriptosistemler” adlı bir makale ile yayınlandı. Adını yaratıcılarının (Ronald Rivest,Adi Shamir,
Leonard Adleman) soyadlarının ba¸sharflerinden alan RSA kriptosistem, g¨ondericinin bir
metodla ve herkes¸ce bilinen a¸cık bir anahtarla mesajlarını ¸sifreledi˘gi bir ¸sifre sistemi olarak
tanımlanır. Daha onceki ¨ gizli(simetrik) anahtarlı sistemlerin tersine anahtarı bilmek
de¸sifre anahtarını ortaya cık ¸ armaz. Bu sistem hem gizlilik hem de dijital imza sa˘glamak
ama¸clı kullanılabilir. Bu sistemin guv¨ enli˘gi tamsayılarda carpanlara ¸ ayırma probleminin
kolaylıkla olmaması temeline dayanır.
RSA kriptosisteminde ki¸silere ¸sifreli mesaj g¨onderilebilmesi i¸cin o ki¸silerin a¸cık anahtarlarına ihtiya¸c vardır. Mesajı alan ki¸sinin de mesajı okuyabilmesi i¸cin gizli bir anahtarının
olması gerekir.Anahtar olu¸sturma a¸s˘gıdaki algoritmada ifade edilmi¸stir.
Anahtar Olu¸sturma algoritması: Her A ki¸sisi anahtarını ¸su ¸sekilde olu¸sturur:
•
˙Iki tane farklı,rasgele ve yakla¸sık aynı uzunlukta olan p ve q asal sayıları se¸cer.
• n = pq ve φ = (p − 1)(q − 1) de˘gerlerini hesaplar.
• 1 < e < φ ve gcd (e, φ) = 1 olacak ¸sekilde rastgele bir e sayısı se¸cer.
• Oklid ¨ algoritmasını kullanarak, 1 < d < φ ve ed ≡ 1 ( mod φ) ko¸sulunu sa˘glayan d
sayısını hesaplar.
• A’nın a¸cık anahtarı (n, e); A’nın gizli anahtarı ise d olur.
75
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
RSA anahtar olu¸sumunda e ve d tamsayıları sırasıyla ¸sifreleme uss ¨ un¨ u¨ ve de¸sifreleme
uss ¨ un¨ u¨ ve n ise mod sayısını g¨osterir. p ve q sayılarının onluk sistemde uzunluklarının
100 ve dolayısıyla da n nin uzunlu˘gunun 200 olması beklenir. Fakat verilecek orneklerde ¨
kolaylık olması a¸cısından ku¸¨cuk¨ sayılar se¸cilecektir.
S¸ifreleme Algoritması:
1. B ¸sahsı, A’ya bir m mesajı g¨ondermek istiyor. B, m mesajını ¸sifrelemek i¸cin
a¸sa˘gıdakileri yapar:
• Oncelikle ¨ A’nın a¸cık anahtarını (n,e) alır.
• m mesajını [0, n − 1] aralı˘gında yazar.
• Sonra c ≡ me
( mod n) de˘gerini hesaplar.
• Olu¸san c ¸sifresini A’ya g¨onderir.
2. S¸ifreli c metninden a¸cık metni bulabilmek i¸cin A a¸sa˘gıdaki i¸slemi uygular:
• d gizli anahtarını kullanarak ve m ≡ c
d
( mod n) i¸slemini uygulayarak m a¸cık
metine ula¸sır.
NOT: De¸sifre sisteminin calı ¸ ¸smasına
ed ≡ 1 ( mod φ) oldu˘gu i¸cini ed = 1 + kφ e¸sitli˘gini sa˘glayan mutlaka bir k tamsayısı
bulunur. E˘ger gcd (m, p) = 1 ise Fermat teoreminden dolayı
mp−1 ≡ 1 ( mod p).
76
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
E˘gere bu denkli˘gin her iki tarafının da k(q − 1)’inci kuvvetlerini alırsak
mk(p−1)(q−1) ≡ 1 ( mod p).
olur ve her iki tarafı da m ile carptı˘ ¸ gımızda
m1+k(p−1)(q−1) ≡ m ( mod p).
sonucuna ula¸sırız.
Di˘ger tarfatan, e˘ger gcd (m, p) = p olursa yukarıdaki denklik yine ge¸cerli olur; c¸unk ¨ u¨
farzedelim belli bir k tamsayısı i¸cin m = kp olsun
mp−1 = (kp)
(p−1) = k
(p−1)p
(p−1) ≡ p ( mod p).
E˘ger bu denkli˘gin her iki tarafının da k(q − 1)’inci kuvvetlerini alırsak
mk(p−1)(q−1) ≡ p
k(p−1)(q−1) ≡ p ( mod p).
olur ve her iki tarafı da m ile carptı˘ ¸ gımızda
m1+k(p−1)(q−1) ≡ mp = kp
2 ≡ kp = m ( mod p).
˙Iki durumda da
med ≡ m ( mod p)
oldu˘gu g¨orul ¨ ur. ¨ Aynı ¸sekilde,
med ≡ m ( mod q)
olur.
77
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Sonu¸cta p ve q farklı asal sayılar ol˘gu i¸cin,
med ≡ m ( mod n)
dir.B¨oylelikle,
c
d = me
d
≡ m ( mod n)
Ornek ¨ 7.2.1 1. Anahtar olu¸sturma: A ¸sahsı p = 2357 ve q = 2551 olan iki tane
asal sayı se¸cmi¸s olsun. Onc ¨ elikle A,
n = pq = 6012707
ve
φ = (p − 1)(q − 1) = 6007800
de˘gerlerini hesaplar. A bir tane e = 3674911 de˘geri se¸cer.Bu e de˘geri, gcd(e =
3674911, φ = 6007800) = 1 ve 1 < e = 3674911 < φ = 6007800 ko¸sullarını sa˘glar.
Daha sonra Oklid ¨ algoritmasını kullanarak
e · d ≡ 1 (mod φ)
3674911 · d ≡ 1 (mod 6007800)
d = 422191 de˘gerini hesaplar. A’ nın a¸cık anahtarı (n = 6012707, e = 3674911);
gizli anahtarı da d = 422191 olur.
2. S¸ifreleme: B, m = 5234673 mesajını ¸sifrelemek i¸cin A’nın a¸cık anahtarını,yani
(n = 6012707, e = 3674911), alır ve a¸sa˘gıdaki ¸sekilde oldu˘gu gibi kapalı metin c ’yi
78
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
hesaplar:
c ≡ me
(mod n) = 52346733674911 (mod 6012707) ≡ 3650502
ve bu de˘geri A’ya g¨onderir.
3. De¸sifreleme: A, gelen c kapalı metninden m a¸cık metni a¸sa˘gıdaki gibi hesaplar:
m ≡ c
d
(mod n) = 3650502422191 (mod 6012707) ≡ 5234673
7.3 RSA ˙Imza S¸eması
RSA kriptosistemi dijital imzalar i¸cin de kullanılabilir. (n, e) A ¸sahsının a¸cık anahtarı,
d sayısı da A’nın gizli de¸sifreleme uss ¨ u¨ olsun.Oncelikle ¨ mesajın imzalanabilmesi i¸cin m
mesajının {0, 1, · · · , n − 1} arasında olması istenir, daha sonra hesaplamalar yapılır.
7.3.1 ˙Imzalama
A B’ye imzalı m mesajını g¨ondermek isterse, mesaja kendisinin kapalı anahtarını uygular,yani
σ = md mod n.
Daha sonra (m, σ) imzalı mesajı B’ye g¨onderir.
79
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
7.3.2 ˙Imzayı Do˘grulama
B, A’dan aldı˘gı (m, σ) imzalı mesajı do˘grulamak i¸cin
m = σ
e mod n
de˘gerini hesaplar. C¸ ıkan sonu¸c m ise mesaj do˘grulanmı¸s olur.
Ornek ¨ 7.3.1 Anahtar Olu¸sturma: A ki¸sisi p = 7927 ve q = 6997 asal sayılarını se¸cer
ve, n = pq = 55465219 ve φ = 7926 · 6996 = 55450296 de˘gerlerini hesaplar. Daha sonra
A, ed = 5d ≡ 1 (mod 55450296) e¸sitli˘ginden d = 44360237 sayısını bulur. A’nın a¸cık
anahtarı (n = 55465219, e = 5); gizli anahtarı d = 44360237 olur.
˙Imzalama: m = 31229978 mesajını imzalamak i¸cin A ¸sunu hesaplar:
σ = md mod n = 3122997844360237 mod 55465219 ≡ 30729435
ve (m = 31229978, σ = 30729435) ’yi B’ye g¨onderir.
˙Imzayı Do˘grulama: (m = 31229978, σ = 30729435)’yi alan B mesajı do˘grulamak i¸cin
¸sunu yapar:
m = σ
e mod n = 307294355 mod 55465219 ≡ 31229978
C¸ ıkan sayı m oldu˘gu i¸cin imza do˘grulanmı¸s olur.
80
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
7.4 Ayrık Logaritma(Discrete Logarithm)
RSA kriptosisteminde, RSA fonksiyonu m olan bir elemanın e. kuvvetini olu¸sturur. Bu
fonksiyon birebir bir fonksiyondur ve etkili bir ¸sekilde hesaplanır.E˘ger n nin carpanlara ¸
ayrımı bilinmiyorsa, e. k¨oku¨ hesaplamak i¸cin etkili bir algoritma yoktur. Sayılar teorisinde
hesaplaması kolay fakat tersinin hesaplaması zor olan ba¸ska fonksiyonlar da vardır. Bunlardan en onemlilerinden ¨ biri de sınırlı alanlar da (finite fields) kuvvet almadır. Basit
olarak sadece asal alanlar (prime fields) du¨¸sun¨ ulecektir. ¨
p bir asal sayı ve g de Z
∗
p de bir primitif k¨ok olsun. Ayrık kuvvet fonksiyonu (discrete
exponential function)
Exp : Zp−1 → Z
∗
p
, x 7→ g
x
,
tekrarlı karesini alma algoritması orne˘ ¨ ginde oldu˘gu gibi etkili bir ¸sekilde hesaplanabilir.
Kuvvetin logaritması fonksiyonunun tersini hesaplamak i¸cin etkili bir algoritma bilinmemektedir. Bu tahmine ayrık logaritma tahmini (discrete logarithm assumption) denir.
7.5 El-Gamal A¸cık Anahtarlı Kriptosistem
ElGamal a¸cık anahtarlı ¸sifre sistemi,anahtar transferi modunda Diffie-Hellman anahtar
anla¸sması(Diffie-Hellman Key Agreement) olarak g¨orulebilir. ¨ Guv¨ enilirli˘gi ayrık logaritma problemi ve Diffie-Helman probleminin kolay c¨¸ozulememesi ¨ temeline dayanır. Temel
ElGamal ve genelle¸stirilmi¸s ElGamal ¸sifreleme ¸seması bu b¨olumde ¨ tanımlanmı¸stır.
81
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
7.6 ElGamal A¸cık Anahtarlı S¸ifrelemede Anahtar Olu¸sturma Algoritması
Her ki¸si kendi a¸cık anahtarını ve buna ba˘glı gizli anahtarını olu¸sturur. Bunu olu¸sturmak
i¸cin A ¸sahsı ¸sunları uygular:
1. C¸ ok buy¨ uk¨ rastgele bir p asal sayısı ve mod p ye g¨ore tamsayıların olu¸sturdu˘gu
carpım ¸ grubu Z
∗
p nin bir jenerat¨oru¨ α yı olu¸sturur.
2. 1 ≤ a ≤ p − 2 ¸seklinde olan bir a tamsayısı se¸cer ve α
a mod p de˘gerini hesaplar.
3. A’nın a¸cık anahtarı (p, α, α
a
); A’nın gizli anahtarı ise a olur.
7.6.1 ElGamal A¸cık Anahtarlı S¸ifreleme
Algoritması
B ¸sahsı A i¸cin m mesajını ¸sifrelesin.
1. S¸ifreleme: B mesajı ¸sifreleme i¸cin ¸sunları yapar:
• A’nın a¸cık anahtarını (p, α, α
a
) alır.
• mesajı {0, 1, · · · , p − 1} aralı˘gında m tamsayısı olarak ifade eder.
• 1 ≤ k ≤ p − 2’yi sa˘glayan rastgele bir k tamsayısı se¸cer.
• γ = α
k mod p ve δ = m · (α
a
)
k mod p de˘gerlerini hesaplar.
• Son olarak c = (γ, δ) kapalı metnini A’ya g¨onderir.
2. De¸sifreleme: c kapalı metninden m a¸cık metine ula¸smak i¸cin A ¸sunları yapar:
82
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
• a gizli anahtarını kullanarak γ
−a mod p de˘gerini hesaplar (γ
−a = α
−ak mod p).
• γ
−a
· δ mod p de˘gerini hesaplayarak m’yi bulur.
γ
−a
· δ ≡ α
−ak
· mαak ≡ m (mod p)
Ornek ¨ 7.6.1 Anahtar Olu¸sturma: A ¸sahsı bir p = 2357 asal sayısı ve α = 2 ∈ Z
∗
∈357
bir jenerat¨or se¸cer. Buna ilave olarak bir a = 1751 gizli anahtarı se¸cer ve
α
a mod p = 2
1751 mod 2357 ≡ 1185
de˘gerini hesaplar. A’nın a¸cık anahtarı (p = 2357, α = 2, α
a = 1185) tir.
S¸ifreleme: m = 2035 mesajını ¸sifrelemek i¸cin B ¸sahsı rastgele bir k = 1820 tamsayısı
se¸cer ve
γ = 2
1520 mod 2357 ≡ 1430
ve
δ = 2035 · 11851520 mod 2357 ≡ 697
de˘gerlerini hesaplar. Son olarak B (γ = 1430, δ = 697) ’yi A’ya g¨onderir.
De¸sifreleme: A gelen kapalı metni c¨¸ozmek i¸cin
γ
−a = 1430−1750 ≡ 1430605 mod 2357 ≡ 872
bulur ve m mesajına da
m = 872 · 697 mod 2357 ≡ 2035
83
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
b¨oylece ula¸sır.
7.6.2 ElGamal ˙Imzası
ElGamal kriptosisteminde imza RSA ’da oldu˘gu gibi mesajın do˘gru ki¸siden geldi˘gini kontrol etmek i¸cin kullanılır. Sadece kapalı metin yerine imzalanmı¸s kapalı metin g¨onderilerek
o kapalı metnin istenen ki¸siden gelip gelmedi˘gi de kontrol edilmi¸s olur. A ¸sahsının a¸cık
anahtarı (p, α, α
a = y) ve gizli anahtarının da a oldu˘gu du¨¸sun¨ uls ¨ un. ¨
7.6.3 ˙Imza Algoritması
m mesajının Zp nin bir elemanı oldu˘gu du¨¸sun¨ ul ¨ ur.E˘ ¨ ger de˘gilse hash fonksiyonu kullanılarak m mesajının Zp nin elemanı olması sa˘glanır. A ¸sahsı m mesajını ¸su ¸sekilde
imzalar:
1. Rastgele bir t tamsayısı se¸cer oyleki ¨ 1 ≤ t ≤ p − 2 ve gcd(t, p − 1) = 1 ko¸sulunu
sa˘glamalıdır.
2. r = α
t ve s = t
−1
(m − ra) mod (p − 1) e¸sitliklerini kurar.
3. (m, r, s) A’nın imzalı mesajıdır.
7.6.4 Do˘grulama
(m, r, s) imzalı mesajı alan B ¸sahsı aldı˘gı mesajın A’dan geldi˘gini ¸su ¸sekilde do˘grular:
84
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
1. Oncelikle ¨ 1 ≤ r ≤ p − 1 oldu˘gunu kontrol eder.E˘ger de˘gilse imzayı reddeder.
2. Daha sonra v = α
m ve w = y
r
r
s de˘gerlerini hesaplar (Buradaki y sayısı A’nın a¸cık
anahtarındaki y sayısıdır. )
3. E˘ger v = w e¸sitli˘gi sa˘glanıyorsa imza kabul edilir, aksi taktirde reddedilir.
Ornek ¨ 7.6.2 Anahtar Olu¸sturma: A ¸sahsı bir p = 2357 asal sayısı ve α = 2 ∈ Z
∗
∈357
bir jenerat¨or se¸cer. Buna ilave olarak bir a = 1751 gizli anahtarı se¸cer ve
α
a mod p = 2
1751 mod 2357 ≡ 1185
de˘gerini hesaplar. A’nın a¸cık anahtarı (p = 2357, α = 2, α
a = 1185) tir.
˙Imza Olu¸sturma: Basit olması a¸cısından mesaj m = 1463 olarak se¸cilsin (E˘ger mesaj
p asal sayısından buy¨ uk¨ olsaydı hash fonksiyonundan ge¸cirilirdi). m = 1463 mesajını
imzalamak i¸cin A onc ¨ e rastgele bir t = 1529 sayısı se¸cer, daha sonra
r = α
t mod p = 2
1529 mod 2357 ≡ 1490
ve
t
−1 mod (p − 1) = 1529−1 mod (2356) ≡ 245
s = t
−1
(m − ra) mod (p − 1) = 245(1463 − 1490 · 1751) mod 2356 ≡ 1777
A’nın imzası (m = 1463, r = 1490, s = 1777)
85
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
˙Imzayı Do˘grulama: B aldı˘gı imzalı mesajı do˘grulamak i¸cin onc ¨ e
v = α
m mod p = 2
1463 mod 2357 ≡ 1072
de˘gerini hesaplar. Daha sonra
w = y
r
r
s mod p = 1185149014901777 mod 2357 ≡ 1072
de˘gerini hesaplar ve v = w oldu˘gu i¸cin imzayı kabul eder.
7.7 Diffie-Hellman Anahtar Anl¸sması (Diffie-Hellman Key Agreement)
Diffie-Hellman anahtar anla¸sması, anahtar da˘gıtma problemine ilk pratik c¨¸ozumd ¨ ur. ¨
Us ¨ olarak anahtar de˘gi¸stirme olarak da bilinen bu sistem daha once ¨ hi¸c haberle¸sme
sa˘glamamı¸s iki tarafın a¸cık kanal uzerinden ¨ mesajlarını birbirlerine g¨ondererek ortak bir
anahtar yaratma temeline dayanır.
p yeteri kadar buy¨ uk¨ bir asal sayı olsun oyleki ¨ Z
∗
p de discrete logaritma problemini c¨¸ozmek
mumk ¨ un¨ olmasın. g’de Z
∗
p de primitif bir k¨ok (primitive root) olsun. p ve g herkes
tarafından bilinsin. A ve B ki¸sileri a¸sa˘gıdaki yolu izleyerek ortak bir anahtar yaratabilirler:
7.7.1 Diffie-Hellman Anahtar Anla¸sması Algoritması:
• A, 0 ≤ a ≤ p − 2 e¸sitsizli˘gini sa˘glayan ve tesadufi¨ olan bir a sayısı se¸cer. c = g
a
’yı
bulur ve bunu B’ye g¨onderir.
• A, 0 ≤ b ≤ p − 2 e¸sitsizli˘gini sa˘glayan ve tesadufi¨ olan bir b sayısı se¸cer. d = g
b
’yi
bulur ve bunu A’ya g¨onderir.
86
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
• A, ortak anahtar k’yı ¸su ¸sekilde hesaplar:
k = d
a = (g
b
)
a
• B, ortak anahtar k’yı ¸su ¸sekilde hesaplar:
k = c
b = (g
a
)
b
B¨oylelikle A ve B aralarında ortak bir anahtar olan k i¸cin anla¸smı¸s olurlar.
87
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
BOL¨ UM¨ 8
KR˙IPTANAL˙IZ
Kriptanaliz (Kripto-analiz) b¨olum¨ unde ¨ modern kripto sistemleri i¸cerisinde onemli ¨ bir sınıf
te¸skil eden simetrik anahtarlı sistemler olarak bilinen blok ¸sifrelerin ve akan ¸sifrelerin
analizi g¨orulecektir. ¨ Kerckhoff’s prensibi : Kripto-analizci ¸sifreleme algoritmasının
but ¨ un¨ detaylarına ula¸sma guc¨ une ¨ sahiptir ve sistemde sadece anahtar gizlidir.
Bu prensibe g¨ore tasarlanmı¸s ve hala guv¨ enli oldu¯gu kabul edilen bir¸cok algoritma
gun¨ um¨ uzde ¨ mevcuttur.
˙Ikinci Dun¨ ya Sava¸sında Polonyalı ve
˙Ingiliz matematik¸ciler Alman Enigma ¸sifreleme makinasının analizini yaparak algoritmayı kırmı¸slardır ve Alman kapalı metinlerini kriptoanaliz y¨ontemi ile a¸cmı¸slardır. Farklı bir algoritma olan ve belli bir sure ¨ guv¨ enli olarak
kabul edilmi¸s olan RC4 algoritması ”tersine giderek” (reverse engineering) ile kırılmı¸stır.
• Analizcinin amacı herhangi bir algoritma kullanılarak kapatılmı¸s metinlerin a¸cık
halini elde edebilmektir. Genellikle bu amaca algoritmada kullanılan gizli anahtarın
tamamı veya belli bir kısmı elde edilerek ula¸sılır.
• Analiz y¨onteminin ne kadar kuvvetli ve efektif oldu¯gu analiz i¸cin gerekli olan on¨ bilgi
ve yapılacak i¸s miktarı ile ol¸ ¨ cul ¨ ur ¨ ( bilinmesi gerekenler a¸cık-kapalı metin ciftlerinin ¸
sayısı, harcanan zaman, ata¯gın ba¸sarı oranı dır).
88
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Atak C¸ e¸sitleri (Senaryoları) :
• Sadece S¸ifreli Metin Ata˘gı (Ciphertext-Only) : En gu¸¨clu¨ kripto-analitik atakdır.
Sadece haberle¸sme pasif olarak dinlenip (mudahale ¨ edilmeden)yeterince kapalı metin
elde edilerek yapılabilir.
• Bilinen A¸cık Metin Ata˘gı (Known Plaintext): Bir miktar a¸cık-kapalı metin cifti ¸
bilinerek yapılan ataktır. Mesajların bir kısmı tahmin edilebilir veya a¸cık g¨onderilen
mesajlar toplanarak atak uygulanabilir.
• Se¸cilmi¸s A¸cık Metin Ata˘gı (Chosen Plaintext): Analizcinin istedi¯gi (se¸cti¯gi)
metni ¸sifreleme imkanına sahip oldu¯gu kabul edilen atak senaryosudur. Analizci ¸sifreleme algoritmasının guv¨ enli olarak yerle¸stirildi¯gi mekanizmayı elde edebilir.
Analizci aktif olarak haberle¸sme sisteminde rol alır.
• Se¸cilmi¸s Kapalı Metin Ata˘gı (Chosen Ciphertext): De¸sifreleme makinasına
ula¸sılarak yapılan atak ce¸ ¸sitidir. Bir onceki ¨ senaryoya benzemektedir.
• Se¸cilmi¸s A¸cık veya Kapalı Metin Ata˘gı (Adaptive Chosen Plaintext or Ciphertext): Bu atak senaryosunda analizcinin istedi¯gi mesajı a¸cma veya kapatma
konusunda sınırsız kapasiteye sahip oldu¯gu kabul edilir. Onceki ¨ iki senaryonun teorik
olarak daha gu¸¨clendirildi¯gi atak ce¸ ¸sitidir.
89
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
8.1 Kriptanalitik Atakların Ama¸cları
Ayıran Ataklar (Distinguishing Attacks) Ayıran Atakların ba¸sarılı olabilmesi i¸cin
¸sifre sisteminin cıktısını ¸ rastgele bir permutasyonun cıktısından ¸ ayırılaması olası olmalıdır.
Kısmi a¸cık metin bilgisi (Partial Knowledge of the Plaintext) Bu atakta kısmi
a¸cık metin bilgisine ( S¸ifre sisteminin girdisi i¸cin herhangi tahmin) sahip olunur.
De¸sifreleme (Decryption) Bu durumda saldıran ¸sifrelenmi¸s trafi˘gin bir kısmını de¸sifre
etme yetene˘gine sahiptir.
S¸ifreleme (Encryption(Forgery))
Bu durumda saldıran anlamlı mesajları bilinmeyen gizli anahtar ile ¸sifreleme olana˘gına
sahiptir. Bu gizli anahtar bilgisine sahip oldu˘gu anlamına gelmez. Bu ata˘ga meyilli
olan ¸sifre sistemleri ger¸cekli˘gini kanıtlama/kimlik belirtme i¸slemlerinde kullanım i¸cin
uygun de˘gillerdir.
Kısmı Anahtar Edinimi (Partial Key Recovery) Bu atakta gizli anahtarın belli
bir kısmı saldıran tarafından ele ge¸cirilir. Belki bu anahtarın geriye kalan kısmı cok ¸
buy¨ uk¨ olabilir fakat bu arzulanan bir durum de˘gildir. C¸unk ¨ u¨ tum¨ anahtarın genellikle ele
ge¸cirilmesi i¸cin ilk basamaktır.
Tum¨ Anahtar Edinimi (Total Key Recovery) Bir kriptosistem i¸cin en korkun¸c
kriptanalitik atak ce¸ ¸sidir.
90
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
8.2 Kriptanaliz Metodları(Methods of Cryptanalysis)
E˘ger ¸sifre sistemi temiz ve basit bir yapıya sahip ise hala kalem ve ka˘gıt kriptanalistin elindeki en gu¸¨clu¨ silahlardır. Bir cok ¸ durumda ka˘gıt analizi bilgisayar analizinden
gelen geribildirimlere (¨ozel istatiksel ozellikler ¨ ve duzensizlikler ¨ arama gibi) ihtiya¸c duyar. Ara¸stırmacı bakı¸s a¸cısından bir ¸sifre sistemi kırıldı˘gının dile getirilmesi, bu sistemin
dizaynı de˘gi¸stirmeye yol a¸cacak bir zayıflı˘gının bulunması demektir. Bu de˘gi¸siklik, ek
d¨ongulerin ¨ eklenmesi veya d¨ongu¨ anahtarlarını olu¸sturan algoritmanın ve bazı i¸c yapıların
de˘gi¸smesi anlamına gelebilir. S¸ifre sisteminin tamamen kırılması ise bu tur ¨ sistemi tamir
etmek yerine ba¸stan tasarlamanın daha anlamlı veya kolay oldu˘gu durumlardır. Tipik
kriptanaliz metodlarını ¸s¨oyle sıralayabiliriz:
Etraflı Arama (Exhaustive Search) Etraflı Arama, ¸sifre sistemleri uzerine ¨ en a¸cık
ve en do˘grudan uygulanabilir bir methodur. Tum¨ olası gizli anahtarları bilinen kısa
a¸cık/kapalı metin ornekleri ¨ uzerinde ¨ dener. Do˘gru gizli anahtar bilinen a¸cık bir metinden
do˘gru kapalı metinin elde edilmesini sa˘glar. Gun¨ um¨ uz¨ hesaplama imkanlarına g¨ore
modern blok ¸sifre sistemlerinin anahtar uzunlukları (128-bit ve yukarısı) bu tip ata˘gı
imkansız kılacak ¸sekilde se¸cilmektedir. DES in en onemli ¨ zayıflı˘gı 56-bit olan kısa anahtar
uzunlu˘gudur ve gun¨ um¨ uz¨ ko¸sulları du¨¸sun¨ uld ¨ u˘¨gunde ¨ bu anahatar uzunlu˘gu etraflı aramayı
mumk ¨ un¨ kılmaktadır.
S¨ozluk¨ Atakları (Dictionary Attacks)
Bu da basit fakat blok ¸sifre sistemleri i¸cin onemli ¨ bir atak ce¸ ¸sidir. E˘ger ¸sifrelenen
metinlerin uzunlukları kısa ise saldıran bir¸cok metin toplar ve farklı metinlerin tekrar91
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
lama analizini yapar. En u¸c noktada bu ata˘ga zayıf ¸sifre sistemi basit de˘gi¸stirmeli ¸sifre
sistemidir (simple substitution cipher).
E¸s Tanımlama (Equivalent Description)
Bazen ¸sifre sistemi tasarlayanlar sistemin veya par¸calarının basit e¸sde˘ger tanımlarını
g¨ozden ka¸cırırmaları, bu atak tarafından s¨omur ¨ ul ¨ ur. ¨
De˘gi¸smezler i¸cin Devirlilik veya Arama (Periodicity or Search for Invariants)
De˘gi¸smezler, ¸sifreleme boyunca de˘gi¸smeyen ozellikler ¨ olarak du¨¸sunelebilir ¨ ve ¸sifre sisteminin istenilmeyen bir ozelli˘ ¨ gidir. E˘ger kriptanalist sistemin herhangi de˘gi¸smezini yada
yakınsamasını bulmayı ba¸sarırsa bir ayıran atak i¸cin malzeme edinmi¸s olur. Her ce¸ ¸sit
devirli davranı¸s veya ¸sifrelenmeler arasındaki korelasyon mutlaka engelllemelidir.
Do˘gum Gun¨ u¨ Paradoks (Birthday Paradox) Blok ¸sifreleme sistemlerinden a¸cık
anahtar ¸sifre sistemlerine uzunan sayılamıyacak kadar onemli ¨ bir olasılıklı paradoksudur.
Ortada bulu¸sma Ata˘gı (Meet-in-the-Middle Attack) Bu metod ¸sifreleme sistemini
alt ve ust ¨ olmak uzere ¨ b¨oler. Sonra kısmi tahmini ile yukarıdan ortaya ve ba¸stan ortaya
kısmi de¸sifreleme yapar. Sonu¸c kar¸sıla¸stırılır ve e˘ger uyumlu ise aday anahtar saklanır.
Aksi takdirde tahmin edilen anahtar yanlı¸s olur.
˙Istatiksel Yakla¸sımlar (Statistic Approaches)
Bu metodlar kapalı ve a¸cık metin arası ili¸ski veren istatiksel ornekleri ¨ arar. Bir tur ¨ ayıran
ataktır ve di˘ger ataklar i¸cin ilk adımdır. ˙Istatiksel yakla¸sımlar hem olu¸sması yuksek ¨
olasılıkta olayları hem de ger¸cekle¸smesi imkansız olayları bulmaya y¨oneliktir.
92
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Ozel ¨ bir Ata˘ga g¨ore Zayıf Anahtarlar (Weak Keys with Respect to a Particular
Attack)
Bazı durumlarda bir zayıf anahtar kumesinin ¨ bir ¸sifre sisteminin analizini ozel ¨ bir atak
modelini du¨¸sun¨ uld ¨ u˘¨gunde ¨ kolayla¸stırması mumk ¨ un¨ olmaktadır. E˘ger bir kriptosistemin
tum¨ anahtar uzayına g¨ore yuksek ¨ bir oranda zayıf anahtarlara sahip ise tekrar dizayn
edilmesi bile s¨oz konusu olabilir.
Ornek ¨ olarak DES te d¨ort tane zayıf ve oniki tane yarı-zayıf anahtar bulunmaktadır.
Gizli anahtar K olmak uzere ¨ DES i EK olarak tanımlarsak d¨ort tane zayıf anahtar i¸cin
EK(EK(m)) = m ve oniki tane yarı-zayıf anahtardan iki tanesi i¸cin EK1(EK2(m)) = m
sa˘glanmaktadır. IDEA blok ¸sifre sistemi i¸cin 2
128 anahtar uzayı uzerinde ¨ 2
63 elemana
sahip bir zayıf anahtar kumesi ¨ bulunmaktadır.
8.3 Akan S¸ifrelerin Analizi
˙Iyi bir akan ¸sifre algoritması bilinen a¸cık metin ata¯ga kar¸sı dayanıklı olmalıdır. Genel
olarak akan ¸sifrelerin olu¸sturulmasında temel yapı ta¸sları olarak LFSR’lar kullanılır ve
gizli anahtar (secret key) LFSR’ların ba¸slangı¸c konumları olarak (initial state) se¸cilir.
Akan ¸sifrelerin analizinde korelasyon ata¯gı ¸su ¸sekildedir.
Akan ¸sifrelerde anahtar ureticinin ¨ kullanımı
ci = mi ⊕ zi ⇒ zi = ci ⊕ mi
93
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Bilinen a¸cık metin ata˘gı: Belirli a¸cık-kapalı mesaj ciftleri ¸ (mi
, ci), zi
’ler bilinirken gizli
anahtarı bulabilmektir.
Korelasyon ata˘gı i¸cin gerekli ve yeterli ko¸sul ui = zi olma olasılı˘gının 0.5 den farklı olmasıdır. E˘gerP olasılı˘gı g¨osterirse, bunu matematiksel olarak P(ui = zi) 6= 0.5 ¸seklinde
ifade edebiliriz.
Korelasyon atak i¸cin gerek ve yeter ¸sart P(ui = zi) 6= 0.5
Nonlinear (Do˘grusal Olmayan) fonksiyonlarla LFSR’ları birle¸stirme (prensibi)
94
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
E˘ger f fonksiyonu (m−1)-dayanıklı (m-dayanıklı olmayan) bir fonksiyonsa P(zi = u
(a1)
i +
u
(a2)
i + · · · + u
(am)
i
) 6= 0.5 dir. Bu durumda f’nin korelasyon ata˘gına dayanıklı olması i¸cin
m de˘gerinin yeterince yuksek ¨ olması gereklidir.
Korelasyon atak Modeli
Yukarıdaki sistemde korelasyon ihtimali 1 − p = P(ui = zi) ve hata ihtimali p’dir.
Korelasyon Ata˘gı: Resim 4 deki sistemde but ¨ un¨ LFSR’ların maksimum periyoda sahip
oldu˘gunu kabul edelim ve LFSR’ların uzunluklarını L1,L2, . . . ,Ln ile g¨osterelim. E˘ger bu
95
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
sistemdeki LFSR’ların ba˘glantı polinomları ve f fonksiyonu biliniyorsa en fazla Qn
i=1(2Li−
1) adet farklı anahtar uretilebilir. ¨ Uretilen ¨ anahtar dizisi ile herhangi bir LFSR’ın -
buna R1 diyelim; cıktısı ¸ arasındaki korelasyon ihtimali p > 0.5 veya (p < 0.5) ise ve
anahtar dizisinin yeterince uzun kısmı biliniyorsa R1’in ba¸slangı¸c konumu bilinen anahtar
dizisi ile R1’in cıktısının ¸ but ¨ un¨ olası kaydırılmı¸s halleri arasındaki cakı ¸ ¸smaların sayısı ile
bulunabilir. C¸ akı¸sma sayısının korelasyon ihtimali ile tutması gereklidir. Bu durumda
R1’in ilk durumunu bulmak en fazla (2L1 − 1) deneme gerektirir. E˘ger di˘ger LFSR’ların
cıktıları ¸ ile anahtar dizisi arasında korelasyon varsa aynı y¨ontem kullanılarak ilk durmları
elde edilebilir. Sonu¸c olarak Pn
i=1(2Li − 1) deneme gerekmektedir. Bu ise Qn
i=1(2Li − 1)
g¨ore daha ku¸¨cuk¨ bir sayıdır. Aynı ¸sekilde LFSR’ların belli bir kombinasyonu ile cıktı ¸
arasındaki korelasyonda analiz i¸cin kullanılabilir.
Ornek: ¨
Geffe ureteci ¨ olarak bilinen a¸sa˘gıdaki sisteme korelasyon ata˘gı uygulayaca˘gız.
Geffe uretici ¨
96
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
z = f(x1, x2, x3) = x1 ⊕ x2(x1 ⊕ x3)
x1 x2 x3 ⇒ z
0 0 0 0
0 0 1 0
0 1 0 0
0 1 1 1
1 0 0 1
1 0 1 1
1 1 0 0
1 1 1 1
P(z = x1) =
6
8 = 0.75, P(z = x2) =
4
8 = 0.5, P(z = x3) =
6
8 = 0.75
G¨oruld ¨ u˘¨gu¨ gibi f fonksiyonunun cıktıları ¸ 0.75 ihtimalle x1 ve x3 ile tutuyor. Dolayısıyla f
fonksiyonu yeteri kadar cıktısı ¸ elde edilirse 3 LFSR’ın ba¸slangı¸c konumlarını bulunabilir.
8.4 Blok S¸ifrelerin Analizi
Blok ¸sifrelerin analizinde en kuvvetli analiz metodları olarak bilinen iki analiz y¨ontemini
inceleyece¯giz. Biham ve Shamir tarafından geli¸stirilen difransiyel kriptanaliz (differential
cryptanalysis) ve Matsui tarafından geli¸stirilen do˘grusal kriptanaliz (linear cryptanalysis).
8.4.1 Difransiyel Kriptanaliz
Difransiyel Kriptanaliz methodu DES, GDES, Lucifer, FEAL, PES, IDEA, LOKI’89,
REDOC ve Khafre dahil olmak uzere ¨ bir cok ¸ sayıda blok ¸sifre sistemine uygulanmı¸s
bir se¸cilmi¸s a¸cık metin ata˘gıdır. Biham ve Shamir tarafından geli¸stirilen bu atak, ilk
once ¨ DES in indirgenmi¸s d¨ongu¨ ce¸ ¸sitlerine ve sonra tum¨ 16-d¨ongu¨ DES e uygulanmı¸stır.
97
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Gun¨ um¨ uzde ¨ bilinen en onemli ¨ ataklardan birisidir c¸unk ¨ u¨ DES in anahtarları teorik olarak
tum¨ anahtar uzayını denemeyle beklenen masraftan daha azı ile elde edilebilinmektedir.
Difransiyel Kriptanaliz, kripto sistemlerin yeniden g¨ozden ge¸cirilmesine, tekrar dizyan
edilmesi ve yeni sistemlerinin bu ata˘ga kar¸sı dayanıklı tasarlanmalarına neden olmu¸stur.
Bu kriptanaliz metodu a¸cık metin ikilileri farkının bunlara kar¸sılık gelen kapalı metin
ikilileri uzerindeki ¨ etkisini kullanarak analiz yapıar. Bu farklar olası anahtarları ihtimal
atamak ve ihtimali en yuksek ¨ anahtarları belirlemek i¸cin kullanılır. Aynı farka sahip olan
bir cok ¸ a¸cık metin ikilisini ve kar¸sı gelen kapalı metin ikililerini kullanır.
2n-bit blok ¸sifre sistemleri i¸cin Difransiyel Kriptanalizin ozet ¨ tanımını verece˘giz. ˙Ilk olarak
e¸sit uzunluktaki iki bit dizinin X ve X´ arasındaki farkı (difference) tanımlayalım:
∆X = X ⊗ X´ −1
Burada ⊗ bit dizi grupları uzerinde, ¨ d¨ongu¨ (round) fonksiyonu i¸cinde anahtar ile metin
girdisinin birle¸stirilmesini sa˘glayan bir grup operasyonudur ve X´ −1 ⊗ operasyonuna g¨ore
X in tersidir. Yukarıdaki farkı tanımlamada asıl ama¸c metin girdileri arasındaki farkın
anahtar eklenmeden ve eklendikten sonra aynı olması yani farkın anahtardan ba˘gımsız
yapılması cabasıdır. ¸ Bu bakı¸s a¸cısını anlamak i¸cin :
∆X =(X ⊗ K) ⊗ (X´ ⊗ K)
−1
= X ⊗ K ⊗ K−1 ⊗ X´ −1 = X ⊗ X´ −1
Feistel yapısındaki blok ¸sifre sistemlerinin bir co˘ ¸ gu i¸cin bu farkı kullanarak ¸sifre sistemin
bir d¨ongus ¨ u¨ i¸cin olası tum¨ metin girdi farklarına ve bunlara kar¸sılık gelen olası cıktı ¸
farklarının ilgili olasılıklarını i¸ceren fark da˘gılım tabloları olu¸sturmak mumk ¨ und ¨ ur. ¨
98
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
A¸cık metinimiz P = C0 ve Ci de i d¨ongu¨ ¸sifrelemesinden olu¸san kapalı metin olsun. αi ∆Ci
nin beklenen de˘geri ve α0 se¸cilen ∆P = ∆C0 olmak uzere ¨ bir r-d¨ongu¨ karakteristi˘gi
(r+1) lik (α0, . . . , αr) dır. Burada ∆P a¸cık metin farkı ve ∆Ci de i inci d¨onguden ¨ sonraki
kapalı metin farkıdır. Bir karakteristi˘gin olasılı˘gı verilen i−1 d¨ongu¨ ¸sifrelemesinden olu¸san
∆Ci−1 = αi−1 farka g¨ore i d¨ongu¨ ¸sifrelemesinden sonra elde edilen ∆Ci = αi
farkının
edilmesinin ko¸sullu olasılı˘gıdır. Rastgele, hep aynı ¸sekilde se¸cilmi¸s d¨ongu¨ anahtarları Ki
ler i¸cin bir karakteristi˘gin olasılı˘gı
Pr(∆Ci−1=αi
, ∆Ci−1=αi−1, . . . , ∆C1 = α1 | ∆P = α0)
Bu olasılı˘gı hesaplamak cok ¸ zor olabilir. Bununla beraber bazı blok ¸sifre sistemleri i¸cin bu
olasılık her bir d¨ongun¨ un¨ olasılıkları kullanılarak hesaplanabilir (Markov ¸sifre sistemleri).
˙Istatistiksel i¸slemleri kolayla¸stırmak adına bundan sonra d¨ongu¨ anahtarlarının ba˘gımsız
ve hep aynı ¸sekilde rastgele se¸cildiklerini varsayaca˘gız.
A¸cık metin ikilisi P ve P´ farkı ∆P, anahtar K ve r-d¨ongu¨ karakteristi˘gine g¨ore do˘gru
ikili olarak adlandırılabilinmesi i¸cin P ve P´ ¸sifrelendikten sonra arada yer alan d¨ongulerin ¨
kapalı metinlerinden olu¸san farklar r-d¨ongu¨ karakteristi˘gi izlemelidir. E˘ger anahtar K ve
r-d¨ongu¨ karakteristi˘gine g¨ore P ve P´ do˘gru ikili de˘gilse yanlı¸s ikili olarak adlandırılırlar.
p karakteristik olasılı˘gı olmak uzere ¨ 2n-bitlik ¸sifre sistemi i¸cin yakla¸sık p.22n do˘gru ikili
bulunmaktadır.
Difransiyel Kriptanalizin amacı son d¨ongude ¨ kullanılan Kr anahtarını belirlemektir. Bazı
a¸cık metin ikilileri i¸cin Cr ve C´
r kapalı metinler olsun. Se¸cilmi¸s a¸cık metin ata˘gında
kriptanalist, blok ¸sifre sistemin son d¨ongus ¨ u¨ girdileri Cr−1 ve C´
r−1 bilemez fakat se¸cilen
99
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
karakteristi˘ge g¨ore r − 1 d¨ongu¨ ¸sifre sonundaki kapalı metinlerin farkı ∆Cr−1 tamamen
veya kısmi olarak p olasılıkla bilir. Ve sonra verilen a¸cık metin P ve P´ ikilisinin farkı ∆P
i¸cin kriptanalist a¸sa˘gıdaki denklemi Kr yi c¨¸ozmeye calı ¸ ¸sır:
g
−1
(Cr, Kr) ⊗ g
−1
(C´
r, Kr)
−1 = ∆Cr−1
Yukarıdaki denklemin c¨¸ozum¨ u¨ aday d¨ongu¨ anahtarları olarak adlandırabilece˘gimiz
k1, k2, . . . , kj olsun. E˘ger P ve P´ do˘gru ikili ise Kr ∈ {k1, k2, . . . , kj}. E˘ger P ve P´
yanlı¸s ikili ise ki nin Kr den ba˘gımsız oldu˘gunu kabul edilir. Sonrası e˘ger cok ¸ miktarda
P ve P´ ikilileri denenirse, aday anahtarların tekrarı kaydedilir ve do˘gru d¨ongu¨ anahtarı
Kr di˘ger adaylara g¨ore daha fazla sayılmasını bekleriz. Difransiyel Kriptanaliz methodu
a¸sa˘gıdaki basamaklarla ozetlenebilir: ¨
• Tamamen veya kısmı olarak yuksek ¨ olasılıkta ∆Cr−1 i veren bir
(∆P, ∆C1, ∆C2, . . . , ∆Cr−1) r-d¨ongu¨ karakteristi˘gi bulunması.
• Do˘gru ikili oldu˘gunu varsaydı˘gımız hep aynı ¸sekilde P ve P´ a¸cık metin ikilisi (farkları
∆P) yardımıyla aday d¨ongu¨ anahtarları k1, k2, . . . , kj
, herbiri ki g¨ozlemlenen cıktı ¸
farkını verenler olmak uzere ¨ se¸cilir. Her aday d¨ongu¨ anahtarı ki
i¸cin saya¸c bir
arttırılır.
• Usteki ¨ iki basamak bir aday anahtar ki di˘gerlerine g¨ore cok ¸ sayıda sayılana kadar
tekrar edilir. En cok ¸ sayılan ki ger¸cek r-d¨ongu¨ anahtarı Kr olarak kabul edilir.
Difransiyel Kriptanalizin karma¸sıklı˘gını tanımlamak i¸cin anahtar veya d¨ongu¨ anahtarını
belirlemek i¸cin se¸cilen farka g¨ore ¸sifrelenen a¸cık metin ikililerin sayısı kullanılabilir.
100
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Sınırlandırılmı¸s DES sur ¨ umleri ¨ uzerinde ¨ Biham ve Shamir (DES kitabi referans olacak) ata˘gın karma¸sıklı˘gını yakla¸sık olarak c/p bulmu¸slardır (p kullanılan karakteristi˘gin
olasılı˘gı ve c sabit sayı ve 2 ≺ c ≺ 8 olmak uzere). ¨
Difransiyel Kriptanaliz se¸cilmi¸s a¸cık metin ata˘gı olmasına kar¸sın kullanılan metin ikilileri
arttırılarak bilinen metin ata˘gında da calı ¸ ¸sması sa˘glanabilir.
DES ¸sifre sistemini ele aldı˘gımızda yukarıda bahsedilen metodun uygulanması i¸cin farklar
kullanılarak a¸sa˘gıdaki gibi bir XOR tablosu olu¸sturulur.
101
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
XOR-tablosu (1. S-kutusunun)
DES’in ce¸ ¸sitleri d¨ongu¨ saıyılarına g¨ore ata˘gın ba¸sarı durumları a¸sa˘gıdaki tabloda verilmi¸stir.
102
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Rounds Complexity
4 2
4
6 2
8
8 2
16
9 2
26
10 2
35
11 2
36
12 2
43
13 2
44
14 2
51
15 2
52
16 2
58
3-round (step) Karakteristik
103
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
(iterative) karakteristik tekrar edilebilen
3-round karakteristik
104
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
3-round karakteristik
8.4.2 Do˘grusal Kriptanaliz
Do˘grusal Kriptanaliz 1993 yılında DES sistemini kırmak i¸cin Matsui tarafından
geli¸stirilmi¸s bir bilinen a¸cık metin atak ce¸ ¸sididir. 2
47 a¸cık metin kullanılarak DES sistemi
kırılmı¸stır. Do˘grusal olmayan (nonlinear) fonksiyonlara do˘grusal (linear) fonksiyonlarla
yakla¸sarak yapılmı¸stır. Bu yakla¸sım olasılık uzerine ¨ dayalı oldu˘gu i¸cin 0.5’ten ne kadar
sapılırsa fonksiyonun yerine do˘grusal fonksiyonlar kullanmak bu sapma miktarı kadar
avantaj kazandırır.
P[i1,i2, ...,ia] ⊕ C[j1, j2, ..., jb] = K[k1, k2, ..., kc] ,
105
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
i1,i2, ...,ia, j1, j2, ..., ja ve k1, k2, ..., kc belirli bit yerlerini g¨ostermektedir, ve yukarıdaki
denklemin tutma ihtimali p 6=
1
2
.
Yukarıdaki efektif do˘grusal ifadeye ula¸sıldıktan sonra anahtar bitleri a¸sa˘gıdaki maksimum
yakınlık metodu ile bulunur.
Algoritma
Adım 1 : Yukarıdaki denklemin sol tarafının 0’a e¸sit oldu˘gu a¸cık metinlerin sayısı T olsun.
Adım 2 : E˘ger T > N/2 (Denenen a¸cık metin sayısı = N ),
−→ K[k1, k2, ..., kc] = 0 (e˘ger p >
1
2
) veya 1 (e˘ger p <
1
2
)
−→ K[k1, k2, ..., kc] = 1 (e˘ger p >
1
2
) veya 0 (e˘ger p <
1
2
)
A¸sa˘gıdaki tabloda N ve p cinsinden ata˘gın ba¸sarı oranları verilmi¸stir.
N
1
4
|p −
1
2
|
−2 1
2
|p −
1
2
|
−2
|p −
1
2
|
−2 2|p −
1
2
|
−2
Ba¸sarı oranı 84.1% 92.1% 97.7% 99.8%
Do˘grusal kriptanaliz a¸sa˘gıda kısaca ozetlenmi ¨ ¸stir.
• Efektif do˘grusal ifadenin bulunması,
• Ba¸sarı oranının N ve p cinsinden ifadesi,
• En iyi do˘grusal ifadenin ve anahtar i¸cin en iyi tutma ihtimalinin hesaplanması.
Kaynaklar:
[1] J.Daeman,R. Govaerts and J. Vandewalle, Weak Keys for IDEA, Advances in Cryptology, Proc. EUROCRYPTO’93, LNCS 773, Springer-Verlag, pp. 224-231, 1994.
106
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
[2] A. Biryukov, Introduction to cryptology and cryptanalysis (Ders Notu),
http://www.wisdom.weizmann.ac.il/ albi/cryptanalysis/lectures.htm
[3] X. Lai, J. L. Massey and S. Murphy, Markov Cipher and Differential Cryptanalysis, Advances in Cryptology, EUROCRYPTO’91, Lecture Notes in Computer Science,
Springer Verlag, Berlin-Heidelberg, 547, pp. 17-38, 1991
[4] X. Lai, On the design and security of block cipher, ETH Series in Information Processing, V.1, Konstanz: Hartung-Gorre Verlag, 1992.
[5] NESSIE Project: New European Schemes for Signatures, Integrity and Encryption at,
http://cryptonessie.org
[6] A. Menezes, P. van Oorschot, S. Vanstone, Handbook of Applied Cryptography,
http://www.cacr.math.uwaterloo.ca/hac/
[7] L. R. Knudsen, Ph.D. thesis: Block ciphers - Analysis, Design and Applications ,
http://www.mat.dtu.dk/people/Lars.R.Knudsen/thesis.html
[8] Crypto papers, http://www.funet.fi/ bande/docs/crypt/
107
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
BOL¨ UM¨ 9
HASH FONKS˙IYONLARI
Hash fonksiyonları h : {1, 2, . . . , 2
m} → {1, 2, . . . , 2
n} ve asa˘gıdaki ozelliklere ¨ sahip olan
fonksiyonlardır:
1. sıkı¸stırma: h fonksiyonu, uzunlu˘gu sonlu ve de˘gi¸sken olabilen girdiyi alıp sabit bir
uzunlukta cıktı ¸ vermelidir,
2. kolay hesaplanabilirlik: herhangi bir girdi i¸cin h(x) de˘gerini hesaplamak kolay
olmalıdır.
Hash fonksiyonları anahtarsız hash fonksiyonları ve anahtarlı hash fonksi-yonları olmak
uzere ¨ ikiye ayrılır:
1. Anahtarsız hash fonksiyonları h : {0, 1}
∗ → {0, 1}
n
• Blok ¸sifreleme sistemleri tabanlı
• Moduler ¨ aritmetik tabanlı
• Customized (MD4,MD5,SHA-1,RIPE-MD,HAVAL)
2. Anahtarlı hash fonksiyonları hk : {0, 1}
∗ → {0, 1}
n
• Blok ¸sifreleme sistemleri tabanlı
108
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
• Anahtarsız hash fonksiyonları tabanlı
• Customized (MAA,MD5-MAC)
• Akan ¸sifreler i¸cin uretilen ¨
Customized hash fonksiyonları sadece hash i¸cin kullanılan anahtarlı veya anahtarsız
olarak uretilen ¨ hash fonksiyonlarıdır. Ayrıca guv¨ enilir-li˘gi teorik olarak ispatlanan fakat pek pratik olmayan evrensel hash fonksiyonlarıda farklı bir grup olarak
g¨orulebilir. ¨
Anahtarsız hash fonksiyonlarının u¸¨c temel ozelli˘ ¨ gi a¸sa˘gıda belirtilmi¸stir(h bir hash fonksiyonu, x ve x
0
girdileri, y ve y
0
cıktıları ¸ g¨ostermektedir):
1. preimage resistance: h(x) = y de˘geri bilindi˘ginde, x’i hesaplamak sonlu zamanda
mumk ¨ un¨ degil. y biliniyor, h(x
0
) = y olacak bir x
0
bulmak zor(hesaplamak sonlu
zamanda mumk ¨ un¨ degil).
2. 2nd-preimage resistance: h(x) = y biliniyor, h(x
0
) = y olacak farklı bir mesaj
x 6= x
0
bulmak zor.
3. collision resistance: h(x) = h(x
0
) olacak ¸sekilde iki farklı mesaj x ve x
0
bulmak
zor.
Ornek ¨ 1 Mod-32 checksum (Mod 32 kontrol toplamları). Mesajın i¸cerisindeki but ¨ un¨ 32-
bit’lik par¸caların toplamı alınarak kullanılan fonksiyon. Hesaplaması kolay, sıkı¸stırma
var, fakat preimage resistant de˘gil.
109
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Ornek ¨ 2 g(x) = x
2 mod n = pq p, q buy¨ uk¨ asal sayılar (n’nin carp ¸ anları bilinmiyorsa
tek y¨onlu¨ fonksiyondur.) Hesaplaması kolay, sıkı¸stırma yok, preimage resistant (¸cunk ¨ u¨
preimage bulmak n’yi carp ¸ anlarına ayırmaya denk), fakat 2nd preimage ve collision var
(x, −x).
Ornek ¨ 3 DES tabanlı tek y¨onlu¨ fonksiyon. f(x) = Ek(x)⊕x ,sabit bir anahtar(k) i¸cin. E
rasgele bir permutasyon ¨ olarak kabul edilirse f fonksi-yonu tek y¨onlu¨ olur. y bilindi˘ginde
y = Ek(x) ⊕ x olacak ¸sekilde x ve k bulmak zor (E’nin rasgele olamasından dolayı),
E
−1
k
(x ⊕ y) = x bulmak zor, Dolayısıyla f tek y¨onlu¨ bir fonksiyon. Fakat fonksiyon belli
mesaj uzunlukları i¸cin calı ¸ ¸sıyor.
• collision resistant ise 2nd preimage resistantdır:
Fonksiyonumuzun collision resistant oldu˘gunu kabul edelim. 2nd preimage resistant
degilse ⇒ Sabit x, h(x) i¸cin h(x) = h(x
0
) olan x 6= x
0
bulabiliriz, fakat bu collision
resistant olamadı˘gını g¨osteririr, kabulum¨ uzle ¨ celi ¸ ¸sir.
• collision resistant ise preimage resistant olmak zorunda degildir:
g : (0, 1)∗ → (0, 1)n
collision resistant olsun, h fonksiyonunu a¸sa˘gıdaki ¸sekilde
tanımlanırsa preimage resistant olmaz;
h(x) =
n
1kx if |x|=n
0kg(x) if |x|6=n
o
,
h : (0, 1)∗ → (0, 1)n+1 n + 1 bit hash fonksiyon.
• preimage resistant ise 2nd preimage resistant olmak zorunda degildir:
Ornek ¨ 2’de g¨orulebilir. ¨
110
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Ekstra S¸artlar:
1. Non-correlation: Girdi ve cıktı ¸ bitleri arasında korelasyon olmamalı, blok ¸sifre
sistemlerindeki gibi avalanche ozelli˘ ¨ gi sa˘glanmalı(but ¨ un¨ girdi bitleri but ¨ un¨ cıktı ¸ bitlerini etkilemeli),
2. Near-collision resistance: w(h(x) ⊕ h(x
0
) ku¸¨cuk¨ olacak farklı x ve x
0
ciftlerini ¸
bulmak zor olmalı (w:hamming agırlı˘gı),
3. Partial-preimage resistance(local one-wayness): Girdi bitlerinin bir kısmını
dahi bulmak zor olmalı, girdinin t uzunlu˘gundaki kısmını bulmak i¸cin yakla¸sık 2
t −
1’lik hesaplama yapmak gerekmeli (girdinin belli bir kısmı bilinse dahi diger kısmını
bulmak zor olmalı).
Anahtarsız hash fonksiyonlarının cogu ¸ girdi ve cıktı ¸ uzunlu˘gu sabit olan bir f hash fonksiyonunun tekrarlı olarak uygulanmasıyla elde edilir. Bu fonksiyonlara Iterative hash
fonksiyonları(h) adı verilir. Herhangi bir uzunluktaki x girdisi, sabit r-bit uzunluklara b¨olun¨ ur( ¨ xi), x’in uzunlu˘gunun r’nin katı olması i¸cin belli bir kurala ba˘glı olarak x’e
padding (bit ekleme) yapılır. Girdi par¸caları xi
’ler sırasıyla f’ye sokulur, f’nin cıktısı ¸ ve
xi+1 tekrar f’nin girdisi olarak kullanılır ve son girdi blo˘guna kadar bu i¸slem tekrarlanır.
Bu durumda a¸sa˘gıdaki i¸slemler yapılmı¸s olur: x = x1x2 . . . xt
,
H0 = IV ; Hi = f(Hi−1, xi), 1 ≤ i ≤ t; h(x) = g(Ht),
IV :ba¸slangı¸c de˘geri
Iterative hash fonksiyonlarının genel ve detaylı yapıları a¸sa˘gıdaki ¸sekillerde verilmi¸stir:
111
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
NOT: f fonksiyonunun collision resistant olması h fonksiyonunun collision resistant olmasını garantiler.
Anahtarsız hash fonksiyonları:
• Blok ¸sifre sistemleri tabanlı: ˙Iterasyonda kullanılan f fonksiyonu herhangi bir
blok ¸sifre sistemi olarak se¸cilir. Kullanılan makinanın i¸cinde bir blok ¸sifreleme sistemi varsa hash fonksiyonu olarakta kullanılabilir.
112
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
• Moduler Aritmetik tabanlı: ˙Iterasyon fonksiyonu (f) mod M aritmeti˘gini baz
alan bir fonksiyon olarak se¸cilir, carpanlara ¸ ayırma ve discrete logaritim problemlerini temel alan sistemler se¸cilebilir.
• Customized: Ozel ¨ olarak hash i¸cin tasarlanmı¸s ve optimize hıza sahip olan fonksiyonlardır. Pratik olarak kullanılmaktadır, MD ailesi ve SHA ornek ¨ olarak verilebilir. Guv¨ enilirlikleri hesaplama guc¨ une ¨ dayalı olarak ispatlanır, matemetiksel
olarak guv¨ enilir oldukları ispatlanmamı¸stır.
Anahtarlı hash fonksiyonları:
• Blok ¸sifreleme sistemleri tabanlı: CBC tabanlı MAC’lar ornek ¨ olarak verilebilir.
• Anahtarsız hash fonksiyonları tabanlı: Gizli bir anahtarın anahtarsız hash
113
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
fonksiyonlarının girdisinin bir par¸cası olarak kullanılmasıyla uretilen ¨ hash fonksiyonlarıdır.
A¸sa˘gıdaki y¨ontemler ornek ¨ olarak verilebilir(k anahtar ve h bir anahtarsız hash
fonksiyonu olmak uzere): ¨
1. secret prefix metod: M(x) = h(k||x),
2. secret suffix metod: M(x) = h(x||k),
3. envelope metod with padding: hk(x) = h(k||p||x||k) p :padding k||p bir blok
uzunlu˘gunda olacak ¸sekilde padding yapılıyor,
4. hash tabanlı: HMAC(x) = h(k||p1||h(k||p2||x)), p1, p2 :padding, k||p1 ve
h(k||p2||x) birer tam blok uzunlu˘gunda olacak ¸sekilde padding yapılıyor.
• Customized MAC’lar: Sadece hash yapmak i¸cin tasarlanmı¸s ve i¸cerisinde gizli
anahtar barındıran hash fonksiyonlarıdır. Ornek ¨ olarak MAA ve MD5-MAC verilebilir.
Hash fonksiyonları ile ilgili detaylı bilgiler a¸sa˘gıdaki kaynaklarda bulunabilir:
• Handbook of Applied Cryptography,Chapter 9, by A. Menezes, P. van Oorschot,
and S. Vanstone, CRC Press, 1996. http://www.cacr.math.uwaterloo.ca/hac
• Cryptographic Hash Functions: A Survey, by S. Bakhtiari, R. Safavi-Naini, J.
Pieprzyk
• Hash functions based on block ciphers: a synthetic approach, by B. Preneel,R.
Govaerts, and J. Vandewalle
114
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
BOL¨ UM¨ 10
TEST YONTEMLER ¨ ˙I
Giri¸s
Rassallı˘gın tanımı kısaca tahmin edilemeyen, belirli bir kalıba sahip olmayan olarak verilebilir. Rassal olarak uretilen ¨ sayılar, ¸sans oyunlarında, istatistiksel orneklemelerde ¨ ve
simulasyon uygulamalarında sık¸ca kullanılır.
Rassallık kriptografide kullanılan en temel ozelliklerden ¨ biridir. Atak yapan ki¸siye, bir
kriptosistem cıktısının ¸ olabildi˘gince tahmin edilemez olması gerekir. Rassal sayılar bir¸cok
kriptografik uygulamanın temelini olu¸sturur. Olu¸sturulması en gerekli ve aynı zamanda
en zor olan kısımdır. Neredeyse but ¨ un¨ kriptografik protokollerde gizli ve tahmin edilmesi
zor de˘gerlere ihtiya¸c duyulur, orne˘ ¨ gin asimetrik ¸sifreleme y¨ontemlerinde (RSA, Diffie Hellman) anahtar olu¸sturulurken, rassal sayılar kullanılır. Anahtar gizlili˘gi kriptosistemlerde
cok ¸ onemli ¨ oldu˘gu i¸cin, programlama dillerinde standart olarak kullanılan rassal sayı
urete¸ ¨ clerinin kriptografik ama¸clar i¸cin kullanılması sakıncalıdır. Genelde, bu algoritmalar
istatistiksel rassallık i¸cin tasarlanmı¸stır, kriptanalize kar¸sı dayanıklı de˘gillerdir). Temel
olarak rassal sayılar iki farklı y¨ontemle olu¸sturulur:
Ger¸cek rassal sayı urete¸ ¨ cleri i¸cinde rassal bir yapı bulunduran fiziksel sinyal kaynakları
kullanarak dizi uretirler. ¨ Bu urete¸ ¨ clerin en onemli ¨ avantajları:
• Dizinin bir kısmına sahipken, farklı bir kısmını elde etmenin mumk ¨ un¨ olmaması;
115
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
• Uretilen ¨ diziler kendi i¸cinde herhangi bir gizli ba˘gıntının bulunmaması;
• Periyodik olmamalarıdır.
Bu avantajların yanı sıra, ger¸cek rassal sayı urete¸ ¨ clerinin onemli ¨ dezavantajları da bulunur.
Bu urete¸ ¨ cler co˘ ¸ gunlukla verimsizdir, uzun sayı dizileri elde etmenin maliyeti yuksektir. ¨
Deneyi tekrarlayıp bir sayı dizisini yeniden elde etmek mumk ¨ un¨ de˘gildir.
S¨ozde-rassal (pseudo-random) sayı urete¸ ¨ cleri matematiksel algoritmalar kullanarak diziler
uretirler. ¨ Bu algoritmalar kendi i¸clerinde herhangi bir rassallık barındırmazlar, algoritmalar da genelde a¸cıktır. Buradaki rassallık algoritmaların girdileri (seed) ile sa˘glanır,
bu yuzden ¨ algoritmaların girdileri gizli tutulmalıdır ve kolay tahmin edilemez olmalıdır.
Algoritma ve girdi bilinirse, dizinin tum¨ u¨ elde edilebilir. Bu urete¸ ¨ cler verimlidir ve uzun
diziler uretmenin ¨ maliyet du¨¸sukt ¨ ur. ¨ Kriptografik olarak kullanılabilecek s¨ozde-rassal sayı
urete¸ ¨ cleri ile uretilen ¨ bir dizinin bir kısmı biliniyorsa, bu dizinin di˘ger kısımları ile ilgili bir
bilgi vermemelidir. Aynı urete¸ ¨ cle uretilen ¨ farklı diziler birbirleri ile ili¸skileri olmamadılır
(correlation). Dizilerin periyotları mumk ¨ un¨ oldu˘gunca uzun olmalıdır.
0 − 1 Dizileri
Kritografide kullanılan sayı dizileri 0 ve 1’lerden olu¸sur. Sayı uretecinin ¨ uretti˘ ¨ gi her bitin
0 veya 1 olma ihtimali 1
2
ye e¸sit olmalıdır. Golumb, periyodik bir dizinin rassallı˘gını test
eden u¸¨c tane kural geli¸stirmi¸stir:
1. Dizi i¸cerinse bulunan 0’ların ve 1’lerin sayısının farkı maksimum 1 olmalı.
116
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
2. Dizi i¸cerisinde bulunan ob¨ eklerin (kendisini tekrarlayan bitler) sayısı, n dizi
uzunlu˘gu olarak verildi˘ginde, (n + 1)/2 olmalıdır. Bir bitten olu¸san ob¨ eklerin sayısı
toplam ob¨ ek sayısının yarısı kadar olmalıdır.
3. Dizinin kendisi ile olan ili¸skisi du¨¸suk¨ olmalıdır.
Bir dizinin rassallı˘gı test edilirken Golumb kuralları yeterli de˘gildir. LFSR’lar ile uretilen ¨
sayı dizileri Golumb kurallarını sa˘glamalarına ra˘gmen kriptografik olarak sayı urete¸ ¨ cleri
olarak kullanılmazlar. LFSR ile uretilen ¨ sayı dizilerinin lineer karma¸sıklıkları du¨¸sukt ¨ ur. ¨
S¨ozde-Rassal Sayı Urete¸ ¨ clerinin Test Edilmesi
S¨ozde-rassal sayı urete¸ ¨ clerini test etmek i¸cin istatistiksel testler kullanılır. A¸sa˘gıda istatistiksel hipotez testleri ile ilgili on¨ bilgi bulunmaktadır.
˙Istatistiksel Testler
˙Istatistiksel cık ¸ arım yapmak i¸cin istatistiksel hipotez testleri kullanılır. Bu testlerde bir
hipotez (null hypothesis, H0) one ¨ sur ¨ ul ¨ ur, ¨ bu hipotezin tersi de alternatif hipotez, Ha
olarak kabul edilir. ˙Istatistiksel test sonucunda varılabilecek iki farklı temel karar vardır:
- H0’ yu reddet. - H0’ yu reddetme. Birinci karar, H0 aleyhine gu¸¨clu¨ bir kanıt elde
edildi˘ginde verilir. Bu gu¸¨clu¨ kanıt bulunamadı˘gında ise ikinci karar verilir.
But ¨ un¨ istatistiksel testlerde ka¸cınılmaz hata yapma payı vardır. Test sonucunda iki
farklı hata, birinci tip (alfa) ve ikinci tip (beta) yapılabilir. Birinci tip hata hipotezimiz
do˘gruyken, kararımız H0’yu reddet oldu˘gunda ger¸cekle¸sir. ˙Ikinci tip hata ise hipotezimiz yanlı¸sken, kararımız H0’yu reddetme oldu˘gunda ger¸cekle¸sir. Hipotez testinde birinci
117
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
tip hata yapma olasılı˘gını sınırlamak gerekir. Test sonucunda birinci tip hata yapma
olasılı˘gımız, testimizin guv¨ enilirlik seviyesini verir. Bu de˘ger genel olarak 0.01-0.05 olarak
se¸cilir. ˙Istatistiksel bir testin guc¨ u, ¨ ikinci tip hatayı yapmama olasılı˘gına e¸sittir. Testin
guc¨ un¨ u¨ arttırmak i¸cin daha fazla ornekleme ¨ yapılır.
˙Istatistiksel bir test yapılaca˘gında ilk olarak, H0 ve Ha belirlenir. Daha sonra testin
guv¨ enilirlik seviyesine karar verilir. Bir ornekleme ¨ yapılır ve test istatisti˘gi ve buna ba˘glı
olarak p-de˘geri hesaplanır. P-de˘geri, birinci tip hata yapma olasılı˘gını kontrol etmek yerine, H0’ın do˘gru oldu˘gu varsayımı ile test istatisti˘ginin g¨ozlemleme de˘geri veya daha u¸c
bir de˘ger olması olasılı˘gına kar¸sılık gelir. Bu tanıma uygun olarak hesaplanan olasılık
p-de˘gerini verir. E˘ger bu de˘ger se¸cilen guv¨ enilirlik de˘gerinden ku¸¨cukse ¨ H0 hipotezi reddedilir.
˙Istatistiksel testlerde en cok ¸ kullanılan da˘gılımlar Normal ve Ki-kare da˘gılımlarıdır.
Normal Da˘gılım
Gauss Da˘gılımı adı ile de bilinen normal da˘gılım ilk kez De Moivre tarafından
bulunmu¸stur. Genelde, hipotez testleri da˘gılımın normal oldu˘gu varsayımına g¨ore
duzenlenir. ¨ Da˘gılımın ortalama ve standart sapma olmak uzere ¨ iki parametresi vardır.
C¸ an e˘grisi olarak da bilinir. E˘grinin tepe noktası ortalamasına denk gelir. Ayrıca bu
da˘gılımda ortalama, medyan ve mod aynı de˘gerdir. Ortalamaya g¨ore simetrik bir grafi˘gi
vardır. Da˘gılımın standart sapması e˘grinin geni¸sli˘gini belirler.
Ortalaması sıfır ve standart sapması 1 olan normal da˘gılıma sahip bir de˘gi¸skenin
da˘gılımına standart normal da˘gılım denir. Standart normal da˘gılıma sahip de˘gi¸skenler
118
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Z ile g¨osterilir.
Ortalamadan iki y¨one 1,2 ve 3 standart sapma kadar uzakla¸sıldı˘gında, toplam alanın
sırasıyla %68.26 , %95.44 ve %99.74’u¨ kapsanır.
Ki-Kare Da˘gılımı
Standart normal bir da˘gılımdan se¸cilen bir birimin x de˘gerinin karesi bir ki-kare de˘geri
olur. Bu ¸sekilde tek bir birimden elde edilen ki-karelerin da˘gılımı bir serbestlik derecelidir.
Standart normal bir da˘gılımdan se¸cilen n de˘gerin karelerinin toplamı n serbestlik dereceli
bir ki-kare da˘gılımı olur. Da˘gılımın ¸sekli serbestlik derecesine g¨ore de˘gi¸sir ve asimetriktir.
Surekli ¨ bir da˘gılıma sahiptir.
NIST Test Paketi
Sayı urete¸ ¨ clerinin rassallı˘gını ol¸ ¨ cmek i¸cin bir istatistiksel test yeterli de˘gildir. Bu konuda
bir¸cok test paketi uretilmi ¨ ¸stir (FIBS 140 - Queensland University, DieHard - Florida State
University, NIST). NIST paketinden se¸cilen bazı testlerin a¸cıklaması a¸sa˘gıda verilmi¸stir.
NIST paketindeki testler ile ilgili daha ayrıntılı bilgi i¸cin : http://csrc.nist.gov/rng/
Frekans Testi
Verilen bir dizide bulunan 0 ve 1’lerin oranını kontrol eder. Testin herhangi bir parametresi
yoktur. Testte kullanılan referans da˘gılım yarım normal da˘gılımdır. Testin sonunda elde
edilen p-de˘geri cok ¸ ku¸¨cuk¨ cıkması, ¸ dizideki 1’lerin yada 0’ların sayısının beklenenden fazla
oldu˘gunu g¨osterir. Testin ge¸cerli olabilmesi i¸cin dizi uzunlu˘gunun enaz 100 olması gerekir.
Blok Frekans Testi
119
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Verilen bir dizide bulunan 0 ve 1’lerin oranını M bitlik bloklar i¸cinde kontrol eder. Testin
tek parametresi blok uzunlu˘gudur (M). Blok uzunlu˘gu 1 olarak alındı˘gında blok frekans
testi, frekans testine d¨onu¨¸sur. ¨ Herbir bloktaki 1’lerin beklenen oranı M/2’dir. Testte
kullanılan referans da˘gılım ki-kare da˘gılımdır. Testin sonunda elde edilen p-de˘geri cok ¸
ku¸¨cuk¨ cıkması, ¸ dizideki bloklarda 1’lerin ve 0’ların oranının 1
1
’den fazlasıyla saptı˘gını
g¨osterir. Testin ge¸cerli olabilmesi i¸cin blok uzunlu˘gunun en az 20, dizi uzunlu˘gunun da
en az 100 olması gerekir.
Ob¨ ek Testi
Dizide bulunan ob¨ eklerin (birbirlerini tekrarlayan bitlerin) sayısını kontrol eder. Test,
frekans testinden ge¸cmi¸s dizilere uygulanır. Dizideki de˘gi¸simler ne cok ¸ hızlı (¨orn.
01010101), ne de cok ¸ yava¸s (¨orn. 00001111) olmalıdır. Testte kullanılan referans da˘gılım
ki-kare da˘gılımdır. Testin ge¸cerli olabilmesi i¸cin dizi uzunlu˘gunun en az 100 olması gerekir.
Bloktaki En Uzun Birler Testi
Test, M-bitlik bloklarda bulunan en uzun birler grubu uzerinde ¨ odakla¸sır. Testin tek
parametresi blok uzunlu˘gudur (M). Dizi M-bitlik n tane blo˘ga b¨olun¨ ur ¨ ve her blok
i¸cerisindeki en uzun birler ob¨ e˘ginin uzunlu˘guna bakılır. Bu de˘gerlerin frekansları beklenen
de˘gerlerle kıyaslanır ve ciddi bir sapma olup olmadı˘gı kontrol edilir. Testte kullanılan
referans da˘gılım ki-kare da˘gılımdır. Dizi uzunlu˘guna g¨ore blok uzunlu˘gu ve blok sayısına
karar verilir.
Matris Rank Testi
120
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Test i¸cerisinde dizi M ∗ M-bitlik matrislere b¨olun¨ ur ¨ ve olu¸sturulan herbir matrisin rankı
hesaplanır. Diziden olu¸sturulan matrislerin ranklarının frekansları hesaplanır, beklenen
frekansla kıyaslanır ve ciddi bir sapma olup olmadı˘gı kontrol edilir. Testte kullanılan
referans da˘gılım ki-kare da˘gılımdır. Dizi uzunlu˘guna g¨ore matrisin boyutlarına karar
verilir. Onerilen ¨ M = 32 de˘geri i¸cin dizi uzunlu˘gu en az 38,912 bit olmalıdır.
Evrensel Test
Verilen dizinin yeterince sıkı¸stırılıp sıkı¸stırılamayaca˘gını kontrol eder. Dizinin fazlasıyla
sıkı¸stırılması, dizinin rassallıktan uzak oldu˘gunu g¨osterir. Testte, dizi L bitlik bloklara
ayrılır. Bu blokların bir kısmı testin ba¸slangı¸c kısmında uygulanır. Testte kullanılan
referans da˘gılım yarım normal da˘gılımdır. L-bitlik kalıpların birbirlerini ne kadar sıklıkla
tekrar etti˘gi hesaplanır ve bu de˘gerler beklenen de˘gerler ile kar¸sıla¸stırılır. Blok uzunlu˘gu
6 se¸cildi˘ginde, dizi uzunlu˘gu en az 387,840 olmalıdır.
Lineer Karma¸sıklık Testi
Test dizinin rassallık i¸cin yeterince karma¸sık olup olmadı˘gını kontrol eder. Diziler LFSR
cıktıları ¸ olarak kabul edilir ve diziyi olu¸sturabilecek en ku¸¨cuk¨ LFSR’ın boyu ku¸¨cukse, ¨
dizinin rassal olmak i¸cin yeterince karma¸sık olmadı˘gına karar verilir. Testte dizi M bitlik
bloklara ayrılır ve bloktaki bitlerin lineer karma¸sıklıkları Berlekamp-Massey algoritması
kullanılarak hesaplanır. Hesaplanan lineer karma¸sıklıkların beklenen da˘gılıma uygun olup
olmadıklarına bakılır. Testte kullanılan referans da˘gılım ki-kare da˘gılımıdır. Testin ge¸cerli
olabilmesi i¸cin dizinin boyu en az 1,000,000; blok uzunlu˘gu da 500 ve 5000 arasında
olmalıdır.
121
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Entropi Testi
Test, m bitlik kesi¸sen blokların frekansları uzerinde ¨ odakla¸sır ve bu frekansları m ve
(m + 1)-bitlik bloklar i¸cin beklenen de˘gerler ile kar¸sıla¸stırır. Testte kullanılan referans
da˘gılım ki-kare da˘gılımıdır. Diziden kesi¸sen n tane m-bitlik blok uretilir. ¨ Bu blokların
frekansları ve entropisi hesaplanır. Aynı i¸slemler blok uzunlu˘gu m+14 i¸cin tekrarlanır. m
ve m + 1 bit i¸cin hesaplanan de˘gerlerin farkına ba˘glı test istatisti˘gi hesaplanır. Bu farkın
du¨¸suk¨ olması rassallıktan uzaklı˘gı g¨osterir.
De˘gerlendirme Stratejileri
Verilen rassal sayı ureteci ¨ kullanılarak uzunlu˘gu n olan m adet sayı dizisi olu¸sturulur.
Bu m dizi verilen testlere girdi olarak kullanılır. Testlerin sonucunda m∗(test sayısı)
kadar p-de˘geri hesaplanır. Bu p-de˘gerlerinin analizi sonucunda uretecin ¨ sa˘gladı˘gı rassallık hakkında karara varılır. Burada 3 farklı karar verilebilir; (1) Rassallıktan sapma
belirlenmedi, (2) A¸cıkca rassallıktan sapma belirlendi, (3) Belirli bir sonuca varılmadı. Bu
kararlar verilirken oncelikle ¨ testin guv¨ enilirlik seviyesinden du¨¸suk¨ ka¸c tane p de˘geri bulundu˘gu ol¸ ¨ cul ¨ ur, ¨ bunun beklenen de˘geri m∗(test sayısı)∗(guv¨ enilirlik seviyesi)’dir. Buna
ek olarak bulunan uretecin ¨ kabul edilmesi i¸cin p-de˘gerlerinin da˘gılımının da tek duze ¨
(uniform) olması beklenir.
122
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
BOL¨ UM¨ 11
KR˙IPTOGRAF˙IK PROTOKOLLER
KR˙IPTOGRAF˙IK PROTOKOL NED˙IR?
Protokol, basit¸ce iki veya daha fazla ki¸si arasındaki onceden ¨ belirlenmi¸s belli bir amaca
y¨onelik haberle¸sme metodu olarak tanımlanabilir. Kriptografik protokol ise protokol
olarak kriptografik bir algoritma i¸ceren bir protokol kastedilir. Ancak genelde ama¸c temel
gizlili˘gin otesindedir. ¨ Haberle¸sen taraflar du¨¸sman ya da dost olabilirler.
KR˙IPTOGRAF˙IK PROTOKOLLER˙IN OZELL ¨ ˙IKLER˙I
Kriptografik algoritmalarda oldu˘gu gibi bir protokolun¨ de guv¨ ensiz oldu˘gunu ispatlamak
guv¨ enlili˘gi ispatlamaya g¨ore cok ¸ daha kolaydır. Bir protokolu¨ incelerken yine tıpkı algoritmalardaki gibi protokolu¨ nasıl bir cihazda hayata ge¸cirece˘gimizden cok ¸ temel calı ¸ ¸sma
prensipleri ile ilgilenilir.
HAKEM (arbitrator) ve DUZENLEY ¨ ˙IC˙I (adjudicator)
Kimi zaman protokollerde haberle¸smenin duzg ¨ un¨ bir ¸sekilde i¸sleyebilmesi i¸cin hakem
olarak adlandırdı˘gımız guv¨ enilir 3. ki¸silere ihtiya¸c duyulur. Hakemlerin en onemli ¨ ozelli˘ ¨ gi
tum¨ protokolun¨ onların g¨ozetiminde yur ¨ ut ¨ ul ¨ uy¨ or olmasıdır. Hakemi cık ¸ ardı˘gınız zaman
protokol i¸slemez. Duzenleyici ¨ ise hakemin aksine sadece bir anla¸smazlık durumunda
ba¸svurulan guv¨ enilir 3. ki¸silere denir.
123
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
DUZENLEY ¨ ˙IC˙IL˙I (adjudicated) PROTOKOLLER
Bu protokoller temelde taraflarin dur ¨ ustl ¨ u˘¨gune ¨ dayanır. Bir anla¸smazlık ya da birisinin
hile yapması durumunda duzenleyici ¨ ki¸si bunu farkeder. Denilebilir ki iyi bir duzenleyicili ¨
protokolde duzenleyici ¨ aynı zamanda hile yapan tarafın kim oldu˘gunu da farkeder.
Dolayısı ili bu ki¸sinin varlı˘gı, hile on¨ unde ¨ engel te¸skil eder.
KEND˙I
˙IS¸LEY˙IS¸
˙IN˙I ZORLAYAN (Self-Enforcing) PROTOKOLLER
Protokol herhangi bir hileye yer bırakmaz. Protokolun¨ sorunsuz i¸slemesi otomatik olarak
herhangi bir hile yapılmadı˘gı anlamına gelir. Hile halinde protokol durur. Devam edilemez
bir hal alır. Ve bunu herhangi bir hakem ya da duzenleyi¸ ¨ ciye ihtiya¸c olmadan sa˘glayacak
¸sekilde tasarlanmı¸stır. Bir protokol i¸cin her zaman istenen bir ozelliktir. ¨ Ancak her durumda kendi i¸sleyi¸sini zorlayan bir protokol bulmak mumk ¨ un¨ olamayabilir.
AKT˙IF ve PAS˙IF SALDIRILAR (attacks)
Bir protokol i¸slerken her zaman saldırı olması olasıdır. Pasif saldırıca k¨otu¨ ama¸clı ki¸si
sadece arada gelip giden trafi˘gi dinleyerek protokol tasarlanırken kendisinin ula¸sması
umulmayan bir bilgiye eri¸smeye calı ¸ ¸sır. Aktif saldırıda ise k¨otu¨ niyetli ki¸si sadece dinlemekle kalmaz. Mesajları ya da kayıtları okumanın otesinde ¨ kesebilir, bozabilir ya
de˘gi¸stirebilir. Aktif saldırgan tamamen dı¸sardan birisi olmak zorunda de˘gildir. Sistemdeki
ba¸ska legal bir kullanıcı ve hatta sistem y¨oneticisi olabilir. Saldırganın protokolu¨ uygulayan taraflardan birisi olması durumunda ise daha cok ¸ hile ve saldırıyı uygulayan ki¸si
124
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
i¸cinse hilekar tabirleri kullanılır. Saldırganlarda oldu˘gu gibi hilekarları da pasif hilekar ve
aktif hilekar olarak ikiye ayırmak mumk ¨ und ¨ ur. ¨
T˙IP˙IK S˙IMETR˙IK ALGOR˙ITMA HABERLES¸ME PROTOKOLU¨
Simetrik kriptografi kullanılarak yapılan tipik bir haberle¸smede A ve B ki¸sileri bir kriptosistem ve bir anahtar uzerinde ¨ anla¸sırlar ve A ki¸sisi bu anahtarı kullanarak ¸sifreledi˘gi
mesajını B ki¸sisine g¨onderir. B ki¸sisi de yine aynı anahtarı kullanarak mesajı de¸sifre eder
ve haberle¸sme tamamlanır.
Bu sistemin onemli ¨ dezavantajları vardır. Oncelikle ¨ A ve B ki¸siler anahtar de˘gi¸stirmek
i¸cin biraraya gelmelidirler (anahtar de˘gi¸simi i¸cin ba¸ska bir algoritma kullanılmadı˘gını
varsayarsak). Araya giren k¨otu¨ niyetli Z ki¸sisi mesajlara ula¸stı˘gı taktirde mesajın
di˘ger tarafa gitmesini engelleyebilir ve hatta anahtarı bilmesi durumunda bu mesajı
kendisininkilerle de˘gi¸stirerek iki haberle¸sme tarafını da farkında olmaksızın bamba¸ska
mesajlar g¨onderebilir.
T˙IP˙IK AC¸ IK ANAHTAR KR˙IPTOS˙ISTEM˙I
˙ILE HABERLES¸ME
A ve B ki¸sileri bir a¸cık anahtar kriptosistemi uzerinde ¨ anla¸sırlar. Simetrik anahtarlı sistemde oldu˘gu gibi burdada kriptosistem uzerinde ¨ anla¸sma gizli yapılmak zorunda de˘gildir.
B ki¸sisi A ki¸sisine kendi a¸cık anahtarını g¨onderir. A ki¸sisi mesajını B’nin a¸cık anahtarı
ile ¸sifreler ve g¨onderir. B ki¸sisi ise kendi gizli anahtarı ile mesajı c¨¸ozer ve mesaja ula¸sır.
A¸cık anahtarlı tipik haberle¸sme sistemlerinin en onemli ¨ dezavantajı ortalama olarak
simetrik bir algoritmadan 1000 kat yava¸s olmalarıdır. Uzun mesajları bu yolla g¨ondermek
125
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
pratik de˘gildir.
T˙IP˙IK KARMA (hybrid) KR˙IPTOS˙ISTEMLER
B, A’ya a¸cık anahtarını g¨onderirir. A bir oturumda kullanılmak uzere ¨ rastgele bir oturum anahtarı uretir ¨ ve B’nin a¸cık anahtarı ile ¸sifreleyerek B’ye g¨onderir. B ki¸sisi ise gizli
anahtarı aracılı˘gıyla edindi˘gi oturum anahtarını a¸car ve daha sonra bu anahtarı belirledikleri simetrik kriptosistemde kullanarak haberle¸smelerini sa˘glarlar.
Tahmin edilece˘gi uzere ¨ bu sistemde taraflar, simetrik kriptosistem anahtarı belirlemek
i¸cin biraraya gelmek zorunda kalmamaktadırlar.
HASH FONKS˙IYONLARI
Hash fonksiyonlarının kriptografide birazdan bir miktar inceleyece˘gimiz uzere ¨ cok ¸ geni¸s bir
kullanım alanı vardır. Hash fonksiyonları, oncelikle ¨ tek-y¨onlu¨ (one-way) fonksiyonlardır.
Yani bir verinin fonksiyon altında g¨orun¨ tus ¨ un¨ u¨ hesaplamak kolaydır ama g¨orun¨ tuden ¨
fonksiyonun tersi aracılı˘gıyla ana veriyi elde etmek hesaplama guc¨ u¨ anlamında zordur.
Hash fonksiyonları ile elde etti˘gimiz de˘ger, yani hash de˘geri, fonksiyon girdisinin de˘gi¸sken
boyuta sahip olmasına kar¸sın sabit boyuta sahiptir ve genelde hash de˘geri, girdiye g¨ore
cok ¸ daha ufak boyuttadır. Kullanılan Hash fonksiyonlarından birbirine cok ¸ benzer girdi
de˘gerlerini i¸cin dahi cok ¸ farklı cıktılar ¸ uretmesi ¨ beklenir. Ve yine onemli ¨ bir ozellik ¨ olarak
hash fonksiyonlarından cakı ¸ ¸smasız (collision-free) olmaları umulur. Yani hash fonksiyonumuz altında aynı hash de˘gerini veren iki girdinin bulunması hesaplama guc¨ u¨ g¨oze
alındı˘gında cok ¸ zor olmalıdır.
126
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Yukarda bahsedilen ozellikler ¨ ı¸sı˘gında hash de˘gerleri, verilerin parmak izi olarak
du¨¸sun¨ ulebilir. ¨ Dolayısıyla birisinde olan bir d¨okumanın ¨ sizde de oldu˘gunu d¨okumanı ¨
o ki¸siye g¨ondermeden ispat etmek isterseniz hash de˘gerini ona s¨oyleme yolunu kullanabilirsiniz. Nitekim dokumanın ¨ elinizde ger¸cekten olmaması durumunda o d¨okumana ¨ ait
hash de˘gerini uretmeniz ¨ cok ¸ zordur. En cok ¸ kullanılan hash fonksiyonları arasında SHA
ve MD5 algoritmaları sayılabilir.
GUNL ¨ UK¨ HAYATTA ˙IMZA
Gunl ¨ uk¨ hayatta sık¸ca kullandı˘gımız imzalarda aradı˘gımız bizim i¸cin cok ¸ onemli ¨ ozellikleri ¨
g¨ozden ge¸cirelim;
1) ˙Imza otentiktir(authentic), imzalayanın kimli˘gini g¨osterir
2) ˙Imza co˘ ¸ galtılamaz.
3) ˙Imza tekrar kullanılamaz.
4) ˙Imza de˘gi¸stirilemez. Uzerinde ¨ oynama yapılamaz.
5) ˙Imza atan ki¸si attıktan sonra imzasını inkar edemez.
AC¸ IK ANAHTAR KR˙IPTOS˙ISTEMLERLE D˙IJ˙ITAL ˙IMZA
Tipik bir a¸cık anahtar kriptosisteminde A ki¸sisi kendi gizli anahtarı ile imzalamak istedi˘gi
d¨okumanı ¨ ¸sifreler. B ki¸sisi ise A’nın a¸cık anahtarı ile d¨okumanı ¨ a¸car. E˘ger a¸camazsa imza
ge¸cerli de˘gildir, imza birisi tarafından ya da do˘gal etkenlerle bozulmu¸stur.
Bu basit imza protokolune ¨ k¨otu¨ taraftan bakacak olursak imzalı d¨okumanı ¨ alan ki¸si dijital ortamda bu imzalı d¨okumanı ¨ diledi˘gi kadar co˘ ¸ galtabilir. ˙Imzalı d¨okuman ¨ bir anla¸sma
127
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
metni ise bu elbette ciddi bir sorun te¸skil etmeyebilir ancak d¨okumanın ¨ para ka¸sılı˘gı
olan bir cek ¸ oldu˘gunu kabul edersek durum farklı olabilir. B ki¸sisinin farklı zamanlarda
farklı ceklermi ¸ ¸s gibi aynı imzalı ceki ¸ bozdurmasını istemeyiz. Bu gibi tekrar kullanımları
onlemek ¨ i¸cin dijital d¨okumanlar ¨ co˘ ¸ gu zaman hangi tarihe ait olduklarını g¨osteren bir zamanpulu (timestamp) ile beraber kullanılır. Mesaj algoritma ile imzalanıp kapatılmadan
once ¨ i¸cine tarih bilgileri de eklenir.
AC¸ IK ANAHTAR KR˙IPTOS˙ISTEM VE HASH FONKS˙IYONUYLA ˙IMZA
A ki¸sisi bu defa d¨okumanın ¨ kendisini (zamanpulu ile veya zamanpulsuz) imzalamak yerine d¨okumanın ¨ bir hash fonksiyonu sonucu uretilmi ¨ ¸s hash de˘gerini imzalar. Ve A ki¸sisi
imzalamak uzere ¨ kullandı˘gı d¨okumanla ¨ beraber imzalanmı¸s hash de˘gerini B’ye g¨onderir.
Alıcı olan B ise imzayı A’nın a¸cık anahtarı ile a¸ctıktan sonra d¨okumanın ¨ hashini kendisi
hesaplar ve bu de˘gerin g¨onderilen hash de˘geri ile uyup uymadı˘gına bakar. E˘ger uyuyorsa
imza ge¸cerlidir. Aksi halde ge¸cersizdir.
Bu protokol d¨okumanın ¨ kendisi yerine sadece hash de˘gerini imzaladı˘gımız i¸cin d¨okumanın ¨
boyutuna ba˘glı olarak bir oncekine ¨ g¨ore inanılmaz ol¸ ¨ cude ¨ hızlı olabilir. ˙Iki farklı
d¨okumanın ¨ hash de˘gerlerinin orne˘ ¨ gin 160-bit’lik bir cıktı ¸ ureten ¨ bir hash fonksiyonunda
1/2
160 oldu˘gu du¨¸sun¨ ul ¨ urse ¨ hash de˘gerini imzalamakla d¨okumanın ¨ kendisini imzalamanın
rahatlıkla e¸sle¸stirilebilece˘gi ortaya cık ¸ ar. Ancak hash fonksiyonunun temel ozellikleri ¨
sa˘glaması gerekti˘gi unutulmamalıdır. S¸ayet tek-y¨onlu¨ olmayan bir hash fonksiyonu
kullanılsaydı, bir d¨okuman ¨ imzalandı˘gı zaman onunla aynı hash de˘gerini veren tum¨
d¨okumanlar ¨ da beraberinde aynı ki¸si tarafından imzalanmı¸s olacaktı.
Bu metodla A ki¸sisi bir d¨okumanı ¨ a¸cı˘ga cık ¸ armadan d¨okumana ¨ sahip oldu˘gunu ispatlaya128
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
bilir. Orne˘ ¨ gin ’copyright’ hakkına sahip olmak isteyece˘gimiz bir d¨okumanı ¨ d¨okumanın ¨
kendisini a¸cı˘ga cık ¸ amadan imzalayabiliriz.
D˙IJ˙ITAL ˙IMZALARDA ˙INKAR EDEMEMEZL˙IK (nonrepudiation)
Yukardaki algoritmanın eksik bir yanı, belgeyi imzalayan ki¸siye her zaman hile olana˘gı
vermesidir. S¸oyle ¨ ki, e˘ger d¨okumanda ¨ bir zamanpulu mevcut de˘gilse A ki¸sisi d¨okumanı ¨
imzaladı˘gını inkar etmek istedi˘gi bir durumda her zaman i¸cin gizli anahtarını herhangi
bir dijital ortamda bırakarak daha sonra da gizli anahtarının calındı˘ ¸ gını ve d¨okumanın ¨
kendisi de˘gil de imzasını calan ¸ ki¸si tarafından imzalandı˘gını one ¨ surebilir. ¨ Bu gibi durumlarda co˘ ¸ gu zaman 3. guv¨ enilir ki¸si olan hakemlerin kontrolunde ¨ olan bir protokole ihtiya¸c
duyulabilir.
˙INKAR ED˙ILEMEYEN D˙IJ˙ITAL ˙IMZALAR
Protokolum¨ uz¨ bu defa bir par¸ca daha karı¸sık ve de 3. guv¨ enilir T ki¸sisine dayanıyor.
S¸oyle ¨ ki; A ki¸sisi mesajı imzalar ve mesaja kendisini tanımlayan bir ba¸slık ekler. Elde
etti˘gi bu yeni birle¸stirilmi¸s mesajı tekrar imzalar ve T ki¸sisine g¨onderir. 3. ki¸side herkesin
a¸cık ve gizli anahtarı bulunmaktadır dolayısıyla dı¸staki mesajı A ki¸sisinin a¸cık anahtarı
ile a¸carak A ki¸sisinin kendisini tanımladı˘gı eklentiye eri¸sir. T daha sonra mesajı ger¸cekten
a ki¸sisinin g¨onderdi˘gini B’ye onaylamak i¸cin mesajın ne zamana ait oldu˘gu bilgisini de
ekleyerek imzalar ve hem A’ya, hem de B’ye g¨onderir. B ki¸sisi T’nin imzasını a¸car ve
A’nın kimlik bilgilerine ula¸sarak imzayı onaylar. ˙Imzanın A’ya da g¨onderiliyor olmasının
sebebi bir anlamda A’ya ”Senin adına ¸s¨oyle bir mesaj g¨onderildi, ¸sayet bunu ger¸cekten
129
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
g¨onderen sen de˘gil de (¨orne˘gin anahtarını calan) ¸ bir ba¸skası ise acele konu¸s, daha sonra
bunu inkar edemezsin” denmesidir.
Bahsedilebilecek bir nokta da ¸sudur ki bu protokolde zaman bilgileri a¸cısından T’ye
guv¨ enilmektedir. Dolayısı ile T ile bir ¸sekilde anla¸san birisi d¨okumanının ¨ tarihi hakkında
hileye giri¸sebilir. Protokolde B’nin A’da mesajı aldıktan sonra ger¸cekten ona dair olup
olmadı˘gını onaylaması i¸cin T’ye sorması gibi de˘gi¸siklikler yapılması suretiyle alternatifleri
de turetilebilir. ¨
S¸
˙IFRELEME ve D˙IJ˙ITAL ˙IMZA
A ve B ki¸silerinin her ikisinin de a¸cık ve gizli anahtarlarının bulundu˘gu bir ortamda bir
mesajı hem ¸sifrelemek ve hem de imzalamak istedi˘gimiz bir durumda A ki¸sisi, mesajı,
basit¸ce s¨oylemek gerekirse once ¨ kendi gizli anahtarı ile imzalar ve daha sonra da imzalanmı¸s mesajı B’nin a¸cık anahtarı ile ¸sifreleyerek B’ye g¨onderir. B de mesajı kendi kapalı
anahtarı ile de¸sifre eder ve daha sonra da A’nın a¸cık anahtarı ile imzaıyı onaylar. S¸ayet
mesajı sorunsuz bir ¸sekilde aldı˘gını A’ya iletmek isterse A’nın yaptı˘gı i¸sin tersini yaparak
mesajı tekrar A’ya g¨onderebilir. A¸cık¸ca ifade etmek gerekirse, B ki¸sisi mesajı kendi gizli
anahtarı ile mesajı imzalayıp daha sonra da A’nın a¸cık anahtarı ile imzayı ¸sifreleyerek
mesajı A’ya g¨onderebilir. A’nınsa geri ters operasyonlarla g¨onderdi˘gi orjinal mesajı elde
etmesi durumunda i¸slemlerin ba¸sarıyla ger¸cekle¸sti˘gi kabul edilir.
Bu operasyonlarda mesajın ¸sifrelenmeden once ¨ imzalanması do˘gal g¨ozukmektedir. ¨ Tersi
bir sıra uygulanması durumunda tıpkı ka˘gıt yerine zarfı imzalayan birisinin, bir ba¸skasına
zarfın i¸cinden ka˘gıdı cık ¸ ararak ba¸ska bir ka˘gıt koyup, koydu˘gu ka˘gıdı imzalanmı¸s
g¨ostermesi gibi bir imkan verdi˘gi a¸cıktır.
130
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Burada dikkat edilmesi gereken bir nokta da ¸sudur ki bu protokol de bir takım ataklara
maruz kalabilir. Orne˘ ¨ gin ba¸skalarından gelen rasgele mesajların imzalanmaması gerekir.
Aynı ¸sekilde ba¸skalarından gelen rasgele mesajların de¸sifre edilip sonucun ba¸skalarına verilmesi de direkt olarak saldırıya meydan verebilmektedir. Ancak genel olarak ¸sifreleme ve
imzalama i¸cin farklı algoritmalar kullanıldı˘gı taktirde ya da aynı algoritma kullanılsa bile
bu iki operasyon i¸cin farklı anahtarlar kullanıldı˘gı zaman bu gibi basit bir saldıyıa meydan
verilmedi˘gi s¨oylenebilir. Benzer ¸sekilde zamanpulu eklentisi de mesajları farklıla¸stırdı˘gı
i¸cin hash fonksiyonlarını burada kullanmak saldırılara kar¸sı iyi bir c¨¸ozum¨ olabilmektedir.
Protokol, de˘gi¸sik ama¸clar ve ortamlar do˘grultusunda ¸sekillendirilebilir.
ANAHTAR DEG˘ ˙IS¸
˙IM˙I (Key Exchange)
Kriptografide en temel uygulamalardan birisi anahtar de˘gi¸simidir. Standart ¸sifreli
haberle¸sme i¸cin, kar¸sılıklı anahtar de˘gi¸simi ba¸sarı ile ger¸cekle¸smi¸sse, co˘ ¸ gu zaman herhangi
bir guv¨ enilir 128-bit (yada daha geni¸s) blok ¸sifre kullanılarak ileti¸sim sa˘glanabilir. Ancak de˘ginildi˘gi gibi oncelikli ¨ olarak anahtar de˘gi¸siminin guv¨ enilir bir ¸sekilde ger¸cekle¸smesi
gereklidir. Sadece belli bir oturum (yada haberle¸sme seansı) i¸cin kullanılan anahtara oturum anahtarı denir.
Anahtar de˘gi¸simi i¸cin simetrik algoritmalar kullanılırsa, guv¨ enilir u¸¨cunc ¨ u¨ ki¸sinin de
yardımıyla anahtar de˘gi¸simini ger¸cekle¸stirmek mumk ¨ und ¨ ur. ¨ Ancak burada, ilk a¸samada
guv¨ enilir 3. bir ki¸siye ihtiya¸c bırakmayan, a¸cık anahtar metoduyla ger¸cekle¸stirilen ve cok ¸
daha i¸slevsel olan bir y¨ontem ele alınacaktır.
131
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
AC¸ IK ANAHTAR METODUYLA ANAHTAR DEG˘ ˙IS¸
˙IM˙I
Bu uygulamada A ki¸sisi once ¨ B’nin a¸cık anahtarını temin eder, rastgele olu¸sturdu˘gu oturum anahtarını B’nin a¸cık anahtarı ile ¸sifreleyerek B’ye g¨onderir. B ki¸sisi ise kendi gizli
anahtarı ile A’nın mesajını a¸car ve haberle¸smelerini g¨onderilen oturum anahtarını kullanarak, simetrik bir algoritma aracılı˘gı ile yur ¨ ut ¨ urler. ¨ Burada a¸cık ve kapalı anahtarlar
bir a¸cık anahtar algoritmasına, oturum anahtarı ise bir simetrik ¸sifreleme algoritmasına
(DES, SAFER, Vigenere vb) aittir.
Burada pasif bir saldırgan i¸cin, yani herhangi bir mudahalede ¨ bulunmayan k¨otu¨ niyetli
ki¸si E i¸cin kullanılan a¸cık anahtar algoritmasını kırmaya calı ¸ ¸smaktan ba¸ska bir yol
g¨orunmemektedir. ¨ Ancak aktif saldırgan i¸cin aynısı s¨oz konusu de˘gildir. Aktif saldırgan,
e˘ger iki ki¸si arasındaki mesajlara eri¸sme ve hatta de˘gi¸stirme imkanına sahipse, B ki¸sisi
A’ya a¸cık anahtarını g¨onderirken araya girip ona kendi a¸cık anahtarını g¨onderebilir.
A ki¸sisi de oturum anahtarını, B’nin anahtarı sandı˘gı bu anahtarla ¸sifreleyerek geri
g¨onderdi˘ginde ise, k¨otu¨ niyetli ki¸si zaten kendi a¸cık anahtarı ile ¸sifrelenmi¸s bu mesajı rahatlıkla a¸cıp okuyabilir. Dahası E, mesajı B’nin ger¸cek a¸cık anahtarı ile tekrar ¸sifreleyerek
B’ye g¨ondererek onların hi¸cbir¸sey olmamı¸scasına anahtarı kendisinde olan bir simetrik algoritmayla haberle¸smelerini sa˘glayabilir. Aktif saldırgan, hissedilir bir yava¸slamaya sebep
olmadı˘gı surece ¨ bu ¸sekilde A ve B ki¸silerinin haberi bile olmadan onların ¸sifreleyerek
g¨onderdikleri tum¨ mesajları okuyabilir. Ortadaki 3. ki¸si tarafından ger¸cekle¸stirilen bu
saldırıya ”ortadaki-adam saldırısı” (man-in-the-middle attack) adı verilir.
132
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Burada bir nokta ise protokolun¨ adım adım i¸slemesi yerine A ki¸sisi tek bir g¨onderimle,
B’nin a¸cık anahtarı ile ¸sifreledi˘gi oturum anahtarını, o oturum anahtarı ile ¸sifreledi˘gi
mesajla birlikte B’ye g¨onderebilir. B de once ¨ kendi gizli anahtarı ile oturum anahtarını
elde eder, sonra da bu anahtarı kullanarak simetrik algoritma ile ¸sifrelenmi¸s mesajı a¸carak
orjinal mesaja ula¸sır.
ARAK˙IL˙IT PROTOKOLU¨ (Interlock Protocol)
Yukarıda de˘ginilen ortadaki-adam saldırısı, A ve B ki¸silerinin ger¸cekten birbirleri ile
konu¸stuklarını onaylama ¸sansları yokken kullanılabilir. Arakilit protokolunde ¨ A ve B
ki¸sileri birbirlerine kar¸sılıklı olarak a¸cık anahtarlarını g¨onderirler. Burada aktif saldırgan
hala araya girip tarafların a¸cık anahtarlarını kendi belirledi˘gi bir a¸cık anahtar ile
de˘gi¸stirebilir) Ancak sonrasında protokol farklı i¸sler. A ki¸sisi oturum anahtarını (veya herhangi bir mesajı da olabilir) yine B’nin a¸cık anahtarı ile ¸sifreler ancak bu defa ¸sifrelenmi¸s
mesajın kendisi yerine yarısını B’ye g¨onderir. Aynı ¸sekilde B ki¸sisi de kendi ¸sifreledi˘gi
mesajın ilk yarısını A’ya g¨onderir. Ve daha sonra, yine once ¨ A ki¸sisi ve sonra da B ki¸sisi
olmak uzere ¨ her iki taraf da ¸sifreledi˘gi mesajın kalan yarısını birbirine g¨onderirler ve iki
yarımı birle¸stirerek kendi gizli anahtarlarıyla mesajın hepsini de¸sifrelerler.
Burada mesajın ikinci yarısı olmadan ilk yarısı kullanı¸ssızdır. Taraflar da ortadaki adam
gibi mesajın ikinci yarısı gelmeden ¸sifreli mesajı de¸sifre etme ¸sansına sahip de˘gildirler. Burada ortadaki-adamı safdı¸sı bırakan etken nedir? Aktif saldırganın daha once ¨ a¸cık anahtarları kendisininki ile de˘gi¸stirerek daha sonra ¸sifreli metinlere nasıl eri¸sti˘gini hatırlayınız.
133
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Ancak burada a¸cık anahtar ile giden mesaj, mesajın tamamı de˘gil. Dolayısıyla saldırgan,
mesajı kendi gizli anahtarı ile a¸cıp B ki¸sisinin a¸cık anahtarı ile tekrar ¸sifreleme ¸sansına
sahip de˘gil. C¸unk ¨ u¨ ¸sifreli mesaj yarım oldu˘gu i¸cin mesajı herhangi bir ¸sekilde a¸cma/
de¸sifre etme ¸sansına sahip de˘gil. Peki bu ozelli˘ ¨ gi sa˘glayan yarım mesaj nedir? Mesajı iki
’yarım’a b¨olmek i¸cin nasıl bir mekanizma kullanılabilir?
Burada kullandi˘gımız mesajı iki par¸caya b¨olup¨ g¨onderme metodundaki par¸calardan ilki
¸sifreli mesajın bir hash fonksiyonu ile elde edilmi¸s bir hash de˘geri olurken ikincisi ise
¸sifreli mesajın kendisi olabilir orne˘ ¨ gin. Ya da ger¸cekten bir 64-bit blok ¸sifre algoritması
ile ¸sifrelenmi¸s mesajın 32’¸ser bit uzunlu˘gunda iki yarısı olabilir. Her iki durumda da
ikinci mesaj gelmeden de¸sifreleme yapılamayacaktır. Ve yine her iki durumda da aktif
saldırganın 2. ¸sifreli mesaj yarısını da bilmeden mesajı de˘gi¸stirmesine olanak yoktur.
˙Ikinci ¸sifreli mesaj, taraflardan birisi tarafından g¨onderildi˘ginde ise coktan ¸ mesajın onay
i¸cin kullanılacak olan ilk yarısı di˘ger tarafın eline ula¸smı¸stır. Dolayısıyla ortadaki adam
i¸cin saldırı vakti coktan ¸ ge¸cmi¸stir. Nitekim protokolun¨ i¸sleyi¸si bunu gerektirmektedir.
Arakilit protokolu¨ Rivest ve Shamir tarafından geli¸stirilmi¸stir.
D˙IJ˙ITAL ˙IMZALARLA ANAHTAR DEG˘ ˙IS¸
˙IM˙I
S¸u ana kadar mesajımızın kendisini ya da mesajımızı iletmede kullanaca˘gımız simetrik
algoritmaya ait anahtarımızı g¨ondermekte kullandı˘gımız metodlarda a¸cık anahtarımızı
g¨onderirken aktif bir saldırganın her zaman i¸cin ger¸cek dun¨ ya uygulamaları ile son derece
ort ¨ u¨¸sen bir ihtimal olan araya girip tarafların a¸cık anahtarlarını de˘gi¸stirmek suretiyle
134
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
ce¸ ¸sitli saldırılarda bulunabilece˘gini kabul ettik. Bu sebeple a¸cık anahtarları da˘gıtmanın
nasıl daha guv¨ enli bir ¸sekilde olabilece˘gi sorusuna cevap olarak 3. guv¨ enilir T ki¸sisinin
imzasını da protokole dahil edelim. S¸oyle ¨ ki; basit bir ifade ile, A ve B ki¸sileri anahtarlarını direkt olarak birbirlerine g¨ondermeleri yerine, 3. guv¨ enilir T ki¸sisi onlar i¸cin anahtar
belirleyip bu anahtarı imzalayabilir. Ve bu ¸sekilde A ve ki¸sileri sadece T ki¸sisinden imzalı
anahtarlar kullanmak uzere ¨ kar¸sılıklı anla¸smı¸slardır. Ve T ki¸sisinin guv¨ enli oldu˘gunu, yani
onun anahtar veri tabanına kimse tarafından eri¸silemedi˘gini kabul edersek (ki bu belli ve
tek bir anahtar da˘gıtıcısının guv¨ enli˘gi sa˘glamak ayrı ayrı pek cok ¸ kullanıcının guv¨ enli˘gini
sa˘glamaktan her zaman i¸cin daha kolaydır) aktif saldırgan araya girip a¸cık anahtarları
kendi anahtarı ile de˘gi¸stiremez.
Bu arada her zaman i¸cin protokol detayları uzerinde ¨ duzenlemeler ¨ yaparak protokolde
faydalı de˘gi¸siklikler yapabilmemizin olası oldu˘gunu unutmayalım. Orne˘ ¨ gin yukarda a¸cık
ve gizli anahtarlarımızı ilk a¸samada bizim i¸cin T ki¸sisinin de˘gil de kendimizin uretti˘ ¨ gini
ve T ki¸sisinin sadece bizim uretti˘ ¨ gimiz anahtarların imzası i¸cin protokolde yer aldı˘gını
du¨¸sun¨ ursek, ¨ anahtarı g¨onderece˘gimiz B ki¸sisi anahtarımızda her zaman T’nin imzasını
arayaca˘gı i¸cin ve aktif saldırgan da dijital imza metodlarının guv¨ enilirli˘gi ol¸ ¨ cus ¨ unde ¨ T
ki¸sisinin imzasını de˘gi¸stiremeye˘gi i¸cin a¸cık anahtar g¨onderimlerimizi cok ¸ daha guv¨ enilir
bir ¸sekilde yur ¨ utebiliriz. ¨ Ustelik ¨ bu durumda aktif saldırgan T’nin dijital anahtarını ele
ge¸cirse bile bu anahtarı A ve B taraflarının mesajlarını okumakta kullanamaz, sadece yeni
a¸cık anahtarlar imzalayabilir. C¸unk ¨ u¨ T’de sadece bizim a¸cık anahtarlarımızı imzalamada
kullandı˘gı bir dijital imza anahtarı bulunmaktadır.
135
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
OTENT˙IKASYON(kimlik do˘grulama)
Bir bilgisayara kendimizi tanıtmak i¸cin kullandı˘gımız yegane metod parola kullanmaktır.
Ancak ilk kez Needham ve Guy ikilisinin ortaya koydu˘gu ¸sekliyle otentikasyon yapan bilgisayarda parolaların kendilerinin bulunmasına gerek yoktur. Dolayısıyla sistem
y¨oneticisinin (ya da sizin parolalarınıza direkt eri¸sme ¸sansına sahip birisinin) parolanızı
farklı ama¸clar i¸cin kullanmasını (¨orne˘gin aynı parolayı kullandı˘gınız ba¸ska bir sisteme
sizin adınıza eri¸smesini) onemli ¨ ol¸ ¨ cude ¨ zorla¸stırmaya yol a¸can ger¸cek ¸sudur ki, bilgisayar i¸cin gerekli olan i¸cinde tum¨ kullanıcı parolalarının bulunması de˘gil, sadece yanlı¸s
girilen parolaları di˘gerlerinden ayırt edebilmesidir. Bu da hash fonksiyonları sayesinde
ger¸cekle¸smektedir, ¸s¨oyle ki; kullanıcı otentikasyon yapılacak bilgisayara parolasını girer,
bilgisayar bu parolanın hash de˘gerini hesaplar ve kendi veri tabanındaki aynı kullanıcı
i¸cin tutulan hash de˘geri ile uyup uymadı˘gını kontrol eder.
Burada otentikasyon yapılan bilgisayara eri¸simi olan bir saldırgan hala ¸sunu yapabilir;
parola olarak kullanılabilecek cok ¸ miktarda s¨ozcuk¨ ureterek ¨ bunların hash de˘gerlerini
hesaplar ve veri tabanındakilerle kar¸sıla¸stırır. Bu metodla yeterli miktarda surey ¨ e sahip
oldu˘gu taktirde tum¨ olası kelimeleri deneyerek parolalara ula¸sabilir. Bu operasyonu
pratik olarak zorla¸stırmak i¸cin tuzlama (salting) i¸slemi uygulanır. Tuzlama, parolalara
hash fonksiyonundan ge¸cirmeden once ¨ rastgele metin eklemektir. Orne˘ ¨ gin UNIX sistemlerde 12-bit tuzlama uygulanmaktadır. Tuzlama metoduyla otentikasyon i¸slemini onemli ¨
oranda yava¸slatmaksızın bir s¨ozluk¨ saldırısını cok ¸ ciddi bi¸cimde zorla¸stırmak mumk ¨ und ¨ ur. ¨
Ancak her zaman i¸cin kolay tahmin edilebilir parolalar b¨oyle bir saldırıda once ¨ kırılanlar
136
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
olacaktır ve tuzlama onları daha gu¸¨clu¨ hale getirmemektedir.
AC¸ IK ANAHTAR KR˙IPTOGRAF˙I
˙ILE OTENT˙IKASYON
Otentikasyonun cok ¸ uzaktaki bir makina tarafından yapıldı˘gı bir ortam du¨¸sunelim. ¨
Orne˘ ¨ gin bizden birka¸c ulk ¨ e uzaklıkta olan bir internet sitesine kendimizi tanıtmak i¸cin
kullandı˘gımız parolamızın a¸cık bir ¸sekilde onca yolu gitmesi ne kadar sa˘glıklı olabilir?
Bunun i¸cin yukardaki basit otentikaston protokolum¨ uz¨ u¨ a¸cık anahtar sistemli otentikaston kullanacak nasıl de˘gi¸stiririz?
A¸cık anahtar kullanan otentikaston metodunda Biz parola yerine kendi gizli anahtarımızı
bilmekteyiz. Makinada ise bizim a¸cık anahtarımız bulunur. Otentikasyon ¸s¨oyle i¸sler; makina bize rastgele bir metin g¨onderir. Biz de gizli anahtarımızla bu metni ¸sifreler ve makinaya geri g¨ondeririz. Makina, bizim a¸cık anahtarımız ile g¨onderdi˘gimiz mesajı a¸ctı˘gında
kendi g¨onderdi˘gi rastgele metni bulursa bize sistem eri¸simi verir. Bu metodun kullanıldı˘gı
ortamda, ne otentikasyon makinasının (gizli anahtarımız sadece bizde bulunuyor, makina
veritabanında mevcut de˘gil), ne de ileti¸sim yolunun (a¸cık anahtar kriptosisteminin temel
ozelli˘ ¨ ginden dolayı) guv¨ enli olması gerekmemektedir.
SIR PARC¸ALAMA (secret splitting)
Bir bilgiyi iki ki¸si arasında payla¸stırmak istedi˘gimizi du¨¸sunelim. ¨ Oyle ¨ ki; her ikisi de
biraraya gelmeden bilgiye ula¸samasınlar. Payla¸stırılacak olan M mesaji i¸cin aynı bit
uzunlu˘gunda R gibi bir rastgele metin olu¸sturdu˘gumuzu du¨¸sun¨ ursek ¨ M ⊕ R = S ¸seklinde
137
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
bir xorlama operasyonu ile S metini elde etti˘gimizi du¨¸suenlim. ¨ Bu durumda bir ki¸siye R’ı
ve de di˘ger ki¸siye de S’i verdi˘gimizi du¨¸sun¨ ursek ¨ her ikisi de biraraya gelmeden M mesajını
elde edemezler. Biraraya geldiklerinde ise R ⊕ S = M ile mesajı geri d¨onu¨¸sturebilirler. ¨
Bu basit metodu ikiden fazla ki¸side uygulamak i¸cinse bir sırrı 4 ki¸si arasında payla¸stırmak
istedi˘gimizi du¨¸sunelim. ¨ Bu defa sır metni ile yine aynı uzunlukta R,S ve T rastgele
metinlerine ihtiyacımız olacak. M ⊕ R ⊕ S ⊕ T = U ¸seklinde bir operasyonla, R,S,T ve
U metinlerini farklı 4 ki¸siye da˘gıtarak ancak biraraya geldiklerinde tum¨ sahip oldukları 4
metni xorlayarak M’i elde etmelerine izin verebiliriz. Dahası bu 4 ki¸siden birisini safdı¸sı
bırakmak istedi˘gimizde onun metinini di˘gerlerine da˘gıtmamız yeterli olacaktır. Bu sayede
o olmadan da bu xor operasyonunu yaparak ana metne ula¸sabilirler.
SAKLI ˙ILET˙IS¸
˙IM YOLU (subliminal channel)
Birisiyle haberle¸smek istedi˘giniz, ancak bunun 3. bir ba¸ska ki¸si aracılı˘gıyla ger¸cekle¸smesi
dı¸sında mumk ¨ un¨ olmadı˘gını bir senaryo du¨¸sunelim. ¨ Ve bu 3. ki¸si de mesajın ¸sifreli
olmasına izin vermiyor, kendisi mesajınızı iletmeyi ancak o i¸ceri˘gini okuyabildi˘gi zaman kabul ediyor. ˙I¸ste b¨oylesi bir durumda bir saklı ileti¸sim yolu metodu kullanımı
c¨¸ozum¨ olabilir. Yani iletti˘gimiz mesajda gizli bir algoritmayla saklanmı¸s, g¨orunenin ¨
ardındaki ba¸ska bir mesajla hem di˘ger tarafa mesajımızı ula¸stırıp hem de 3. aracı
ki¸sinin yalnızca g¨orun¨ urdeki ¨ mesajı g¨onderdi˘gimizi sanmasına yol a¸carak ger¸cekte ne
g¨onderdi˘gimiz hakkında hi¸c bir fikri olmamasını sa˘glayabiliriz.
138
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
C¸ ok basit bir saklı ileti¸sim yolu metodu olarak, kurdu˘gumuz cumlelerde ¨ tek sayıda kelime
olması durumunda 1-bitini, cift ¸ sayıda kelime i¸ceren cumleler ¨ ile de 0-bitini g¨onderdi˘gimizi
du¨¸sunebiliriz. ¨ Saklı ileti¸sim yoluyla, tıpkı steganografide oldu˘gu gibi herhangi bir anahtar
bulunmamakta ve mesajın gizlili˘gi tamamen algoritmanın gizlili˘gine dayanmaktadır. Saklı
ileti¸sim yollarına cok ¸ ce¸ ¸sitli uygulama alanları bulmak olasıdır. Orne˘ ¨ gin dijital imzalama sırasında saklı ileti¸sim yolu metodları ile mesaji bir taraftan imzalarken di˘ger
taraftan imzanın i¸cine ”ben bu mesajı baskı altında imzalıyorum” gibi bir ifade saklamak mumk ¨ und ¨ ur. ¨
B˙IT VADETME (bit commitment)
S¸oyle ¨ bir senaryo du¨¸sunelim; ¨ Bir yatırımcıya hisse senedi onerece˘ ¨ giz. Yukselecek ¨ olan
hisseleri onerebilirsek, ¨ kar¸sılı˘gında ondan bir i¸s alaca˘gız. Ancak onerdi˘ ¨ gimiz hisse senetlerini hemen bilmesini istemiyoruz, c¸unk ¨ u¨ o zaman bize i¸si vermeden o senetlere kendisi para yatırıp bizi yuz¨ ust ¨ u¨ bırakabilir. Ancak di˘ger taraftan, yatırımcı da bizim
samimiyetimize inanmak istiyor. E˘ger hisse senedi sonu¸cları belli olduktan sonra ona
a¸cıklarsak, sonucu ba¸stan tahmin etti˘gimize dair onu ikna etme ¸sansımız kalmaz. Ozetle ¨
durum ¸su ki; A ki¸sisi, B ki¸sisine, belli bir tarihte belli bir bilgiyi bildi˘gini aradan bir sure ¨
ge¸ctikten sonra ona ispatlamak istiyor, ve kendisi izin verene kadar bilginin ne oldu˘guna
dair B’ye ipucu vermek istemiyor.
B ki¸sisi rastgele bir R metni uretir ¨ ve bunu A’ya g¨onderir. A’nın belli bir grup bit
i¸cerisinden se¸cimini g¨osteren bite ’b’ dersek A ki¸sisi, simetrik bir algoritma kullanarak
139
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
kendi belirledi˘gi bir anahtar ile (R,b) ikisisini ¸sifreler ve geri B’ye g¨onderir. Ve se¸cti˘gi biti
a¸cı˘ga cık ¸ armak istedi˘gi gun¨ geldi˘ginde ise ¸sifrelemede kullandı˘gı anahtarı B’ye vererek
onun paketi a¸cmasını sa˘glar. B ki¸sisi ise kendi ilk ba¸sta g¨onderdi˘gi rastgele R metninin
pakette se¸cim biti ile beraber bulunup bulunmadı˘gını kontrol eder. E˘ger protokolde b¨oyle
bir rastgele R metni olmasaydı, s¨ozkonusu olan yalnızca bir bit olabilece˘gi i¸cin A ki¸sisi son
a¸samada g¨onderdi˘gi paketi rahatlıkla istedi˘gi bite (veya hatta bit grubuna) de¸sifre edebilen bir anahtar g¨onderebilirdi. Ancak paketin i¸cinde fazladan bir rastgele metnin farklı
anahtarlı de¸sifre etmeler i¸cin bozulacak olması A ki¸sisini b¨oylesi bir hileden alıkoyar.
SIFIR-B˙ILG˙I
˙ISPAT METODU (zero-knowledge proof)
Sıfır bilgi ispat, kısaca belli bir bilgiye sahip oldu˘gumuzu, o bilginin ne oldu˘gunu a¸cı˘ga
cık ¸ armadan ispatlamamızı sa˘glayan metodtur. S¸oyle ¨ ki, ispatlayaca˘gımız problemi onunla
e¸syapıda (isomorphic) ba¸ska bir probleme d¨onu¨¸sturerek ¨ problemin kendisi yerine yeni
problemi ispatlıyoruz. Ancak d¨onu¨¸sturd ¨ u˘¨gum¨ uz¨ problemi, oyle ¨ bir ¸sekilde se¸ciyoruz ki bu
yeni problemin c¨¸ozum¨ u¨ orjinal problemin c¨¸ozum¨ u¨ hakkında bilgi vermiyor. Burada orjinal
problem hakkında bilgi vermeyecek s¨ozu¨ ile ifade edilen ¸su ki; hesapsal olarak kar¸sı tarafın
yeni c¨¸ozum¨ u¨ orjinal problemin c¨¸ozum¨ une ¨ d¨onu¨¸sturmesi, ¨ en az orjinal problemin kendisini
c¨¸ozmesi kadar zor olmalıdır. Ancak di˘ger taraftan, bizim aslında c¨¸ozum¨ une ¨ sahip olmadı˘gımız bir probleme e¸syapıdaki bir problem i¸cin c¨¸ozum¨ sahibiymi¸siz gibi davranmamız
olasılı˘gına kar¸sı di˘ger taraf her seferinde bize ¸su soruyu soruyor. ”Ya bu e¸syapıdaki problemin c¨¸ozum¨ un¨ u¨ bana ver, ya da onun asıl probleme e¸s yapıda oldu˘gunu g¨oster”. Ve e˘ger
iddiamızda haklı isek bu iki iste˘gi de ger¸cekle¸stirebiliriz. Ancak bu iki onermeden ¨ birini
140
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
ger¸cekten sa˘glayamıyo olmamız, yani hile yapmamız durumuna yer bırakmamak i¸cinse
bu i¸slemler n kez (kar¸sı taraf ikna oluncaya kadar) tekrarlanır. Oyle ¨ ki, ger¸cekten orjinal
problemin cevabını bilmedi˘gimiz bir durumda her defasında sorulan soruya do˘gru cevabı
verme olasılı˘gımız 1/2 dir. n kez tekrarlanma durumunda ise bu ¸sekilde hile ihtimalimiz
1/n e du¨¸ser ki yeterli tekrardan sonra ihmal edilebilecek bir olasılıktır. Sıfır-bilgi ispat’ın
dayandı˘gı nokta ise bu olasılı˘gın du¨¸sukl ¨ u˘¨gud¨ ur. ¨ Dolayısıyla sıfır-bilgi ispatta yeterli miktarda tekrar i¸cin mutlak manada bir ispattan cok ¸ kar¸sı tarafın iknası s¨oz konusudur.
Sıfır-bilgi ispat metodları ne yazık ki her matematiksel probleme aynı verimde uygulanamamaktadır. Kimi zaman ispat i¸cin c¨¸ozum¨ un¨ bir kısmını a¸cı˘ga cık ¸ armak zorunda
oldu˘gumuz problemler s¨ozkonusudur. Bu yuzden ¨ sıfır bilgi ispat metodları, kar¸sı tarafın
sorusuna ne kadar sıklıkta do˘gru cevap verebilece˘gimiz ol¸ ¨ cus ¨ une ¨ g¨ore kusursuz, istatistiksel, hesapsal ya da kullanı¸ssız gibi kategorilere ayrılmı¸stır.
141
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
æ
UYGULAMALI MATEMAT˙IK ENST˙ITUS¨ U, ¨ Kriptografi B¨olum¨ u¨
ODTU, ¨ TURK ¨ ˙IYE
KR˙IPTOLOJ˙IYE G˙IR˙IS¸ DERS NOTLARI

Kriptolojiye Giri¸s Ders Notları,
Prof. Dr. Ersan Akyıldız
Do¸c. Dr. Ali Do˘ganaksoy
Yrd. Do¸c. Ebru Keyman
Dr. Muhiddin U˘guz
g¨ozetimi altında a¸sa˘gıda adı ge¸cen ki¸siler tarafından hazırlanmı¸stır:
Kadir Altan
Kerem Ka¸skalo˘glu
Nihal Kındap
C¸ i˘gdem Ozakın ¨
Zulf ¨ uk¨ ar Saygı
Elif Yıldırım
Murat Yıldırım
Senay Yıldız
Derleyenler: Ebru Keyman - Murat Yıldırım
2
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
˙IC¸ ˙INDEK˙ILER
1 G˙IR˙IS¸ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
2 BLOK S¸˙IFRELER . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
2.1 Blok S¸ifre Sistemlerinin Parametreleri . . . . . . . . . . . . . . . . . . . . 7
2.1.1 Blok Uzunlu˘gu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
2.1.2 Anahtar ve Ger¸cek Anahtar Uzunlu˘gu . . . . . . . . . . . . . . . . 7
2.2 Blok S¸ifre Sistemlerinin Tasarım Ol¸ ¨ cutleri ¨ . . . . . . . . . . . . . . . . . . 8
2.2.1 Yayılma . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
2.2.2 Nufuz ¨ Etme . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
2.3 D¨ongul ¨ u¨ (Iterated) Blok S¸ifre Sistemleri . . . . . . . . . . . . . . . . . . . 9
2.4 Feistel Yapılar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
3 DES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
3.1 DES Algoritması . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
3.1.1 Ba¸slangı¸c Permutasy ¨ onu . . . . . . . . . . . . . . . . . . . . . . . . 12
3.1.2 Ba¸slangı¸c Permutasy ¨ onun Tersi . . . . . . . . . . . . . . . . . . . . 12
3.1.3 Anahtar Permutasy ¨ onu ve D¨ongu¨ Anahtarının Uretilmesi ¨ . . . . . . 13
3.1.4 f fonksiyonu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
3.2 DES’in Tasarım Ozellikleri ¨ . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
4 RIJNDAEL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
3
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
4.1 Matematiksel Ozellikler ¨ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
4.1.1 Toplama ˙I¸slemi . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
4.1.2 C¸ arpma ˙I¸slemi . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
4.2 Algoritma . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
4.2.1 Byte Sub . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
4.2.2 Shift Row . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
4.2.3 Mix Column . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
4.2.4 Anahtarla XOR’lama . . . . . . . . . . . . . . . . . . . . . . . . . . 27
4.3 Anahtar Algoritması . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.4 ALGOR˙ITMANIN TERS˙I . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
4.4.1 Mix Column . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
4.4.2 Byte Sub . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
5 AKAN S¸˙IFRELER. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
5.1 One Time Pad Sistemi . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
5.1.1 Sistemin Avantajları . . . . . . . . . . . . . . . . . . . . . . . . . . 33
5.1.2 Sistemin Dezavantajları . . . . . . . . . . . . . . . . . . . . . . . . 33
5.2 Dizi Ureticiler ¨ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
5.3 Geri Beslemeli KaydırmalıYazdırga¸c (Feedback Shift Register) . . . . . . . 37
5.4 Uretecinin ¨ Sahip Olması Gereken Ozellikler ¨ . . . . . . . . . . . . . . . . . 41
5.4.1 ˙Istatistiksel Ozellikler ¨ . . . . . . . . . . . . . . . . . . . . . . . . . . 41
5.5 Do˘grusal Geri Beslemeli KaydırmalıYazdırga¸c (LFSR) . . . . . . . . . . . . 44
5.5.1 Dizinin Periyodu . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
5.6 Do˘grusal Karma¸sıklık (Linear Complexity) . . . . . . . . . . . . . . . . . . 49
4
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
5.6.1 Do˘grusal Karma¸sıklık Profili (Linear Complexity Profile) . . . . . . 50
5.6.2 Berleckamp Massey Algoritması . . . . . . . . . . . . . . . . . . . . 51
5.7 LFSR Kullanılarak Yapılan Akan S¸ifre Sistemleri . . . . . . . . . . . . . . 52
6 SAYILAR TEOR˙IS˙I . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
6.1 Tamsayılar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
6.1.1 B¨olunebilirlik: ¨ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
6.1.2 B¨olunebilirlik ¨ Ozellikleri ¨ . . . . . . . . . . . . . . . . . . . . . . . . 58
6.1.3 Tamsayılar i¸cin B¨olum¨ Algoritması: . . . . . . . . . . . . . . . . . . 59
6.1.4 En Buy¨ uk¨ Ortak B¨olen (Greatest Common Divisor) . . . . . . . . . 59
6.1.5 En Ku¸¨cuk¨ Ortak Kat (Least common Multiple) . . . . . . . . . . . 60
6.1.6 Asal Sayı . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
6.1.7 Aralarında Asal Sayı . . . . . . . . . . . . . . . . . . . . . . . . . . 61
6.1.8 Aritmeti˘gin Esas Teoremi . . . . . . . . . . . . . . . . . . . . . . . 61
6.1.9 Oklid ¨ Algoritması(Euclidean Algorithm) . . . . . . . . . . . . . . . 61
6.2 Asal Sayılar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
6.2.1 Eratosthenes Kalburu(The Sieve of Eratosthenes) . . . . . . . . . . 64
6.3 Eratosthenes Metodu (Method of Eratosthenes) . . . . . . . . . . . . . . . 65
6.4 Denklik Teorisi(Theory of Congruence (Modularity)) . . . . . . . . . . . . 66
6.4.1 Teoremler: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
6.4.2 Aritmetik Tersi . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67
6.5 Euler Fi(φ) Fonksiyonu (Euler Phi Function) . . . . . . . . . . . . . . . . . 68
7 AC¸ IK ANAHTARLI S˙ISTEMLER . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
5
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
7.1 MERKLE-HELLMAN KNAPSACK
KR˙IPTOS˙ISTEM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
7.1.1 Sup¨ erartan dizi (Superincreasing sequence) . . . . . . . . . . . . . . 71
7.1.2 Sup¨ erartan Altkume ¨ Toplama Problemini c¨¸ozme Algoritması . . . . 71
7.1.3 Merkle-HellmanKnapsack S¸ifrelemesinde Anahtar Olu¸sturma Algoritması . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
7.1.4 Basit Merkle-Hellman Knapsack A¸cık Anahtar S¸ifreleme Algoritması 73
7.2 RSA Kriptosistem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75
7.3 RSA ˙Imza S¸eması . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
7.3.1 ˙Imzalama . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
7.3.2 ˙Imzayı Do˘grulama . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
7.4 Ayrık Logaritma(Discrete Logarithm) . . . . . . . . . . . . . . . . . . . . . 81
7.5 El-Gamal A¸cık Anahtarlı Kriptosistem . . . . . . . . . . . . . . . . . . . . 81
7.6 ElGamal A¸cık Anahtarlı S¸ifrelemede Anahtar Olu¸sturma Algoritması . . . 82
7.6.1 ElGamal A¸cık Anahtarlı S¸ifreleme
Algoritması . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82
7.6.2 ElGamal ˙Imzası . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
7.6.3 ˙Imza Algoritması . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
7.6.4 Do˘grulama . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
7.7 Diffie-Hellman Anahtar Anl¸sması (Diffie-Hellman Key Agreement) . . . . . 86
7.7.1 Diffie-Hellman Anahtar Anla¸sması Algoritması: . . . . . . . . . . . 86
8 KR˙IPTANAL˙IZ. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
8.1 Kriptanalitik Atakların Ama¸cları . . . . . . . . . . . . . . . . . . . . . . . 90
8.2 Kriptanaliz Metodları(Methods of Cryptanalysis) . . . . . . . . . . . . . . 91
6
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
8.3 Akan S¸ifrelerin Analizi . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
8.4 Blok S¸ifrelerin Analizi . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97
8.4.1 Difransiyel Kriptanaliz . . . . . . . . . . . . . . . . . . . . . . . . . 97
8.4.2 Do˘grusal Kriptanaliz . . . . . . . . . . . . . . . . . . . . . . . . . . 105
9 HASH FONKS˙IYONLARI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108
10 TEST YONTEMLER ¨ ˙I . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
11 KR˙IPTOGRAF˙IK PROTOKOLLER . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
7
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
BOL¨ UM¨ 1
G˙IR˙IS¸
S¸ifre sistemleri a¸cık anahtarlı ve gizli anahtarlı (simetrik) olmak uzere ¨ ikiye ayrılır. A¸cık
anahtarlı sistemlerde her ki¸si, biri a¸cık di˘geri gizli olmak uzere ¨ bir cift ¸ anahtar edinir. A¸cık
anahtar di˘ger kullanıcıların eri¸simine a¸cıkken; gizli anahtar sadece sahibinin eri¸sebilece˘gi
¸sekilde saklanmalıdır. A¸cık anahtarı kullanarak herhangi bir ki¸si ¸sifreli mesaj g¨onderebilir,
ancak g¨onderilen ¸sifreli mesajı sadece kullanılan a¸cık anahtarın e¸si olan gizli anahtar
a¸cabilir. A¸cık anahtarlı ¸sifre sistemleri sadece ¸sifreli mesaj g¨ondermek amacıyla de˘gil,
kimlik denetimi yani sayısal imza ve daha bir¸cok teknik i¸cin kullanılır. A¸cık anahtarlı
sistemlerde, her zaman gizli anahtarın a¸cık anahtarla matematiksel bir ba˘gıntısı vardır.
Bu anahtarları olu¸sturmak i¸cin c¨¸ozulememi ¨ ¸s matematik problemleri kullanıldı˘gından, a¸cık
anahtarı kullananarak gizli anahtarı elde etme i¸slemi de imkansız kabul edilir.
Ornek ¨ 1.0.1 A, B kullanıcılar, KA, KB kullanıcıların a¸cık anahtarları ve K0
A, K0
B kullanıcıların gizli anahtarları olsun. Her bir kullanıcı di˘gerlerinin a¸cık anahtarını bilir. B
kullanıcısı A kullanıcısına bir mesajı g¨ondermek i¸cin mesajı KA ile ¸sifreleyip g¨onderir, A
kullanıcısı ¸sifrelenmi¸s mesajı K0
A ile de¸sifre eder.
A¸cık anahtarlı sistemleri ayrıntılı olarak ilerki konularda o˘¨grenece˘giz. Oncelikle ¨ gizli
anahtarlı yani simetrik sistemlerden bahsedelim. Simetrik sistemlerde tek bir anahtar,
hem ¸sifreleme hem de de¸sifre amacıyla kullanılır. Guv¨ enli bir ¸sekilde ileti¸sim kur1
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
madan once ¨ g¨onderici ile alıcının gizli anahtar olarak adlandırılan bir anahtar uzerinde ¨
uzla¸smaları gerekir.
Simetrik sistemlerde temel problem, g¨ondericinin ve alıcının u¸¨cunc ¨ u¨ bir ki¸sinin eline
ge¸cmesini engelleyerek ortak bir anahtar uzerinde ¨ anla¸smalarıdır. Ancak simetrik sistemlerin avantajı da, a¸cık anahtarlı sistemlere g¨ore daha hızlı olmalarıdır.
Bir sistemin guv¨ enli˘gi anahtarda yatar. S¸ifre c¨¸ozmeye y¨onelik ataklar anahtarı bulmaya
y¨oneliktir. Kriptanalist sahip oldu˘gu on¨ bilgiye g¨ore farklı saldırı ce¸ ¸sitleri uygular. Bunlar:
Sadece S¸ifreli Metin Saldırısı : Kriptanalist, aynı ¸sifreleme algoritması kullanılarak
¸sifrelenmi¸s ce¸ ¸sitli a¸cık metinlerin ¸sifreli metinlerine sahiptir. Kriptanalist mumk ¨ un¨
oldu˘gunca cok ¸ sayıdaki ¸sifreli metinin a¸cık metnini bulmaya calı ¸ ¸sır. Asıl onemli ¨ olan
ise a¸cık metinleri ¸sifrelemek i¸cin kullanılan anahtarı ya da anahtarları, aynı anahtarla
¸sifrelenen ba¸ska mesajları c¨¸ozmek i¸cin bulmaktır.
Bilinen A¸cık Metin Saldırısı : Kriptanalist sadece ce¸ ¸sitli a¸cık metinlerin ¸sifrelenmi¸s
haline de˘gil, bu mesajların a¸cık metinlerine de eri¸sebilmektedir.
Se¸cilmi¸s A¸cık Metin Saldırısı : Kriptanalist sadece ce¸ ¸sitli a¸cık metinlerin ¸sifreli
metinlerine ve bunlarla ili¸skilendirilmi¸s a¸cık metinlere eri¸smekle kalmayıp, aynı zamanda
da ¸sifrelenmi¸s a¸cık metinleri se¸cebilmektedir. Bu atak bilinen a¸cık metin ata˘gından daha
gu¸¨clu¨ bir ataktır. C¸unk ¨ u¨ kriptanalist ¸sifrelemek i¸cin a¸cık metinin belirli bloklarını yani
anahtar hakkında daha fazla bilgi sa˘glayabilecek olanları se¸cebilmektedir.
Simetrik sistemler Blok S¸ifre Sistemleri ve Akan S¸ifre Sistemleri olarak ikiye ayrılır.
2
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
BOL¨ UM¨ 2
BLOK S¸˙IFRELER
Blok ¸sifrelemenin en basit tanımı, a¸cık metni biti¸sik bloklara b¨olme, her blo˘gu ¸sifreleyerek
¸sifreli metin bloklarına d¨onu¨¸sturme, ¨ bu ¸sifreli blokları ¸sifreli metin cıkı ¸ ¸sı olarak gruplamaktır. Blok ¸sifre sistemini ¸sekille g¨ostermek istersek, M1, M2, . . . , Mn a¸cık metnin blokları, yani her biri k bitten olu¸san ardı¸sık par¸caları, C1, C2, . . . ,Cn bu bloklara kar¸sılık gelen ¸sifrelenmi¸s metinler ve E ¸sifreleme i¸slemi olmak uzere, ¨ blok ¸sifre sistemlerini a¸sa˘gıdaki
¸semayla g¨osterebiliriz.
Blok ¸sifre Sistemlerinde ¸sifreleme
C¸ o˘gu blok ¸sifre sistemlerinde blok uzunlu˘gu 64 bittir. ˙I¸slemcilerin hızı arttık¸ca blok
uzunlu˘gu da artabilmektedir. Son yıllarda uretilen ¨ sistemler 128 bit blok uzunlu˘gu kullanılmaya ba¸slanmı¸stır.
3
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Bir blok ¸sifre sisteminde, ¸sifreli metin bloklarından birinin kaybolması, di˘ger blokların
de¸sifre i¸sleminde bir yanlı¸slı˘ga neden olmaz. Bu blok ¸sifre sistemlerinin en buy¨ uk¨ avantajıdır. Blok ¸sifre sistemlerinin en buy¨ uk¨ dezavantajı ise ¸sifreli metindeki birbirinin aynısı
olan blokların, a¸cık metinde de birbirinin aynı olmasıdır.
Ornek ¨ 2.0.2 ”Senay’a kitabı sen ver” cumlesini, ¨ blok uzunlu˘gu 3 olacak ¸sekilde b¨olup¨
¸sifrelersek,
A¸cık Metin: sen-aya-kit-abı-sen-ver
S¸ifreli Metin: axk-bcg-xkt-ase-axk-hyt
birinci ve be¸sinci blokların aynı ¸sekilde ¸sifrelendi˘gini g¨oruy¨ oruz.
B¨oyle bir sorunun ustesinden ¨ gelmek i¸cin ¸sifreleme i¸slemini de˘gi¸sik modellerle yapabiliriz. Mi−1, Mi
, Mi+1 a¸cık metnin ardı¸sık 3 blo˘gu, E ¸sifreleme i¸slemi, Ci−1,Ci
,Ci+1
Mi−1, Mi
, Mi+1 ardı¸sık bloklarının ¸sifreli halleri olsun.
1. Elektronik Kod Modeli (Electronic Code Mode)
4
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Elektronik Kod Modeli
Ornekteki ¨ gibi i¸sler.
2. Kapalı Metin Zincirleme Modeli (Cipher Block Chaining Mode)
Kapalı Metin Zincirleme Modeli
5
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Aslında bu modelde yaptı˘gımız i¸slemleri, buy¨ uk¨ bloklar uzerinde ¨ akan ¸sifre sistemini
uygulamak olarak g¨orebiliriz.
3. C¸ ıktıyı Geribesleme Modeli (Output Feedback Mode)
C¸ ıktıyı Geribesleme Modeli
4. Girdiyi Geribesleme Modeli (Input Feedback Mode)
Girdiyi Geribesleme Modeli
Bir blok ¸sifre sisteminin matematiksel olarak ¸s¨oyle tanımlayabiliriz. Z2 = {0 1}, Z
n
2 =
Z2×. . .×Z2 = {(xn−1, . . . , x0) : xi ∈ Z2} ve K ise anahtar uzayı olsun. E : Z
n
2 ×K → Z
n
2
6
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
ve her k ∈ K i¸cin E (p, k) tersi alınabilir bir fonksiyondur. Bu fonksiyona ¸sifreleme
fonksiyonu denir. Blok ¸sifre sistemi ile ¸sifrelenen bir mesajı de¸sifre ederken aynı sistemi
¸sifreli mesaja aynı anahtar ile uygulamak gerekir. Bunun i¸cin ¸sifreleme i¸sleminin tersinin
olması gerekir. S¸ifreleme fonksiyonunun tersine de de¸sifreleme fonksiyonu denir ve D (c, k)
ile g¨osterilir.
2.1 Blok S¸ifre Sistemlerinin Parametreleri
2.1.1 Blok Uzunlu˘gu
Bir blok ¸sifre sisteminin guv¨ enli olabilmesi i¸cin, blok uzunlu˘gunun bazı blokların
di˘gerlerinden daha fazla g¨orunmey ¨ ece˘gi ¸sekilde uzun olması gerekir. Orne˘ ¨ gin bir blok
¸sifreleme sistemi olan DES’teki 64 bit uzunluk, sıklık analizine kar¸sı DES’i gu¸¨clu¨
kılmaktadır. Aynı zamanda blok uzunlu˘gu n olan bir blok i¸cin, sabit bir anahtarla saldırı
yapan ki¸sinin elde edebilece˘gi a¸cık metin-¸sifreli metin ciftlerinin ¸ sayısı buy¨ uk¨ olmalıdır
(bu sayı 2
n yi ge¸cemez). Blok uzunlu˘gu buy¨ ud¨ uk¸ ¨ ce sistemin uygulaması da daha karı¸sık
hale gelmektedir.
2.1.2 Anahtar ve Ger¸cek Anahtar Uzunlu˘gu
Bir blok ¸sifre sisteminin anahtarı deneme-yanılma (exhaustive key search) ile bulunamamalıdır. Bunun i¸cin de anahtar uzun olmalıdır. Di˘ger taraftan da anahtar uzunlu˘gu
uretim, ¨ da˘gıtım ve saklama i¸cin uygun ve guv¨ enilir olmalıdır. Orne˘ ¨ gin DES her zaman anahtar uzunlu˘gunun kısa olmasından dolayı ele¸stirilmi¸stir. Diffie ve Hellman
7
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
DES’in anahtar deneme-yanılma yolu ile 20 milyon dolara mal olacak bir sistemle 12
saatte kırılabilece˘gini one ¨ surd ¨ uler. ¨ Gelen oneriler ¨ do˘grultusunda, DES’in ger¸cek anahtar
uzunlu˘gu 128 bite cık ¸ arıldı ve u¸¨clu¨ ¸sifreleme ile DES daha guv¨ enli bir ¸sekilde kullanılabilir
hale getirildi.
2.2 Blok S¸ifre Sistemlerinin Tasarım Ol¸ ¨ cutleri ¨
Guv¨ enli bir blok ¸sifre sisteminin kırılması zor ama uygulaması kolay olmalıdır. S¸ifreleme
ve de¸sifreleme fonksiyonlarının kolay uygulanabilir olması gerekirken, C = E(P, k) ve
P = D(C, k) e¸sitliklerinden k yı bulmanın zor olması gerekir. ilk defa Claude Shannon
tarafından onerilen ¨ tasarım ol¸ ¨ cutleri ¨ yayılma (confusion) ve nufuz ¨ etme (diffusion)dir.
2.2.1 Yayılma
Bir blok ¸sifre sistemini ya da genel olarak bir ¸sifreleme sistemini yayılma ol¸ ¨ cut ¨ une ¨ g¨ore
tasarlamak demek, ¸sifreli metinle anahtar arasındaki ili¸skiyi mumk ¨ un¨ oldu˘gunca karı¸sık
yapmaktır. Daha a¸cık bir tanım verirsek, yayılma, anahtarın a¸cık ve ¸sifreli metne
ba˘glılı˘gının kriptanaliz i¸cin faydalı olmayacak kadar karı¸sık olması demektir. Yani blok
¸sifre sistemini tanımlayan e¸sitliklerin do˘grusal olmaması ve karı¸sık olması ve b¨oylece
C = E(P, k) denkleminden anahtarı bulmanın imkansız olması gerekir.
8
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
2.2.2 Nufuz ¨ Etme
Bu ol¸ ¨ cute ¨ g¨ore her anahtar i¸cin ¸sifreleme fonksiyonu oyle ¨ olmalı ki, a¸cık metin ve ¸sifreli
metin arasındaki yapılar arasında istatiksel ba˘glılık olmamalıdır. Bu ol¸ ¨ cut ¨ un¨ olabilmesi
i¸cin anahtarın ve a¸cık metinin her bitinin ¸sifreli metini etkilemesi gerekir.
2.3 D¨ongul ¨ u¨ (Iterated) Blok S¸ifre Sistemleri
Aynı fonksiyonu belli d¨onguler ¨ i¸cinde uygulayan sistemlere d¨ongul ¨ u¨ blok ¸sifre sistemleri
denir.
D¨ongul ¨ u¨ (Iterated) Blok S¸ifre Sistemleri
Fonksiyonun ilk kullanım hari¸c girdisi; bir onceki ¨ d¨ongun¨ un¨ cıktısıdı ¸ ve anahtar ureten ¨ algoritmadan elde edilen d¨ongu¨ anahtarıdır. Orne˘ ¨ gin DES’te 16 d¨ongu¨ vardır. Algoritmada
9
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
kullanılan f fonsiyonu basit bir fonksiyon olursa uygulamada bize hız y¨onunden ¨ kolaylık
sa˘glar. D¨ongu¨ sayısı uygun ¸sekilde se¸cilirse, sistemde gereken yayılma ve nufuz ¨ etme
sa?lanır. Bu tur ¨ sistemlerde d¨ongu¨ sayısı, sistem tasarlandıktan sonra belli saldırılara
kar¸sı dayanıklılı˘gı hesaplanarak belirlenmektedir.
2.4 Feistel Yapılar
Horst Feistel tarafından ilk defa tasarlanan sistem gun¨ um¨ uzde ¨ bir¸cok modern sistemde
kullanılmaktadır.
k1, k2, . . . , kn: D¨ongu¨ Anahtarları olmak ko¸suluyla , Feistel yapılarını a¸sa˘gıdaki gibi
g¨osterebiliriz.
Feistel Yapısı
S¸ifreleme yapılırken L blo˘gu uzerine, ¨ de¸sifreleme yapılırken R blo˘gu uzerine ¨ i¸slem
yapılmaktadır. Ancak de¸sifreleme i¸sleminde d¨ongu¨ anahtarları, ters sırada kullanılmaktadır.
10
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
BOL¨ UM¨ 3
DES
3.1 DES Algoritması
DES (Data Encryption Standard) algoritması, 1970 yılında IBM tarafından geli¸stirilen
Lucifer algoritmasının biraz daha geli¸stirilmi¸s halidir. 1974’te IBM’in NSA ile birlikte
geli¸stirdi˘gi algoritma olan DES’in yayınlanmasından itibaren DES algoritması uzerinde ¨
geni¸s ol¸ ¨ cude ¨ calı ¸ ¸smalar yapılmı¸stır.
˙Ilk tasarladı˘gında donanım uygulamalarında kullanılması ama¸clanmı¸stır. ˙Ileti¸sim ama¸clı
kullanımda hem g¨onderen, hem de alıcı ¸sifreleme ve de¸sifrelemede kullanılan aynı gizli
anahtar uzerinde ¨ anla¸smı¸s olmalıdır. Gizli anahtarın guv¨ enli bir bi¸cimde da˘gıtımı i¸cin a¸cık
anahtarlı sistem kullanılabilir. DES aynı zamanda sabit diskte veri saklamak gibi tek kullanıcılı ¸sifreleme ama¸clı da kullanılabilir. DES’in en buy¨ uk¨ zayıflı˘gı 56 bitlik anahtarıdır.
Geli¸stirildi˘gi zamanlarda cok ¸ iyi bir ¸sifreleme algoritması olmasına ra˘gmen modern bilgisayarlar tarafından yapılan anahtar saldırılarına kar¸sı yetersiz kalmı¸stır. DES’in di˘ger
bir zayıflı˘gı da yava¸s olmasıdır.
DES algoritması Feistel yapısındadır. DES’i 16 d¨onguden ¨ olu¸san bir d¨onguy¨ e benzetebiliriz. ˙Ilk d¨onguy¨ e girmeden once ¨ ba¸slangı¸c permutasy ¨ onu ve son d¨onguden ¨ sonra
da ba¸slangı¸c permutasy ¨ onunun tersi uygulanır. DES algoritmasını a¸sa˘gıdaki ¸sekilde
g¨osterilebilir.
11
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
DES Algoritması
Her d¨ongu¨ bir onceki ¨ d¨onguden ¨ gelen mesajı ikiye ayırır: Li ve Ri
,i = 1, 2, . . . , 16. ˙I¸slemler
Ri uzerinde ¨ yapılır. Her d¨ongu¨ i¸cin anahtardan d¨ongu¨ anahtarları uretilir. ¨ De¸sifreleme
i¸sleminde de aynı algoritma kullanılır. Ancak anahtarların kullanım sırası tersten olur.
S¸imdi algoritmanın bile¸senlerinin tek tek inceleyelim.
3.1.1 Ba¸slangı¸c Permutasy ¨ onu
Ba¸slangı¸c permutasy ¨ onu DES’e hi¸cbir kuvvet katmamaktadır.Ba¸slangı¸c permutasy ¨ onunu
a¸sa˘gıda verilmi¸stir.
58 50 42 34 26 18 10 02 60 52 44 36 28 20 12 04
62 54 46 38 30 22 14 06 64 56 48 40 32 24 16 08
57 49 41 33 25 17 09 01 59 51 43 35 27 19 11 03
61 53 45 37 29 21 13 05 63 55 47 39 31 23 15 07
G¨oruld ¨ u˘¨gu¨ uzere, ¨ ba¸slangı¸c permutasy ¨ onunda 58. bit 1. bit yerine, 50.bit 2. bit yerine,. . . gelmektedir.
3.1.2 Ba¸slangı¸c Permutasy ¨ onun Tersi
Ba¸slangı¸c permutasy ¨ onunun tersi olan permutasy ¨ on son rounddan sonra uygulanır.Bu
permutasy ¨ on a¸sa˘gıda verilmi¸stir.
40 08 48 16 56 24 64 32 39 07 47 15 55 23 63 31
12
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
38 06 46 14 54 22 62 30 37 05 45 13 53 21 61 29
36 04 44 12 52 20 60 28 35 03 43 11 51 19 59 27
34 02 42 10 50 18 58 26 33 01 41 09 49 17 57 25
3.1.3 Anahtar Permutasy ¨ onu ve D¨ongu¨ Anahtarının Uretilmesi ¨
Anahtar uzerine ¨ ilk i¸slem 64 bitten 56 bite indirgemektir.Bunun i¸cin her 8. bit
do˘gruluk kontrolu(parit ¨ y check)i¸cin atılır. Daha sonra 56 bitlik anahtar a¸sa˘gıda verilen
permutasy ¨ ona girer.
57 49 41 33 25 17 09
01 58 50 42 34 26 18
10 02 59 51 43 35 27
19 11 03 60 52 44 36
63 55 47 39 31 23 15
07 62 54 46 38 30 22
14 06 61 53 45 37 29
21 13 05 28 20 12 04
Bu permutasy ¨ ondan sonra 56 bitlik anahtar 28 bitlik sa˘g ve sol olmak uzere ¨ iki par¸caya
ayrılır. D¨ondurme(rotation) ¨ olarak adlandırdı˘gımız kısımda, 28 bitlik par¸calar her d¨ongu¨
i¸cin 1 yada 2 bit sola kayar.Bu kaydırma d¨ondurme ¨ olarak adlandırılır c¸unk ¨ u¨ kayan bitler
sona eklenir.
D¨ongu¨ 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16
Kayma Miktarı 1 1 2 2 2 2 2 2 1 2 2 2 2 2 2 1
13
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Daha sonra anahtarı d¨onguy¨ e g¨ondermeden once ¨ tekrar bir permutasy ¨ on ger¸cekle¸sir. Bu
permutasy ¨ on sonucu 56 bit 48 bite iner. Bu permutasy ¨ on a¸sa˘gıda verilmi¸stir.
14 17 11 24 01 05
03 28 15 06 21 10
23 19 12 04 26 08
16 07 27 20 13 02
41 52 31 37 47 55
30 40 51 45 33 48
44 49 39 56 34 53
46 42 50 36 29 32
3.1.4 f fonksiyonu
Onceden ¨ de bahsedildi˘gi uzere ¨ her d¨ongude ¨ sa˘g 32 bitlik kısım (Ri) uzerine ¨ i¸slemler yapılır.
Oncelikle ¨ bu 32 bitlik kısım a¸sa˘gıdaki gibi 48 bite geni¸sletilir.
32 01 02 03 04 05 04 05 06 07 08 09
08 09 10 11 12 13 12 13 14 15 16 17
16 17 18 19 20 21 20 21 22 23 24 25
24 25 26 27 28 29 28 29 30 31 32 01
48 bitlik bu kısım d¨ongu¨ anahtarı ile x-or i¸slemine (⊕) g¨onderilir. Sonra 48 bit, 6 bitlik
8 gruba b¨olun¨ ur ¨ ve her bir grup ayrı bir S-kutusuna g¨onderilir. S-kutularında 6 bitler 4
bite cevrilir. ¸ 8 S-kutusu a¸sa˘gıda verilmi¸stir.
14
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
1. S-kutusu
00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15
0 14 04 13 01 02 15 11 08 03 10 06 12 05 09 00 07
1 00 15 07 04 14 02 13 01 10 06 12 11 09 05 03 08
2 04 01 14 08 13 06 02 11 15 12 09 07 03 10 05 00
3 15 12 08 02 04 09 01 07 05 11 03 14 10 00 06 13
Ornek ¨ 3.1.1 girdi = 101110 satır = 10(ilk ve son bitler) = 2 , sutun ¨ = 0111(ortada
kalan bitler) = 7 cıktı ¸ = 11 (onbir) = 1011
2. S-kutusu
00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15
0 15 01 08 14 06 11 03 04 09 07 02 13 12 00 05 10
1 03 13 04 07 15 02 08 14 12 00 01 10 06 09 11 05
2 00 14 07 11 10 04 13 01 05 08 12 06 09 03 02 15
3 13 08 10 01 03 15 04 02 11 06 07 12 00 05 14 09
3. S-kutusu
00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15
0 10 00 09 14 06 03 15 05 01 13 12 07 11 04 02 08
1 13 07 00 09 03 04 06 10 02 08 05 14 12 11 15 01
2 13 06 04 09 08 15 03 00 11 01 02 12 05 10 14 07
3 01 10 13 00 06 09 08 07 04 15 14 03 11 05 02 12
4. S-kutusu
00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15
0 07 13 14 03 00 06 09 10 01 02 08 05 11 12 04 15
1 13 08 11 05 06 15 00 03 04 07 02 12 01 10 14 09
2 10 06 09 00 12 11 07 13 15 01 03 14 05 02 08 04
3 03 15 00 06 10 01 13 08 09 04 05 11 12 07 02 14
5. S-kutusu
15
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15
0 02 12 04 01 07 10 11 06 08 05 03 15 13 00 14 09
1 14 11 02 12 04 07 13 01 05 00 15 10 03 09 08 06
2 04 02 01 11 10 13 07 08 15 09 12 05 06 03 00 14
3 11 08 12 07 01 14 02 13 06 15 00 09 10 04 05 03
6. S-kutusu
00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15
0 12 01 10 15 09 02 06 08 00 13 03 04 14 07 05 11
1 10 15 04 02 07 12 09 05 06 01 13 14 00 11 03 08
2 09 14 15 05 02 08 12 03 07 00 04 10 01 13 11 06
3 04 03 02 12 09 05 15 10 11 14 01 07 06 00 08 13
7. S-kutusu
00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15
0 04 11 02 14 15 00 08 13 03 12 09 07 05 10 06 01
1 13 00 11 07 04 09 01 10 14 03 05 12 02 15 08 06
2 01 04 11 13 12 03 07 14 10 15 06 08 00 05 09 02
3 06 11 13 08 01 04 10 07 09 05 00 15 14 02 03 12
8. S-kutusu
00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15
0 13 02 08 04 06 15 11 01 10 09 03 14 05 00 12 07
1 01 15 13 08 10 03 07 04 12 05 06 11 00 14 09 02
2 07 11 04 01 09 12 14 02 00 06 10 13 15 03 05 08
3 02 01 14 07 04 10 08 13 15 12 09 00 03 05 06 11
S-kutuları blok ¸sifrelerin do˘grusal olmayan kısımlarıdır. Hi¸cbir S-kutusu girdinin do˘grusal
yada afin fonksiyonu de˘gildir.
S-kutularından cık ¸ an 4 bitlik par¸calar yanyana gelerek birle¸sir ve a¸sa˘gıdaki permutasy ¨ ona
gider.
16 07 20 21
29 12 28 17
16
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
01 15 23 26
05 18 31 10
02 08 24 14
32 27 03 09
19 13 30 06
22 11 04 25
Permutasy ¨ ondan cık ¸ an 32 bitlik kısım d¨ongun¨ un¨ ba¸saında ayrılan 32 bitlik kısımla XOR
i¸slemi uygulanır.
3.2 DES’in Tasarım Ozellikleri ¨
DES’in en onemli ¨ ozelli˘ ¨ gi yayılma(confusion) ve nufuz ¨ etme(diffusion)¨ozellikleridir.
DES’te her blo˘gun her biti di˘ger bitlere ve anahtarın her bitine ba˘gımlıdır. Bunun iki
amacı vardır:Oncelikle, ¨ anahtar uzerindeki ¨ bilinmezlik(uncertanity)artmaktadır. ˙Ikinci
olaraksa, a¸cık metindeki veya anahtardaki 1 bitin de˘gi¸smesi but ¨ un¨ ¸sifreli metinin
de˘gi¸smesine sebep olur ki bu bizim ileride o˘¨grenece˘gimiz diffrensiyel kriptanalizde i¸se
yaramaktadır.
17
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
18
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
BOL¨ UM¨ 4
RIJNDAEL
4.1 Matematiksel Ozellikler ¨
8 bitten olu¸san bir byte 16’lık tabanda yazılabildi˘gi gibi polinom olarak ifade ediliyor. ˙Iki
byte’ı toplamak, carpmak ¸ ve bir byte’ın tersini almak polinomlarca ifade edilecektir.Buna
g¨ore bir b = (b7 b6 b5 b4 b3 b2 b1 b0) bytının polinom g¨osterimi:
p(a) = b7x
7 + b6x
6 + b5x
5 + b4x
4 + b3x
3 + b2x
2 + b1x + b0
Bir byte’ın de˘geri 10’luk tabanda kendisine kar¸sılık gelen sayıdır.
Ornek ¨ 4.1.1 (53)16 byte’ının de˘geri: (53)16 = ‘53‘ = 3 + 5.16 = 83
B˙It olarak ifadesi yani ikilik duzende: ¨ 83 = (0 1 0 1 0 1 1 1)
pa(x) = x
6 + x
4 + x
2 + x + 1
4.1.1 Toplama ˙I¸slemi
Byte’ların polinomlarını modulo 2’de toplamaktır. Bu i¸slem aynı zamanda iki byte’ı
XOR’lamaya da denktir.
19
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Ornek ¨ 4.1.2
a = (1 0 0 1 1 0 1 0) ⇒ pa(x) = x
7 + x
4 + x
3 + x
b = (1 0 1 0 1 0 1 1) ⇒ pb(x) = x
7 + x
5 + x
3 + x + 1
pa(x) + pb(x) = x
7 + x
4 + x
3 + x + x
7 + x
5 + x
3 + x + 1 mod 2
= x
5 + x
4 + 1 ⇒ (0 0 1 1 0 0 0 1)
a ⊕ b = (0 0 1 1 0 0 0 1)
4.1.2 C¸ arpma ˙I¸slemi
1. ˙Iki Byte’ı C¸ arpma:
carpma ¸ i¸sleminde, iki byte polinom olarak ifade edilir. ˙Iki polinom carpılır, ¸
carpma ¸ i¸slemi mod m(x) = x
8 + x
4 + x
3 + x + 1 de yapılır. m(x) modulo 2’de
carpanlarına ¸ ayrılamayan bir polinomdur. Modulo 2’de carpanlarına ¸ ayrılamamak
demek katsayıları 1 veya 0 olan polinomların carpımı ¸ ¸seklinde yazılamamak demektir. Bir polinomun modulo m(x)’deki de˘geri polinomun m(x)’e b¨olum¨ unden ¨ kalana
denktir.
Bir polinomun m(x)’e b¨olum¨ unden ¨ kalanı bulmak i¸cin polinomda x
8+x
4+x
3+x+1
g¨orulen ¨ yere 0 koymaktır. Bu aynı zamanda x
8 g¨orulen ¨ yere x
4+x
3+x+1 koymakla
aynıdır.
Bir byte’ın polinom g¨osteriminde en fazla yedinci dereceden bir terim olaca˘gından
iki byte’ın carpımının ¸ yine bir byte olabilmesi polinom ifadesinde derecesi sekiz ve
sekizden buy¨ uk¨ terimlerin yok edilmesi gerekiyor. Bu nedenle carpma ¸ i¸slemi modulo
20
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
2’de carpanlarına ¸ ayrılamamyan bir polinom olan mod m(x) de yapılıyor
Not: Bu i¸slem i¸cin derecesi 8 olan ve modulo 2’de carpanlarına ¸ ayrılamamyan ba¸ska
bir polinom da se¸cilebilirdi.
Kısaca:
a → pa(x)
b → pb(x)
(a).(b) = pa(x).pb(x) mod m(x)
Ornek ¨ 4.1.3
a = (0 1 0 1 0 1 0 1) ⇒ pa(x) = x
6 + x
4 + x
2 + 1
b = (1 0 0 0 0 0 1 1) ⇒ pb(x) = x
7 + x + 1
21
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
(a).(b) = pa(x).pb(x) mod m(x) = x
8 + x
4 + x
3 + x + 1
= (x
6 + x
4 + x
2 + 1)(x
7 + x + 1)
= x
13 + x
7 + x
6 + x
11 + x
5 + x
4 + x
9 + x
3 + x
2 + x
7 + x + 1
= x
13 + x
11 + x
9 + x
6 + x
5 + x
4 + x
3 + x
2 + x + 1
= x
5x
8 + x
3x
8 + x + x
8 + x
6 + x
5 + x
4 + x
3 + x
2 + x + 1
= x
5
(x
4 + x
3 + x + 1) + x
3
(x
4 + x
3 + x + 1) + x(x
4 + x
3 + x + 1)
+x
6 + x
5 + x
4 + x
3 + x
2 + x + 1
= x
9 + x
8 + x
6 + x
5 + x
7 + x
6 + x
4 + x
3 + x
5 + x
4 + x
2 + x
+x
6 + x
5 + x
4 + x
3 + x
2 + x + 1
= x
9 + x
8 + x
7 + x
6 + x
5 + x
4 + 1
= xx8 + x
8 + x
7 + x
6 + x
5 + x
4 + 1
= x(x
4 + x
3 + x + 1) + x
4 + x
3 + x + 1 + x
7 + x
6 + x
5 + x
4 + 1
= x
5 + x
4 + x
2 + x + x
4 + x
3 + x + 1 + x
7 + x
6 + x
5 + x
4 + 1
= x
7 + x
6 + x
4 + x
3 + x
2
⇒ (a)(b) = (1 1 0 1 1 1 0 0)
2. 4 Byte’lık Vekt¨orleri C¸ arpma:
4 byle’lık bir vekt¨or olan ~a = (a3, a2, a1, a0) polinom olarak ifade edilir.
p~a(x) = a3x
3 + a2x
2 + a1x + a0
Burada a3, a2, a1, a0’ın byte oldukları unutulmamalıdır.
22
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
~a ve
~b = (b3, b2, b1, b0) vekt¨orleri i¸cin:
~a.~b = p~a(x).p~b
(x) mod M(x) = x
4 + 1
Aynı zamanda








c0
c1
c2
c3








=








a0 a3 a2 a1
a1 a0 a3 a2
a2 a1 a0 a3
a3 a2 a1 a0








.








b0
b1
b2
b3








Not: 4 byte’lık bir ~b = (b3, b2, b1, b0)vekt¨orun¨ u¨ ~a = (‘00‘, ‘00‘, ‘01‘, ‘00‘) ⇒ p~a(x) = x
ile carpmak ¸ bir sola kaydırmaya denktir. Yani
(b3b2b1b0).(0010) = (b2b1b0b3)
3. a = (a7 a6 a5 a4 a3 a2 a1 a0) byte’ının carpma ¸ ya g¨ore tersi
pa(x).pb(x) = 1 mod m(x) = x
8 + x
4 + x
3 + x + 1
e¸sitli˘gini sa˘glayan pb(x) polinomuna kar¸sılık gelen byte’tır.
p
−1
a
(x) = pb(x) mod m(x) = x
8 + x
4 + x
3 + x + 1.
Buna g¨ore a = (0 0 0 0 0 0 0 0) nın tersi kendisidir.
4. 4 byte’lık ~a = (a3, a2, a1, a0) vekt¨orun¨ un¨ carpma ¸ ya g¨ore tersi
p~a(x).p~b
(x) = 1 mod M(x) = x
4 + 1
e¸sitli˘gini sa˘glayan p~b
(x) polinomuna kar¸sılık gelen 4 byte’lık ~b vekt¨orud¨ ur. ¨
p
−1
~a
(x) = p~b
(x) mod M(x) = x
4 + 1.
23
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
4.2 Algoritma
Rijndael Algoritması
Metin uzunlu˘gu: 128,192,256 bit olabilir.
Anahtar uzunlu˘gu: 128,192,256 bit olabilir.
D¨ongu¨ (round) sayısı: Anahtar uzunlu˘gu ve metin uzunlu˘guna g¨ore de˘gi¸siklik
g¨ostermektedir. A¸sa˘gıdaki tabloda g¨osterilmi¸stir. Satırlar metin uzunluklarını, sut ¨ unlar ¨
anahtar uzunlukarını g¨ostermektedir.
128 192 256
128 10 12 14
192 12 12 14
256 14 14 14
Her d¨ongude ¨ u¸¨c ayrı b¨olum¨ vardır.
1. Do˘grusal (linear) i¸slemlerin oldu˘gu b¨olum. ¨ Bu katmanlarda (layer ) difuzy ¨ on
sa˘glanmaktadır.
2. Do˘grusal olmayan b¨olum. ¨ S kutularından (S-box ) olu¸smaktadır.
3. Anahtarın XOR’landı˘gı katman.
Bit olarak ifade edilen mesajı byte’lara ayrılır.
a00 a10 a20 a30 a01 a11 a21 a31 a02 a12 a22 a32 a03 a13 a23 a33 . . .
24
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Metin 4 byte’lık sut ¨ un¨ vekt¨orleri ¸seklinde, yani 128 bit i¸cin 4 × 4, 192 bit i¸cin 4 × 6, 256
bit i¸cin 4 × 8’lik matrislerle ifade edilir. 128 bitlik bir metin i¸cin a¸sa˘gıdaki gibidir.








a00 a01 a02 a03
a10 a11 a12 a13
a20 a21 a22 a23
a30 a31 a32 a33








4.2.1 Byte Sub
S-kutusunun oldu˘gu katmandır. Matristeki her byte’ın modulo m(x) = x
8+x
4+x
3+x+1’e
g¨ore tersi bulunur. a −→ a
−1 = b = (b7 b6 b5 b4 b3 b2 b1 b0) S-kutusunun cıktısı ¸
y = (y7 y6 y5 y4 y3 y2 y1 y0) olmak uzere: ¨





















y0
y1
y2
y3
y4
y5
y6
y7





















=





















1 1 1 1 1 0 0 0
0 1 1 1 1 1 0 0
0 0 1 1 1 1 1 0
0 0 0 1 1 1 1 1
1 0 0 0 1 1 1 1
1 1 0 0 0 1 1 1
1 1 1 0 0 0 1 1
1 1 1 1 0 0 0 1










































x0
x1
x2
x3
x4
x5
x6
x7





















⊕





















0
1
1
0
0
0
1
1





















Burdaki 8 × 8’lik matrisin ozelli˘ ¨ gi modulo 2’de tersi olan bir matris olmasıdır.
25
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
4.2.2 Shift Row
128 bit i¸cin:
1 5 9 13
2 6 10 14
3 7 11 15
4 8 12 16
−→
1 5 9 13
6 10 14 2
11 15 3 7
16 4 8 12
Bu permutasy ¨ ona g¨ore 6. pozisyondaki byte 2. pozisyona, 3. pozisyondaki byte 11.
pozisyona ge¸cmi¸s.
192 bit i¸cin:
1 5 9 13 17 21
2 6 10 14 18 22
3 7 11 15 19 23
4 8 12 16 20 24
−→
1 5 9 13 17 21
6 10 14 18 22 2
11 15 19 23 3 7
16 20 24 4 8 12
256 bit i¸cin:
1 5 9 13 17 21 25 29
2 6 10 14 18 22 26 30
3 7 11 15 19 23 27 31
4 8 12 16 20 24 28 32
−→
1 5 9 13 17 21 25 29
6 10 14 18 22 26 30 2
15 19 23 27 31 3 7 11
20 24 28 32 4 8 12 16
4.2.3 Mix Column
Byte Sub ve Shift Row i¸slemlerinden cık ¸ an, her sut ¨ un¨ u¨ 4 bytle’lık vekt¨or olan matris, bu
katmanda modulo M(x) = x
4 + 1’de c(x) = ‘03‘x
3 + ‘01‘x
2 + ‘01‘x + ‘02‘ polinomuyla
26
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
carpılır. ¸ Buna g¨ore:








b00 b01 b02 b03
b10 b11 b12 b13
b20 b21 b22 b23
b30 b31 b32 b33








=








‘02‘ ‘03‘ ‘01‘ ‘01‘
‘01‘ ‘02‘ ‘03‘ ‘01‘
‘01‘ ‘01‘ ‘02‘ ‘03‘
‘03‘ ‘01‘ ‘01‘ ‘02‘
















a00 a01 a02 a03
a10 a11 a12 a13
a20 a21 a22 a23
a30 a31 a32 a33








4.2.4 Anahtarla XOR’lama
Anahtarlar da aynı ¸sekilde matrislerle ifade edilir, anahtarla metnin kar¸sılıklı byte’ları
XOR’lanır.








a00 a01 a02 a03
a10 a11 a12 a13
a20 a21 a22 a23
a30 a31 a32 a33








⊕








k00 k01 k02 k03
k10 k11 k12 k13
k20 k21 k22 k23
k30 k31 k32 k33








=








a00 ⊕ k00 a01 ⊕ k01 a02 ⊕ k02 a03 ⊕ k03
a10 ⊕ k10 a11 ⊕ k11 a12 ⊕ k12 a13 ⊕ k13
a20 ⊕ k20 a21 ⊕ k21 a22 ⊕ k22 a23 ⊕ k23
a30 ⊕ k30 a31 ⊕ k31 a32 ⊕ k32 a33 ⊕ k33








27
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
4.3 Anahtar Algoritması
Anahtar olarak uretilen ¨ toplam bit sayısı (blok uzunlu˘gu) × (D¨ongu¨ sayısı+1) kadardır.
E˘ger 4 bytle’lık vekt¨orlerin her birine kelime (1 kelime=32 bit) dersek, kelime olarak
uretilen ¨ anahtar sayısı (bloktaki kelime sayısı) × (d¨ongu¨ sayısı+1) dir.
Nb = 1 bloktaki kelime sayısı
Nk = Anahtardaki kelime sayısı
Nr = D¨ongu¨ sayısı
Bu anahtar algoritmasından cık ¸ an her kelimeye








w0i
w1i
w2i
w3i








dersek,
0 ≤ i < Nk i¸cin








w0i
w1i
w2i
w3i








=








k0i
k1i
k2i
k3i








Nk ≤ i < Nb(Nr + 1) i¸cin
Nk | i ise
wi = wi−Nk ⊕ Subbyte(RotByte(wi−1)) ⊕ RoundConstant[i/Nk]
28
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Nk - i ise
wi = wi−Nk ⊕ wi−1
Subbyte: Byte sub katmanındaki i¸slemlerden olu¸sur.
Rotbyte: Rotbyte((a,b,c,d))=(b,c,d,a).
Round Constant:
RC[1]=‘01‘
RC[j]=x.RC[j-1]
RoundConstant[j] =








RC[j]
‘00‘
‘00‘
‘00‘








Anahtar algoritmasında ilk alınan anahtar 32 bitlik kelimeler halinde hi¸c de˘gi¸sikli˘ge
u˘gramadan kullanılır. E˘ger algoritmadan cık ¸ an anahtar kelimeler (32 bit uzunlu˘gunda
4 byte’lık vekt¨orler) w0 w1 w2 w3 w4 w5 . . . ise 128 bitlik blok uzunlu˘gu i¸cin:
w0 w1 w2 w3 → Round 0 Round’a girmeden
w4 w5 w6 w7 → Round 1
w8 w9 w10 w11 → Round 2
.
.
.
29
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
192 bitlik blok uzunlu˘gu i¸cin:
w0 w1 w2 w3 w4 w5 → Round 0 Round’a girmeden
w6 w7 w8 w9 w10 w11 → Round 1
w12 w13 w14 w15 w16 w17 → Round 2
.
.
.
256 bitlik blok uzunlu˘gu i¸cin:
w0 w1 w2 w3 w4 w5 w6 w7 → Round 0 Round’a girmeden
w8 w9 w10 w11 w12 w13 w14 w15 → Round 1
w16 w17 w18 w19 w20 w21 w22 w23 → Round 2
.
.
.
30
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
4.4 ALGOR˙ITMANIN TERS˙I
Algoritmaın Tersi
Algoritmanın tersinde katmanların tersi uygulanır.
4.4.1 Mix Column
Mix Column’da kullanılan polinomun tersi kullanılır. c
−1
(x) = d(x) = ‘0B‘x
3 + ‘0D‘x
2 +
‘09‘x + ‘0E‘ carpma ¸ i¸slemi yine modulo M(x) = x
4 + 1’de yapılır.
4.4.2 Byte Sub
Byte Sub katmanında yapılan i¸slemlerin tersi yapılır.





















x0
x1
x2
x3
x4
x5
x6
x7





















=





















0 1 0 1 0 0 1 0
0 0 1 0 1 0 0 1
1 0 0 1 0 1 0 0
0 1 0 0 1 0 1 0
0 0 1 0 0 1 0 1
1 0 0 1 0 0 1 0
0 1 0 0 1 0 0 1
1 0 1 0 0 1 0 0












































y0
y1
y2
y3
y4
y5
y6
y7





















⊕





















0
1
1
0
0
0
1
1























Bulunan x = (x7 x6 x5 x4 x3 x2 x1 x0)’in modulo m(x) = x
8 +x
4 +x
3 +x+1’de tersi alınır.
31
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
BOL¨ UM¨ 5
AKAN S¸˙IFRELER
Akan ¸sifre sistemleri, mesajın her karakterini (bitini) ayrı ayrı ¸sifreler. S¸ifreleme i¸slemi
mesaj uzunlu˘gunda bir anahtar kullanılarak yapılır. Anahtarın her biti mesajın her bitiyle
mod 2’de kar¸sılıklı toplanır. Bu i¸sleme XOR i¸slemi denir ve ⊕ ile g¨osterilir.
S¸ifreleme :
A¸cık metin m = m1 m2 . . . mn
Anahtar k = k1 k2 . . . kn
Kapalı metin c = c1 c2 . . . cn
Burada her i i¸cin ci = mi ⊕ ki dir.
S¸ifreleme i¸sleminde kullanılan iki tip anahtar dizisi vardır.
1. Tam Rastgele (true random) Dizi : Dizideki her bit birbirinden ba˘gımsız olarak
uretilir. ¨ Buna bir ornek ¨ olarak yazı tura atı¸sı verilebilir.
2. Pseudo Rastgele (pseudo random) Dizi : Dizinin her biti kendinden once ¨ gelen
bitlere ba˘glıdır. Aynı zamanda her bit kendinden sonra gelen biti etkiler.
32
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
5.1 One Time Pad Sistemi
S¸ifrelenecek mesajın uzunlu˘gunda tam rastgele bir anahtar dizisi se¸cilir. Mesaj ve
anahtara XOR i¸slemi uygulanır.
Ornek ¨ 5.1.1
m = 11010001011010110
k = 01110100101101000
m ⊕ k = 10100101110111110
Mesajı a¸cmak i¸cin aynı anahtara ve kapalı metine tekrar XOR i¸slemi uygulanır.
5.1.1 Sistemin Avantajları
Uzunlu˘gu n bit olan bir mesaj i¸cin n bitlik bir anahtar dizisi se¸cilir. Mesaj ¸sifrelenir ve
g¨onderilir. Mesajı ele ge¸ciren birisi olası but ¨ un¨ anahtarları (2n
tane) denese bile mesajı
bulamaz. C¸unk ¨ u¨ bu i¸slemin sonunda n bitlik but ¨ un¨ kelimeleri bulur. Elinde birden fazla
anlamlı mesaj olaca˘gıi¸cin bu mesajların i¸cinden ger¸cek mesajı tahmin etmek imkansızdır.
Bu a¸cıdan ko¸sulsuz guvenli ¨ bir sistemdir.
5.1.2 Sistemin Dezavantajları
Uzun bir mesaj ¸sifrelemek i¸cin uzun bir anahtar uretmek ¨ gerekir. Bu sistem tam rastgele bir anahtar dizisi kullandı˘gından, uzun bir anahtar uretmek, ¨ bu anahtarı guv¨ enli bir
33
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
¸sekilde kar¸sı tarafa iletmek ve saklamak zor olur. Ayrıca kullanılan anahtar tekrar kullanılamayaca˘gı i¸cin, her seferinde ba¸ska bir anahtar uretilmesi ¨ gerekir. Bu nedenlerden
dolayı sistemin kullanımı zordur.
5.2 Dizi Ureticiler ¨
Ger¸cekten rastgele dizilerin uretilmesi ¨ ve iletilmesi gibi zordur. Bu nedeniyle pseudo
rastgele diziler kullanılr. Bu diziler kısa bir anahtar kullanılarak bir dizi uretici ¨ tarafından
uretilir. ¨
Dizi ureticiler ¨ a¸cısından akan ¸sifreleri ikiye ayırabiliriz.
1. Senkronize (Synchronous) Akan S¸ifre :
fs: Faz fonksiyonu, bir sonraki fazı belirleyen fonksiyon.
f : Ureticinin ¨ fazına g¨ore bit ureten ¨ fonksiyon.
h : S¸ifreleme algoritması (XOR i¸slemi)
σi
: Ureticinin ¨ i zamandaki fazı
σ0: Ureticinin ¨ calı ¸ ¸smaya ba¸slaması i¸cin belirlenen ilk faz. Gizlidir, genellikle anahtar
ilk fazın ne olaca˘gını belirler.
S¸ifreleme :
34
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Resim 1: Senkronize sistemlerde ¸sifreleme
f(k, σi) = zi
fs(k, σi) = σi+1
h(mi
, zi) = ci
De¸sifreleme :
Resim 2: Senkronize sistemlerde de¸sifreleme
35
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
f(k, σi) = zi
fs(k, σi) = σi+1
h
−1
(ci
, zi) = mi
2. Oto-Senkronize (Self Synchronous) Akan S¸ifre :
fs: Faz fonksiyonu, bir sonraki fazı belirleyen fonksiyon.
f : Ureticinin ¨ fazına g¨ore bit ureten ¨ fonksiyon.
h : S¸ifreleme algoritması
σi
: (ci−t
, ci−t+1, . . . , ci−1)
σ0: (c−t
, c−t+1, . . . , c−1)
S¸ifreleme :
Resim 3: Oto-Senkronize sistemlerde ¸sifreleme
f(k, σi) = zi
h(mi
, zi) = ci
36
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
De¸sifreleme :
Resim 4: Oto-Senkronize sistemlerde de¸sifreleme
f(k, σi) = zi
h
−1
(ci
, zi) = mi
5.3 Geri Beslemeli Kaydırmalı Yazdırga¸c (Feedback Shift Register)
Kısaca FSR olarak adlandırılan bir geri beslemeli kaydırmalı yazdırga¸cın nasıl calıS ¸ ¸tı˘gı
aS¸a˘gıdaki S¸ekilde g¨osterilmektedir.
37
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Resim 5: Geri Beslemeli Kaydırmalı Yazdırga¸c (FSR)
f : Z
n
2 → Z2
Z2 = {0, 1} Z
n
2 = {(x1, x2, . . . , xn) | xi ∈ Z2}
L: Yazdırgacın boyu
Bir sonraki fazda her bit sa˘ga kayar. f fonksiyonu yeni bir bit uretir, ¨ uretilen ¨ bit en
sa˘gdaki g¨oze yazılır.
z = z0z1z2z3 . . . dizisinde her i ∈ N i¸cin zi = zi+p e¸sitli˘gini sa˘glayan en ku¸¨cuk¨ p sayısı
dizinin periyodudur. Yani bu diziyi ureten ¨ FSR p adım sonra ba¸slangı¸c fazına geri d¨oner.
Ornek ¨ 5.3.1 f(x1, x2, x3, x4, x5) = x1 ⊕ x2x3 ⊕ x4x5
38
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Resim 6: Fonksiyonu f(x1, x2, x3, x4, x5) = x1 ⊕ x2x3 ⊕ x4x5 olan FSR
σ0 = 0 1 0 1 1 f(σ0) = 1 ⊕ 1.0 ⊕ 1.0 = 1
σ1 = 1 0 1 1 1 f(σ1) = 1 ⊕ 1.1 ⊕ 0.1 = 0
σ2 = 0 1 1 1 0 f(σ2) = 0 ⊕ 1.1 ⊕ 1.0 = 1
σ3 = 1 1 1 0 1 f(σ3) = 1 ⊕ 0.1 ⊕ 1.1 = 0
σ4 = 1 1 0 1 0 f(σ4) = 0 ⊕ 1.0 ⊕ 1.1 = 1
σ5 = 1 0 1 0 1 f(σ5) = 1 ⊕ 0.1 ⊕ 0.1 = 1
σ6 = σ0 = 0 1 0 1 1
B¨oylece periyodu 6 olan z = (010111)∞ dizisi uretilir. ¨
Ornek ¨ 5.3.2 Aynı fonksiyon kullanılarak periyodik olmayan bir dizi uretebiliriz. ¨ E˘ger
ba¸slangı¸c fazını σ0 = (01010) se¸cersek:
39
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
x5 x4 x3 x2 x1
σ0 0 1 0 1 0
σ1 1 0 1 0 0
σ2 0 1 0 0 0
σ3 1 0 0 0 0
σ4 0 0 0 0 0
σ5 0 0 0 0 0
uretilen ¨ dizi z = 0101000 . . ., periyodik de˘gildir.
Ornek ¨ 5.3.3 f(x1, x2, x3) = x1 ⊕ x3
x3 x2 x1
σ0 1 0 1
σ1 0 1 0
σ2 1 0 0
σ3 0 0 1
σ4 0 1 1
σ5 1 1 1
σ6 1 1 0
σ0 = σ7 1 0 1
Periyodu 7 olan z = (1010011)∞ dizisi uretildi. ¨
Bir f fonksiyonu, ai ∈ {0, 1} olmak uzere, ¨ f(x1, x2, . . . , xL) = a1x1 ⊕ a2x2 ⊕ . . . ⊕ aLxL
¸seklinde yazılabiliyorsa, bu fonksiyona do˘grusal denir. FSR’nin kullandı˘gı fonksiyon
do˘grusalsa bu uretece ¨ do˘grusal geri beslemeli kaydırmalı yazdırga¸c veya LFSR (linear
feedback shift register) denir.
40
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
5.4 Uretecinin ¨ Sahip Olması Gereken Ozellikler ¨
1. Uretti˘ ¨ gi dizi iyi istatistikler ozellikler ¨ g¨ostermelidir.
2. Periyodu buy¨ uk¨ olan bir dizi uretmelidir. ¨
3. Uretti˘ ¨ gi dizinin do˘grusal karma¸sıklı˘gı(linear complexity) buy¨ uk¨ olmalıdır.
5.4.1 ˙Istatistiksel Ozellikler ¨
Anahtar olarak kullanılacak dizinin tesadufi¨ ve kuralsız olması tercih edilir. Belirgin ozellikleri ¨ olan bir dizi genellikle anahtar olarak kullanılmaz. Orne˘ ¨ gin, z =
(10100100010000100000 . . .) dizisi kuralsız g¨ozukmemektedir. ¨
Dizinin kuralsız olmasını veya kuralsız bir diziye yakın olup olmadı˘gını ol¸ ¨ cen bir cok ¸ test
vardır. AS¸a˘gıdaki u¸¨c testi LFSR’lar sa˘glar.
1. Dizinin bir tam periyodunda 1 ve 0 ların sayısı e¸sit olmalı, ya da aralarındaki fark
1 olmalıdır. Yani
0 ≤ |(1 ’lerin sayısı) − (0 ’ların sayısı)| ≤ 1.
Ornek ¨ 5.4.1 n = 21 bit uzunlu˘gunda z = 000110101110010001101 dizisinde 10
tane 1 ve 11 tane 0 vardır. Dolayısıyla aranan ko¸sul sa˘glanır.
Ornek ¨ 5.4.2 n = 14 bit uzunlu˘gunda ki z = 10101010101010 dizisinde
0 ve 1 yedi kere g¨ozuk¨ urler ¨ ama bu dizi tesadufi¨ bir dizi de˘gildir.
41
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
2. Tek ce¸ ¸sit karakterden olu¸san bloklara run denir.
n bitlik bir dizide toplam n+1
2
tane run olması beklenir. Bunlardan
uzunlu˘gu 1 olanların sayısının n+1
2
2
,
uzunlu˘gu 2 olanların sayısının n+1
2
3
,
uzunlu˘gu 3 olanların sayısının n+1
2
4
,
.
.
.
uzunlu˘gu k olanların sayısının n+1
2
k+1 olması beklenir.
Ornek ¨ 5.4.3 z = 00110001101, n=11
Beklenen run sayısı 11+1
2 = 6
Uzunlu˘gu 1 olan run sayısı 11+1
2
2 = 3
Dizinin run sayısı beklendi˘gi gibi 6 dır, ancak uzunlu˘gu 1 olan runların sayısı bekledi˘gi gibi 3 de˘gil, 2 dir. Dolayısıyla, bu dizi run sayısı testini ge¸cemez.
Ornek ¨ 5.4.4 z = 1000010111011000111110011010010, n=31
42
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Beklenen run sayısı 31+1
2 = 16 X
Uzunlu˘gu 1 olan run sayısı 31+1
2
2 = 8 X
Uzunlu˘gu 2 olan run sayısı 31+1
2
3 = 4 X
Uzunlu˘gu 3 olan run sayısı 31+1
2
4 = 2 X
Uzunlu˘gu 4 olan run sayısı 31+1
2
5 = 1 X
Uzunlu˘gu 5 olan run sayısı 31+1
2
6 = 0.5 ∼= 1 X
Bu dizi beklenen but ¨ un¨ de˘gerleri sa˘glar ve run sayısı testinden ge¸cer.
3. Periyodu p olan bir dizinin otokorelasyon fonksiyonu C(τ ), dizinin kendisinin τ
kadar kaydırılmasıyla oluS¸an diziye ne kadar uydu˘gunu g¨osterir. Periyodu p olan
{ai} dizisinin otokorelasyon fonksiyonunu
C(τ ) =
1
p
X
p
i=1
(−1)ai
(−1)ai+τ
¸seklinde ifade edilir. Her dizi i¸cin
C(0) =
1
p
X
p
i=1
(−1)ai
(−1)ai =
1
p
X
p
i=1
(−1)ai⊕ai =
1
p
X
p
i=1
1 = 1 dir.
Bir dizinin rastgele olup olmadı˘gına karar vermekte aranılan bir ba¸ska ko¸sul da C(τ )
fonksiyonunun
C(1) = C(2) = . . . = C(p − 1) e¸sitli˘gini sa˘glamasıdır.
43
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Ornek ¨ 5.4.5
ai = 0 0 0 1 0 1 1 C(0) = 1, p = 7
(−1)ai = 1 1 1 − 1 1 − 1 − 1
(−1)ai+1 = 1 1 1 1 −1 −1 1 C(1) =
1
7
(1 + 1 − 1 − 1 − 1 + 1 − 1) =
−1
7
(−1)ai+2 = 1 −1 1 −1 −1 1 1 C(2) =
1
7
(1 − 1 − 1 − 1 + 1 − 1 + 1) =
−1
7
(−1)ai+3 = −1 1 −1 −1 1 1 1 C(3) =
1
7
(−1 + 1 − 1 + 1 + 1 − 1 − 1) =
−1
7
(−1)ai+4 = 1 −1 −1 1 1 1 −1 C(4) =
1
7
(1 − 1 − 1 − 1 + 1 − 1 + 1) =
−1
7
(−1)ai+5 = −1 1 1 1 1 −1 1 C(5) =
1
7
(1 + 1 − 1 − 1 − 1 + 1 − 1) =
−1
7
(−1)ai+6 = −1 1 1 1 −1 1 −1 C(6) =
1
7
(1 + 1 − 1 − 1 − 1 + 1 − 1) =
−1
7
C(1) = C(2) = C(3) = C(4) = C(5) = C(6) =
−1
7
oldu˘gu i¸cin bu dizi testten ge¸cer.
5.5 Do˘grusal Geri Beslemeli Kaydırmalı Yazdırga¸c (LFSR)
Resim 7: LFSR
44
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
L: LFSR’ın boyu
Ba¸slangı¸c fazı σ0 : a−L, a−L+1, . . . , a−2, a−1
Geri besleme katsayıları (feedback coefficients): c1, c2, . . . , cL−1, cL ∈ Z2 = {0, 1}
LFSR’ın do˘grusal fonksiyonu:
f(x1, x2 . . . xL) = c1x1 ⊕ c2x2 ⊕ . . . ⊕ cLxL
Buna g¨ore:
a0 = cLa−L ⊕ cL−1a−L+1 ⊕ . . . c2a−2 ⊕ c1a−1
⇒ σ1 : a−L+1, a−L+2, . . . , a−1, a0
a1 = cLa−L+1 ⊕ cL−1a−L+2 ⊕ . . . c2a−1 ⊕ c1a0
Genel olarak:
an = cLan−L ⊕ cL−1an−L+1 ⊕ . . . c2an−2 ⊕ c1an−1.
Bu recursive ba˘gıntının karakteristik polinomu aynı zamanda LFSR’ın karakteristik polinomudur. Buna g¨ore karakteristik polinom:
m(x) = x
L + c1x
L−1 + c2x
L−2
. . . + cL−1x + cL.
LFSR’ın ba˘glayıcı polinomu (connection polynomial):
C(D) = 1 + c1D + c2D
2 + . . . + cL−1D
L−1 + cLD
L
.
Ba˘glayıcı polinom ile karakteristik polinom arasındaki ba˘gıntı a¸sa˘gıdaki gibidir:
m(x) = x
LC
 
1
x
 
.
Bir LFSR, boyu L ve ba˘glayıcı polinomu C(D) ile belirlenir:
LFSR = hL,C(D)i.
45
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Ornek ¨ 5.5.1 LFSR=h4,C(D) = 1 + D + D4
i
c1 = 1, c2 = c3 = 0, c4 = 1 ⇒ f(x1, x2, x3, x4) = x1 ⊕ x4
Resim 8: h4,C(D) = 1 + D + D4
i
Bu LFSR’ı calı ¸ ¸stırmak i¸cin ba¸slangı¸c fazı olarak σ0 = (0 0 1 1) alınırsa, periyodu 5 olan
z = (001111010110010)∞ dizisi uretilir. ¨
46
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
x1 x2 x3 x4 x1 ⊕ x4
0 0 1 1 1
0 1 1 1 1
1 1 1 1 0
1 1 1 0 1
1 1 0 1 0
1 0 1 0 1
0 1 0 1 1
1 0 1 1 0
0 1 1 0 0
1 1 0 0 1
1 0 0 1 0
0 0 1 0 0
0 1 0 0 0
1 0 0 0 1
0 0 0 1 1
0 0 1 1 = σ0
LFSR’ın fonksiyonu do˘grusal oldu˘gundan f(0, 0, . . . , 0) = 0 dır. Dolayısıyla ba¸slangı¸c
fazını 0 vekt¨oru¨ alınırsa 0 geri beslenir. 0 vekt¨orunden ¨ ba¸ska bir faz g¨orulmez. ¨ 0’dan
farklı bir vekt¨orle ba¸slanırsa 0 vekt¨oru¨ faz olarak hi¸c g¨orulmez. ¨
5.5.1 Dizinin Periyodu
Boyu L olan bir LFRS’ın uretti˘ ¨ gi dizinin periyodu en fazla 2
L −1 olabilir c¸unk ¨ u¨ LFSR’da
faz olarak L uzunlu˘gunda vekt¨orler g¨ozuk¨ ur. ¨ L uzunlu˘gunda 2
L − 1 tane vekt¨or vardır.
LFSR da 0 vekt¨orun¨ u¨ g¨orulmezse ¨ en fazla 2
L − 1 tane de˘gi¸sik vekt¨or g¨orulebilir. ¨ Yani
LFSR en fazla 2
L − 1 adım sonra ba¸slangı¸c noktasına geri d¨oner.
47
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
hL,C(D)i LFSR’ının uretti˘ ¨ gi dizinin periyodu C(D) polinomunun carpanlarına ¸ ayrılabilir
olup olmamasıyla ve ba¸slangı¸c fazıyla iliS¸kilidir.
• E˘ger C(D) carpanlarına ¸ ayrılıyorsa uretilen ¨ dizinin periyodu ba¸slangı¸c fazına g¨ore
de˘gi¸sir.
Ornek ¨ 5.5.2 hL,C(D) = 1 + D2 + D4
i
⇒ c1 = 0, c2 = 1, c3 = 0, c4 = 1 ⇒ f(x1, x2, x3, x4) = x2 ⊕ x4 ve C(D) =
1 + D2 + D4 = (1 + D + D2
)
2
x1 x2 x3 x4
σ0 1 0 0 0
0 0 0 1
0 0 1 0
0 1 0 1
1 0 1 0
0 1 0 0
σ0 1 0 0 0
x1 x2 x3 x4
σ0 1 1 1 1
1 1 1 0
1 1 0 0
1 0 0 1
0 0 1 1
0 1 1 1
σ0 1 1 1 1
x1 x2 x3 x4
σ0 1 0 1 1
0 1 1 0
1 1 0 1
σ0 1 0 1 1
Periyod = 6 Periyod = 6 Periyod = 3
• Maksimum periyodda dizi uretmek ¨ i¸cin C(D) polinomunun carpanlarına ¸ ayrılamaz
olması gerekir. E˘ger C(D) carpanlarına ¸ ayrılamayan bir polinomsa dizinin periyodu
ba¸slangı¸c fazına ba˘glı de˘gildir ve C(D) polinomunun b¨oldu˘¨gu¨ 1+Dp polinomlarından
en ku¸¨cuk¨ dereceli olanın derecesi, uretilen ¨ dizinin periyoduna e¸sittir. Buradaki p
sayısı 2
L − 1 sayısının bir b¨olenidir. Orne˘ ¨ gin C(D) | 1 + D5 ve C(D), 1 + Dk
, k =
1, 2, 3, 4, polinomlarını b¨olmuy¨ orsa uretilen ¨ dizinin periyodu 5 tir.
• Dizinin periyodunun maksimum yani 2
L −1 olması i¸cin C(D) polinomunun b¨oldu˘¨gu¨
48
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
en ku¸¨cuk¨ dereceli polinom 1 + D2
L−1 olmalıdır. Bunu sa˘glayan C(D) polinomuna
ilkel polinom(primitive polynomial) denir.
Maksimum periyodda dizi ureten ¨ bir LFSR’a maksimum uzunlukta LFSR denir.
5.6 Do˘grusal Karma¸sıklık (Linear Complexity)
Bir dizinin do˘grusal karma¸sıklı˘gı (L.C.) onu uretebilecek ¨ LFSR’lardan en kısa olanın
boyuna e¸sittir.
z = 0000 . . . 0 . . . dizisinin do˘grusal karma¸sıklı˘gı 0 ’dır.
z = 1111 . . . 1 . . . dizisinin do˘grusal karma¸sıklı˘gı 1 ’dir.
z = 0000 . . . 1
| {z }
n
dizisinin do˘grusal karma¸sıklı˘gı n ’dir.
z L.C C(D)
0 0 0
1 1 1 + D
01 2 1 + D2
001 3 1 + D3
011 2 1 + D + D2
100 1 1
101 2 1 + D2
110 2 1 + D + D2
111 1 1 + D
Do˘grusal karma¸sıklık ile ilgili bazı ozellikler: ¨
• z = z0z1z2z3 . . . dizisi i¸cin, bu diziden alınan her n bitlik z
n dizisinin do˘grusal
karma¸sıklı˘gı en fazla n olabilir. Yani 0 ≤ L.C.(z
n
) ≤ n dir. Bu nedenle bir dizinin
49
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
do˘grusal karma¸sıklı˘gı en fazla dizinin boyu kadardır.
• E˘ger dizinin periyodu N ise L.C.(z) ≤ N dir.
• s ve t birer dizi olmak uzere ¨ L.C.(s ⊕ t) ≤ L.C.(s) + L.C.(t) dir.
5.6.1 Do˘grusal Karma¸sıklık Profili (Linear Complexity Profile)
s = s0s1s2 . . . bir dizi olsun. N ≥ 1 i¸cin s
N sonlu dizisi s
N = s0s1s2 . . . sN−1 ¸seklinde
tanımlanır. O zaman her N ≥ 1 i¸cin LN = L.C.(s
N ) ¸seklinde tanımlanan L1,L2, . . . ,LN
dizisine s
N dizisinin do˘grusal karma¸sıklık profili denir. Bu dizi a¸sa˘gıdaki ozellikleri ¨
g¨osterir:
• E˘ger j ≥ i ise Lj ≥ Li dir.
• LN+1 > LN olması i¸cin LN ≤ N/2 olması gerekir.
• E˘ger LN+1 > LN ise LN+1 + LN = N + 1 dir.
Profilde onemli ¨ noktalar LN ≤ N/2 oldu˘gu yerlerdir. Bu noktalarda LN+1 artabilir.
Boyu LN olan hi¸c bir LFSR s
N+1 dizisini uretmezse ¨ LN+1 > LN dir, dolayısıyla LN+1 =
LN − N − 1 dir.
Kriptografik anlamda iyi bir LFSR’ın uretti˘ ¨ gi bir dizinin, do˘grusal karma¸sıklık profilinin
grafi˘gi y = N/2 do˘grusuna yakın olmalıdır. Bu do˘grudan fazla sapmamalıdır.
50
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
5.6.2 Berleckamp Massey Algoritması
Berleckamp Massey Algoritması sonlu bir dizinin do˘grusal karma¸sıklı˘gını ve onu
uretebilecek ¨ en kısa LFSR’ın ba˘glayıcı polinomu C(D) yi bulmak i¸cin kullanılır.
s
N+1 = s0s1 . . . sN−1sN dizisi verilsin. hK,C(D)i LFSR’ı s
N = s0s1 . . . sN−1 dizisini
uretsin. ¨ s
N+1 dizisinin ve hK,C(D)i LFSR’ının uretti˘ ¨ gi dizinin (N +1). terimi arasındaki
farka uymazlık sayısı (next discrepancy) denir. Bu sayı
dN = sN +
X
L
i=1
cisN−i (mod 2)
¸seklinde hesaplanır. dN = 0 olması i¸cin bu LFSR’ın s
N+1 dizisinin (N + 1). terimini
uretmesi ¨ gerekir.
Berleckamp Massey Algoritmasının i¸sleyi¸si a¸sa˘gıdaki gibidir:
Girdi olarak s
n = s0s1s2 . . . sn−1 dizisini alır.
1. BaS¸langı¸c konumu: C(D) = 1, L = 0, m = −1, B(D) = 1, N = 0
2. N < n durumunda
(a) d = sN +
PL
i=1 cisN−i (mod 2).
(b) d = 1 ise
T(D) ←− C(D)
C(D) ←− C(D) + B(D)DN−m
E˘ger L ≤ N/2 ise L ←− N + 1 − L
51
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
m ←− N
B(D) ←− T(D)
(c) N ←− N + 1
5.7 LFSR Kullanılarak Yapılan Akan S¸ifre Sistemleri
Bir dizinin do˘grusal karma¸sıklı˘gı en fazla onu ureten ¨ LFSR’ın boyu kadar olabilir.
Maksimum uzunlukta bir LFSR, do˘grusal karma¸sıklı˘gı en fazla kendi boyuna e¸sit bir
dizi uretebilir. ¨ Bu da do˘grusal karma¸sıklık i¸cin ku¸¨cuk¨ bir sayıdır. Dizinin do˘grusal
karma¸sıklı˘gını arttırmak i¸cin ce¸ ¸sitli yollar vardır:
• LFSR’a do˘grusal olmayan bir filtre ba˘glanır. Bu filtre do˘grusal olmayan yani derecesi en az iki olan bir fonksiyondur.
Resim 9: Do˘grusal olmayan filtre
52
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Do˘grusal olmayan bir filtre: f(xL, xL−1, . . . , x2, x1) : Z
L
2 → Z2
Ornek ¨ 5.7.1 h3, 1 + D + D2
i ve do˘grusal olmayan filtre f(x3, x2, x1) = x1⊕x1x2⊕
x2x3
x3 x2 x1 f(x3, x2, x1)
σ0 1 0 1 1
0 1 0 0
1 0 0 0
0 0 1 1
0 1 1 0
1 1 1 1
1 1 0 1
σ0 1 0 1
z = (1001011)∞
• Birden fazla LFSR do˘grusal olmayan bir fonksiyonla ba˘glanabilir.
Resim 10: Birden fazla LFSR’ın do˘grusal olmayan bir fonksiyonla ba˘glanması
53
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
F : (z1, z2, . . . , zn) : Z
n
2 → Z2 do˘grusal olmayan bir fonksiyon.
z dizisinin periyodu: T(z) = okek(T1, T2, . . . , Tn) dir.
E˘ger LFSR’lar maksimum uzunlukta ise ve urettikleri ¨ dizilerin periyodu ikiden
buy¨ uk¨ ve birbirlerinden farklı ise z dizisinin do˘grusal karma¸sıklı˘gı
F(L1,L2, . . . ,Ln) dir.
Ornek ¨ 5.7.2 Geffe Ur ¨ eteci: U¸ ¨ c tane LFSR kullanır.
F(x1, x2, x3) = x1x2 ⊕ (1 ⊕ x2)x3.
Resim 11: Geffe Ureteci ¨
• Saat Kontrollu¨ Urete¸ ¨ cler (Clock Controlled Generators):
– De˘gi¸sen Adımlı Urete¸ ¨ c (Alternating Step Generator ): U¸ ¨ c tane LFSR kullanılır.
54
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Resim 12: De˘gi¸sen Adımlı Urete¸ ¨ c
LFSR1 = hL1,C1(D)i
LFSR2 = hL2,C2(D)i
LFSR3 = hL3,C3(D)i
LFSR1 calı ¸ ¸stırılır;
x1 = 1 ise LFSR2 calı ¸ ¸stırılır. LFSR3’un¨ bir once ¨ uretti˘ ¨ gi bit tekrar eder, LFSR3
daha once ¨ calı ¸ ¸smamı¸ssa 0 alınır.
x1 = 0 ise LFSR3 calı ¸ ¸stırılır. LFSR2’nin bir once ¨ uretti˘ ¨ gi bit tekrar eder,
LFSR2 daha once ¨ calı ¸ ¸smamı¸ssa 0 alınır.
LFSR2 ve LFSR3 XOR i¸slemine tabi tutulur. E˘ger LFSR1 periyodu 2
L1 olan
bir dizi uretiy ¨ orsa LFSR2 ve LFSR3 maksimum periyodda diziler uretiy ¨ orsa ve
o.b.e.b.(L1,L2) ise uretilecek ¨ z dizisinin
1. periyodu 2
L1 (2L2 − 1)(2L3 − 1),
2. do˘grusal karma¸sıklı˘gı (L2 + L3)2L1−1 < L.C.(z) ≤ (L2 + L3)2L1 dir.
55
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Ornek ¨ 5.7.3 LFSR2 → 1, 1, 0, 0, 1, 1, 0, 1, . . .
LFSR1 → 0, 1, 1, 1, 0, 0, 1, 1, . . .
LFSR3 → 0, 0, 1, 1, 0, 1, 1, 0, . . .
x2 0 1 1 0 0 0 0
x1 0 ↓ 1 ↑ 1 ↑ 1 ↑ 0 ↓ 0 ↓ 1 ↑
x3 0 0 0 0 0 1 1
z 0 1 1 0 0 1 1
– Ku¸¨culen ¨ Urete¸ ¨ c (Shrinking Generator ): ˙Iki tane LFSR kullanılır. ˙Ikisi de aynı
anda calı ¸ ¸sır.
Resim 13: Ku¸¨culen ¨ Urete¸ ¨ c
x = 1 ise y ’den al.
x = 0 ise y ’den alma.
LFSR1=hL1,C1(D)i ⇒ T(x) = 2
L1 − 1
LFSR2=hL2,C2(D)i ⇒ T(y) = 2
L2 − 1
56
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
1. L1 ve L2 aralarında asal ise olu¸san dizinin periyodu
(2L1−1
)2L2 − 1,
2. do˘grusal karma¸sıklı˘gı ise L2(2L1−2
) < L.C.(z) ≤ L2(2L1−1
) dir.
Ornek ¨ 5.7.4 LFSR1 → (101)∞
LFSR2 → (0101101)∞
x 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1
y 0 1 0 1 1 0 1 0 1 0 1 1 0 1 0 1 0 1 1 0 1
z 0 0 1 0 1 1 0 1 0 0 1 1 1 1
z = (00101101101111)∞
57
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
BOL¨ UM¨ 6
SAYILAR TEOR˙IS˙I
6.1 Tamsayılar
Tamsayılar kumesi ¨ {· · · , −3, −2, −1, 0, 1, 2, 3, · · · } sayılarından olu¸sur ve Z sembolu¨ ile
g¨osterilir.
6.1.1 B¨olunebilirlik: ¨
a ve b verilen tamsayılar olsun. E˘ger b = a · d e¸sitli˘gini sa˘glayan bir d sayısı varsa a b’yi
b¨oler(b, a tarafından b¨olun¨ ur ¨ ya da a, b nin bir carpanı) ¸ denir ve a|b ¸seklinde g¨osterilir.
Her b > 1 tamsayısı en azından iki pozitif b¨olene sahiptir; bunlar 1 ve b dir.
Ornek ¨ 6.1.1 1. −5|15, c¸unk ¨ u¨ 15 = 5 · 3.
2. 256|0, c¸unk ¨ u¨ 0 = 256 · 0.
3. 16|48, c¸unk ¨ u¨ 48 = 16 · 3.
6.1.2 B¨olunebilirlik ¨ Ozellikleri ¨
But ¨ un¨ a, b, c ∈ Z i¸cin, a¸sa˘gıdakiler do˘grudur.
58
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
1. a|a.
2. E˘ger a|b ve b|c ise a|c.
3. E˘ger a|b ve a|c ise but ¨ un¨ x, y ∈ Z i¸cin a|bx + cy ifadesi do˘grudur.
4. E˘ger a|b ve b|a ise a = ±b.
6.1.3 Tamsayılar i¸cin B¨olum¨ Algoritması:
E˘ger a ve b, b ≥ 1 olmak ko¸sulu ile, tamsayılar ise a’nın b’ye b¨olum¨ u¨ q tamsayısı gibi bir
b¨olum¨ ve r tamsayısı gibi bir kalan verir.
a = qb + r, 0 ≤ r < b.
Ustelik ¨ q ve r tektir. Bu b¨olum¨ un¨ kalanı a mod b olarak g¨osterilir.
Ornek ¨ 6.1.2 E˘ger a = 73, b = 17 ise q = 4 ve r = 5 tir. B¨oylece 73 mod 17 ≡ 5 tir.
6.1.4 En Buy¨ uk¨ Ortak B¨olen (Greatest Common Divisor)
a ve b her ikisi birlikte 0 olmamak ko¸sulu ile iki tamsayı olsun. a ve b nin en buy¨ uk¨ ortak
b¨oleni, a ve b yi b¨olen en buy¨ uk¨ d tamsayısıdır. a ve b nin en buy¨ uk¨ ortak b¨oleni gcd(a, b)
ya da kısaca (a, b) ile g¨osterilir.
Ornek ¨ 6.1.3 1. gcd(7, 11) = 1, c¸unk ¨ u¨ 7 = 7 · 1, 11 = 11 · 1
59
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
2. gcd(48, 40) = 8, c¸unk ¨ u¨ 48 = 2
4
· 3, 40 = 2
3
· 5
6.1.5 En Ku¸¨cuk¨ Ortak Kat (Least common Multiple)
a ve b her ikisi birlikte 0 olmamak ko¸sulu ile iki tamsayı olsun. a ve b nin en ku¸¨cuk¨ ortak
katı a ve b nin her ikisinin de b¨oldu˘¨gu¨ en ku¸¨cuk¨ tamsayıdır ve lcm(a, b) ile g¨osterilir.
Ornek ¨ 6.1.4 lcm(8, 12) = 24 c¸unk ¨ u¨ 8 = 2
3
ve 12 = 2
2
· 3 tur. ¨
Teorem 6.1.5 a ve b her ikiside birlikte 0 olmayacak ¸sekilde tamsayılar olsun. gcd(a, b) =
ax + by e¸sitli˘gini sa˘glayan x ve y tamsayılar her zaman vardır.
6.1.6 Asal Sayı
1 den buy¨ uk, ¨ 1 ve kendisinden ba¸ska b¨oleni olmayan tamsayılara asal sayı denir.Asal
olmayan sayılara da b¨olunebilir ¨ sayı denir.
Ornek ¨ 6.1.6 2, 3, 5, 7, 11, 13, 17, 19, 23, · · · sayıları bazı asal sayılara ornektir. ¨
NOT: Asal sayılarla ilgili bazı ozellikler: ¨
• E˘ger p sayısı asal sayı ve p|ab ise p|a’yi veya p|b’yi b¨oler.
• Sonsuz sayıda asal sayı vardır.
60
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
6.1.7 Aralarında Asal Sayı
a ve b iki tamsayısı gcd(a, b) = 1 ko¸sulunu sa˘glıyorsa bu sayılara aralarında asal denir.
gcd(12, 5) = 1 oldu˘gu i¸cin 2 ve 5 sayıları aralarında asaldır.
6.1.8 Aritmeti˘gin Esas Teoremi
n ≥ 2 olan her tamsayı asal sayıların carpımları ¸ ¸seklinde tek olarak yazılır. Yani,
n = p
e1
1
· p
e2
2
· · · p
ek
k
sayısında pk lar farklı asal sayıları ek lar da pozitif tamsayıları g¨ostermektedir.
Ornek ¨ 6.1.7 4200 = 2
3
· 3 · 5
2
· 7.
6.1.9 Oklid ¨ Algoritması(Euclidean Algorithm)
a ve b ¸seklinde olan iki tamsayının en buy¨ uk¨ ortak b¨olenini aritmeti˘gin esas teoreminde
bahsedildi˘gi gibi carpanlarına ¸ ayırarak ve ortak carpanların en buy¨ u˘¨gun¨ u¨ alarak bulabiliriz. E˘ger a ve b buy¨ uk¨ sayılarsa bunların asal carpanlarını ¸ bulmak zor olur; bunun sonucunda da en buy¨ uk¨ ortak b¨oleni bulmak da zorla¸sır. Sayılar teorisinin onemli ¨ bir ara¸stırma
alanı da buy¨ uk¨ tamsayıları daha cabuk ¸ carpanlarına ¸ ayırma uzerine ¨ ara¸stırmadır. E˘ger a
ve b nin asal carpanları ¸ bilinmiyorsa, gcd(a, b) yi bulmak i¸cin cabuk ¸ bir yol vardır. O da
Oklid ¨ algoritmasıdır.
Oklid ¨ Algoritması ¸s¨oyle calı ¸ ¸sır.
61
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
• a > b olmak uzere, ¨ a, b ’ye b¨olun¨ ur. ¨ B¨olum¨ q1, kalan r1 olsun
a = b · q1 + r1
•
˙Ikinci b¨olme i¸slemi ger¸cekle¸stirilir. b, r1 ’e b¨olun¨ ur ¨ ve b¨olum¨ q2, kalan ise r2 olur.
b = q2 · r1 + r2
• U¸ ¨ cunc ¨ u¨ olarak r1, r2 ’ye b¨olun¨ ur ¨ ve b¨olum¨ q3, kalan ise r3 olur.
r1 = q3 · r2 + r3
.
.
.
• Son olarak rn−1, rn ’e b¨olun¨ ur ¨ ve b¨olum¨ qn+1, kalan ise rn+1 = 0 olur.
rn−1 = qn+1 · rn + rn+1
• rn+1 = 0 oldu˘gu i¸cin rn de˘geri a ve b tamsayılarının en buy¨ uk¨ ortak b¨oleni olur.
Yani gcd(a, b) = rn dir.
Bu algoritmadaki i¸slemler sonsuza kadar gitmez, c¸unk ¨ u¨ 0 ile a tamsayısı arasında sonlu
sayıda tamsayı vardır.
Ornek ¨ 6.1.8 • gcd(24, 138) ’in sonucu ka¸ctır? gcd(24, 138) = ax + by ifadesinde x
ve y sayıları ka¸c olur?
138 = 5 · 24 + 18
24 = 1 · 18 + 6 ise gcd(24, 138) = 6 dır.
18 = 3 · 6 + 0
62
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
x ve y a¸sa˘gıdaki ¸sekilde bulunur. gcd(24, 138) = 6
6 = 24 − 1 · 18 = 24 − 1 · (138 − 5 · 24)
= 24 − 1 · 138 + 5 · 24 = 6 · 24 − 1 · 138
Yani,
6 = 6 · 24 + (−1) · 138. Buradan x = 6 ve y = −1 bulunur.
• gcd(1547, 560) ’ın sonucu ka¸ctır? gcd(1547, 560) = ax+by ifadesinde x ve y sayıları
ka¸c olur?
1547 = 2 · 560 + 427
560 = 1 · 427 + 133 ise gcd(1547, 560) = 7 dir.
427 = 3 · 133 + 28
133 = 4 · 28 + 21
28 = 1 · 21 + 7
21 = 3 · 7 + 0
x ve y a¸sa˘gıdaki ¸sekilde bulunur. gcd(1547, 560) = 7
7 = 28 − 1 · 21
= 28 − 1 · (133 − 4 · 28) = 28 − 1 · 133 + 4 · 28
= 5 · 28 − 1 · 133 = 5 · (427 − 3 · 133) − 1 · 133
= 5 · 427 − 15 · 133 − 1 · 133 = 5 · 427 − 16 · 133
= 5 · 427 − 16 · (560 − 1 · 427) = 5 · 427 − 16 · 560 + 16 · 427
= 21 · 427 − 16 · 560 = 21 · (1547 − 2 · 560) − 16 · 560
= 21 · 1547 − 42 · 560 − 16 · 560 = 21 · 1547 − 58 · 560
63
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Yani,
7 = 21 · 1547 + (−58) · y. Buradan x = 21 ve y = −58 bulunur.
6.2 Asal Sayılar
Tanım 6.2.1 1 den buy¨ uk¨ olan, 1 ve kendisinden ba¸ska b¨oleni olmayan sayılara asal sayı
denir.
Soru: Verilen bir tamsayının asal sayı olup olmadı˘gı nasıl anla¸sılır?
6.2.1 Eratosthenes Kalburu(The Sieve of Eratosthenes)
Verilen bir tamsayının asal sayı olup olmadı˘gı Eratosthenes Kalburu metodu ile bulunabilir. Verilen tamsayı kendisinden once ¨ gelen her pozitif tamsayıyla b¨olun¨ ur. ¨ E˘ger hi¸c
bir sayıya b¨olunemiy ¨ or ise bu sayıya asal sayı denir.
Metod:
a > 1 bir tamsayı olsun.Bu sayı e˘ger b¨olunebilir ¨ bir sayı ise 1 < b < a , 1 < c < a olmak
uzere ¨ a = b·c ¸seklinde yazılabilir.But ¨ unl ¨ u˘¨gu¨ bozmadan b ≤ c oldu˘gu farzedilsin. O zaman,
b
2 ≤ b · c = a ⇒ b ≤
√
a
Aritmeti˘gin esas teoremini kullanarak b yi b¨olen ve p ≤ b ≤
√
a ko¸sulunu sa˘glayan bir p
sayısı bulunur. Oyle ¨ ki bu p sayısı b yi b¨oldu˘¨gu¨ ve b de a yı b¨oldu˘¨gu¨ i¸cin p a yı da b¨olmu¨¸s
64
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
olur.
Ornek ¨ 6.2.2 • a = 173. a asal mıdır? 13 <
√
173 < 14. 173 sayısını b¨olebilecek asal
sayılar 2, 3, 5, 7, 9, 11, 13 olabilir. Bu sayıların 173 u¨ b¨olup¨ b¨olmedi˘gi kontrol edilir.
Hi¸c birisi 173 sayısını b¨olmedi˘gi i¸cin sayı asal sayıdır.
• 701 ve1009 sayıları asal mıdır? 26 < 701 < 27. 701 sayısını b¨olebilecek asal sayılar
2, 3, 5, 7, 9, 11, 13, 17, 19, 23 olabilir. Bu sayıların 173 u¨ b¨olup¨ b¨olmedi˘gi kontrol edilir.
Hi¸c birisi 701 sayısını b¨olmedi˘gi i¸cin sayı asal sayıdır.
31 < 1009 < 32. 1009 sayısını b¨olebilecek
asal sayılar 2, 3, 5, 7, 9, 11, 13, 17, 19, 23, 29, 31 olabilir. Bu sayıların 1009 u¨ b¨olup¨
b¨olmedi˘gi kontrol edilir. Hi¸c birisi 1009 sayısını b¨olmedi˘gi i¸cin sayı asal sayıdır.
6.3 Eratosthenes Metodu (Method of Eratosthenes)
Bu metod, verilen bir tamsayının altında kalan but ¨ un¨ asal sayıları bulmak i¸cin kullanılır.
Oncelikle ¨ 2 den n ye kadar olan tamsayılar sırasıyla yazılır ve
√
n den ku¸¨cuk¨ ve e¸sit
olan asalların carpanları ¸ (2p, 3p, · · ·) elimine edilir. Listede geri kalan sayılar asal sayıları
g¨osterir.
Ornek ¨ 6.3.1 49 u a¸smayan but ¨ un¨ asalları bulunuz.
65
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
2 3 4 5 6 7 8 9 10
11 12 13 14 15 16 17 18 19 20
21 22 23 24 25 26 27 28 29 30
31 32 33 34 35 36 37 38 39 40
41 42 43 44 45 46 47 48 49
√
49 = 7. B¨oylelikle cevap:2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47 asal sayılarıdır.
6.4 Denklik Teorisi(Theory of Congruence (Modularity))
Tanım 6.4.1 n sabit pozitif bir tamsayı olsun. E˘ger n|a − b ya da bir k tamsayısı i¸cin
a − b = nk e¸sitli˘gi sa˘glanırsa, a b ye mod n e g¨ore denktir denir ve a ≡ b mod n ile
g¨osterilir.
Ornek ¨ 6.4.2 • 1 ≡ 5 mod 4, c¸unk ¨ u¨ 1 − 5 = −4 ve 4| − 4.
• −2 ≡ 9 mod 11, c¸unk ¨ u¨ −2 − 9 = −11 ve 11| − 11.
6.4.1 Teoremler:
1. a ≡ b mod n ⇔ a = bk + n esitli˘gini sa˘glayan bir k vardır.
2. Her tamsayı mod n ye g¨ore 0, 1, 2, · · · , n − 1 sayılarından sadece birine denktir.
3. a ≡ b mod n ⇔ a ve b, n ile b¨olund ¨ u˘¨gunde ¨ aynı kalanı verir.
4. a ≡ a mod n
66
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
5. a ≡ b mod n ⇒ b ≡ a mod n
6. a ≡ b mod n ve b ≡ c mod n ⇒ a ≡ c mod n
7. a ≡ b mod n ve c ≡ d mod n ⇒ a + c ≡ b + d mod n
8. a ≡ b mod n ⇒ a
k ≡ b
k mod n
6.4.2 Aritmetik Tersi
a 6= 0 herhangi bir tamsayı olmak uzere,e˘ ¨ ger a · a
∗ ≡ 1 mod n denkli˘gini sa˘glayan bir a
∗
tamsayısı var ise bu a
∗
sayısına a nın mod n ye g¨ore aritmetik tersi denir.
Teorem 6.4.3 E˘ger gcd(a, n) = 1 ⇒ a nın aritmetik tersi vardır.
Ornek ¨ 6.4.4 gcd(4, 9) = 1 c¸unk ¨ u¨ Oklid ¨ algoritmasına g¨ore, 9 = 4 · 2 + 1 b¨oylece 1 =
4 · 2 − 1 · 9 bulunur.
1 = 4 · 2 + (−1) · 9 ⇒ 4 · 2 ≡ 1 mod 9
Neticede 4 un¨ mod 9 a g¨ore tersi 2 dir.
NOT: a · b ≡ 1 mod m e¸sitli˘ginin sa˘glanması gcd(a, m) = 1 olmasıyla mumk ¨ und ¨ ur. ¨
Teorem 6.4.5 (Fermat’s Little Theorem) E˘ger p asal bir sayı ise ve gcd(a, p) = 1
ko¸sulunu sa˘glıyor ise
a
p−1 ≡ 1 (mod p) denkli˘gi her zaman do˘grudur.
67
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
NOT: a
p−1 ≡ 1 (mod p) ⇒ a
p ≡ a (mod p)
Tanım 6.4.6 E˘ger p ve q, a
p ≡ a (mod p) ile a
q ≡ a (mod q) denkliklerini sa˘glayan farklı
asal sayılar ise a
pq ≡ a (mod pq) dur.
Ornek ¨ 6.4.7 • 2
1000000 ≡ ? (mod 7)
p = 7 p − 1 = 6
1000000 = 6 · 166666 + 4 yani 1000000 ≡ 4(mod6)
B¨oylece
2
1000000 = (26
)
166666
· 2
4 ≡ 1 · 2
4 = 16 ≡ 2 mod 7
• 2
340 ≡ ? (mod 341)
2
11 = 2 · 2
10 ≡ 2 · 1 ≡ 2 mod 31
2
31 = 2 · (210)
3 ≡ 2 · 1
3 ≡ 2 mod 11
⇒ a = 2, p = 11, q = 31
2
11·31 ≡ 2 mod 341
2
341 ≡ 2 mod 341 ⇒ 2
340 ≡ 1 mod 341
6.5 Euler Fi(φ) Fonksiyonu (Euler Phi Function)
Tanım 6.5.1 n ≥ 1 bir tamsayı olsun. φ(n) fonksiyonu, 1 ≤ a ≤ n ve gcd(a, n) =
1 ko¸sulunu sa˘glayan a tamsayılarının sayısını g¨osterir, yani n ye kadar olan ve n ile
68
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
aralarında asal olan sayıların sayısını verir.
Ornek ¨ 6.5.2
Φ(1) = 1
Φ(2) = 1 c¸unk ¨ u¨ gcd(1, 2) = 1
Φ(3) = 2 c¸unk ¨ u¨ gcd(1, 3) = gcd(2, 3) = 1
Φ(4) = 2 c¸unk ¨ u¨ gcd(1, 4) = gcd(3, 4) = 1
Φ(5) = 4 c¸unk ¨ u¨ gcd(1, 5) = gcd(2, 5) = gcd(3, 5) = gcd(4, 5) = 1
NOT: φ(n) = n − 1 ⇔ n bir asal sayı olursa.
Teorem 6.5.3 E˘ger p asal bir sayı ise ve k > 0 ise φ(p
k
) = p
k − p
k−1 = p
k
(1 −
1
p
) dir.
Teorem 6.5.4 (Euler Teoremi) n > 1 ve gcd(a, n) = 1 ise a
φ(n) ≡ 1 mod n
Ornek ¨ 6.5.5 3
φ(8) ≡ 1 mod 8 oldu˘gunu g¨osterin.
• φ(8) = φ(23
) = 2
3 − 2
2 = 4
3
φ(8) = 3
4 = 81 ≡ 1 mod 8
69
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
BOL¨ UM¨ 7
AC¸ IK ANAHTARLI S˙ISTEMLER
Farzedin ki siz e-mail yoluyla ba¸ska bir ki¸siyle haberle¸smek istiyorsunuz ve mesajlarınızın
¸sifreli olmasını istiyorsunuz. Ornek ¨ vermek gerekirse, du¨¸sun¨ un¨ ki ¸sifreleme metodunuz
u¸¨c harf anahtarlı Vigenere olsun. 26 sayı sistemi taban alındı˘gında, bu anahtar 0 ile
262 = 676; 2 lik sistemde 0 ile 1010100100 arasındadır. Sizinle haberle¸sti˘giniz ki¸si
arasındaki bilgisayar a˘gı, internet ve fiber optik kanallar guv¨ enli olmadı˘gı i¸cin, siz anahtarlarınızı e-mail yoluyla de˘gi¸stirmek istemezsiniz. 2 lik anahtarlarınızı a¸cık kanal uzerinden ¨
guv¨ enli bir ¸sekilde de˘gi¸stirme yolları vardır. Algoritma ve karma¸sıklık teorisinde uzmanlar belirli matematik problemlerin c¨¸ozum¨ u¨ i¸cin a¸sırı zaman gerekti˘gine inanıyorlar. A¸cık
anahtarlı kriptosistemler de bu mantı˘ga g¨ore geli¸stirilmi¸stir ; oyle ¨ ki bu kriptosistemlerin
birini kırmak bu zor matematik problemleri c¨¸ozmekle e¸sde˘gerdir.C¸ ok hızlı bilgisayarlar da
programlanmı¸s olan c¨¸ozum¨ metodları bile haftalar, aylar, yuzyıllar ¨ hatta evrenin sonuna
kadar olan hayatı bile kapsayabilir.
7.1 MERKLE-HELLMAN KNAPSACK
KR˙IPTOS˙ISTEM
Knapsack a¸cık anahtarlı ¸sifreleme sistemleri alt kume ¨ toplama problemleri temeline
dayanır. Buradaki temel du¨¸sunce, ¨ c¨¸ozum¨ u¨ kolay olan bir alt kume ¨ toplam problemi
orne˘ ¨ gini se¸cip, onu c¨¸ozum¨ u¨ zor olan bir alt kume ¨ toplama problemi orne˘ ¨ gine cevirerek ¸
70
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
gizlemektir. ˙Ilk(orjinal) knapsack kumesi ¨ gizli anahtarı, d¨onu¨¸stur ¨ ulm¨ u¨¸s(gizlenmi¸s) knapsack kumesi ¨ de kapalı anahtarı olu¸sturur.
Merkle-Helman a¸cık anahtarlı ¸sifreleme ¸seması, sup¨ erartan alt kume ¨ toplama problemi
olarak da adlandırılan kolayca c¨¸ozulebilen ¨ bir alt kume ¨ toplama problemi orne˘ ¨ gini moduler ¨
carpım ¸ ve permutasy ¨ on yoluyla gizleme giri¸simidir.
7.1.1 Sup¨ erartan dizi (Superincreasing sequence)
B = (b1, b2, · · · , bn) dizisinde e˘ger her sayı kendisinden once ¨ gelen sayıların toplamından
buy¨ uk¨ ise ,yani
bi =
Pi−1
j=1 bj oyleki ¨ 2 ≤ i ≤ n,
bu diziye sup¨ erartan dizi denir.
7.1.2 Sup¨ erartan Altkume ¨ Toplama Problemini c¨¸ozme Algoritması
G˙IRD˙I: (b1, b2, · · · , bn) ¸seklinde olan sup¨ erartan bir dizi ve bi
lerin altkumesinin ¨ toplamını
ifade eden s tamsayısı algoritmamızın girdileri olsun.
C¸ IKTI: Elemanları xi ∈ {0, 1} olan ve
Pn
i=n
xibi = s ko¸sulunu sa˘glayan (x1, x2, · · · , xn)
dizi a¸sa˘gıdaki ¸sekilde hesaplanır:
1. i ← n.
2. i ≥ 1 ise a¸sa˘gıdakiler yapılır:
71
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
• E˘ger s ≥ bi
, xi = 1 yazılır ve s ← s−bi uygulanır. Aksi taktirde xi = 0 yazılır.
• i ← i − 1 i¸slemi i = 1 olana kadar surer. ¨
3. Bulunan xi
ler (x1, x2, · · · , xn) dizisini olu¸sturur.
7.1.3 Merkle-HellmanKnapsack S¸ifrelemesinde Anahtar Olu¸sturma Algoritması
Bu kriptosistemde her ki¸si kendi a¸cık anahtarını ve buna ba˘glı gizli anahtarını ¸su ¸sekilde
olu¸sturur:
1. Sistem parametresi olarak sabit bir n tamsayısı alınır.
2. Her A ki¸sisi a¸sa˘gıdaki 3 − 7. adımları uygular.
3. Bir tane sup¨ erartan (b1, b2, · · · , bn) dizisi ve M > b1 + b2 + · · · + bn ¸sartını sa˘glayan
bir M mod sayısı se¸cer.
4. 1 ≤ W ≤ M − 1 ve gcd(W, M) = 1 ko¸sullarını sa˘glayan rastgele bir W tamsayısı
se¸cer.
5. {1, 2, · · · , n} tamsayılarıyla ifade edilen rastgele bir π permutasy ¨ onu se¸cer.
6. i = 1, 2, · · · , n de˘gerleri i¸cin ai = Wbπi mod M ifadelerini hesaplar.
7. A’nın a¸cık anahtarı (a1, a2, · · · , an); A’nın kapalı anahtarı ise
(π, M, W,(b1, b2, · · · , bn)) olur.
72
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
7.1.4 Basit Merkle-Hellman Knapsack A¸cık Anahtar S¸ifreleme Algoritması
B ¸sahsı A i¸cin m mesajını ¸sifreliyor olsun.
1. S¸ifreleme: B, ¸sunları yapar:
• A’nın a¸cık anahtarı (a1, a2, · · · , an) i alır.
• m mesajını n uzunlu˘gundaki 2 lik dizi,m = m1m2 · · · mn, olarak ifade eder
• Daha sonra c = m1a1 + m2a2 + · · · + mnan de˘gerini hesaplar.
• Olu¸san kapalı metni A’ya g¨onderir.
2. De¸sifreleme: c kapalı metnine kar¸sılık gelen m a¸cık metnini c¨¸ozmek i¸cin A ¸sunları
yapar:
• Oncelikle ¨ d = W−1
c mod M de˘gerini hesaplar.
• Sup¨ erartan altkume ¨ toplam problemini c¨¸ozerek, d = r1b1 + r2b2 + · · · + rnbn
e¸sitli˘gini sa˘glayan r1, r2, · · · , rn ri ∈ {0, 1} tamsayılarını bulur.
• Mesaj bitleri mi = rπ(i)
, i = 1, 2, · · · , n dir.
Ornek ¨ 7.1.1 Anahtar Olu¸sturma: n = 6 olsun. A ¸sahsı (12, 17, 33, 74, 157, 316)
sup¨ erartan bir dizi ve M = 737 > 12 + 17 + 33 + 74 + 157 + 316 = 609 tamsayısı
se¸cer. Daha sonra gcd(W = 635, M = 737) = 1 ko¸sulunu sa˘glayan bir W = 635 sayısını
se¸cer. Son olarakta {1, 2, · · · , 6} sayılarından olu¸sup π(1) = 3, π(2) = 6, π(3) = 1,
π(4) = 2, π(5) = 5, π(6) = 4 leri sa˘glayan bir π permutasyonunu ¨ alır. A a¸cık anahtarını
73
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
ai = Wbπi mod M e¸sitli˘gini kullanarak ¸su ¸sekilde olu¸sturur:
a1 = Wbπ(1) = Wb3 = 635 · 33 mod 737 ≡ 319
a2 = Wbπ(2) = Wb6 = 635 · 316 mod 737 ≡ 196
a3 = Wbπ(3) = Wb1 = 635 · 12 mod 737 ≡ 250
a4 = Wbπ(4) = Wb2 = 635 · 17 mod 737 ≡ 477
a5 = Wbπ(5) = Wb5 = 635 · 157 mod 737 ≡ 200
a6 = Wbπ(6) = Wb4 = 635 · 74 mod 737 ≡ 559
B¨oylece A’nın a¸cık anahtarı (319, 196, 250, 477, 200, 559) knapsack dizisidir. A’nın gizli
anahtarı ise (π, M, W,(12, 17, 33, 74, 157, 316)) dır.
S¸ifreleme: B, m = 101101 mesajını ¸s¨oyle ¸sifreler:
c = 1 · 319 + 0 · 196 + 1 · 250 + 1 · 477 + 0 · 200 + 1 · 559
= 319 + 250 + 477 + 559 = 1605
ve bunu A’ya g¨onderir.
De¸sifreleme: Mesajı c¨¸ozmek i¸cin A, d = W−1
c mod M de˘gerini hesaplar ve sup¨ erartan
altkume ¨ toplama problemini c¨¸ozer. Onc ¨ elikle W−1 = 635−1 ≡ 513 mod 737, ikinci olarak
d = W−1
c = 513 · 1605 ≡ 136 mod 737 de˘gerlerini bulur.
136 = 12 · r1 + 17 · r2 + 33 · r3 + 74 · r4 + 157 · r5 + 316 · r6
= 12 + 17 + 33 + 74
B¨oylelikle r1 = 1, r2 = 1, r3 = 1, r4 = 1, r5 = 0, r6 = 0 ve π nin permutasyonunun ¨
uygulanmasıyla mesaj bitleri m1 = r3 = 1, m2 = r6 = 0, m3 = r1 = 1, m4 = r2 = 1,
m5 = r5 = 0, m6 = r4 = 1 bulunur.
74
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
7.2 RSA Kriptosistem
RSA kriptosistem, 1978 yılında ” Dijital imza elde etme metodu ve a¸cık anahtarlı kriptosistemler” adlı bir makale ile yayınlandı. Adını yaratıcılarının (Ronald Rivest,Adi Shamir,
Leonard Adleman) soyadlarının ba¸sharflerinden alan RSA kriptosistem, g¨ondericinin bir
metodla ve herkes¸ce bilinen a¸cık bir anahtarla mesajlarını ¸sifreledi˘gi bir ¸sifre sistemi olarak
tanımlanır. Daha onceki ¨ gizli(simetrik) anahtarlı sistemlerin tersine anahtarı bilmek
de¸sifre anahtarını ortaya cık ¸ armaz. Bu sistem hem gizlilik hem de dijital imza sa˘glamak
ama¸clı kullanılabilir. Bu sistemin guv¨ enli˘gi tamsayılarda carpanlara ¸ ayırma probleminin
kolaylıkla olmaması temeline dayanır.
RSA kriptosisteminde ki¸silere ¸sifreli mesaj g¨onderilebilmesi i¸cin o ki¸silerin a¸cık anahtarlarına ihtiya¸c vardır. Mesajı alan ki¸sinin de mesajı okuyabilmesi i¸cin gizli bir anahtarının
olması gerekir.Anahtar olu¸sturma a¸s˘gıdaki algoritmada ifade edilmi¸stir.
Anahtar Olu¸sturma algoritması: Her A ki¸sisi anahtarını ¸su ¸sekilde olu¸sturur:
•
˙Iki tane farklı,rasgele ve yakla¸sık aynı uzunlukta olan p ve q asal sayıları se¸cer.
• n = pq ve φ = (p − 1)(q − 1) de˘gerlerini hesaplar.
• 1 < e < φ ve gcd (e, φ) = 1 olacak ¸sekilde rastgele bir e sayısı se¸cer.
• Oklid ¨ algoritmasını kullanarak, 1 < d < φ ve ed ≡ 1 ( mod φ) ko¸sulunu sa˘glayan d
sayısını hesaplar.
• A’nın a¸cık anahtarı (n, e); A’nın gizli anahtarı ise d olur.
75
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
RSA anahtar olu¸sumunda e ve d tamsayıları sırasıyla ¸sifreleme uss ¨ un¨ u¨ ve de¸sifreleme
uss ¨ un¨ u¨ ve n ise mod sayısını g¨osterir. p ve q sayılarının onluk sistemde uzunluklarının
100 ve dolayısıyla da n nin uzunlu˘gunun 200 olması beklenir. Fakat verilecek orneklerde ¨
kolaylık olması a¸cısından ku¸¨cuk¨ sayılar se¸cilecektir.
S¸ifreleme Algoritması:
1. B ¸sahsı, A’ya bir m mesajı g¨ondermek istiyor. B, m mesajını ¸sifrelemek i¸cin
a¸sa˘gıdakileri yapar:
• Oncelikle ¨ A’nın a¸cık anahtarını (n,e) alır.
• m mesajını [0, n − 1] aralı˘gında yazar.
• Sonra c ≡ me
( mod n) de˘gerini hesaplar.
• Olu¸san c ¸sifresini A’ya g¨onderir.
2. S¸ifreli c metninden a¸cık metni bulabilmek i¸cin A a¸sa˘gıdaki i¸slemi uygular:
• d gizli anahtarını kullanarak ve m ≡ c
d
( mod n) i¸slemini uygulayarak m a¸cık
metine ula¸sır.
NOT: De¸sifre sisteminin calı ¸ ¸smasına
ed ≡ 1 ( mod φ) oldu˘gu i¸cini ed = 1 + kφ e¸sitli˘gini sa˘glayan mutlaka bir k tamsayısı
bulunur. E˘ger gcd (m, p) = 1 ise Fermat teoreminden dolayı
mp−1 ≡ 1 ( mod p).
76
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
E˘gere bu denkli˘gin her iki tarafının da k(q − 1)’inci kuvvetlerini alırsak
mk(p−1)(q−1) ≡ 1 ( mod p).
olur ve her iki tarafı da m ile carptı˘ ¸ gımızda
m1+k(p−1)(q−1) ≡ m ( mod p).
sonucuna ula¸sırız.
Di˘ger tarfatan, e˘ger gcd (m, p) = p olursa yukarıdaki denklik yine ge¸cerli olur; c¸unk ¨ u¨
farzedelim belli bir k tamsayısı i¸cin m = kp olsun
mp−1 = (kp)
(p−1) = k
(p−1)p
(p−1) ≡ p ( mod p).
E˘ger bu denkli˘gin her iki tarafının da k(q − 1)’inci kuvvetlerini alırsak
mk(p−1)(q−1) ≡ p
k(p−1)(q−1) ≡ p ( mod p).
olur ve her iki tarafı da m ile carptı˘ ¸ gımızda
m1+k(p−1)(q−1) ≡ mp = kp
2 ≡ kp = m ( mod p).
˙Iki durumda da
med ≡ m ( mod p)
oldu˘gu g¨orul ¨ ur. ¨ Aynı ¸sekilde,
med ≡ m ( mod q)
olur.
77
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Sonu¸cta p ve q farklı asal sayılar ol˘gu i¸cin,
med ≡ m ( mod n)
dir.B¨oylelikle,
c
d = me
d
≡ m ( mod n)
Ornek ¨ 7.2.1 1. Anahtar olu¸sturma: A ¸sahsı p = 2357 ve q = 2551 olan iki tane
asal sayı se¸cmi¸s olsun. Onc ¨ elikle A,
n = pq = 6012707
ve
φ = (p − 1)(q − 1) = 6007800
de˘gerlerini hesaplar. A bir tane e = 3674911 de˘geri se¸cer.Bu e de˘geri, gcd(e =
3674911, φ = 6007800) = 1 ve 1 < e = 3674911 < φ = 6007800 ko¸sullarını sa˘glar.
Daha sonra Oklid ¨ algoritmasını kullanarak
e · d ≡ 1 (mod φ)
3674911 · d ≡ 1 (mod 6007800)
d = 422191 de˘gerini hesaplar. A’ nın a¸cık anahtarı (n = 6012707, e = 3674911);
gizli anahtarı da d = 422191 olur.
2. S¸ifreleme: B, m = 5234673 mesajını ¸sifrelemek i¸cin A’nın a¸cık anahtarını,yani
(n = 6012707, e = 3674911), alır ve a¸sa˘gıdaki ¸sekilde oldu˘gu gibi kapalı metin c ’yi
78
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
hesaplar:
c ≡ me
(mod n) = 52346733674911 (mod 6012707) ≡ 3650502
ve bu de˘geri A’ya g¨onderir.
3. De¸sifreleme: A, gelen c kapalı metninden m a¸cık metni a¸sa˘gıdaki gibi hesaplar:
m ≡ c
d
(mod n) = 3650502422191 (mod 6012707) ≡ 5234673
7.3 RSA ˙Imza S¸eması
RSA kriptosistemi dijital imzalar i¸cin de kullanılabilir. (n, e) A ¸sahsının a¸cık anahtarı,
d sayısı da A’nın gizli de¸sifreleme uss ¨ u¨ olsun.Oncelikle ¨ mesajın imzalanabilmesi i¸cin m
mesajının {0, 1, · · · , n − 1} arasında olması istenir, daha sonra hesaplamalar yapılır.
7.3.1 ˙Imzalama
A B’ye imzalı m mesajını g¨ondermek isterse, mesaja kendisinin kapalı anahtarını uygular,yani
σ = md mod n.
Daha sonra (m, σ) imzalı mesajı B’ye g¨onderir.
79
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
7.3.2 ˙Imzayı Do˘grulama
B, A’dan aldı˘gı (m, σ) imzalı mesajı do˘grulamak i¸cin
m = σ
e mod n
de˘gerini hesaplar. C¸ ıkan sonu¸c m ise mesaj do˘grulanmı¸s olur.
Ornek ¨ 7.3.1 Anahtar Olu¸sturma: A ki¸sisi p = 7927 ve q = 6997 asal sayılarını se¸cer
ve, n = pq = 55465219 ve φ = 7926 · 6996 = 55450296 de˘gerlerini hesaplar. Daha sonra
A, ed = 5d ≡ 1 (mod 55450296) e¸sitli˘ginden d = 44360237 sayısını bulur. A’nın a¸cık
anahtarı (n = 55465219, e = 5); gizli anahtarı d = 44360237 olur.
˙Imzalama: m = 31229978 mesajını imzalamak i¸cin A ¸sunu hesaplar:
σ = md mod n = 3122997844360237 mod 55465219 ≡ 30729435
ve (m = 31229978, σ = 30729435) ’yi B’ye g¨onderir.
˙Imzayı Do˘grulama: (m = 31229978, σ = 30729435)’yi alan B mesajı do˘grulamak i¸cin
¸sunu yapar:
m = σ
e mod n = 307294355 mod 55465219 ≡ 31229978
C¸ ıkan sayı m oldu˘gu i¸cin imza do˘grulanmı¸s olur.
80
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
7.4 Ayrık Logaritma(Discrete Logarithm)
RSA kriptosisteminde, RSA fonksiyonu m olan bir elemanın e. kuvvetini olu¸sturur. Bu
fonksiyon birebir bir fonksiyondur ve etkili bir ¸sekilde hesaplanır.E˘ger n nin carpanlara ¸
ayrımı bilinmiyorsa, e. k¨oku¨ hesaplamak i¸cin etkili bir algoritma yoktur. Sayılar teorisinde
hesaplaması kolay fakat tersinin hesaplaması zor olan ba¸ska fonksiyonlar da vardır. Bunlardan en onemlilerinden ¨ biri de sınırlı alanlar da (finite fields) kuvvet almadır. Basit
olarak sadece asal alanlar (prime fields) du¨¸sun¨ ulecektir. ¨
p bir asal sayı ve g de Z
∗
p de bir primitif k¨ok olsun. Ayrık kuvvet fonksiyonu (discrete
exponential function)
Exp : Zp−1 → Z
∗
p
, x 7→ g
x
,
tekrarlı karesini alma algoritması orne˘ ¨ ginde oldu˘gu gibi etkili bir ¸sekilde hesaplanabilir.
Kuvvetin logaritması fonksiyonunun tersini hesaplamak i¸cin etkili bir algoritma bilinmemektedir. Bu tahmine ayrık logaritma tahmini (discrete logarithm assumption) denir.
7.5 El-Gamal A¸cık Anahtarlı Kriptosistem
ElGamal a¸cık anahtarlı ¸sifre sistemi,anahtar transferi modunda Diffie-Hellman anahtar
anla¸sması(Diffie-Hellman Key Agreement) olarak g¨orulebilir. ¨ Guv¨ enilirli˘gi ayrık logaritma problemi ve Diffie-Helman probleminin kolay c¨¸ozulememesi ¨ temeline dayanır. Temel
ElGamal ve genelle¸stirilmi¸s ElGamal ¸sifreleme ¸seması bu b¨olumde ¨ tanımlanmı¸stır.
81
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
7.6 ElGamal A¸cık Anahtarlı S¸ifrelemede Anahtar Olu¸sturma Algoritması
Her ki¸si kendi a¸cık anahtarını ve buna ba˘glı gizli anahtarını olu¸sturur. Bunu olu¸sturmak
i¸cin A ¸sahsı ¸sunları uygular:
1. C¸ ok buy¨ uk¨ rastgele bir p asal sayısı ve mod p ye g¨ore tamsayıların olu¸sturdu˘gu
carpım ¸ grubu Z
∗
p nin bir jenerat¨oru¨ α yı olu¸sturur.
2. 1 ≤ a ≤ p − 2 ¸seklinde olan bir a tamsayısı se¸cer ve α
a mod p de˘gerini hesaplar.
3. A’nın a¸cık anahtarı (p, α, α
a
); A’nın gizli anahtarı ise a olur.
7.6.1 ElGamal A¸cık Anahtarlı S¸ifreleme
Algoritması
B ¸sahsı A i¸cin m mesajını ¸sifrelesin.
1. S¸ifreleme: B mesajı ¸sifreleme i¸cin ¸sunları yapar:
• A’nın a¸cık anahtarını (p, α, α
a
) alır.
• mesajı {0, 1, · · · , p − 1} aralı˘gında m tamsayısı olarak ifade eder.
• 1 ≤ k ≤ p − 2’yi sa˘glayan rastgele bir k tamsayısı se¸cer.
• γ = α
k mod p ve δ = m · (α
a
)
k mod p de˘gerlerini hesaplar.
• Son olarak c = (γ, δ) kapalı metnini A’ya g¨onderir.
2. De¸sifreleme: c kapalı metninden m a¸cık metine ula¸smak i¸cin A ¸sunları yapar:
82
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
• a gizli anahtarını kullanarak γ
−a mod p de˘gerini hesaplar (γ
−a = α
−ak mod p).
• γ
−a
· δ mod p de˘gerini hesaplayarak m’yi bulur.
γ
−a
· δ ≡ α
−ak
· mαak ≡ m (mod p)
Ornek ¨ 7.6.1 Anahtar Olu¸sturma: A ¸sahsı bir p = 2357 asal sayısı ve α = 2 ∈ Z
∗
∈357
bir jenerat¨or se¸cer. Buna ilave olarak bir a = 1751 gizli anahtarı se¸cer ve
α
a mod p = 2
1751 mod 2357 ≡ 1185
de˘gerini hesaplar. A’nın a¸cık anahtarı (p = 2357, α = 2, α
a = 1185) tir.
S¸ifreleme: m = 2035 mesajını ¸sifrelemek i¸cin B ¸sahsı rastgele bir k = 1820 tamsayısı
se¸cer ve
γ = 2
1520 mod 2357 ≡ 1430
ve
δ = 2035 · 11851520 mod 2357 ≡ 697
de˘gerlerini hesaplar. Son olarak B (γ = 1430, δ = 697) ’yi A’ya g¨onderir.
De¸sifreleme: A gelen kapalı metni c¨¸ozmek i¸cin
γ
−a = 1430−1750 ≡ 1430605 mod 2357 ≡ 872
bulur ve m mesajına da
m = 872 · 697 mod 2357 ≡ 2035
83
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
b¨oylece ula¸sır.
7.6.2 ElGamal ˙Imzası
ElGamal kriptosisteminde imza RSA ’da oldu˘gu gibi mesajın do˘gru ki¸siden geldi˘gini kontrol etmek i¸cin kullanılır. Sadece kapalı metin yerine imzalanmı¸s kapalı metin g¨onderilerek
o kapalı metnin istenen ki¸siden gelip gelmedi˘gi de kontrol edilmi¸s olur. A ¸sahsının a¸cık
anahtarı (p, α, α
a = y) ve gizli anahtarının da a oldu˘gu du¨¸sun¨ uls ¨ un. ¨
7.6.3 ˙Imza Algoritması
m mesajının Zp nin bir elemanı oldu˘gu du¨¸sun¨ ul ¨ ur.E˘ ¨ ger de˘gilse hash fonksiyonu kullanılarak m mesajının Zp nin elemanı olması sa˘glanır. A ¸sahsı m mesajını ¸su ¸sekilde
imzalar:
1. Rastgele bir t tamsayısı se¸cer oyleki ¨ 1 ≤ t ≤ p − 2 ve gcd(t, p − 1) = 1 ko¸sulunu
sa˘glamalıdır.
2. r = α
t ve s = t
−1
(m − ra) mod (p − 1) e¸sitliklerini kurar.
3. (m, r, s) A’nın imzalı mesajıdır.
7.6.4 Do˘grulama
(m, r, s) imzalı mesajı alan B ¸sahsı aldı˘gı mesajın A’dan geldi˘gini ¸su ¸sekilde do˘grular:
84
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
1. Oncelikle ¨ 1 ≤ r ≤ p − 1 oldu˘gunu kontrol eder.E˘ger de˘gilse imzayı reddeder.
2. Daha sonra v = α
m ve w = y
r
r
s de˘gerlerini hesaplar (Buradaki y sayısı A’nın a¸cık
anahtarındaki y sayısıdır. )
3. E˘ger v = w e¸sitli˘gi sa˘glanıyorsa imza kabul edilir, aksi taktirde reddedilir.
Ornek ¨ 7.6.2 Anahtar Olu¸sturma: A ¸sahsı bir p = 2357 asal sayısı ve α = 2 ∈ Z
∗
∈357
bir jenerat¨or se¸cer. Buna ilave olarak bir a = 1751 gizli anahtarı se¸cer ve
α
a mod p = 2
1751 mod 2357 ≡ 1185
de˘gerini hesaplar. A’nın a¸cık anahtarı (p = 2357, α = 2, α
a = 1185) tir.
˙Imza Olu¸sturma: Basit olması a¸cısından mesaj m = 1463 olarak se¸cilsin (E˘ger mesaj
p asal sayısından buy¨ uk¨ olsaydı hash fonksiyonundan ge¸cirilirdi). m = 1463 mesajını
imzalamak i¸cin A onc ¨ e rastgele bir t = 1529 sayısı se¸cer, daha sonra
r = α
t mod p = 2
1529 mod 2357 ≡ 1490
ve
t
−1 mod (p − 1) = 1529−1 mod (2356) ≡ 245
s = t
−1
(m − ra) mod (p − 1) = 245(1463 − 1490 · 1751) mod 2356 ≡ 1777
A’nın imzası (m = 1463, r = 1490, s = 1777)
85
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
˙Imzayı Do˘grulama: B aldı˘gı imzalı mesajı do˘grulamak i¸cin onc ¨ e
v = α
m mod p = 2
1463 mod 2357 ≡ 1072
de˘gerini hesaplar. Daha sonra
w = y
r
r
s mod p = 1185149014901777 mod 2357 ≡ 1072
de˘gerini hesaplar ve v = w oldu˘gu i¸cin imzayı kabul eder.
7.7 Diffie-Hellman Anahtar Anl¸sması (Diffie-Hellman Key Agreement)
Diffie-Hellman anahtar anla¸sması, anahtar da˘gıtma problemine ilk pratik c¨¸ozumd ¨ ur. ¨
Us ¨ olarak anahtar de˘gi¸stirme olarak da bilinen bu sistem daha once ¨ hi¸c haberle¸sme
sa˘glamamı¸s iki tarafın a¸cık kanal uzerinden ¨ mesajlarını birbirlerine g¨ondererek ortak bir
anahtar yaratma temeline dayanır.
p yeteri kadar buy¨ uk¨ bir asal sayı olsun oyleki ¨ Z
∗
p de discrete logaritma problemini c¨¸ozmek
mumk ¨ un¨ olmasın. g’de Z
∗
p de primitif bir k¨ok (primitive root) olsun. p ve g herkes
tarafından bilinsin. A ve B ki¸sileri a¸sa˘gıdaki yolu izleyerek ortak bir anahtar yaratabilirler:
7.7.1 Diffie-Hellman Anahtar Anla¸sması Algoritması:
• A, 0 ≤ a ≤ p − 2 e¸sitsizli˘gini sa˘glayan ve tesadufi¨ olan bir a sayısı se¸cer. c = g
a
’yı
bulur ve bunu B’ye g¨onderir.
• A, 0 ≤ b ≤ p − 2 e¸sitsizli˘gini sa˘glayan ve tesadufi¨ olan bir b sayısı se¸cer. d = g
b
’yi
bulur ve bunu A’ya g¨onderir.
86
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
• A, ortak anahtar k’yı ¸su ¸sekilde hesaplar:
k = d
a = (g
b
)
a
• B, ortak anahtar k’yı ¸su ¸sekilde hesaplar:
k = c
b = (g
a
)
b
B¨oylelikle A ve B aralarında ortak bir anahtar olan k i¸cin anla¸smı¸s olurlar.
87
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
BOL¨ UM¨ 8
KR˙IPTANAL˙IZ
Kriptanaliz (Kripto-analiz) b¨olum¨ unde ¨ modern kripto sistemleri i¸cerisinde onemli ¨ bir sınıf
te¸skil eden simetrik anahtarlı sistemler olarak bilinen blok ¸sifrelerin ve akan ¸sifrelerin
analizi g¨orulecektir. ¨ Kerckhoff’s prensibi : Kripto-analizci ¸sifreleme algoritmasının
but ¨ un¨ detaylarına ula¸sma guc¨ une ¨ sahiptir ve sistemde sadece anahtar gizlidir.
Bu prensibe g¨ore tasarlanmı¸s ve hala guv¨ enli oldu¯gu kabul edilen bir¸cok algoritma
gun¨ um¨ uzde ¨ mevcuttur.
˙Ikinci Dun¨ ya Sava¸sında Polonyalı ve
˙Ingiliz matematik¸ciler Alman Enigma ¸sifreleme makinasının analizini yaparak algoritmayı kırmı¸slardır ve Alman kapalı metinlerini kriptoanaliz y¨ontemi ile a¸cmı¸slardır. Farklı bir algoritma olan ve belli bir sure ¨ guv¨ enli olarak
kabul edilmi¸s olan RC4 algoritması ”tersine giderek” (reverse engineering) ile kırılmı¸stır.
• Analizcinin amacı herhangi bir algoritma kullanılarak kapatılmı¸s metinlerin a¸cık
halini elde edebilmektir. Genellikle bu amaca algoritmada kullanılan gizli anahtarın
tamamı veya belli bir kısmı elde edilerek ula¸sılır.
• Analiz y¨onteminin ne kadar kuvvetli ve efektif oldu¯gu analiz i¸cin gerekli olan on¨ bilgi
ve yapılacak i¸s miktarı ile ol¸ ¨ cul ¨ ur ¨ ( bilinmesi gerekenler a¸cık-kapalı metin ciftlerinin ¸
sayısı, harcanan zaman, ata¯gın ba¸sarı oranı dır).
88
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Atak C¸ e¸sitleri (Senaryoları) :
• Sadece S¸ifreli Metin Ata˘gı (Ciphertext-Only) : En gu¸¨clu¨ kripto-analitik atakdır.
Sadece haberle¸sme pasif olarak dinlenip (mudahale ¨ edilmeden)yeterince kapalı metin
elde edilerek yapılabilir.
• Bilinen A¸cık Metin Ata˘gı (Known Plaintext): Bir miktar a¸cık-kapalı metin cifti ¸
bilinerek yapılan ataktır. Mesajların bir kısmı tahmin edilebilir veya a¸cık g¨onderilen
mesajlar toplanarak atak uygulanabilir.
• Se¸cilmi¸s A¸cık Metin Ata˘gı (Chosen Plaintext): Analizcinin istedi¯gi (se¸cti¯gi)
metni ¸sifreleme imkanına sahip oldu¯gu kabul edilen atak senaryosudur. Analizci ¸sifreleme algoritmasının guv¨ enli olarak yerle¸stirildi¯gi mekanizmayı elde edebilir.
Analizci aktif olarak haberle¸sme sisteminde rol alır.
• Se¸cilmi¸s Kapalı Metin Ata˘gı (Chosen Ciphertext): De¸sifreleme makinasına
ula¸sılarak yapılan atak ce¸ ¸sitidir. Bir onceki ¨ senaryoya benzemektedir.
• Se¸cilmi¸s A¸cık veya Kapalı Metin Ata˘gı (Adaptive Chosen Plaintext or Ciphertext): Bu atak senaryosunda analizcinin istedi¯gi mesajı a¸cma veya kapatma
konusunda sınırsız kapasiteye sahip oldu¯gu kabul edilir. Onceki ¨ iki senaryonun teorik
olarak daha gu¸¨clendirildi¯gi atak ce¸ ¸sitidir.
89
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
8.1 Kriptanalitik Atakların Ama¸cları
Ayıran Ataklar (Distinguishing Attacks) Ayıran Atakların ba¸sarılı olabilmesi i¸cin
¸sifre sisteminin cıktısını ¸ rastgele bir permutasyonun cıktısından ¸ ayırılaması olası olmalıdır.
Kısmi a¸cık metin bilgisi (Partial Knowledge of the Plaintext) Bu atakta kısmi
a¸cık metin bilgisine ( S¸ifre sisteminin girdisi i¸cin herhangi tahmin) sahip olunur.
De¸sifreleme (Decryption) Bu durumda saldıran ¸sifrelenmi¸s trafi˘gin bir kısmını de¸sifre
etme yetene˘gine sahiptir.
S¸ifreleme (Encryption(Forgery))
Bu durumda saldıran anlamlı mesajları bilinmeyen gizli anahtar ile ¸sifreleme olana˘gına
sahiptir. Bu gizli anahtar bilgisine sahip oldu˘gu anlamına gelmez. Bu ata˘ga meyilli
olan ¸sifre sistemleri ger¸cekli˘gini kanıtlama/kimlik belirtme i¸slemlerinde kullanım i¸cin
uygun de˘gillerdir.
Kısmı Anahtar Edinimi (Partial Key Recovery) Bu atakta gizli anahtarın belli
bir kısmı saldıran tarafından ele ge¸cirilir. Belki bu anahtarın geriye kalan kısmı cok ¸
buy¨ uk¨ olabilir fakat bu arzulanan bir durum de˘gildir. C¸unk ¨ u¨ tum¨ anahtarın genellikle ele
ge¸cirilmesi i¸cin ilk basamaktır.
Tum¨ Anahtar Edinimi (Total Key Recovery) Bir kriptosistem i¸cin en korkun¸c
kriptanalitik atak ce¸ ¸sidir.
90
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
8.2 Kriptanaliz Metodları(Methods of Cryptanalysis)
E˘ger ¸sifre sistemi temiz ve basit bir yapıya sahip ise hala kalem ve ka˘gıt kriptanalistin elindeki en gu¸¨clu¨ silahlardır. Bir cok ¸ durumda ka˘gıt analizi bilgisayar analizinden
gelen geribildirimlere (¨ozel istatiksel ozellikler ¨ ve duzensizlikler ¨ arama gibi) ihtiya¸c duyar. Ara¸stırmacı bakı¸s a¸cısından bir ¸sifre sistemi kırıldı˘gının dile getirilmesi, bu sistemin
dizaynı de˘gi¸stirmeye yol a¸cacak bir zayıflı˘gının bulunması demektir. Bu de˘gi¸siklik, ek
d¨ongulerin ¨ eklenmesi veya d¨ongu¨ anahtarlarını olu¸sturan algoritmanın ve bazı i¸c yapıların
de˘gi¸smesi anlamına gelebilir. S¸ifre sisteminin tamamen kırılması ise bu tur ¨ sistemi tamir
etmek yerine ba¸stan tasarlamanın daha anlamlı veya kolay oldu˘gu durumlardır. Tipik
kriptanaliz metodlarını ¸s¨oyle sıralayabiliriz:
Etraflı Arama (Exhaustive Search) Etraflı Arama, ¸sifre sistemleri uzerine ¨ en a¸cık
ve en do˘grudan uygulanabilir bir methodur. Tum¨ olası gizli anahtarları bilinen kısa
a¸cık/kapalı metin ornekleri ¨ uzerinde ¨ dener. Do˘gru gizli anahtar bilinen a¸cık bir metinden
do˘gru kapalı metinin elde edilmesini sa˘glar. Gun¨ um¨ uz¨ hesaplama imkanlarına g¨ore
modern blok ¸sifre sistemlerinin anahtar uzunlukları (128-bit ve yukarısı) bu tip ata˘gı
imkansız kılacak ¸sekilde se¸cilmektedir. DES in en onemli ¨ zayıflı˘gı 56-bit olan kısa anahtar
uzunlu˘gudur ve gun¨ um¨ uz¨ ko¸sulları du¨¸sun¨ uld ¨ u˘¨gunde ¨ bu anahatar uzunlu˘gu etraflı aramayı
mumk ¨ un¨ kılmaktadır.
S¨ozluk¨ Atakları (Dictionary Attacks)
Bu da basit fakat blok ¸sifre sistemleri i¸cin onemli ¨ bir atak ce¸ ¸sidir. E˘ger ¸sifrelenen
metinlerin uzunlukları kısa ise saldıran bir¸cok metin toplar ve farklı metinlerin tekrar91
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
lama analizini yapar. En u¸c noktada bu ata˘ga zayıf ¸sifre sistemi basit de˘gi¸stirmeli ¸sifre
sistemidir (simple substitution cipher).
E¸s Tanımlama (Equivalent Description)
Bazen ¸sifre sistemi tasarlayanlar sistemin veya par¸calarının basit e¸sde˘ger tanımlarını
g¨ozden ka¸cırırmaları, bu atak tarafından s¨omur ¨ ul ¨ ur. ¨
De˘gi¸smezler i¸cin Devirlilik veya Arama (Periodicity or Search for Invariants)
De˘gi¸smezler, ¸sifreleme boyunca de˘gi¸smeyen ozellikler ¨ olarak du¨¸sunelebilir ¨ ve ¸sifre sisteminin istenilmeyen bir ozelli˘ ¨ gidir. E˘ger kriptanalist sistemin herhangi de˘gi¸smezini yada
yakınsamasını bulmayı ba¸sarırsa bir ayıran atak i¸cin malzeme edinmi¸s olur. Her ce¸ ¸sit
devirli davranı¸s veya ¸sifrelenmeler arasındaki korelasyon mutlaka engelllemelidir.
Do˘gum Gun¨ u¨ Paradoks (Birthday Paradox) Blok ¸sifreleme sistemlerinden a¸cık
anahtar ¸sifre sistemlerine uzunan sayılamıyacak kadar onemli ¨ bir olasılıklı paradoksudur.
Ortada bulu¸sma Ata˘gı (Meet-in-the-Middle Attack) Bu metod ¸sifreleme sistemini
alt ve ust ¨ olmak uzere ¨ b¨oler. Sonra kısmi tahmini ile yukarıdan ortaya ve ba¸stan ortaya
kısmi de¸sifreleme yapar. Sonu¸c kar¸sıla¸stırılır ve e˘ger uyumlu ise aday anahtar saklanır.
Aksi takdirde tahmin edilen anahtar yanlı¸s olur.
˙Istatiksel Yakla¸sımlar (Statistic Approaches)
Bu metodlar kapalı ve a¸cık metin arası ili¸ski veren istatiksel ornekleri ¨ arar. Bir tur ¨ ayıran
ataktır ve di˘ger ataklar i¸cin ilk adımdır. ˙Istatiksel yakla¸sımlar hem olu¸sması yuksek ¨
olasılıkta olayları hem de ger¸cekle¸smesi imkansız olayları bulmaya y¨oneliktir.
92
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Ozel ¨ bir Ata˘ga g¨ore Zayıf Anahtarlar (Weak Keys with Respect to a Particular
Attack)
Bazı durumlarda bir zayıf anahtar kumesinin ¨ bir ¸sifre sisteminin analizini ozel ¨ bir atak
modelini du¨¸sun¨ uld ¨ u˘¨gunde ¨ kolayla¸stırması mumk ¨ un¨ olmaktadır. E˘ger bir kriptosistemin
tum¨ anahtar uzayına g¨ore yuksek ¨ bir oranda zayıf anahtarlara sahip ise tekrar dizayn
edilmesi bile s¨oz konusu olabilir.
Ornek ¨ olarak DES te d¨ort tane zayıf ve oniki tane yarı-zayıf anahtar bulunmaktadır.
Gizli anahtar K olmak uzere ¨ DES i EK olarak tanımlarsak d¨ort tane zayıf anahtar i¸cin
EK(EK(m)) = m ve oniki tane yarı-zayıf anahtardan iki tanesi i¸cin EK1(EK2(m)) = m
sa˘glanmaktadır. IDEA blok ¸sifre sistemi i¸cin 2
128 anahtar uzayı uzerinde ¨ 2
63 elemana
sahip bir zayıf anahtar kumesi ¨ bulunmaktadır.
8.3 Akan S¸ifrelerin Analizi
˙Iyi bir akan ¸sifre algoritması bilinen a¸cık metin ata¯ga kar¸sı dayanıklı olmalıdır. Genel
olarak akan ¸sifrelerin olu¸sturulmasında temel yapı ta¸sları olarak LFSR’lar kullanılır ve
gizli anahtar (secret key) LFSR’ların ba¸slangı¸c konumları olarak (initial state) se¸cilir.
Akan ¸sifrelerin analizinde korelasyon ata¯gı ¸su ¸sekildedir.
Akan ¸sifrelerde anahtar ureticinin ¨ kullanımı
ci = mi ⊕ zi ⇒ zi = ci ⊕ mi
93
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Bilinen a¸cık metin ata˘gı: Belirli a¸cık-kapalı mesaj ciftleri ¸ (mi
, ci), zi
’ler bilinirken gizli
anahtarı bulabilmektir.
Korelasyon ata˘gı i¸cin gerekli ve yeterli ko¸sul ui = zi olma olasılı˘gının 0.5 den farklı olmasıdır. E˘gerP olasılı˘gı g¨osterirse, bunu matematiksel olarak P(ui = zi) 6= 0.5 ¸seklinde
ifade edebiliriz.
Korelasyon atak i¸cin gerek ve yeter ¸sart P(ui = zi) 6= 0.5
Nonlinear (Do˘grusal Olmayan) fonksiyonlarla LFSR’ları birle¸stirme (prensibi)
94
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
E˘ger f fonksiyonu (m−1)-dayanıklı (m-dayanıklı olmayan) bir fonksiyonsa P(zi = u
(a1)
i +
u
(a2)
i + · · · + u
(am)
i
) 6= 0.5 dir. Bu durumda f’nin korelasyon ata˘gına dayanıklı olması i¸cin
m de˘gerinin yeterince yuksek ¨ olması gereklidir.
Korelasyon atak Modeli
Yukarıdaki sistemde korelasyon ihtimali 1 − p = P(ui = zi) ve hata ihtimali p’dir.
Korelasyon Ata˘gı: Resim 4 deki sistemde but ¨ un¨ LFSR’ların maksimum periyoda sahip
oldu˘gunu kabul edelim ve LFSR’ların uzunluklarını L1,L2, . . . ,Ln ile g¨osterelim. E˘ger bu
95
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
sistemdeki LFSR’ların ba˘glantı polinomları ve f fonksiyonu biliniyorsa en fazla Qn
i=1(2Li−
1) adet farklı anahtar uretilebilir. ¨ Uretilen ¨ anahtar dizisi ile herhangi bir LFSR’ın -
buna R1 diyelim; cıktısı ¸ arasındaki korelasyon ihtimali p > 0.5 veya (p < 0.5) ise ve
anahtar dizisinin yeterince uzun kısmı biliniyorsa R1’in ba¸slangı¸c konumu bilinen anahtar
dizisi ile R1’in cıktısının ¸ but ¨ un¨ olası kaydırılmı¸s halleri arasındaki cakı ¸ ¸smaların sayısı ile
bulunabilir. C¸ akı¸sma sayısının korelasyon ihtimali ile tutması gereklidir. Bu durumda
R1’in ilk durumunu bulmak en fazla (2L1 − 1) deneme gerektirir. E˘ger di˘ger LFSR’ların
cıktıları ¸ ile anahtar dizisi arasında korelasyon varsa aynı y¨ontem kullanılarak ilk durmları
elde edilebilir. Sonu¸c olarak Pn
i=1(2Li − 1) deneme gerekmektedir. Bu ise Qn
i=1(2Li − 1)
g¨ore daha ku¸¨cuk¨ bir sayıdır. Aynı ¸sekilde LFSR’ların belli bir kombinasyonu ile cıktı ¸
arasındaki korelasyonda analiz i¸cin kullanılabilir.
Ornek: ¨
Geffe ureteci ¨ olarak bilinen a¸sa˘gıdaki sisteme korelasyon ata˘gı uygulayaca˘gız.
Geffe uretici ¨
96
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
z = f(x1, x2, x3) = x1 ⊕ x2(x1 ⊕ x3)
x1 x2 x3 ⇒ z
0 0 0 0
0 0 1 0
0 1 0 0
0 1 1 1
1 0 0 1
1 0 1 1
1 1 0 0
1 1 1 1
P(z = x1) =
6
8 = 0.75, P(z = x2) =
4
8 = 0.5, P(z = x3) =
6
8 = 0.75
G¨oruld ¨ u˘¨gu¨ gibi f fonksiyonunun cıktıları ¸ 0.75 ihtimalle x1 ve x3 ile tutuyor. Dolayısıyla f
fonksiyonu yeteri kadar cıktısı ¸ elde edilirse 3 LFSR’ın ba¸slangı¸c konumlarını bulunabilir.
8.4 Blok S¸ifrelerin Analizi
Blok ¸sifrelerin analizinde en kuvvetli analiz metodları olarak bilinen iki analiz y¨ontemini
inceleyece¯giz. Biham ve Shamir tarafından geli¸stirilen difransiyel kriptanaliz (differential
cryptanalysis) ve Matsui tarafından geli¸stirilen do˘grusal kriptanaliz (linear cryptanalysis).
8.4.1 Difransiyel Kriptanaliz
Difransiyel Kriptanaliz methodu DES, GDES, Lucifer, FEAL, PES, IDEA, LOKI’89,
REDOC ve Khafre dahil olmak uzere ¨ bir cok ¸ sayıda blok ¸sifre sistemine uygulanmı¸s
bir se¸cilmi¸s a¸cık metin ata˘gıdır. Biham ve Shamir tarafından geli¸stirilen bu atak, ilk
once ¨ DES in indirgenmi¸s d¨ongu¨ ce¸ ¸sitlerine ve sonra tum¨ 16-d¨ongu¨ DES e uygulanmı¸stır.
97
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Gun¨ um¨ uzde ¨ bilinen en onemli ¨ ataklardan birisidir c¸unk ¨ u¨ DES in anahtarları teorik olarak
tum¨ anahtar uzayını denemeyle beklenen masraftan daha azı ile elde edilebilinmektedir.
Difransiyel Kriptanaliz, kripto sistemlerin yeniden g¨ozden ge¸cirilmesine, tekrar dizyan
edilmesi ve yeni sistemlerinin bu ata˘ga kar¸sı dayanıklı tasarlanmalarına neden olmu¸stur.
Bu kriptanaliz metodu a¸cık metin ikilileri farkının bunlara kar¸sılık gelen kapalı metin
ikilileri uzerindeki ¨ etkisini kullanarak analiz yapıar. Bu farklar olası anahtarları ihtimal
atamak ve ihtimali en yuksek ¨ anahtarları belirlemek i¸cin kullanılır. Aynı farka sahip olan
bir cok ¸ a¸cık metin ikilisini ve kar¸sı gelen kapalı metin ikililerini kullanır.
2n-bit blok ¸sifre sistemleri i¸cin Difransiyel Kriptanalizin ozet ¨ tanımını verece˘giz. ˙Ilk olarak
e¸sit uzunluktaki iki bit dizinin X ve X´ arasındaki farkı (difference) tanımlayalım:
∆X = X ⊗ X´ −1
Burada ⊗ bit dizi grupları uzerinde, ¨ d¨ongu¨ (round) fonksiyonu i¸cinde anahtar ile metin
girdisinin birle¸stirilmesini sa˘glayan bir grup operasyonudur ve X´ −1 ⊗ operasyonuna g¨ore
X in tersidir. Yukarıdaki farkı tanımlamada asıl ama¸c metin girdileri arasındaki farkın
anahtar eklenmeden ve eklendikten sonra aynı olması yani farkın anahtardan ba˘gımsız
yapılması cabasıdır. ¸ Bu bakı¸s a¸cısını anlamak i¸cin :
∆X =(X ⊗ K) ⊗ (X´ ⊗ K)
−1
= X ⊗ K ⊗ K−1 ⊗ X´ −1 = X ⊗ X´ −1
Feistel yapısındaki blok ¸sifre sistemlerinin bir co˘ ¸ gu i¸cin bu farkı kullanarak ¸sifre sistemin
bir d¨ongus ¨ u¨ i¸cin olası tum¨ metin girdi farklarına ve bunlara kar¸sılık gelen olası cıktı ¸
farklarının ilgili olasılıklarını i¸ceren fark da˘gılım tabloları olu¸sturmak mumk ¨ und ¨ ur. ¨
98
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
A¸cık metinimiz P = C0 ve Ci de i d¨ongu¨ ¸sifrelemesinden olu¸san kapalı metin olsun. αi ∆Ci
nin beklenen de˘geri ve α0 se¸cilen ∆P = ∆C0 olmak uzere ¨ bir r-d¨ongu¨ karakteristi˘gi
(r+1) lik (α0, . . . , αr) dır. Burada ∆P a¸cık metin farkı ve ∆Ci de i inci d¨onguden ¨ sonraki
kapalı metin farkıdır. Bir karakteristi˘gin olasılı˘gı verilen i−1 d¨ongu¨ ¸sifrelemesinden olu¸san
∆Ci−1 = αi−1 farka g¨ore i d¨ongu¨ ¸sifrelemesinden sonra elde edilen ∆Ci = αi
farkının
edilmesinin ko¸sullu olasılı˘gıdır. Rastgele, hep aynı ¸sekilde se¸cilmi¸s d¨ongu¨ anahtarları Ki
ler i¸cin bir karakteristi˘gin olasılı˘gı
Pr(∆Ci−1=αi
, ∆Ci−1=αi−1, . . . , ∆C1 = α1 | ∆P = α0)
Bu olasılı˘gı hesaplamak cok ¸ zor olabilir. Bununla beraber bazı blok ¸sifre sistemleri i¸cin bu
olasılık her bir d¨ongun¨ un¨ olasılıkları kullanılarak hesaplanabilir (Markov ¸sifre sistemleri).
˙Istatistiksel i¸slemleri kolayla¸stırmak adına bundan sonra d¨ongu¨ anahtarlarının ba˘gımsız
ve hep aynı ¸sekilde rastgele se¸cildiklerini varsayaca˘gız.
A¸cık metin ikilisi P ve P´ farkı ∆P, anahtar K ve r-d¨ongu¨ karakteristi˘gine g¨ore do˘gru
ikili olarak adlandırılabilinmesi i¸cin P ve P´ ¸sifrelendikten sonra arada yer alan d¨ongulerin ¨
kapalı metinlerinden olu¸san farklar r-d¨ongu¨ karakteristi˘gi izlemelidir. E˘ger anahtar K ve
r-d¨ongu¨ karakteristi˘gine g¨ore P ve P´ do˘gru ikili de˘gilse yanlı¸s ikili olarak adlandırılırlar.
p karakteristik olasılı˘gı olmak uzere ¨ 2n-bitlik ¸sifre sistemi i¸cin yakla¸sık p.22n do˘gru ikili
bulunmaktadır.
Difransiyel Kriptanalizin amacı son d¨ongude ¨ kullanılan Kr anahtarını belirlemektir. Bazı
a¸cık metin ikilileri i¸cin Cr ve C´
r kapalı metinler olsun. Se¸cilmi¸s a¸cık metin ata˘gında
kriptanalist, blok ¸sifre sistemin son d¨ongus ¨ u¨ girdileri Cr−1 ve C´
r−1 bilemez fakat se¸cilen
99
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
karakteristi˘ge g¨ore r − 1 d¨ongu¨ ¸sifre sonundaki kapalı metinlerin farkı ∆Cr−1 tamamen
veya kısmi olarak p olasılıkla bilir. Ve sonra verilen a¸cık metin P ve P´ ikilisinin farkı ∆P
i¸cin kriptanalist a¸sa˘gıdaki denklemi Kr yi c¨¸ozmeye calı ¸ ¸sır:
g
−1
(Cr, Kr) ⊗ g
−1
(C´
r, Kr)
−1 = ∆Cr−1
Yukarıdaki denklemin c¨¸ozum¨ u¨ aday d¨ongu¨ anahtarları olarak adlandırabilece˘gimiz
k1, k2, . . . , kj olsun. E˘ger P ve P´ do˘gru ikili ise Kr ∈ {k1, k2, . . . , kj}. E˘ger P ve P´
yanlı¸s ikili ise ki nin Kr den ba˘gımsız oldu˘gunu kabul edilir. Sonrası e˘ger cok ¸ miktarda
P ve P´ ikilileri denenirse, aday anahtarların tekrarı kaydedilir ve do˘gru d¨ongu¨ anahtarı
Kr di˘ger adaylara g¨ore daha fazla sayılmasını bekleriz. Difransiyel Kriptanaliz methodu
a¸sa˘gıdaki basamaklarla ozetlenebilir: ¨
• Tamamen veya kısmı olarak yuksek ¨ olasılıkta ∆Cr−1 i veren bir
(∆P, ∆C1, ∆C2, . . . , ∆Cr−1) r-d¨ongu¨ karakteristi˘gi bulunması.
• Do˘gru ikili oldu˘gunu varsaydı˘gımız hep aynı ¸sekilde P ve P´ a¸cık metin ikilisi (farkları
∆P) yardımıyla aday d¨ongu¨ anahtarları k1, k2, . . . , kj
, herbiri ki g¨ozlemlenen cıktı ¸
farkını verenler olmak uzere ¨ se¸cilir. Her aday d¨ongu¨ anahtarı ki
i¸cin saya¸c bir
arttırılır.
• Usteki ¨ iki basamak bir aday anahtar ki di˘gerlerine g¨ore cok ¸ sayıda sayılana kadar
tekrar edilir. En cok ¸ sayılan ki ger¸cek r-d¨ongu¨ anahtarı Kr olarak kabul edilir.
Difransiyel Kriptanalizin karma¸sıklı˘gını tanımlamak i¸cin anahtar veya d¨ongu¨ anahtarını
belirlemek i¸cin se¸cilen farka g¨ore ¸sifrelenen a¸cık metin ikililerin sayısı kullanılabilir.
100
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Sınırlandırılmı¸s DES sur ¨ umleri ¨ uzerinde ¨ Biham ve Shamir (DES kitabi referans olacak) ata˘gın karma¸sıklı˘gını yakla¸sık olarak c/p bulmu¸slardır (p kullanılan karakteristi˘gin
olasılı˘gı ve c sabit sayı ve 2 ≺ c ≺ 8 olmak uzere). ¨
Difransiyel Kriptanaliz se¸cilmi¸s a¸cık metin ata˘gı olmasına kar¸sın kullanılan metin ikilileri
arttırılarak bilinen metin ata˘gında da calı ¸ ¸sması sa˘glanabilir.
DES ¸sifre sistemini ele aldı˘gımızda yukarıda bahsedilen metodun uygulanması i¸cin farklar
kullanılarak a¸sa˘gıdaki gibi bir XOR tablosu olu¸sturulur.
101
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
XOR-tablosu (1. S-kutusunun)
DES’in ce¸ ¸sitleri d¨ongu¨ saıyılarına g¨ore ata˘gın ba¸sarı durumları a¸sa˘gıdaki tabloda verilmi¸stir.
102
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Rounds Complexity
4 2
4
6 2
8
8 2
16
9 2
26
10 2
35
11 2
36
12 2
43
13 2
44
14 2
51
15 2
52
16 2
58
3-round (step) Karakteristik
103
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
(iterative) karakteristik tekrar edilebilen
3-round karakteristik
104
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
3-round karakteristik
8.4.2 Do˘grusal Kriptanaliz
Do˘grusal Kriptanaliz 1993 yılında DES sistemini kırmak i¸cin Matsui tarafından
geli¸stirilmi¸s bir bilinen a¸cık metin atak ce¸ ¸sididir. 2
47 a¸cık metin kullanılarak DES sistemi
kırılmı¸stır. Do˘grusal olmayan (nonlinear) fonksiyonlara do˘grusal (linear) fonksiyonlarla
yakla¸sarak yapılmı¸stır. Bu yakla¸sım olasılık uzerine ¨ dayalı oldu˘gu i¸cin 0.5’ten ne kadar
sapılırsa fonksiyonun yerine do˘grusal fonksiyonlar kullanmak bu sapma miktarı kadar
avantaj kazandırır.
P[i1,i2, ...,ia] ⊕ C[j1, j2, ..., jb] = K[k1, k2, ..., kc] ,
105
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
i1,i2, ...,ia, j1, j2, ..., ja ve k1, k2, ..., kc belirli bit yerlerini g¨ostermektedir, ve yukarıdaki
denklemin tutma ihtimali p 6=
1
2
.
Yukarıdaki efektif do˘grusal ifadeye ula¸sıldıktan sonra anahtar bitleri a¸sa˘gıdaki maksimum
yakınlık metodu ile bulunur.
Algoritma
Adım 1 : Yukarıdaki denklemin sol tarafının 0’a e¸sit oldu˘gu a¸cık metinlerin sayısı T olsun.
Adım 2 : E˘ger T > N/2 (Denenen a¸cık metin sayısı = N ),
−→ K[k1, k2, ..., kc] = 0 (e˘ger p >
1
2
) veya 1 (e˘ger p <
1
2
)
−→ K[k1, k2, ..., kc] = 1 (e˘ger p >
1
2
) veya 0 (e˘ger p <
1
2
)
A¸sa˘gıdaki tabloda N ve p cinsinden ata˘gın ba¸sarı oranları verilmi¸stir.
N
1
4
|p −
1
2
|
−2 1
2
|p −
1
2
|
−2
|p −
1
2
|
−2 2|p −
1
2
|
−2
Ba¸sarı oranı 84.1% 92.1% 97.7% 99.8%
Do˘grusal kriptanaliz a¸sa˘gıda kısaca ozetlenmi ¨ ¸stir.
• Efektif do˘grusal ifadenin bulunması,
• Ba¸sarı oranının N ve p cinsinden ifadesi,
• En iyi do˘grusal ifadenin ve anahtar i¸cin en iyi tutma ihtimalinin hesaplanması.
Kaynaklar:
[1] J.Daeman,R. Govaerts and J. Vandewalle, Weak Keys for IDEA, Advances in Cryptology, Proc. EUROCRYPTO’93, LNCS 773, Springer-Verlag, pp. 224-231, 1994.
106
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
[2] A. Biryukov, Introduction to cryptology and cryptanalysis (Ders Notu),
http://www.wisdom.weizmann.ac.il/ albi/cryptanalysis/lectures.htm
[3] X. Lai, J. L. Massey and S. Murphy, Markov Cipher and Differential Cryptanalysis, Advances in Cryptology, EUROCRYPTO’91, Lecture Notes in Computer Science,
Springer Verlag, Berlin-Heidelberg, 547, pp. 17-38, 1991
[4] X. Lai, On the design and security of block cipher, ETH Series in Information Processing, V.1, Konstanz: Hartung-Gorre Verlag, 1992.
[5] NESSIE Project: New European Schemes for Signatures, Integrity and Encryption at,
http://cryptonessie.org
[6] A. Menezes, P. van Oorschot, S. Vanstone, Handbook of Applied Cryptography,
http://www.cacr.math.uwaterloo.ca/hac/
[7] L. R. Knudsen, Ph.D. thesis: Block ciphers - Analysis, Design and Applications ,
http://www.mat.dtu.dk/people/Lars.R.Knudsen/thesis.html
[8] Crypto papers, http://www.funet.fi/ bande/docs/crypt/
107
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
BOL¨ UM¨ 9
HASH FONKS˙IYONLARI
Hash fonksiyonları h : {1, 2, . . . , 2
m} → {1, 2, . . . , 2
n} ve asa˘gıdaki ozelliklere ¨ sahip olan
fonksiyonlardır:
1. sıkı¸stırma: h fonksiyonu, uzunlu˘gu sonlu ve de˘gi¸sken olabilen girdiyi alıp sabit bir
uzunlukta cıktı ¸ vermelidir,
2. kolay hesaplanabilirlik: herhangi bir girdi i¸cin h(x) de˘gerini hesaplamak kolay
olmalıdır.
Hash fonksiyonları anahtarsız hash fonksiyonları ve anahtarlı hash fonksi-yonları olmak
uzere ¨ ikiye ayrılır:
1. Anahtarsız hash fonksiyonları h : {0, 1}
∗ → {0, 1}
n
• Blok ¸sifreleme sistemleri tabanlı
• Moduler ¨ aritmetik tabanlı
• Customized (MD4,MD5,SHA-1,RIPE-MD,HAVAL)
2. Anahtarlı hash fonksiyonları hk : {0, 1}
∗ → {0, 1}
n
• Blok ¸sifreleme sistemleri tabanlı
108
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
• Anahtarsız hash fonksiyonları tabanlı
• Customized (MAA,MD5-MAC)
• Akan ¸sifreler i¸cin uretilen ¨
Customized hash fonksiyonları sadece hash i¸cin kullanılan anahtarlı veya anahtarsız
olarak uretilen ¨ hash fonksiyonlarıdır. Ayrıca guv¨ enilir-li˘gi teorik olarak ispatlanan fakat pek pratik olmayan evrensel hash fonksiyonlarıda farklı bir grup olarak
g¨orulebilir. ¨
Anahtarsız hash fonksiyonlarının u¸¨c temel ozelli˘ ¨ gi a¸sa˘gıda belirtilmi¸stir(h bir hash fonksiyonu, x ve x
0
girdileri, y ve y
0
cıktıları ¸ g¨ostermektedir):
1. preimage resistance: h(x) = y de˘geri bilindi˘ginde, x’i hesaplamak sonlu zamanda
mumk ¨ un¨ degil. y biliniyor, h(x
0
) = y olacak bir x
0
bulmak zor(hesaplamak sonlu
zamanda mumk ¨ un¨ degil).
2. 2nd-preimage resistance: h(x) = y biliniyor, h(x
0
) = y olacak farklı bir mesaj
x 6= x
0
bulmak zor.
3. collision resistance: h(x) = h(x
0
) olacak ¸sekilde iki farklı mesaj x ve x
0
bulmak
zor.
Ornek ¨ 1 Mod-32 checksum (Mod 32 kontrol toplamları). Mesajın i¸cerisindeki but ¨ un¨ 32-
bit’lik par¸caların toplamı alınarak kullanılan fonksiyon. Hesaplaması kolay, sıkı¸stırma
var, fakat preimage resistant de˘gil.
109
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Ornek ¨ 2 g(x) = x
2 mod n = pq p, q buy¨ uk¨ asal sayılar (n’nin carp ¸ anları bilinmiyorsa
tek y¨onlu¨ fonksiyondur.) Hesaplaması kolay, sıkı¸stırma yok, preimage resistant (¸cunk ¨ u¨
preimage bulmak n’yi carp ¸ anlarına ayırmaya denk), fakat 2nd preimage ve collision var
(x, −x).
Ornek ¨ 3 DES tabanlı tek y¨onlu¨ fonksiyon. f(x) = Ek(x)⊕x ,sabit bir anahtar(k) i¸cin. E
rasgele bir permutasyon ¨ olarak kabul edilirse f fonksi-yonu tek y¨onlu¨ olur. y bilindi˘ginde
y = Ek(x) ⊕ x olacak ¸sekilde x ve k bulmak zor (E’nin rasgele olamasından dolayı),
E
−1
k
(x ⊕ y) = x bulmak zor, Dolayısıyla f tek y¨onlu¨ bir fonksiyon. Fakat fonksiyon belli
mesaj uzunlukları i¸cin calı ¸ ¸sıyor.
• collision resistant ise 2nd preimage resistantdır:
Fonksiyonumuzun collision resistant oldu˘gunu kabul edelim. 2nd preimage resistant
degilse ⇒ Sabit x, h(x) i¸cin h(x) = h(x
0
) olan x 6= x
0
bulabiliriz, fakat bu collision
resistant olamadı˘gını g¨osteririr, kabulum¨ uzle ¨ celi ¸ ¸sir.
• collision resistant ise preimage resistant olmak zorunda degildir:
g : (0, 1)∗ → (0, 1)n
collision resistant olsun, h fonksiyonunu a¸sa˘gıdaki ¸sekilde
tanımlanırsa preimage resistant olmaz;
h(x) =
n
1kx if |x|=n
0kg(x) if |x|6=n
o
,
h : (0, 1)∗ → (0, 1)n+1 n + 1 bit hash fonksiyon.
• preimage resistant ise 2nd preimage resistant olmak zorunda degildir:
Ornek ¨ 2’de g¨orulebilir. ¨
110
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Ekstra S¸artlar:
1. Non-correlation: Girdi ve cıktı ¸ bitleri arasında korelasyon olmamalı, blok ¸sifre
sistemlerindeki gibi avalanche ozelli˘ ¨ gi sa˘glanmalı(but ¨ un¨ girdi bitleri but ¨ un¨ cıktı ¸ bitlerini etkilemeli),
2. Near-collision resistance: w(h(x) ⊕ h(x
0
) ku¸¨cuk¨ olacak farklı x ve x
0
ciftlerini ¸
bulmak zor olmalı (w:hamming agırlı˘gı),
3. Partial-preimage resistance(local one-wayness): Girdi bitlerinin bir kısmını
dahi bulmak zor olmalı, girdinin t uzunlu˘gundaki kısmını bulmak i¸cin yakla¸sık 2
t −
1’lik hesaplama yapmak gerekmeli (girdinin belli bir kısmı bilinse dahi diger kısmını
bulmak zor olmalı).
Anahtarsız hash fonksiyonlarının cogu ¸ girdi ve cıktı ¸ uzunlu˘gu sabit olan bir f hash fonksiyonunun tekrarlı olarak uygulanmasıyla elde edilir. Bu fonksiyonlara Iterative hash
fonksiyonları(h) adı verilir. Herhangi bir uzunluktaki x girdisi, sabit r-bit uzunluklara b¨olun¨ ur( ¨ xi), x’in uzunlu˘gunun r’nin katı olması i¸cin belli bir kurala ba˘glı olarak x’e
padding (bit ekleme) yapılır. Girdi par¸caları xi
’ler sırasıyla f’ye sokulur, f’nin cıktısı ¸ ve
xi+1 tekrar f’nin girdisi olarak kullanılır ve son girdi blo˘guna kadar bu i¸slem tekrarlanır.
Bu durumda a¸sa˘gıdaki i¸slemler yapılmı¸s olur: x = x1x2 . . . xt
,
H0 = IV ; Hi = f(Hi−1, xi), 1 ≤ i ≤ t; h(x) = g(Ht),
IV :ba¸slangı¸c de˘geri
Iterative hash fonksiyonlarının genel ve detaylı yapıları a¸sa˘gıdaki ¸sekillerde verilmi¸stir:
111
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
NOT: f fonksiyonunun collision resistant olması h fonksiyonunun collision resistant olmasını garantiler.
Anahtarsız hash fonksiyonları:
• Blok ¸sifre sistemleri tabanlı: ˙Iterasyonda kullanılan f fonksiyonu herhangi bir
blok ¸sifre sistemi olarak se¸cilir. Kullanılan makinanın i¸cinde bir blok ¸sifreleme sistemi varsa hash fonksiyonu olarakta kullanılabilir.
112
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
• Moduler Aritmetik tabanlı: ˙Iterasyon fonksiyonu (f) mod M aritmeti˘gini baz
alan bir fonksiyon olarak se¸cilir, carpanlara ¸ ayırma ve discrete logaritim problemlerini temel alan sistemler se¸cilebilir.
• Customized: Ozel ¨ olarak hash i¸cin tasarlanmı¸s ve optimize hıza sahip olan fonksiyonlardır. Pratik olarak kullanılmaktadır, MD ailesi ve SHA ornek ¨ olarak verilebilir. Guv¨ enilirlikleri hesaplama guc¨ une ¨ dayalı olarak ispatlanır, matemetiksel
olarak guv¨ enilir oldukları ispatlanmamı¸stır.
Anahtarlı hash fonksiyonları:
• Blok ¸sifreleme sistemleri tabanlı: CBC tabanlı MAC’lar ornek ¨ olarak verilebilir.
• Anahtarsız hash fonksiyonları tabanlı: Gizli bir anahtarın anahtarsız hash
113
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
fonksiyonlarının girdisinin bir par¸cası olarak kullanılmasıyla uretilen ¨ hash fonksiyonlarıdır.
A¸sa˘gıdaki y¨ontemler ornek ¨ olarak verilebilir(k anahtar ve h bir anahtarsız hash
fonksiyonu olmak uzere): ¨
1. secret prefix metod: M(x) = h(k||x),
2. secret suffix metod: M(x) = h(x||k),
3. envelope metod with padding: hk(x) = h(k||p||x||k) p :padding k||p bir blok
uzunlu˘gunda olacak ¸sekilde padding yapılıyor,
4. hash tabanlı: HMAC(x) = h(k||p1||h(k||p2||x)), p1, p2 :padding, k||p1 ve
h(k||p2||x) birer tam blok uzunlu˘gunda olacak ¸sekilde padding yapılıyor.
• Customized MAC’lar: Sadece hash yapmak i¸cin tasarlanmı¸s ve i¸cerisinde gizli
anahtar barındıran hash fonksiyonlarıdır. Ornek ¨ olarak MAA ve MD5-MAC verilebilir.
Hash fonksiyonları ile ilgili detaylı bilgiler a¸sa˘gıdaki kaynaklarda bulunabilir:
• Handbook of Applied Cryptography,Chapter 9, by A. Menezes, P. van Oorschot,
and S. Vanstone, CRC Press, 1996. http://www.cacr.math.uwaterloo.ca/hac
• Cryptographic Hash Functions: A Survey, by S. Bakhtiari, R. Safavi-Naini, J.
Pieprzyk
• Hash functions based on block ciphers: a synthetic approach, by B. Preneel,R.
Govaerts, and J. Vandewalle
114
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
BOL¨ UM¨ 10
TEST YONTEMLER ¨ ˙I
Giri¸s
Rassallı˘gın tanımı kısaca tahmin edilemeyen, belirli bir kalıba sahip olmayan olarak verilebilir. Rassal olarak uretilen ¨ sayılar, ¸sans oyunlarında, istatistiksel orneklemelerde ¨ ve
simulasyon uygulamalarında sık¸ca kullanılır.
Rassallık kriptografide kullanılan en temel ozelliklerden ¨ biridir. Atak yapan ki¸siye, bir
kriptosistem cıktısının ¸ olabildi˘gince tahmin edilemez olması gerekir. Rassal sayılar bir¸cok
kriptografik uygulamanın temelini olu¸sturur. Olu¸sturulması en gerekli ve aynı zamanda
en zor olan kısımdır. Neredeyse but ¨ un¨ kriptografik protokollerde gizli ve tahmin edilmesi
zor de˘gerlere ihtiya¸c duyulur, orne˘ ¨ gin asimetrik ¸sifreleme y¨ontemlerinde (RSA, Diffie Hellman) anahtar olu¸sturulurken, rassal sayılar kullanılır. Anahtar gizlili˘gi kriptosistemlerde
cok ¸ onemli ¨ oldu˘gu i¸cin, programlama dillerinde standart olarak kullanılan rassal sayı
urete¸ ¨ clerinin kriptografik ama¸clar i¸cin kullanılması sakıncalıdır. Genelde, bu algoritmalar
istatistiksel rassallık i¸cin tasarlanmı¸stır, kriptanalize kar¸sı dayanıklı de˘gillerdir). Temel
olarak rassal sayılar iki farklı y¨ontemle olu¸sturulur:
Ger¸cek rassal sayı urete¸ ¨ cleri i¸cinde rassal bir yapı bulunduran fiziksel sinyal kaynakları
kullanarak dizi uretirler. ¨ Bu urete¸ ¨ clerin en onemli ¨ avantajları:
• Dizinin bir kısmına sahipken, farklı bir kısmını elde etmenin mumk ¨ un¨ olmaması;
115
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
• Uretilen ¨ diziler kendi i¸cinde herhangi bir gizli ba˘gıntının bulunmaması;
• Periyodik olmamalarıdır.
Bu avantajların yanı sıra, ger¸cek rassal sayı urete¸ ¨ clerinin onemli ¨ dezavantajları da bulunur.
Bu urete¸ ¨ cler co˘ ¸ gunlukla verimsizdir, uzun sayı dizileri elde etmenin maliyeti yuksektir. ¨
Deneyi tekrarlayıp bir sayı dizisini yeniden elde etmek mumk ¨ un¨ de˘gildir.
S¨ozde-rassal (pseudo-random) sayı urete¸ ¨ cleri matematiksel algoritmalar kullanarak diziler
uretirler. ¨ Bu algoritmalar kendi i¸clerinde herhangi bir rassallık barındırmazlar, algoritmalar da genelde a¸cıktır. Buradaki rassallık algoritmaların girdileri (seed) ile sa˘glanır,
bu yuzden ¨ algoritmaların girdileri gizli tutulmalıdır ve kolay tahmin edilemez olmalıdır.
Algoritma ve girdi bilinirse, dizinin tum¨ u¨ elde edilebilir. Bu urete¸ ¨ cler verimlidir ve uzun
diziler uretmenin ¨ maliyet du¨¸sukt ¨ ur. ¨ Kriptografik olarak kullanılabilecek s¨ozde-rassal sayı
urete¸ ¨ cleri ile uretilen ¨ bir dizinin bir kısmı biliniyorsa, bu dizinin di˘ger kısımları ile ilgili bir
bilgi vermemelidir. Aynı urete¸ ¨ cle uretilen ¨ farklı diziler birbirleri ile ili¸skileri olmamadılır
(correlation). Dizilerin periyotları mumk ¨ un¨ oldu˘gunca uzun olmalıdır.
0 − 1 Dizileri
Kritografide kullanılan sayı dizileri 0 ve 1’lerden olu¸sur. Sayı uretecinin ¨ uretti˘ ¨ gi her bitin
0 veya 1 olma ihtimali 1
2
ye e¸sit olmalıdır. Golumb, periyodik bir dizinin rassallı˘gını test
eden u¸¨c tane kural geli¸stirmi¸stir:
1. Dizi i¸cerinse bulunan 0’ların ve 1’lerin sayısının farkı maksimum 1 olmalı.
116
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
2. Dizi i¸cerisinde bulunan ob¨ eklerin (kendisini tekrarlayan bitler) sayısı, n dizi
uzunlu˘gu olarak verildi˘ginde, (n + 1)/2 olmalıdır. Bir bitten olu¸san ob¨ eklerin sayısı
toplam ob¨ ek sayısının yarısı kadar olmalıdır.
3. Dizinin kendisi ile olan ili¸skisi du¨¸suk¨ olmalıdır.
Bir dizinin rassallı˘gı test edilirken Golumb kuralları yeterli de˘gildir. LFSR’lar ile uretilen ¨
sayı dizileri Golumb kurallarını sa˘glamalarına ra˘gmen kriptografik olarak sayı urete¸ ¨ cleri
olarak kullanılmazlar. LFSR ile uretilen ¨ sayı dizilerinin lineer karma¸sıklıkları du¨¸sukt ¨ ur. ¨
S¨ozde-Rassal Sayı Urete¸ ¨ clerinin Test Edilmesi
S¨ozde-rassal sayı urete¸ ¨ clerini test etmek i¸cin istatistiksel testler kullanılır. A¸sa˘gıda istatistiksel hipotez testleri ile ilgili on¨ bilgi bulunmaktadır.
˙Istatistiksel Testler
˙Istatistiksel cık ¸ arım yapmak i¸cin istatistiksel hipotez testleri kullanılır. Bu testlerde bir
hipotez (null hypothesis, H0) one ¨ sur ¨ ul ¨ ur, ¨ bu hipotezin tersi de alternatif hipotez, Ha
olarak kabul edilir. ˙Istatistiksel test sonucunda varılabilecek iki farklı temel karar vardır:
- H0’ yu reddet. - H0’ yu reddetme. Birinci karar, H0 aleyhine gu¸¨clu¨ bir kanıt elde
edildi˘ginde verilir. Bu gu¸¨clu¨ kanıt bulunamadı˘gında ise ikinci karar verilir.
But ¨ un¨ istatistiksel testlerde ka¸cınılmaz hata yapma payı vardır. Test sonucunda iki
farklı hata, birinci tip (alfa) ve ikinci tip (beta) yapılabilir. Birinci tip hata hipotezimiz
do˘gruyken, kararımız H0’yu reddet oldu˘gunda ger¸cekle¸sir. ˙Ikinci tip hata ise hipotezimiz yanlı¸sken, kararımız H0’yu reddetme oldu˘gunda ger¸cekle¸sir. Hipotez testinde birinci
117
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
tip hata yapma olasılı˘gını sınırlamak gerekir. Test sonucunda birinci tip hata yapma
olasılı˘gımız, testimizin guv¨ enilirlik seviyesini verir. Bu de˘ger genel olarak 0.01-0.05 olarak
se¸cilir. ˙Istatistiksel bir testin guc¨ u, ¨ ikinci tip hatayı yapmama olasılı˘gına e¸sittir. Testin
guc¨ un¨ u¨ arttırmak i¸cin daha fazla ornekleme ¨ yapılır.
˙Istatistiksel bir test yapılaca˘gında ilk olarak, H0 ve Ha belirlenir. Daha sonra testin
guv¨ enilirlik seviyesine karar verilir. Bir ornekleme ¨ yapılır ve test istatisti˘gi ve buna ba˘glı
olarak p-de˘geri hesaplanır. P-de˘geri, birinci tip hata yapma olasılı˘gını kontrol etmek yerine, H0’ın do˘gru oldu˘gu varsayımı ile test istatisti˘ginin g¨ozlemleme de˘geri veya daha u¸c
bir de˘ger olması olasılı˘gına kar¸sılık gelir. Bu tanıma uygun olarak hesaplanan olasılık
p-de˘gerini verir. E˘ger bu de˘ger se¸cilen guv¨ enilirlik de˘gerinden ku¸¨cukse ¨ H0 hipotezi reddedilir.
˙Istatistiksel testlerde en cok ¸ kullanılan da˘gılımlar Normal ve Ki-kare da˘gılımlarıdır.
Normal Da˘gılım
Gauss Da˘gılımı adı ile de bilinen normal da˘gılım ilk kez De Moivre tarafından
bulunmu¸stur. Genelde, hipotez testleri da˘gılımın normal oldu˘gu varsayımına g¨ore
duzenlenir. ¨ Da˘gılımın ortalama ve standart sapma olmak uzere ¨ iki parametresi vardır.
C¸ an e˘grisi olarak da bilinir. E˘grinin tepe noktası ortalamasına denk gelir. Ayrıca bu
da˘gılımda ortalama, medyan ve mod aynı de˘gerdir. Ortalamaya g¨ore simetrik bir grafi˘gi
vardır. Da˘gılımın standart sapması e˘grinin geni¸sli˘gini belirler.
Ortalaması sıfır ve standart sapması 1 olan normal da˘gılıma sahip bir de˘gi¸skenin
da˘gılımına standart normal da˘gılım denir. Standart normal da˘gılıma sahip de˘gi¸skenler
118
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Z ile g¨osterilir.
Ortalamadan iki y¨one 1,2 ve 3 standart sapma kadar uzakla¸sıldı˘gında, toplam alanın
sırasıyla %68.26 , %95.44 ve %99.74’u¨ kapsanır.
Ki-Kare Da˘gılımı
Standart normal bir da˘gılımdan se¸cilen bir birimin x de˘gerinin karesi bir ki-kare de˘geri
olur. Bu ¸sekilde tek bir birimden elde edilen ki-karelerin da˘gılımı bir serbestlik derecelidir.
Standart normal bir da˘gılımdan se¸cilen n de˘gerin karelerinin toplamı n serbestlik dereceli
bir ki-kare da˘gılımı olur. Da˘gılımın ¸sekli serbestlik derecesine g¨ore de˘gi¸sir ve asimetriktir.
Surekli ¨ bir da˘gılıma sahiptir.
NIST Test Paketi
Sayı urete¸ ¨ clerinin rassallı˘gını ol¸ ¨ cmek i¸cin bir istatistiksel test yeterli de˘gildir. Bu konuda
bir¸cok test paketi uretilmi ¨ ¸stir (FIBS 140 - Queensland University, DieHard - Florida State
University, NIST). NIST paketinden se¸cilen bazı testlerin a¸cıklaması a¸sa˘gıda verilmi¸stir.
NIST paketindeki testler ile ilgili daha ayrıntılı bilgi i¸cin : http://csrc.nist.gov/rng/
Frekans Testi
Verilen bir dizide bulunan 0 ve 1’lerin oranını kontrol eder. Testin herhangi bir parametresi
yoktur. Testte kullanılan referans da˘gılım yarım normal da˘gılımdır. Testin sonunda elde
edilen p-de˘geri cok ¸ ku¸¨cuk¨ cıkması, ¸ dizideki 1’lerin yada 0’ların sayısının beklenenden fazla
oldu˘gunu g¨osterir. Testin ge¸cerli olabilmesi i¸cin dizi uzunlu˘gunun enaz 100 olması gerekir.
Blok Frekans Testi
119
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Verilen bir dizide bulunan 0 ve 1’lerin oranını M bitlik bloklar i¸cinde kontrol eder. Testin
tek parametresi blok uzunlu˘gudur (M). Blok uzunlu˘gu 1 olarak alındı˘gında blok frekans
testi, frekans testine d¨onu¨¸sur. ¨ Herbir bloktaki 1’lerin beklenen oranı M/2’dir. Testte
kullanılan referans da˘gılım ki-kare da˘gılımdır. Testin sonunda elde edilen p-de˘geri cok ¸
ku¸¨cuk¨ cıkması, ¸ dizideki bloklarda 1’lerin ve 0’ların oranının 1
1
’den fazlasıyla saptı˘gını
g¨osterir. Testin ge¸cerli olabilmesi i¸cin blok uzunlu˘gunun en az 20, dizi uzunlu˘gunun da
en az 100 olması gerekir.
Ob¨ ek Testi
Dizide bulunan ob¨ eklerin (birbirlerini tekrarlayan bitlerin) sayısını kontrol eder. Test,
frekans testinden ge¸cmi¸s dizilere uygulanır. Dizideki de˘gi¸simler ne cok ¸ hızlı (¨orn.
01010101), ne de cok ¸ yava¸s (¨orn. 00001111) olmalıdır. Testte kullanılan referans da˘gılım
ki-kare da˘gılımdır. Testin ge¸cerli olabilmesi i¸cin dizi uzunlu˘gunun en az 100 olması gerekir.
Bloktaki En Uzun Birler Testi
Test, M-bitlik bloklarda bulunan en uzun birler grubu uzerinde ¨ odakla¸sır. Testin tek
parametresi blok uzunlu˘gudur (M). Dizi M-bitlik n tane blo˘ga b¨olun¨ ur ¨ ve her blok
i¸cerisindeki en uzun birler ob¨ e˘ginin uzunlu˘guna bakılır. Bu de˘gerlerin frekansları beklenen
de˘gerlerle kıyaslanır ve ciddi bir sapma olup olmadı˘gı kontrol edilir. Testte kullanılan
referans da˘gılım ki-kare da˘gılımdır. Dizi uzunlu˘guna g¨ore blok uzunlu˘gu ve blok sayısına
karar verilir.
Matris Rank Testi
120
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Test i¸cerisinde dizi M ∗ M-bitlik matrislere b¨olun¨ ur ¨ ve olu¸sturulan herbir matrisin rankı
hesaplanır. Diziden olu¸sturulan matrislerin ranklarının frekansları hesaplanır, beklenen
frekansla kıyaslanır ve ciddi bir sapma olup olmadı˘gı kontrol edilir. Testte kullanılan
referans da˘gılım ki-kare da˘gılımdır. Dizi uzunlu˘guna g¨ore matrisin boyutlarına karar
verilir. Onerilen ¨ M = 32 de˘geri i¸cin dizi uzunlu˘gu en az 38,912 bit olmalıdır.
Evrensel Test
Verilen dizinin yeterince sıkı¸stırılıp sıkı¸stırılamayaca˘gını kontrol eder. Dizinin fazlasıyla
sıkı¸stırılması, dizinin rassallıktan uzak oldu˘gunu g¨osterir. Testte, dizi L bitlik bloklara
ayrılır. Bu blokların bir kısmı testin ba¸slangı¸c kısmında uygulanır. Testte kullanılan
referans da˘gılım yarım normal da˘gılımdır. L-bitlik kalıpların birbirlerini ne kadar sıklıkla
tekrar etti˘gi hesaplanır ve bu de˘gerler beklenen de˘gerler ile kar¸sıla¸stırılır. Blok uzunlu˘gu
6 se¸cildi˘ginde, dizi uzunlu˘gu en az 387,840 olmalıdır.
Lineer Karma¸sıklık Testi
Test dizinin rassallık i¸cin yeterince karma¸sık olup olmadı˘gını kontrol eder. Diziler LFSR
cıktıları ¸ olarak kabul edilir ve diziyi olu¸sturabilecek en ku¸¨cuk¨ LFSR’ın boyu ku¸¨cukse, ¨
dizinin rassal olmak i¸cin yeterince karma¸sık olmadı˘gına karar verilir. Testte dizi M bitlik
bloklara ayrılır ve bloktaki bitlerin lineer karma¸sıklıkları Berlekamp-Massey algoritması
kullanılarak hesaplanır. Hesaplanan lineer karma¸sıklıkların beklenen da˘gılıma uygun olup
olmadıklarına bakılır. Testte kullanılan referans da˘gılım ki-kare da˘gılımıdır. Testin ge¸cerli
olabilmesi i¸cin dizinin boyu en az 1,000,000; blok uzunlu˘gu da 500 ve 5000 arasında
olmalıdır.
121
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Entropi Testi
Test, m bitlik kesi¸sen blokların frekansları uzerinde ¨ odakla¸sır ve bu frekansları m ve
(m + 1)-bitlik bloklar i¸cin beklenen de˘gerler ile kar¸sıla¸stırır. Testte kullanılan referans
da˘gılım ki-kare da˘gılımıdır. Diziden kesi¸sen n tane m-bitlik blok uretilir. ¨ Bu blokların
frekansları ve entropisi hesaplanır. Aynı i¸slemler blok uzunlu˘gu m+14 i¸cin tekrarlanır. m
ve m + 1 bit i¸cin hesaplanan de˘gerlerin farkına ba˘glı test istatisti˘gi hesaplanır. Bu farkın
du¨¸suk¨ olması rassallıktan uzaklı˘gı g¨osterir.
De˘gerlendirme Stratejileri
Verilen rassal sayı ureteci ¨ kullanılarak uzunlu˘gu n olan m adet sayı dizisi olu¸sturulur.
Bu m dizi verilen testlere girdi olarak kullanılır. Testlerin sonucunda m∗(test sayısı)
kadar p-de˘geri hesaplanır. Bu p-de˘gerlerinin analizi sonucunda uretecin ¨ sa˘gladı˘gı rassallık hakkında karara varılır. Burada 3 farklı karar verilebilir; (1) Rassallıktan sapma
belirlenmedi, (2) A¸cıkca rassallıktan sapma belirlendi, (3) Belirli bir sonuca varılmadı. Bu
kararlar verilirken oncelikle ¨ testin guv¨ enilirlik seviyesinden du¨¸suk¨ ka¸c tane p de˘geri bulundu˘gu ol¸ ¨ cul ¨ ur, ¨ bunun beklenen de˘geri m∗(test sayısı)∗(guv¨ enilirlik seviyesi)’dir. Buna
ek olarak bulunan uretecin ¨ kabul edilmesi i¸cin p-de˘gerlerinin da˘gılımının da tek duze ¨
(uniform) olması beklenir.
122
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
BOL¨ UM¨ 11
KR˙IPTOGRAF˙IK PROTOKOLLER
KR˙IPTOGRAF˙IK PROTOKOL NED˙IR?
Protokol, basit¸ce iki veya daha fazla ki¸si arasındaki onceden ¨ belirlenmi¸s belli bir amaca
y¨onelik haberle¸sme metodu olarak tanımlanabilir. Kriptografik protokol ise protokol
olarak kriptografik bir algoritma i¸ceren bir protokol kastedilir. Ancak genelde ama¸c temel
gizlili˘gin otesindedir. ¨ Haberle¸sen taraflar du¨¸sman ya da dost olabilirler.
KR˙IPTOGRAF˙IK PROTOKOLLER˙IN OZELL ¨ ˙IKLER˙I
Kriptografik algoritmalarda oldu˘gu gibi bir protokolun¨ de guv¨ ensiz oldu˘gunu ispatlamak
guv¨ enlili˘gi ispatlamaya g¨ore cok ¸ daha kolaydır. Bir protokolu¨ incelerken yine tıpkı algoritmalardaki gibi protokolu¨ nasıl bir cihazda hayata ge¸cirece˘gimizden cok ¸ temel calı ¸ ¸sma
prensipleri ile ilgilenilir.
HAKEM (arbitrator) ve DUZENLEY ¨ ˙IC˙I (adjudicator)
Kimi zaman protokollerde haberle¸smenin duzg ¨ un¨ bir ¸sekilde i¸sleyebilmesi i¸cin hakem
olarak adlandırdı˘gımız guv¨ enilir 3. ki¸silere ihtiya¸c duyulur. Hakemlerin en onemli ¨ ozelli˘ ¨ gi
tum¨ protokolun¨ onların g¨ozetiminde yur ¨ ut ¨ ul ¨ uy¨ or olmasıdır. Hakemi cık ¸ ardı˘gınız zaman
protokol i¸slemez. Duzenleyici ¨ ise hakemin aksine sadece bir anla¸smazlık durumunda
ba¸svurulan guv¨ enilir 3. ki¸silere denir.
123
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
DUZENLEY ¨ ˙IC˙IL˙I (adjudicated) PROTOKOLLER
Bu protokoller temelde taraflarin dur ¨ ustl ¨ u˘¨gune ¨ dayanır. Bir anla¸smazlık ya da birisinin
hile yapması durumunda duzenleyici ¨ ki¸si bunu farkeder. Denilebilir ki iyi bir duzenleyicili ¨
protokolde duzenleyici ¨ aynı zamanda hile yapan tarafın kim oldu˘gunu da farkeder.
Dolayısı ili bu ki¸sinin varlı˘gı, hile on¨ unde ¨ engel te¸skil eder.
KEND˙I
˙IS¸LEY˙IS¸
˙IN˙I ZORLAYAN (Self-Enforcing) PROTOKOLLER
Protokol herhangi bir hileye yer bırakmaz. Protokolun¨ sorunsuz i¸slemesi otomatik olarak
herhangi bir hile yapılmadı˘gı anlamına gelir. Hile halinde protokol durur. Devam edilemez
bir hal alır. Ve bunu herhangi bir hakem ya da duzenleyi¸ ¨ ciye ihtiya¸c olmadan sa˘glayacak
¸sekilde tasarlanmı¸stır. Bir protokol i¸cin her zaman istenen bir ozelliktir. ¨ Ancak her durumda kendi i¸sleyi¸sini zorlayan bir protokol bulmak mumk ¨ un¨ olamayabilir.
AKT˙IF ve PAS˙IF SALDIRILAR (attacks)
Bir protokol i¸slerken her zaman saldırı olması olasıdır. Pasif saldırıca k¨otu¨ ama¸clı ki¸si
sadece arada gelip giden trafi˘gi dinleyerek protokol tasarlanırken kendisinin ula¸sması
umulmayan bir bilgiye eri¸smeye calı ¸ ¸sır. Aktif saldırıda ise k¨otu¨ niyetli ki¸si sadece dinlemekle kalmaz. Mesajları ya da kayıtları okumanın otesinde ¨ kesebilir, bozabilir ya
de˘gi¸stirebilir. Aktif saldırgan tamamen dı¸sardan birisi olmak zorunda de˘gildir. Sistemdeki
ba¸ska legal bir kullanıcı ve hatta sistem y¨oneticisi olabilir. Saldırganın protokolu¨ uygulayan taraflardan birisi olması durumunda ise daha cok ¸ hile ve saldırıyı uygulayan ki¸si
124
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
i¸cinse hilekar tabirleri kullanılır. Saldırganlarda oldu˘gu gibi hilekarları da pasif hilekar ve
aktif hilekar olarak ikiye ayırmak mumk ¨ und ¨ ur. ¨
T˙IP˙IK S˙IMETR˙IK ALGOR˙ITMA HABERLES¸ME PROTOKOLU¨
Simetrik kriptografi kullanılarak yapılan tipik bir haberle¸smede A ve B ki¸sileri bir kriptosistem ve bir anahtar uzerinde ¨ anla¸sırlar ve A ki¸sisi bu anahtarı kullanarak ¸sifreledi˘gi
mesajını B ki¸sisine g¨onderir. B ki¸sisi de yine aynı anahtarı kullanarak mesajı de¸sifre eder
ve haberle¸sme tamamlanır.
Bu sistemin onemli ¨ dezavantajları vardır. Oncelikle ¨ A ve B ki¸siler anahtar de˘gi¸stirmek
i¸cin biraraya gelmelidirler (anahtar de˘gi¸simi i¸cin ba¸ska bir algoritma kullanılmadı˘gını
varsayarsak). Araya giren k¨otu¨ niyetli Z ki¸sisi mesajlara ula¸stı˘gı taktirde mesajın
di˘ger tarafa gitmesini engelleyebilir ve hatta anahtarı bilmesi durumunda bu mesajı
kendisininkilerle de˘gi¸stirerek iki haberle¸sme tarafını da farkında olmaksızın bamba¸ska
mesajlar g¨onderebilir.
T˙IP˙IK AC¸ IK ANAHTAR KR˙IPTOS˙ISTEM˙I
˙ILE HABERLES¸ME
A ve B ki¸sileri bir a¸cık anahtar kriptosistemi uzerinde ¨ anla¸sırlar. Simetrik anahtarlı sistemde oldu˘gu gibi burdada kriptosistem uzerinde ¨ anla¸sma gizli yapılmak zorunda de˘gildir.
B ki¸sisi A ki¸sisine kendi a¸cık anahtarını g¨onderir. A ki¸sisi mesajını B’nin a¸cık anahtarı
ile ¸sifreler ve g¨onderir. B ki¸sisi ise kendi gizli anahtarı ile mesajı c¨¸ozer ve mesaja ula¸sır.
A¸cık anahtarlı tipik haberle¸sme sistemlerinin en onemli ¨ dezavantajı ortalama olarak
simetrik bir algoritmadan 1000 kat yava¸s olmalarıdır. Uzun mesajları bu yolla g¨ondermek
125
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
pratik de˘gildir.
T˙IP˙IK KARMA (hybrid) KR˙IPTOS˙ISTEMLER
B, A’ya a¸cık anahtarını g¨onderirir. A bir oturumda kullanılmak uzere ¨ rastgele bir oturum anahtarı uretir ¨ ve B’nin a¸cık anahtarı ile ¸sifreleyerek B’ye g¨onderir. B ki¸sisi ise gizli
anahtarı aracılı˘gıyla edindi˘gi oturum anahtarını a¸car ve daha sonra bu anahtarı belirledikleri simetrik kriptosistemde kullanarak haberle¸smelerini sa˘glarlar.
Tahmin edilece˘gi uzere ¨ bu sistemde taraflar, simetrik kriptosistem anahtarı belirlemek
i¸cin biraraya gelmek zorunda kalmamaktadırlar.
HASH FONKS˙IYONLARI
Hash fonksiyonlarının kriptografide birazdan bir miktar inceleyece˘gimiz uzere ¨ cok ¸ geni¸s bir
kullanım alanı vardır. Hash fonksiyonları, oncelikle ¨ tek-y¨onlu¨ (one-way) fonksiyonlardır.
Yani bir verinin fonksiyon altında g¨orun¨ tus ¨ un¨ u¨ hesaplamak kolaydır ama g¨orun¨ tuden ¨
fonksiyonun tersi aracılı˘gıyla ana veriyi elde etmek hesaplama guc¨ u¨ anlamında zordur.
Hash fonksiyonları ile elde etti˘gimiz de˘ger, yani hash de˘geri, fonksiyon girdisinin de˘gi¸sken
boyuta sahip olmasına kar¸sın sabit boyuta sahiptir ve genelde hash de˘geri, girdiye g¨ore
cok ¸ daha ufak boyuttadır. Kullanılan Hash fonksiyonlarından birbirine cok ¸ benzer girdi
de˘gerlerini i¸cin dahi cok ¸ farklı cıktılar ¸ uretmesi ¨ beklenir. Ve yine onemli ¨ bir ozellik ¨ olarak
hash fonksiyonlarından cakı ¸ ¸smasız (collision-free) olmaları umulur. Yani hash fonksiyonumuz altında aynı hash de˘gerini veren iki girdinin bulunması hesaplama guc¨ u¨ g¨oze
alındı˘gında cok ¸ zor olmalıdır.
126
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Yukarda bahsedilen ozellikler ¨ ı¸sı˘gında hash de˘gerleri, verilerin parmak izi olarak
du¨¸sun¨ ulebilir. ¨ Dolayısıyla birisinde olan bir d¨okumanın ¨ sizde de oldu˘gunu d¨okumanı ¨
o ki¸siye g¨ondermeden ispat etmek isterseniz hash de˘gerini ona s¨oyleme yolunu kullanabilirsiniz. Nitekim dokumanın ¨ elinizde ger¸cekten olmaması durumunda o d¨okumana ¨ ait
hash de˘gerini uretmeniz ¨ cok ¸ zordur. En cok ¸ kullanılan hash fonksiyonları arasında SHA
ve MD5 algoritmaları sayılabilir.
GUNL ¨ UK¨ HAYATTA ˙IMZA
Gunl ¨ uk¨ hayatta sık¸ca kullandı˘gımız imzalarda aradı˘gımız bizim i¸cin cok ¸ onemli ¨ ozellikleri ¨
g¨ozden ge¸cirelim;
1) ˙Imza otentiktir(authentic), imzalayanın kimli˘gini g¨osterir
2) ˙Imza co˘ ¸ galtılamaz.
3) ˙Imza tekrar kullanılamaz.
4) ˙Imza de˘gi¸stirilemez. Uzerinde ¨ oynama yapılamaz.
5) ˙Imza atan ki¸si attıktan sonra imzasını inkar edemez.
AC¸ IK ANAHTAR KR˙IPTOS˙ISTEMLERLE D˙IJ˙ITAL ˙IMZA
Tipik bir a¸cık anahtar kriptosisteminde A ki¸sisi kendi gizli anahtarı ile imzalamak istedi˘gi
d¨okumanı ¨ ¸sifreler. B ki¸sisi ise A’nın a¸cık anahtarı ile d¨okumanı ¨ a¸car. E˘ger a¸camazsa imza
ge¸cerli de˘gildir, imza birisi tarafından ya da do˘gal etkenlerle bozulmu¸stur.
Bu basit imza protokolune ¨ k¨otu¨ taraftan bakacak olursak imzalı d¨okumanı ¨ alan ki¸si dijital ortamda bu imzalı d¨okumanı ¨ diledi˘gi kadar co˘ ¸ galtabilir. ˙Imzalı d¨okuman ¨ bir anla¸sma
127
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
metni ise bu elbette ciddi bir sorun te¸skil etmeyebilir ancak d¨okumanın ¨ para ka¸sılı˘gı
olan bir cek ¸ oldu˘gunu kabul edersek durum farklı olabilir. B ki¸sisinin farklı zamanlarda
farklı ceklermi ¸ ¸s gibi aynı imzalı ceki ¸ bozdurmasını istemeyiz. Bu gibi tekrar kullanımları
onlemek ¨ i¸cin dijital d¨okumanlar ¨ co˘ ¸ gu zaman hangi tarihe ait olduklarını g¨osteren bir zamanpulu (timestamp) ile beraber kullanılır. Mesaj algoritma ile imzalanıp kapatılmadan
once ¨ i¸cine tarih bilgileri de eklenir.
AC¸ IK ANAHTAR KR˙IPTOS˙ISTEM VE HASH FONKS˙IYONUYLA ˙IMZA
A ki¸sisi bu defa d¨okumanın ¨ kendisini (zamanpulu ile veya zamanpulsuz) imzalamak yerine d¨okumanın ¨ bir hash fonksiyonu sonucu uretilmi ¨ ¸s hash de˘gerini imzalar. Ve A ki¸sisi
imzalamak uzere ¨ kullandı˘gı d¨okumanla ¨ beraber imzalanmı¸s hash de˘gerini B’ye g¨onderir.
Alıcı olan B ise imzayı A’nın a¸cık anahtarı ile a¸ctıktan sonra d¨okumanın ¨ hashini kendisi
hesaplar ve bu de˘gerin g¨onderilen hash de˘geri ile uyup uymadı˘gına bakar. E˘ger uyuyorsa
imza ge¸cerlidir. Aksi halde ge¸cersizdir.
Bu protokol d¨okumanın ¨ kendisi yerine sadece hash de˘gerini imzaladı˘gımız i¸cin d¨okumanın ¨
boyutuna ba˘glı olarak bir oncekine ¨ g¨ore inanılmaz ol¸ ¨ cude ¨ hızlı olabilir. ˙Iki farklı
d¨okumanın ¨ hash de˘gerlerinin orne˘ ¨ gin 160-bit’lik bir cıktı ¸ ureten ¨ bir hash fonksiyonunda
1/2
160 oldu˘gu du¨¸sun¨ ul ¨ urse ¨ hash de˘gerini imzalamakla d¨okumanın ¨ kendisini imzalamanın
rahatlıkla e¸sle¸stirilebilece˘gi ortaya cık ¸ ar. Ancak hash fonksiyonunun temel ozellikleri ¨
sa˘glaması gerekti˘gi unutulmamalıdır. S¸ayet tek-y¨onlu¨ olmayan bir hash fonksiyonu
kullanılsaydı, bir d¨okuman ¨ imzalandı˘gı zaman onunla aynı hash de˘gerini veren tum¨
d¨okumanlar ¨ da beraberinde aynı ki¸si tarafından imzalanmı¸s olacaktı.
Bu metodla A ki¸sisi bir d¨okumanı ¨ a¸cı˘ga cık ¸ armadan d¨okumana ¨ sahip oldu˘gunu ispatlaya128
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
bilir. Orne˘ ¨ gin ’copyright’ hakkına sahip olmak isteyece˘gimiz bir d¨okumanı ¨ d¨okumanın ¨
kendisini a¸cı˘ga cık ¸ amadan imzalayabiliriz.
D˙IJ˙ITAL ˙IMZALARDA ˙INKAR EDEMEMEZL˙IK (nonrepudiation)
Yukardaki algoritmanın eksik bir yanı, belgeyi imzalayan ki¸siye her zaman hile olana˘gı
vermesidir. S¸oyle ¨ ki, e˘ger d¨okumanda ¨ bir zamanpulu mevcut de˘gilse A ki¸sisi d¨okumanı ¨
imzaladı˘gını inkar etmek istedi˘gi bir durumda her zaman i¸cin gizli anahtarını herhangi
bir dijital ortamda bırakarak daha sonra da gizli anahtarının calındı˘ ¸ gını ve d¨okumanın ¨
kendisi de˘gil de imzasını calan ¸ ki¸si tarafından imzalandı˘gını one ¨ surebilir. ¨ Bu gibi durumlarda co˘ ¸ gu zaman 3. guv¨ enilir ki¸si olan hakemlerin kontrolunde ¨ olan bir protokole ihtiya¸c
duyulabilir.
˙INKAR ED˙ILEMEYEN D˙IJ˙ITAL ˙IMZALAR
Protokolum¨ uz¨ bu defa bir par¸ca daha karı¸sık ve de 3. guv¨ enilir T ki¸sisine dayanıyor.
S¸oyle ¨ ki; A ki¸sisi mesajı imzalar ve mesaja kendisini tanımlayan bir ba¸slık ekler. Elde
etti˘gi bu yeni birle¸stirilmi¸s mesajı tekrar imzalar ve T ki¸sisine g¨onderir. 3. ki¸side herkesin
a¸cık ve gizli anahtarı bulunmaktadır dolayısıyla dı¸staki mesajı A ki¸sisinin a¸cık anahtarı
ile a¸carak A ki¸sisinin kendisini tanımladı˘gı eklentiye eri¸sir. T daha sonra mesajı ger¸cekten
a ki¸sisinin g¨onderdi˘gini B’ye onaylamak i¸cin mesajın ne zamana ait oldu˘gu bilgisini de
ekleyerek imzalar ve hem A’ya, hem de B’ye g¨onderir. B ki¸sisi T’nin imzasını a¸car ve
A’nın kimlik bilgilerine ula¸sarak imzayı onaylar. ˙Imzanın A’ya da g¨onderiliyor olmasının
sebebi bir anlamda A’ya ”Senin adına ¸s¨oyle bir mesaj g¨onderildi, ¸sayet bunu ger¸cekten
129
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
g¨onderen sen de˘gil de (¨orne˘gin anahtarını calan) ¸ bir ba¸skası ise acele konu¸s, daha sonra
bunu inkar edemezsin” denmesidir.
Bahsedilebilecek bir nokta da ¸sudur ki bu protokolde zaman bilgileri a¸cısından T’ye
guv¨ enilmektedir. Dolayısı ile T ile bir ¸sekilde anla¸san birisi d¨okumanının ¨ tarihi hakkında
hileye giri¸sebilir. Protokolde B’nin A’da mesajı aldıktan sonra ger¸cekten ona dair olup
olmadı˘gını onaylaması i¸cin T’ye sorması gibi de˘gi¸siklikler yapılması suretiyle alternatifleri
de turetilebilir. ¨
S¸
˙IFRELEME ve D˙IJ˙ITAL ˙IMZA
A ve B ki¸silerinin her ikisinin de a¸cık ve gizli anahtarlarının bulundu˘gu bir ortamda bir
mesajı hem ¸sifrelemek ve hem de imzalamak istedi˘gimiz bir durumda A ki¸sisi, mesajı,
basit¸ce s¨oylemek gerekirse once ¨ kendi gizli anahtarı ile imzalar ve daha sonra da imzalanmı¸s mesajı B’nin a¸cık anahtarı ile ¸sifreleyerek B’ye g¨onderir. B de mesajı kendi kapalı
anahtarı ile de¸sifre eder ve daha sonra da A’nın a¸cık anahtarı ile imzaıyı onaylar. S¸ayet
mesajı sorunsuz bir ¸sekilde aldı˘gını A’ya iletmek isterse A’nın yaptı˘gı i¸sin tersini yaparak
mesajı tekrar A’ya g¨onderebilir. A¸cık¸ca ifade etmek gerekirse, B ki¸sisi mesajı kendi gizli
anahtarı ile mesajı imzalayıp daha sonra da A’nın a¸cık anahtarı ile imzayı ¸sifreleyerek
mesajı A’ya g¨onderebilir. A’nınsa geri ters operasyonlarla g¨onderdi˘gi orjinal mesajı elde
etmesi durumunda i¸slemlerin ba¸sarıyla ger¸cekle¸sti˘gi kabul edilir.
Bu operasyonlarda mesajın ¸sifrelenmeden once ¨ imzalanması do˘gal g¨ozukmektedir. ¨ Tersi
bir sıra uygulanması durumunda tıpkı ka˘gıt yerine zarfı imzalayan birisinin, bir ba¸skasına
zarfın i¸cinden ka˘gıdı cık ¸ ararak ba¸ska bir ka˘gıt koyup, koydu˘gu ka˘gıdı imzalanmı¸s
g¨ostermesi gibi bir imkan verdi˘gi a¸cıktır.
130
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Burada dikkat edilmesi gereken bir nokta da ¸sudur ki bu protokol de bir takım ataklara
maruz kalabilir. Orne˘ ¨ gin ba¸skalarından gelen rasgele mesajların imzalanmaması gerekir.
Aynı ¸sekilde ba¸skalarından gelen rasgele mesajların de¸sifre edilip sonucun ba¸skalarına verilmesi de direkt olarak saldırıya meydan verebilmektedir. Ancak genel olarak ¸sifreleme ve
imzalama i¸cin farklı algoritmalar kullanıldı˘gı taktirde ya da aynı algoritma kullanılsa bile
bu iki operasyon i¸cin farklı anahtarlar kullanıldı˘gı zaman bu gibi basit bir saldıyıa meydan
verilmedi˘gi s¨oylenebilir. Benzer ¸sekilde zamanpulu eklentisi de mesajları farklıla¸stırdı˘gı
i¸cin hash fonksiyonlarını burada kullanmak saldırılara kar¸sı iyi bir c¨¸ozum¨ olabilmektedir.
Protokol, de˘gi¸sik ama¸clar ve ortamlar do˘grultusunda ¸sekillendirilebilir.
ANAHTAR DEG˘ ˙IS¸
˙IM˙I (Key Exchange)
Kriptografide en temel uygulamalardan birisi anahtar de˘gi¸simidir. Standart ¸sifreli
haberle¸sme i¸cin, kar¸sılıklı anahtar de˘gi¸simi ba¸sarı ile ger¸cekle¸smi¸sse, co˘ ¸ gu zaman herhangi
bir guv¨ enilir 128-bit (yada daha geni¸s) blok ¸sifre kullanılarak ileti¸sim sa˘glanabilir. Ancak de˘ginildi˘gi gibi oncelikli ¨ olarak anahtar de˘gi¸siminin guv¨ enilir bir ¸sekilde ger¸cekle¸smesi
gereklidir. Sadece belli bir oturum (yada haberle¸sme seansı) i¸cin kullanılan anahtara oturum anahtarı denir.
Anahtar de˘gi¸simi i¸cin simetrik algoritmalar kullanılırsa, guv¨ enilir u¸¨cunc ¨ u¨ ki¸sinin de
yardımıyla anahtar de˘gi¸simini ger¸cekle¸stirmek mumk ¨ und ¨ ur. ¨ Ancak burada, ilk a¸samada
guv¨ enilir 3. bir ki¸siye ihtiya¸c bırakmayan, a¸cık anahtar metoduyla ger¸cekle¸stirilen ve cok ¸
daha i¸slevsel olan bir y¨ontem ele alınacaktır.
131
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
AC¸ IK ANAHTAR METODUYLA ANAHTAR DEG˘ ˙IS¸
˙IM˙I
Bu uygulamada A ki¸sisi once ¨ B’nin a¸cık anahtarını temin eder, rastgele olu¸sturdu˘gu oturum anahtarını B’nin a¸cık anahtarı ile ¸sifreleyerek B’ye g¨onderir. B ki¸sisi ise kendi gizli
anahtarı ile A’nın mesajını a¸car ve haberle¸smelerini g¨onderilen oturum anahtarını kullanarak, simetrik bir algoritma aracılı˘gı ile yur ¨ ut ¨ urler. ¨ Burada a¸cık ve kapalı anahtarlar
bir a¸cık anahtar algoritmasına, oturum anahtarı ise bir simetrik ¸sifreleme algoritmasına
(DES, SAFER, Vigenere vb) aittir.
Burada pasif bir saldırgan i¸cin, yani herhangi bir mudahalede ¨ bulunmayan k¨otu¨ niyetli
ki¸si E i¸cin kullanılan a¸cık anahtar algoritmasını kırmaya calı ¸ ¸smaktan ba¸ska bir yol
g¨orunmemektedir. ¨ Ancak aktif saldırgan i¸cin aynısı s¨oz konusu de˘gildir. Aktif saldırgan,
e˘ger iki ki¸si arasındaki mesajlara eri¸sme ve hatta de˘gi¸stirme imkanına sahipse, B ki¸sisi
A’ya a¸cık anahtarını g¨onderirken araya girip ona kendi a¸cık anahtarını g¨onderebilir.
A ki¸sisi de oturum anahtarını, B’nin anahtarı sandı˘gı bu anahtarla ¸sifreleyerek geri
g¨onderdi˘ginde ise, k¨otu¨ niyetli ki¸si zaten kendi a¸cık anahtarı ile ¸sifrelenmi¸s bu mesajı rahatlıkla a¸cıp okuyabilir. Dahası E, mesajı B’nin ger¸cek a¸cık anahtarı ile tekrar ¸sifreleyerek
B’ye g¨ondererek onların hi¸cbir¸sey olmamı¸scasına anahtarı kendisinde olan bir simetrik algoritmayla haberle¸smelerini sa˘glayabilir. Aktif saldırgan, hissedilir bir yava¸slamaya sebep
olmadı˘gı surece ¨ bu ¸sekilde A ve B ki¸silerinin haberi bile olmadan onların ¸sifreleyerek
g¨onderdikleri tum¨ mesajları okuyabilir. Ortadaki 3. ki¸si tarafından ger¸cekle¸stirilen bu
saldırıya ”ortadaki-adam saldırısı” (man-in-the-middle attack) adı verilir.
132
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Burada bir nokta ise protokolun¨ adım adım i¸slemesi yerine A ki¸sisi tek bir g¨onderimle,
B’nin a¸cık anahtarı ile ¸sifreledi˘gi oturum anahtarını, o oturum anahtarı ile ¸sifreledi˘gi
mesajla birlikte B’ye g¨onderebilir. B de once ¨ kendi gizli anahtarı ile oturum anahtarını
elde eder, sonra da bu anahtarı kullanarak simetrik algoritma ile ¸sifrelenmi¸s mesajı a¸carak
orjinal mesaja ula¸sır.
ARAK˙IL˙IT PROTOKOLU¨ (Interlock Protocol)
Yukarıda de˘ginilen ortadaki-adam saldırısı, A ve B ki¸silerinin ger¸cekten birbirleri ile
konu¸stuklarını onaylama ¸sansları yokken kullanılabilir. Arakilit protokolunde ¨ A ve B
ki¸sileri birbirlerine kar¸sılıklı olarak a¸cık anahtarlarını g¨onderirler. Burada aktif saldırgan
hala araya girip tarafların a¸cık anahtarlarını kendi belirledi˘gi bir a¸cık anahtar ile
de˘gi¸stirebilir) Ancak sonrasında protokol farklı i¸sler. A ki¸sisi oturum anahtarını (veya herhangi bir mesajı da olabilir) yine B’nin a¸cık anahtarı ile ¸sifreler ancak bu defa ¸sifrelenmi¸s
mesajın kendisi yerine yarısını B’ye g¨onderir. Aynı ¸sekilde B ki¸sisi de kendi ¸sifreledi˘gi
mesajın ilk yarısını A’ya g¨onderir. Ve daha sonra, yine once ¨ A ki¸sisi ve sonra da B ki¸sisi
olmak uzere ¨ her iki taraf da ¸sifreledi˘gi mesajın kalan yarısını birbirine g¨onderirler ve iki
yarımı birle¸stirerek kendi gizli anahtarlarıyla mesajın hepsini de¸sifrelerler.
Burada mesajın ikinci yarısı olmadan ilk yarısı kullanı¸ssızdır. Taraflar da ortadaki adam
gibi mesajın ikinci yarısı gelmeden ¸sifreli mesajı de¸sifre etme ¸sansına sahip de˘gildirler. Burada ortadaki-adamı safdı¸sı bırakan etken nedir? Aktif saldırganın daha once ¨ a¸cık anahtarları kendisininki ile de˘gi¸stirerek daha sonra ¸sifreli metinlere nasıl eri¸sti˘gini hatırlayınız.
133
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Ancak burada a¸cık anahtar ile giden mesaj, mesajın tamamı de˘gil. Dolayısıyla saldırgan,
mesajı kendi gizli anahtarı ile a¸cıp B ki¸sisinin a¸cık anahtarı ile tekrar ¸sifreleme ¸sansına
sahip de˘gil. C¸unk ¨ u¨ ¸sifreli mesaj yarım oldu˘gu i¸cin mesajı herhangi bir ¸sekilde a¸cma/
de¸sifre etme ¸sansına sahip de˘gil. Peki bu ozelli˘ ¨ gi sa˘glayan yarım mesaj nedir? Mesajı iki
’yarım’a b¨olmek i¸cin nasıl bir mekanizma kullanılabilir?
Burada kullandi˘gımız mesajı iki par¸caya b¨olup¨ g¨onderme metodundaki par¸calardan ilki
¸sifreli mesajın bir hash fonksiyonu ile elde edilmi¸s bir hash de˘geri olurken ikincisi ise
¸sifreli mesajın kendisi olabilir orne˘ ¨ gin. Ya da ger¸cekten bir 64-bit blok ¸sifre algoritması
ile ¸sifrelenmi¸s mesajın 32’¸ser bit uzunlu˘gunda iki yarısı olabilir. Her iki durumda da
ikinci mesaj gelmeden de¸sifreleme yapılamayacaktır. Ve yine her iki durumda da aktif
saldırganın 2. ¸sifreli mesaj yarısını da bilmeden mesajı de˘gi¸stirmesine olanak yoktur.
˙Ikinci ¸sifreli mesaj, taraflardan birisi tarafından g¨onderildi˘ginde ise coktan ¸ mesajın onay
i¸cin kullanılacak olan ilk yarısı di˘ger tarafın eline ula¸smı¸stır. Dolayısıyla ortadaki adam
i¸cin saldırı vakti coktan ¸ ge¸cmi¸stir. Nitekim protokolun¨ i¸sleyi¸si bunu gerektirmektedir.
Arakilit protokolu¨ Rivest ve Shamir tarafından geli¸stirilmi¸stir.
D˙IJ˙ITAL ˙IMZALARLA ANAHTAR DEG˘ ˙IS¸
˙IM˙I
S¸u ana kadar mesajımızın kendisini ya da mesajımızı iletmede kullanaca˘gımız simetrik
algoritmaya ait anahtarımızı g¨ondermekte kullandı˘gımız metodlarda a¸cık anahtarımızı
g¨onderirken aktif bir saldırganın her zaman i¸cin ger¸cek dun¨ ya uygulamaları ile son derece
ort ¨ u¨¸sen bir ihtimal olan araya girip tarafların a¸cık anahtarlarını de˘gi¸stirmek suretiyle
134
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
ce¸ ¸sitli saldırılarda bulunabilece˘gini kabul ettik. Bu sebeple a¸cık anahtarları da˘gıtmanın
nasıl daha guv¨ enli bir ¸sekilde olabilece˘gi sorusuna cevap olarak 3. guv¨ enilir T ki¸sisinin
imzasını da protokole dahil edelim. S¸oyle ¨ ki; basit bir ifade ile, A ve B ki¸sileri anahtarlarını direkt olarak birbirlerine g¨ondermeleri yerine, 3. guv¨ enilir T ki¸sisi onlar i¸cin anahtar
belirleyip bu anahtarı imzalayabilir. Ve bu ¸sekilde A ve ki¸sileri sadece T ki¸sisinden imzalı
anahtarlar kullanmak uzere ¨ kar¸sılıklı anla¸smı¸slardır. Ve T ki¸sisinin guv¨ enli oldu˘gunu, yani
onun anahtar veri tabanına kimse tarafından eri¸silemedi˘gini kabul edersek (ki bu belli ve
tek bir anahtar da˘gıtıcısının guv¨ enli˘gi sa˘glamak ayrı ayrı pek cok ¸ kullanıcının guv¨ enli˘gini
sa˘glamaktan her zaman i¸cin daha kolaydır) aktif saldırgan araya girip a¸cık anahtarları
kendi anahtarı ile de˘gi¸stiremez.
Bu arada her zaman i¸cin protokol detayları uzerinde ¨ duzenlemeler ¨ yaparak protokolde
faydalı de˘gi¸siklikler yapabilmemizin olası oldu˘gunu unutmayalım. Orne˘ ¨ gin yukarda a¸cık
ve gizli anahtarlarımızı ilk a¸samada bizim i¸cin T ki¸sisinin de˘gil de kendimizin uretti˘ ¨ gini
ve T ki¸sisinin sadece bizim uretti˘ ¨ gimiz anahtarların imzası i¸cin protokolde yer aldı˘gını
du¨¸sun¨ ursek, ¨ anahtarı g¨onderece˘gimiz B ki¸sisi anahtarımızda her zaman T’nin imzasını
arayaca˘gı i¸cin ve aktif saldırgan da dijital imza metodlarının guv¨ enilirli˘gi ol¸ ¨ cus ¨ unde ¨ T
ki¸sisinin imzasını de˘gi¸stiremeye˘gi i¸cin a¸cık anahtar g¨onderimlerimizi cok ¸ daha guv¨ enilir
bir ¸sekilde yur ¨ utebiliriz. ¨ Ustelik ¨ bu durumda aktif saldırgan T’nin dijital anahtarını ele
ge¸cirse bile bu anahtarı A ve B taraflarının mesajlarını okumakta kullanamaz, sadece yeni
a¸cık anahtarlar imzalayabilir. C¸unk ¨ u¨ T’de sadece bizim a¸cık anahtarlarımızı imzalamada
kullandı˘gı bir dijital imza anahtarı bulunmaktadır.
135
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
OTENT˙IKASYON(kimlik do˘grulama)
Bir bilgisayara kendimizi tanıtmak i¸cin kullandı˘gımız yegane metod parola kullanmaktır.
Ancak ilk kez Needham ve Guy ikilisinin ortaya koydu˘gu ¸sekliyle otentikasyon yapan bilgisayarda parolaların kendilerinin bulunmasına gerek yoktur. Dolayısıyla sistem
y¨oneticisinin (ya da sizin parolalarınıza direkt eri¸sme ¸sansına sahip birisinin) parolanızı
farklı ama¸clar i¸cin kullanmasını (¨orne˘gin aynı parolayı kullandı˘gınız ba¸ska bir sisteme
sizin adınıza eri¸smesini) onemli ¨ ol¸ ¨ cude ¨ zorla¸stırmaya yol a¸can ger¸cek ¸sudur ki, bilgisayar i¸cin gerekli olan i¸cinde tum¨ kullanıcı parolalarının bulunması de˘gil, sadece yanlı¸s
girilen parolaları di˘gerlerinden ayırt edebilmesidir. Bu da hash fonksiyonları sayesinde
ger¸cekle¸smektedir, ¸s¨oyle ki; kullanıcı otentikasyon yapılacak bilgisayara parolasını girer,
bilgisayar bu parolanın hash de˘gerini hesaplar ve kendi veri tabanındaki aynı kullanıcı
i¸cin tutulan hash de˘geri ile uyup uymadı˘gını kontrol eder.
Burada otentikasyon yapılan bilgisayara eri¸simi olan bir saldırgan hala ¸sunu yapabilir;
parola olarak kullanılabilecek cok ¸ miktarda s¨ozcuk¨ ureterek ¨ bunların hash de˘gerlerini
hesaplar ve veri tabanındakilerle kar¸sıla¸stırır. Bu metodla yeterli miktarda surey ¨ e sahip
oldu˘gu taktirde tum¨ olası kelimeleri deneyerek parolalara ula¸sabilir. Bu operasyonu
pratik olarak zorla¸stırmak i¸cin tuzlama (salting) i¸slemi uygulanır. Tuzlama, parolalara
hash fonksiyonundan ge¸cirmeden once ¨ rastgele metin eklemektir. Orne˘ ¨ gin UNIX sistemlerde 12-bit tuzlama uygulanmaktadır. Tuzlama metoduyla otentikasyon i¸slemini onemli ¨
oranda yava¸slatmaksızın bir s¨ozluk¨ saldırısını cok ¸ ciddi bi¸cimde zorla¸stırmak mumk ¨ und ¨ ur. ¨
Ancak her zaman i¸cin kolay tahmin edilebilir parolalar b¨oyle bir saldırıda once ¨ kırılanlar
136
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
olacaktır ve tuzlama onları daha gu¸¨clu¨ hale getirmemektedir.
AC¸ IK ANAHTAR KR˙IPTOGRAF˙I
˙ILE OTENT˙IKASYON
Otentikasyonun cok ¸ uzaktaki bir makina tarafından yapıldı˘gı bir ortam du¨¸sunelim. ¨
Orne˘ ¨ gin bizden birka¸c ulk ¨ e uzaklıkta olan bir internet sitesine kendimizi tanıtmak i¸cin
kullandı˘gımız parolamızın a¸cık bir ¸sekilde onca yolu gitmesi ne kadar sa˘glıklı olabilir?
Bunun i¸cin yukardaki basit otentikaston protokolum¨ uz¨ u¨ a¸cık anahtar sistemli otentikaston kullanacak nasıl de˘gi¸stiririz?
A¸cık anahtar kullanan otentikaston metodunda Biz parola yerine kendi gizli anahtarımızı
bilmekteyiz. Makinada ise bizim a¸cık anahtarımız bulunur. Otentikasyon ¸s¨oyle i¸sler; makina bize rastgele bir metin g¨onderir. Biz de gizli anahtarımızla bu metni ¸sifreler ve makinaya geri g¨ondeririz. Makina, bizim a¸cık anahtarımız ile g¨onderdi˘gimiz mesajı a¸ctı˘gında
kendi g¨onderdi˘gi rastgele metni bulursa bize sistem eri¸simi verir. Bu metodun kullanıldı˘gı
ortamda, ne otentikasyon makinasının (gizli anahtarımız sadece bizde bulunuyor, makina
veritabanında mevcut de˘gil), ne de ileti¸sim yolunun (a¸cık anahtar kriptosisteminin temel
ozelli˘ ¨ ginden dolayı) guv¨ enli olması gerekmemektedir.
SIR PARC¸ALAMA (secret splitting)
Bir bilgiyi iki ki¸si arasında payla¸stırmak istedi˘gimizi du¨¸sunelim. ¨ Oyle ¨ ki; her ikisi de
biraraya gelmeden bilgiye ula¸samasınlar. Payla¸stırılacak olan M mesaji i¸cin aynı bit
uzunlu˘gunda R gibi bir rastgele metin olu¸sturdu˘gumuzu du¨¸sun¨ ursek ¨ M ⊕ R = S ¸seklinde
137
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
bir xorlama operasyonu ile S metini elde etti˘gimizi du¨¸suenlim. ¨ Bu durumda bir ki¸siye R’ı
ve de di˘ger ki¸siye de S’i verdi˘gimizi du¨¸sun¨ ursek ¨ her ikisi de biraraya gelmeden M mesajını
elde edemezler. Biraraya geldiklerinde ise R ⊕ S = M ile mesajı geri d¨onu¨¸sturebilirler. ¨
Bu basit metodu ikiden fazla ki¸side uygulamak i¸cinse bir sırrı 4 ki¸si arasında payla¸stırmak
istedi˘gimizi du¨¸sunelim. ¨ Bu defa sır metni ile yine aynı uzunlukta R,S ve T rastgele
metinlerine ihtiyacımız olacak. M ⊕ R ⊕ S ⊕ T = U ¸seklinde bir operasyonla, R,S,T ve
U metinlerini farklı 4 ki¸siye da˘gıtarak ancak biraraya geldiklerinde tum¨ sahip oldukları 4
metni xorlayarak M’i elde etmelerine izin verebiliriz. Dahası bu 4 ki¸siden birisini safdı¸sı
bırakmak istedi˘gimizde onun metinini di˘gerlerine da˘gıtmamız yeterli olacaktır. Bu sayede
o olmadan da bu xor operasyonunu yaparak ana metne ula¸sabilirler.
SAKLI ˙ILET˙IS¸
˙IM YOLU (subliminal channel)
Birisiyle haberle¸smek istedi˘giniz, ancak bunun 3. bir ba¸ska ki¸si aracılı˘gıyla ger¸cekle¸smesi
dı¸sında mumk ¨ un¨ olmadı˘gını bir senaryo du¨¸sunelim. ¨ Ve bu 3. ki¸si de mesajın ¸sifreli
olmasına izin vermiyor, kendisi mesajınızı iletmeyi ancak o i¸ceri˘gini okuyabildi˘gi zaman kabul ediyor. ˙I¸ste b¨oylesi bir durumda bir saklı ileti¸sim yolu metodu kullanımı
c¨¸ozum¨ olabilir. Yani iletti˘gimiz mesajda gizli bir algoritmayla saklanmı¸s, g¨orunenin ¨
ardındaki ba¸ska bir mesajla hem di˘ger tarafa mesajımızı ula¸stırıp hem de 3. aracı
ki¸sinin yalnızca g¨orun¨ urdeki ¨ mesajı g¨onderdi˘gimizi sanmasına yol a¸carak ger¸cekte ne
g¨onderdi˘gimiz hakkında hi¸c bir fikri olmamasını sa˘glayabiliriz.
138
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
C¸ ok basit bir saklı ileti¸sim yolu metodu olarak, kurdu˘gumuz cumlelerde ¨ tek sayıda kelime
olması durumunda 1-bitini, cift ¸ sayıda kelime i¸ceren cumleler ¨ ile de 0-bitini g¨onderdi˘gimizi
du¨¸sunebiliriz. ¨ Saklı ileti¸sim yoluyla, tıpkı steganografide oldu˘gu gibi herhangi bir anahtar
bulunmamakta ve mesajın gizlili˘gi tamamen algoritmanın gizlili˘gine dayanmaktadır. Saklı
ileti¸sim yollarına cok ¸ ce¸ ¸sitli uygulama alanları bulmak olasıdır. Orne˘ ¨ gin dijital imzalama sırasında saklı ileti¸sim yolu metodları ile mesaji bir taraftan imzalarken di˘ger
taraftan imzanın i¸cine ”ben bu mesajı baskı altında imzalıyorum” gibi bir ifade saklamak mumk ¨ und ¨ ur. ¨
B˙IT VADETME (bit commitment)
S¸oyle ¨ bir senaryo du¨¸sunelim; ¨ Bir yatırımcıya hisse senedi onerece˘ ¨ giz. Yukselecek ¨ olan
hisseleri onerebilirsek, ¨ kar¸sılı˘gında ondan bir i¸s alaca˘gız. Ancak onerdi˘ ¨ gimiz hisse senetlerini hemen bilmesini istemiyoruz, c¸unk ¨ u¨ o zaman bize i¸si vermeden o senetlere kendisi para yatırıp bizi yuz¨ ust ¨ u¨ bırakabilir. Ancak di˘ger taraftan, yatırımcı da bizim
samimiyetimize inanmak istiyor. E˘ger hisse senedi sonu¸cları belli olduktan sonra ona
a¸cıklarsak, sonucu ba¸stan tahmin etti˘gimize dair onu ikna etme ¸sansımız kalmaz. Ozetle ¨
durum ¸su ki; A ki¸sisi, B ki¸sisine, belli bir tarihte belli bir bilgiyi bildi˘gini aradan bir sure ¨
ge¸ctikten sonra ona ispatlamak istiyor, ve kendisi izin verene kadar bilginin ne oldu˘guna
dair B’ye ipucu vermek istemiyor.
B ki¸sisi rastgele bir R metni uretir ¨ ve bunu A’ya g¨onderir. A’nın belli bir grup bit
i¸cerisinden se¸cimini g¨osteren bite ’b’ dersek A ki¸sisi, simetrik bir algoritma kullanarak
139
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
kendi belirledi˘gi bir anahtar ile (R,b) ikisisini ¸sifreler ve geri B’ye g¨onderir. Ve se¸cti˘gi biti
a¸cı˘ga cık ¸ armak istedi˘gi gun¨ geldi˘ginde ise ¸sifrelemede kullandı˘gı anahtarı B’ye vererek
onun paketi a¸cmasını sa˘glar. B ki¸sisi ise kendi ilk ba¸sta g¨onderdi˘gi rastgele R metninin
pakette se¸cim biti ile beraber bulunup bulunmadı˘gını kontrol eder. E˘ger protokolde b¨oyle
bir rastgele R metni olmasaydı, s¨ozkonusu olan yalnızca bir bit olabilece˘gi i¸cin A ki¸sisi son
a¸samada g¨onderdi˘gi paketi rahatlıkla istedi˘gi bite (veya hatta bit grubuna) de¸sifre edebilen bir anahtar g¨onderebilirdi. Ancak paketin i¸cinde fazladan bir rastgele metnin farklı
anahtarlı de¸sifre etmeler i¸cin bozulacak olması A ki¸sisini b¨oylesi bir hileden alıkoyar.
SIFIR-B˙ILG˙I
˙ISPAT METODU (zero-knowledge proof)
Sıfır bilgi ispat, kısaca belli bir bilgiye sahip oldu˘gumuzu, o bilginin ne oldu˘gunu a¸cı˘ga
cık ¸ armadan ispatlamamızı sa˘glayan metodtur. S¸oyle ¨ ki, ispatlayaca˘gımız problemi onunla
e¸syapıda (isomorphic) ba¸ska bir probleme d¨onu¨¸sturerek ¨ problemin kendisi yerine yeni
problemi ispatlıyoruz. Ancak d¨onu¨¸sturd ¨ u˘¨gum¨ uz¨ problemi, oyle ¨ bir ¸sekilde se¸ciyoruz ki bu
yeni problemin c¨¸ozum¨ u¨ orjinal problemin c¨¸ozum¨ u¨ hakkında bilgi vermiyor. Burada orjinal
problem hakkında bilgi vermeyecek s¨ozu¨ ile ifade edilen ¸su ki; hesapsal olarak kar¸sı tarafın
yeni c¨¸ozum¨ u¨ orjinal problemin c¨¸ozum¨ une ¨ d¨onu¨¸sturmesi, ¨ en az orjinal problemin kendisini
c¨¸ozmesi kadar zor olmalıdır. Ancak di˘ger taraftan, bizim aslında c¨¸ozum¨ une ¨ sahip olmadı˘gımız bir probleme e¸syapıdaki bir problem i¸cin c¨¸ozum¨ sahibiymi¸siz gibi davranmamız
olasılı˘gına kar¸sı di˘ger taraf her seferinde bize ¸su soruyu soruyor. ”Ya bu e¸syapıdaki problemin c¨¸ozum¨ un¨ u¨ bana ver, ya da onun asıl probleme e¸s yapıda oldu˘gunu g¨oster”. Ve e˘ger
iddiamızda haklı isek bu iki iste˘gi de ger¸cekle¸stirebiliriz. Ancak bu iki onermeden ¨ birini
140
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
ger¸cekten sa˘glayamıyo olmamız, yani hile yapmamız durumuna yer bırakmamak i¸cinse
bu i¸slemler n kez (kar¸sı taraf ikna oluncaya kadar) tekrarlanır. Oyle ¨ ki, ger¸cekten orjinal
problemin cevabını bilmedi˘gimiz bir durumda her defasında sorulan soruya do˘gru cevabı
verme olasılı˘gımız 1/2 dir. n kez tekrarlanma durumunda ise bu ¸sekilde hile ihtimalimiz
1/n e du¨¸ser ki yeterli tekrardan sonra ihmal edilebilecek bir olasılıktır. Sıfır-bilgi ispat’ın
dayandı˘gı nokta ise bu olasılı˘gın du¨¸sukl ¨ u˘¨gud¨ ur. ¨ Dolayısıyla sıfır-bilgi ispatta yeterli miktarda tekrar i¸cin mutlak manada bir ispattan cok ¸ kar¸sı tarafın iknası s¨oz konusudur.
Sıfır-bilgi ispat metodları ne yazık ki her matematiksel probleme aynı verimde uygulanamamaktadır. Kimi zaman ispat i¸cin c¨¸ozum¨ un¨ bir kısmını a¸cı˘ga cık ¸ armak zorunda
oldu˘gumuz problemler s¨ozkonusudur. Bu yuzden ¨ sıfır bilgi ispat metodları, kar¸sı tarafın
sorusuna ne kadar sıklıkta do˘gru cevap verebilece˘gimiz ol¸ ¨ cus ¨ une ¨ g¨ore kusursuz, istatistiksel, hesapsal ya da kullanı¸ssız gibi kategorilere ayrılmı¸stır.
141
UYGULAMALI MATEMATİK ENSTİTÜSÜ
KRİPTOLOJİ SEM NOTLARI
ŞUBAT 2004
Understanding Cryptography – Öğrenci ve
Uygulamacılar İçin Ders kitabı
www.crypto-textbook.com
Ünite1 – Şifrelemeye Giriş
Çeviren: Selman YAKUT
2/36
Ünite içeriği
• Şifreleme alanlarına genel bakış
• Simetrik şifrelemenin temelleri
• Kripto analiz
• Yer değiştirmeli şifreleme
• Modüler aritmetik
• Kaymalı (veya sezar) şifreleme ve Affine
şifreleme
3/36
Ünite içeriği
• Şifreleme alanlarına genel bakış
• Simetrik şifrelemenin temelleri
• Kripto analiz
• Yer değiştirmeli şifreleme
• Modüler aritmetik
• Kaymalı (veya sezar) şifreleme ve Affine
şifreleme
4/36
• Şifreleme hakkında daha çok okuma ve bilgi
Addition to Understanding Cryptography .
• A.Menezes, P. van Oorschot, S. Vanstone, Handbook of Applied Cryptography.
CRC Press, October 1996.
• H.v.Tilborg (ed.), Encyclopedia of Cryptography and Security, Springer, 2005
History of Cryptography (great bedtime reading)
• S. Singh, The Code Book: The Science of Secrecy from Ancient Egypt to
Quantum Cryptography, Anchor, 2000.
• D. Kahn, The Codebreakers: The Comprehensive History of Secret
Communication from Ancient Times to the Internet. 2nd edition, Scribner, 1996.
Software (excellent demonstration of many ancient and modern ciphers)
• Cryptool, http://www.cryptool.de
• Şifreleme alanlarının sınıflandırılması
Cryptology
Cryptography Cryptanalysis
Symmetric Ciphers Asymmetric Ciphers Protocols
Block Ciphers Stream Ciphers
5/36
6/36
• Bazı temel gerçekler
• İlk çağ şifreleme: ilk şifreleme işaretleri M.Ö. 2000 mısırda kahirede görülmüştür.
Harf-tabanlı şifreleme yapısı (örneğin sezar şifreleme) ondan sonra popülerleşti.
• Simetrik şifreleme: Tarihöncesi zamanlardan 1976 ya kadar olan bütün
şifreleme yapıları buna örnektir.
• Asymmetric ciphers: 1976'da açık anahtar (veya asimetrik) şifreleme Diffie,
Hellman ve Merkle tarafından açık bir şekilde önerildi.
• Karışık yapılar: günümüz protokollerinin büyük bir kısmı bu yapıdadır, örneğin
ikisini kullanan
• Simetrik şifreleme (örneğin şifreleme ve mesaj doğrulama için) ve
• Asimetrik şifreleme (örneğin; mesaj değişimi ve sayısal imza için).
7/36
Ünite içeriği
• Şifreleme alanlarına genel bakış
• Simetrik şifrelemenin temelleri
• Kripto analiz
• Yer değiştirmeli şifreleme
• Modüler aritmetik
• Kaymalı (veya sezar) şifreleme ve Affine
şifreleme
• Symmetric Cryptography
Alternatif isimler: özel anahtarlı, tek anahtarlı veya gizli anahtarlı
şifreleme.
Oscar
(bad guy)
Unsecure
channel
(e.g. Internet)
8/36
Alice
(good)
Bob
x x (good)
• Problem Statement:
1)Alice ve BOB güvenli olmayan kanal üzerinden haberleşmek istiyorlar
(örneğin, WLAN or Internet).
2) kötü niyetli üçüncü kişi olan Oscar kanala ulaşabilir fakat fakat
haberleşmeyi anlayamamalı.
• Symmetric Cryptography
Alice
(good)
Bob
(good)
Oscar
(bad guy)
Encryption
e( )
Key Generator
Decryption
d( )
Secure Channel
K
x y
K
x
Unsecure
channel
(e.g. Internet)
9/36
• x düz metin
• y şifreli metin
• K anahtar değeri
• Bütün anahtar değerleri {K1, K2, ...,Kn}
anahtar uzayıdır
Çözüm: simetrik şifre ile şifrelemektir.
⇒ Oscar sadece şifreli metni elde edebilir
buda rastgele bit dizisidir.
y
• Simetrik şifreleme
• Şifreleme denklemi
• Şifre çözme denklemi
10/36
y = eK(x)
x = dK(y)
• önemli: anahtar Bob ve Alice arasında güvenli bir kanaldan iletilmeli.
• Güvenli kanal kurye veya benzeri yöntemlerle oluşturulabilir.
• Bununla birlikte saldırgan K anahtar değerini bilmediği sürece güvenlidir.
⇒ güvenli haberleşme problemini güvenli iletim ve Kanahtar değerinin
saklanması azaltmaktadır.
• İki tarafta da aynı anahtar değeri kullanılıyorsa şifreleme ve şifre çözme işlemleri
birbirinin tersidir:
dK(y) = dK(eK(x)) = x
11/36
Ünite içeriği
• Şifreleme alanlarına genel bakış
• Simetrik şifrelemenin temelleri
• Kripto analiz
• Yer değiştirmeli şifreleme
• Modüler aritmetik
• Kaymalı (veya sezar) şifreleme ve Affine
şifreleme
• Neden kripto analize ihtiyaç duyarız?
• Herhangi pratik bir şifre için güvenliğin matematiksel bir kanıtı yoktur.
• Sistemin güvenli olduğunu garanti etmenin tek yolu sistemi kırmaya çalışmaktır!
Kerckhoff prensibi modern şifrelemede çok iyidir:
Saldırgan gizli anahtar dışında sistemle ilgili her şeyi biliyor olsa
bile şifreleme sistemi güvenli olmalıdır .
• Kirşof prensiplerini pratikte uygulayabilmek için:
Sadece iyi şifreleyiciler tarafından birkaç yıl kriptoanaliz edilmiş geniş bir
ölçekte kullanılan şifreler kullanılmalı! (Understanding Cryptography only treats
such ciphers)
• dikkat: şifrelemenin daha güvenli olması için şifreleme yapısının detaylarını
gizlemek daha cazip gelebilir. Bununla beraber, fakat zaman gösteriyor ki bu yapılar
mühendisler tarafından incelendiğinde her zaman kırılmıştır. (örneğin: DVD içeriğini
korumak için kullanılan program Content Scrambling System (CSS).)
12/36
• Şifre Analizi: Şifreleme Sistemlerine Saldırı
• Klasik saldırılar
• Matematiksel analiz
• Kaba kuvvet saldırısı
• Uygulama saldırıları: Ters mühendislikle veya güç ölçümüyle anahtar
değerini çıkarmaya çalışırız, örneğin bankalar için kullanılan banking smart
card.
• Sosyal mühendislik: örneğin kullanıcının şifresini vermesi için kandırmak
13/36
• Şifreye blok kutular gibi davranır.
• En az bir düz metin şifreli metin çifti (x0
, y0
) gerekir.
• Şart gerçekleşene kadar bütün mümkün anahtarları
kontrol eder:
dK(y0
) = x0
• Kaç türlü anahtara ihtiyaç duyarız ?
• Simetrik Şifrelemeye Karşı Kaba Kuvvet Saldırısı
14/36
?
Önemli: karşı taraf başarmak için sadece bir saldırıya ihtiyaç duyar. Böylece, sosyal
mühendislik gibi diğer saldırılar yapılabiliyorsa uzun anahtar uzayı pekte faydalı
olmayacaktır..
Key length
in bit
Key space Security life time
(assuming brute-force as best possible attack)
64 264 Short term (few days or less)
128 2128 Long-term (several decades in the absence of
quantum computers)
256 2256 Long-term (also resistant against quantum
computers – note that QC do not exist at the
moment and might never exist)
15/36
Ünite içeriği
• Şifreleme alanlarına genel bakış
• Simetrik şifrelemenin temelleri
• Kripto analiz
• Yer değiştirmeli şifreleme
• Modüler aritmetik
• Kaymalı (veya sezar) şifreleme ve Affine
şifreleme
16/36
• Yer Değiştirmeli Şifreleme
• Tarihsel şifreleme
• Kaba kuvvet vs analitik saldırıları anlamak için harika bir araç
• İkinci dünya savaşına kadar bitlerden ziyade harflere dayanan şifreler kullanılıdı.
fikir: düz metindeki her bir harfe şifreli metinde sabit bir harfle yer değiştirsin.
örneğin, ABBA kddk gibi şifrelenebilir
• örnek (şifreli metin):
iq ifcc vqqr fb rdq vfllcq na rdq cfjwhwz
hwwhbsqvqbre hwq vhlq
hr bnnb hcc
• Yer değiştirmeli şifreleme ne kadar güvenlidir? Saldırılara bakalım…
Plaintext Ciphertext
A
B
C



k
d
w
....
17/36
• Yer değiştirme şifrelemeye karşı saldırılar
1. Saldırı: sonsuz anahtar arama (kaba kuvvet saldırısı)
• Basitçe mantıklı bir düz metin elde edilene kadar bütün mümkün yer
değiştirmelerin yapılması (dikkat edin ki yer yer değiştirme bir anahtardır)..
• How many substitution tables (= keys) are there?
26 x 25 x … x 3 x 2 x 1 = 26!  288
288 Anahtar arasından değerleri araştırmak günümüz bilgisayarları için
mümkün değildir!
• S: kaba kuvvet saldırısı mümkün olmadığı için yer değiştirme şifresinin
güvenli olduğunu çıkarabilir miyiz?
• A: hayır! Bütün saldırılara karşı güvenli olmalıdır…
• 2. saldırı: harf frekanslarının analizi (kaba kuvvet saldırısı)
E T A O I N S H R D L C U M W F G Y P B V K J X Q Z
0.0000
2.0000
4.0000
6.0000
8.0000
10.0000
12.0000
14.0000
• İngilizcede harflerin farklı kullanım sıklığı vardır.
• Dahası: düz metindeki sıklık şifreli metinde de korunur.
• Örneğin, „e“ ingilizcede en çok kullanılan harftir; tipik bir ingilizce metindeki
harflerin 13% „e“ dir.
• Diğer en çok kullanılan harf yaklaşık 9% la t’ dir.
İngilizcede kelime sıklıkları
18/36
Letters
Frequencyin%
19/36
• Harf sıklıkları analiziyle yer değiştirme şifrelerinin kırılması
• Şimdi örneğimize dönüp en çok geçen harfi bulalım:
iq ifcc vqqr fb rdq vfllcq na rdq cfjwhwz hr bnnb hcc
hwwhbsqvqbre hwq vhlq
• Şimdi şifreli metinde q'nun yerine E yazalım :
iE ifcc vEEr fb rdE vfllcE na rdE cfjwhwz hr bnnb hcc
hwwhbsEvEbre hwE vhlE
• Kalan harflerin sıklığına dayanarak daha fazla tahmin yapılır ve düz metin
bulunur:
WE WILL MEET IN THE MIDDLE OF THE LIBRARY AT NOON ALL
ARRANGEMENTS ARE MADE
20/36
• Harf sıklıkları analiziyle yer değiştirme şifrelerinin kırılması
• Pratikte, sadece harflerin değil ingilizcede sık kullanılan kelime ikilileri ve
üçlüleri de şifreli metni çözmek için kullanılır.
• Problem 1.1 in Understanding Cryptography kitabın ilgili metnindeki şifreli
metni kırmaya çalışabilirsiniz!
önemli ders: yer değiştirmeli şifre 288 gibi yeterli büyüklükte anahtar uzayına
sahip olmasına rağmen, sayısal yöntemlerle kolaylıkla kırılabilir. Bu şifreleme
yapılarının bütün saldırılara karşı dayanıklı olması gerektiğini gösteren çok
güzel bir örnektir.
21/36
Ünite içeriği
• Şifreleme alanlarına genel bakış
• Simetrik şifrelemenin temelleri
• Kripto analiz
• Yer değiştirmeli şifreleme
• Modüler aritmetik
• Kaymalı (veya sezar) şifreleme ve Affine
şifreleme
22/36
• Modüler aritmetiğe kısa bir giriş
Neden modüler aritmetik çalışmaya ihtiyacımız var?
• Asimetrik şifreleme için çok önemlidir (RSA, elliptic curves gibi.)
• Bazı tarihsel şifreler modüler aritmetikle güzel bir şekilde ifade
edilebilir(örneğin Caesar and affine cipher later on).
• Modüler aritmetiğe kısa bir giriş
12
11 1
2
3
4
7 5
6
8
9
10
Genel konuşursak, birçok şifreleme sistemi sayı kümelerine dayanır şöyle ki
1. ayrı (sayılı kümeler oldukça faydalıdır)
2. sonlu (ör. sadece sonlu sayılarla hesaplayabilirsek)
23/36
çok mu soyut gözüküyor? --- şimdi sonlu kümelere ayrık sayılarla bakalım saate oldukça
aşinayızdır.
Enteresan bir şekilde, saat sürekli artmasına rağmen biz belli bir sayı kümenin dışına
çıkmayız:
1, 2, 3, … 11, 12, 1, 2, 3, … 11, 12, 1, 2, 3, …:
• Modüler aritmetiğe kısa bir giriş
• Let a= 12 and m= 9 :
• Let a= 37 and m= 9:
• Let a= -7 and m= 9:
12 ≡ 3 mod 9
34 ≡ 7 mod 9
-7 ≡ 2 mod 9
• saate bulunan (1,2,3, … ,12) gibi sayılarla sonlu bir kümeyi hesaplamak için bir
aritmetik sistem geliştirelim.
• Çarpma ve toplama gibi işlemlerden sonra elde edilen sayıların yine küme içerisinde
kalması çok önemlidir. (örneğin asla 12 den büyük olamaz).
Definition: Modulus Operation
Let a, r, m be integers and m > 0. We write
a ≡ r mod m
if (r-a) is divisable by m.
• “m” is called the modulus
• “r” is called the remainder
Modüler azalma için bir örnek.
24/36
25/36
• Modüler aritmetiğin özellikleri
• Kalan tek değildir
Şurası ilginçtir ki verilen bir mod m’de kalan a değerine karşılık sonsuz değer denk
gelmektedir.
örneğin:
• 12 ≡ 3 mod 9
• 12 ≡ 21 mod 9
• 12 ≡ -6 mod 9
→ 3 geçerli kalandır çünkü 9 böler (3-12)
→ 21 geçerli kalandır çünkü 9 böler(21-12)
→ 6 geçerli kalandır çünkü 9 böler (-6-12)
• Hangi kalanı seçmeliyiz?
Genel olarak, en küçük pozitif sayı r yi alırız. Bu sayı şöyle hesaplanabilir:
quotient
a = q m + r
• Example: a=12 and m= 9
12 = 1 x 9 + 3
remainder
where 0 ≤ r ≤ m-1
→ r = 3
dikkat: This is just a convention.Algoritmik olarak şifreleme fonksiyonumuzu
hesaplamak için herhangi bir geçerli kalan kümesini almakta serbestiz .
• Modüler aritmetiğin özellikleri
26/36
27/36
• Modüler bölme işlemi nasıl yapılır?
İlk olarak, şunu belirtelim ki, bölme yapmaktan çok tersini alarak çarpmayı tercih ederiz.
Ex:
b / a≡ b x a-1 mod m
a-1 sayısı a sayısının tersidir ve şöyle tanımlanır:
a a-1 ≡ 1 mod m
Ex: 5 / 7 mod 9 nedir ?
mod 9 da 7 nin tersi 4 çünkü 7 x 4 ≡ 28 ≡ 1 mod 9, böylece:
5 / 7 ≡ 5 x 4 = 20 ≡ 2 mod 9
• Modüler aritmetiğin özellikleri
• Ters hesaplama nasıl yapılır?
a sayısının mod m d tersi vardır eğer sadece ve sadece:
gcd (a, m) = 1
(yukarıdaki örneğe dikkat edildiğinde gcd(5, 9) = 1, bundan dolayı modulo 9 da 5 in tersi
vardır)
Understanding Cryptography kitabının 6. ünitesinde bu konu daha ayrıntılı anlatılmıştır.
• Modüler aritmetiğe cebirsel bakış: halka Zm
We can view modular arithmetic in terms of sets and operations in the set. By doing
arithmetic modulo m we obtain the integer ring Zm .with the following properties:
28/36
• Kapatma: herhangi iki sayıyı toplayıp çarpabiliriz sonuç yine halka içindedir.
• Toplama ve çarpmada birleşme özelliği vardır ör: a,b,c  Zm
için a + (b + c) = (a + b) + c
a  (b  c) = (a  b)  c
Ve toplamada değişim özelliği de vardır: a + b = b + a
• dağılma kuralı : a×(b+c) = (a×b)+(a×c) şeklindedir a,b,c  Zm
toplama için etkisiz eleman sıfırdır, i.e., for all a  Zm a + 0  a mod m
•  Zm, her zaman toplamaya göre tersi –a vardır. Şöyle ki
a + (-a)  0 mod m
• çarpmaya göre etkisiz eleman 1 dir, örneğin a  Zm için
a  1  a mod m
• çarpmaya göre ters a-1
a  a-1  1 mod m
Zm deki bazı değerler için vardır hepsi için olmayabilir.
• Modüler aritmetiğe cebirsel bakış: halka Zm
Kısaca, halka üzerinde toplama çıkarma çarpma işlemlerini yapabildiğimiz bir
yapıdır fakat sadece bazı elemanları bölebiliriz (yani çarpmaya göre tersi olanları).
• Eğer sadece : gcd (a, m) = 1 ise Zm deki bir sayının çarpmaya göre tersi
vardır.
o zaman a ve m nin aralarında asal olduğunu söyleyebiliriz.
• Ör: şu halkaya dikkat edersek Z9 = {0,1,2,3,4,5,6,7,8}
0, 3 ve 6 nın tersi yoktur çünkü bu sayılar 9 la aralarında asaldır. Diğer
elemanların tersi ise şu şekildedir:
29/36
1-1  1 mod 9 2-1  5 mod 9 4-1  7 mod 9
5-1  2 mod 9 7-1  4 mod 9 8-1  8 mod 9
30/36
Ünite İeriği
• Şifreleme alanlarına genel bakış
• Simetrik şifrelemenin temelleri
• Kripto analiz
• Yer değiştirmeli şifreleme
• Modüler aritmetik
• Kaymalı (veya sezar) şifreleme ve Affine
şifreleme
31/36
• kaymalı (veya Sezar) şifreleme
•İlk şifrelerin Julius Caesar tarafından kullanıldığı iddia edilir.
• Düz metindeki her harfin yerine bir harf yazılır.
•Değişim kuralı oldukça basit: belirlenen bir k anahtar değeriyle her harften k:sonraki harf alınır.
• Örnek k = 7 için
Düz metin = ATTACK = 0, 19, 19, 0, 2, 10
Şifreli metin = haahr = 7, 0, 0, 7, 17
Burada işlemler mod 26 da yapılmaktadır yani 26 değerini aşan durumda mod 26 daki
değeri alınır.
A B C D E F G H I J K L M
0 1 2 3 4 5 6 7 8 9 10 11 12
N O P Q R S T U V W X Y Z
13 14 15 16 17 18 19 20 21 22 23 24 25
• Kaymalı (veya Sezar) Şifreleme
• S; kaymalı şifre güvenli midir?
• C: Hayır! Birkaç saldırı mümkün, including:
• Sonsuz anahtar arama (anahtar uzayı sadece 26!)
• Harf sıklığı analizi, yer değiştirme şifresinde olduğu gibi
• Şifrelemenin zekice matematiksel tarifi.
Let k, x, y ε {0,1, …, 25}
32/36
• Encryption:
• Decryption:
y = ek
(x) ≡ x + k mod 26
x = dk
(x) ≡ y - k mod 26
• Affine Şifreleme
• Şifreleme işleminde tersini almaya ihtiyaç duyduğumuz için, aşağıdaki ifadeye göre
sadece tersi olan sayılar kullanılır:
gcd(a, 26) = 1
bu şartı sağlayan 12 değer vardır.
• Bundan dolayı anahtar uzayı sadece 12 x 26 = 312 (cf. Sec 1.4 in Understanding
Cryptography)
• Yine aşağıdakileri içeren birkaç saldırı vardır:
• Detaylı anahtar uzayı ve harf sıklığı analizi, yer değiştirme şifresine karşı benzer
saldırılar.
• Kaymalı şifrenin gelişmiş hali: düz metne sadece anahtar değerini eklemekten
ziyade, başka bir anahtar değeriyle de toplarız.
• Burada iki parçadan oluşan bir anahtar değeri kullanırız: k = (a, b)
Let k, x, y ε {0,1, …, 25}
33/36
• Encryption:
• Decryption:
y = ek
(x) ≡ a x + b mod 26
x = dk
(x) ≡ a-1( y – b) mod 26
Understanding Cryptography Öğrenci ve
Uygulamacılar İçin Ders kitabı
www.crypto-textbook.com
Ünite 2 – Stream(akan) Şifreleme
Çeviren: Selman YAKUT
2/27
Ünite içeriği
• Akan (stream) şifrelemeye giriş
• Rastgele sayı üreteci (Random number
generators (RNGs))
• Tek kullanımlık blok notlar(One-Time Pad
(OTP))
• Linner geri beslemeli kaymalı kaydediciler
(Linear feedback shift registers (LFSRs))
• Trivium: a modern stream şifre
3/27
Ünite içeriği
• Stream şifrelemeye giriş
• Rastgele sayı üreteci (Random number
generators (RNGs))
• Tek kullanımlık blok notlar(One-Time
Pad (OTP))
• Linear feedback shift registers (LFSRs)
• Trivium: a modern stream şifre
• Şifrelemede Stream Şifrelemenin Yeri
Cryptology
Cryptography Cryptanalysis
Symmetric Ciphers Asymmetric Ciphers Protocols
Block Ciphers Stream Ciphers
Stream Ciphers 1917 de Gilbert Vernam tarafından bulundu
4/27
• Stream şifreleme ve Blok şifreleme
• Stream Şifreler
• Bitler tek tek şifrelenir
• Gömülü sistemlerde yaygındır genellikle küçük ve hızlıdır (e.g., A5/1 for
GSM phones)
• Block Şifreler:
• Her zaman blokun hepsini şifreler (birkaç bit)
• İnternet uygulamaları için yaygındır.
5/27
• Stream şifreleme ile şifreleme ve şifre çözme
• Şifreleme ve şifre çözme mod 2 de toplama işlemi gibidir (aka XOR)
• Şifreleme ve şifre çözme aynı fonksiyondur.
• şifreleme: yi = esi
(xi
) = xi + si mod 2
• Şifre çözme: xi = esi
(yi
) = yi + si mod 2
xi
, yi
, si ∈ {0,1}
Düz metin xi
, şifreli metin yi ve stream anahtarı si
tek tek bitlerden oluşur
6/27
• Senkron ve Asenkron Stream Şifreleme
• si Anahtar üretiminin güvenliği tamamıyla anahtar değerine bağlıdır:
• Rastgele olmalı , i.e., Pr(si = 0) = Pr(si = 1) = 0.5
• Gönderici ve alıcı tarafından yeniden üretilebilmeli
• Senkron Stream Şifreler
• Anahtar üretimi sadece anahtara bağlıdır(ve IV başlangıç değeri olabilir)
• Asenkron Stream şifreler
• Anahtar üretimi şifreli metne de bağlıdır.
7/27
• Neden Mod 2 de Toplamak İyi Bir Şifreleme Fonksiyonudur?
• Mod 2 toplama işlemi XOR işlemine eşittir.
• Mükemmel bir stream si
,anahtarı için each her şifreli metin çıkış
bitinin 0 veya 1 olma ihtimali 50% olmalıdır.
• Ters çevrilmiş XOR basittir, çünkü XOR işleminin aynısıdır.
8/27
xi si yi
0 0 0
0 1 1
1 0 1
1 1 0
9/27
• Stream Şifre: Çıktı
Simetrik şifrelerin performans karşılaştırması (Pentium4):
Source: Zhao et al., Anatomy and Performance of SSL Processing, ISPASS 2005
Cipher Key length Mbit/s
DES 56 36.95
3DES 112 13.32
AES 128 51.19
RC4 (stream cipher) (choosable) 211.34
10/27
Ünite içeriği
• stream şifrelemeye giriş
• Rastgele sayı üreteci (Random
number generators (RNGs))
• Tek kullanımlık blok notlar(One-Time
Pad (OTP))
• Linear feedback shift registers (LFSRs)
• Trivium: a modern stream şifre
• Rastgele Sayı Üreteci (RNGs)
RNG
Cryptographically
Secure RNG
True RNG Pseudorandom NG
11/27
• Yalancı Rastgele Sayı Üreteci(TRNGs)
• Fiziksel rastgele işlemlere dayanır: yarı iletken gürültüsü, radyoaktif kalıntılar,
fare hareketleri
• Çıkış stream si değeri iyi istatiksel özeliklere sahip olmalı:
Pr(si = 0) = Pr(si = 1) = 50% (sıklıkla sonraki işlemlerle yapılır)
• Çıkış değeri hem tahmin edilememeli hem de yeniden üretilememeli
Anahtarların üretimi için tipik kullanım, (sadece tek kullanımlık değerler
kullanılır) ve başka bir çok amaç için
12/27
• Yalancı Rastgele Sayı (PRNG)
13/27
•Başlangıç çekirdek değerinden bir zincir üretir.
• Tipik olarak, çıkış stream iyi istatiksel özelliklere
sahiptir.
•Özyinelemeli yollarla çıkış değeri yeniden
üretilebilir ve tahmin edilebilir :
s0  seed
si1  f (si
,si1
,...,sit
)
Örnek: rand() function inANSI C:
s0 12345
s 1103515245s 12345mod 2
31
i1 i
birçok PRNG nin kötü şifreleme özellikleri vardır!
• Basit bir PRNG nin kripto analizi
14/27
Örnek PRNG: Linear Congruential Generator
S0  seed
Si1  ASi  Bmod m
Farz edelim
• A, B ve S0 anahtar gibi bilinmiyor
• A, B ve Si boyutu 100 bit
• Çıkışın 300 biti biliniyor, i.e. S1
, S2 and S3
çözüm
S2  AS1  B mod m S3
 AS2  B mod m
… A ve B yi direk gösterir. bütün Si kolaylıkla hesaplanabilir!
Birçok PRNG liner yapıda olduğundan şifreleme özellikleri kötüdür.
15/27
• Yalancı Rastgele Sayı Üreteci (CSPRNG) Şifresel
güvenliği
• Ek özellikleriyle özel PRNG:
• Çıkış kesinlikle tahmin edilememeli
Daha Doğrusu : si
, çıkışından verilen sıralı n bit bir sonraki çıkış sn+1
de tahmin edilemez (polinom zamanda).
• Buna şifrelemede özellikle stream şifre yapısında ihtiyaç duyulur
16/27
Ünite içeriği
• stream şifrelemeye giriş
• Rastgele sayı üreteci (Random number
generators (RNGs))
• Tek kullanımlık blok notlar(One-Time
Pad (OTP))
• Linear feedback shift registers (LFSRs)
• Trivium: a modern stream şifre
• One-Time Pad (OTP)
17/27
alışılmadık ölçüde güvenli şifreleme sistemleri:
• Eğer şifreleme sistemi sonsuz hesaplama kaynağıyla da kırılamıyorsa bu
sistem şartlara bağlı olmayarak güvenlidir.
One-Time Pad
• Bu şifreleme sistemi Vernam’s stream şifre yapısına dayanır:
• Özellikler:
Düz metin, şifreli metin ve anahtar kendi bitlerinden oluşsun
xi
, yi
, ki  {0,1}.
Encryption:
Decryption:
eki
(xi
) = xi  ki
.
dki
(yi
) = yi  ki
OTP alışılmadık ölçüde güvenlidir eğer ki Anahtar değeri sadece bir
defa kullanılırsa!
18/27
• One-Time Pad (OTP)
Alışılmadık ölçüde güvenli şifreleme sistemi :
y0 = x0  k0
y1 = x1  k1
:
Her denklem iki bilinmeyenli bir liner denklemdir
⇒ her yi
için xi = 0 ve xi = 1 dir!
⇒Bu doğrudur eğer k0
, k1
, ... Değerleri bağımsızsa, örneğin ki
anahtar değerleri tamamen rastgele olursa
dezavantaj: Hemen hemen bütün OTP uygulamaları pratik
değildir çünkü anahtar mesajla aynı boyutta olmalı! (Imagine
you have to encrypt a 1GByte email attachment.)
19/27
Ünite içeriği
• stream şifrelemeye giriş
• Rastgele sayı üreteci (Random number
generators (RNGs))
• Tek kullanımlık blok notlar(One-Time Pad
(OTP))
• Linear feedback shift registers (LFSRs)
• Trivium: a modern stream şifre
• Linear Feedback Shift Registers (LFSRs)
• Geri besleme durum bitlerini XOR layarak yeni giriş değerini üretmeye çalışır.
• m derecesi depolanan elementlerin sayısını verir.
• Eğer pi = 1 se, geri besleme bağlantısı vardır (“kapalı anahtar), aksi halde bu
flip-flop ta geri besleme yoktur(“açık anahtar”)
• Çıkış zinciri periyodik olarak tekrarlar
• Maximum çıkış uzunluğu: 2m-1
20/27
• Linear Feedback Shift Registers (LFSRs):
• LFSR çıkışı rekürsif denklemlerle tanımlanır:
si3  si1  si mod 2
• Maximum çıkış uzunluğu (of 23-1=7) kabul edilir sadece belli
geri besleme yapısı için, örneğin biri burda gösterilmiştir.
21/27
clk FF2 FF1 FF0=si
0 1 0 0
1 0 1 0
2 1 0 1
3 1 1 0
4 1 1 1
5 0 1 1
6 0 0 1
7 1 0 0
8 0 1 0
• Security of LFSRs
LFSR polinomlarla şöyle gösterilir:
• Tek LFSR büyük ihtimalle tahmin edilebilir bir sonuç üretir.
• Eğer 2m çıkış biti varsa LFSR nin o zaman bunun derecesi m
olmaktadır, geri besleme sabitleri pi ler liner sistemlerdeki çözümlerle
bulunabilir.
• Bir çok stream şifreleme LFSR nin birleşimi şeklindedir.
*daha fazla ayrıntı için Understanding Cryptography ünite 2 bak
... p1x  p0
P(x)  x
m  p x
m1
l1
22/27
23/27
Ünite içeriği
• stream şifrelemeye giriş
• Rastgele sayı üreteci (Random number
generators (RNGs))
• Tek kullanımlık blok notlar(One-Time
Pad (OTP))
• Linear feedback shift registers (LFSRs)
• Trivium: a modern stream şifre
• A Modern Stream Cipher - Trivium
• Üç nonlinear LFSRs (NLFSR) nin uzunluğu 93, 84, 111
• XOR-toplama üç NLFSR çıkışları streamanahtarı si Üretir.
Donanımda küçüklük:
• Toplam kaydedici sayısı: 288
• Liner olmayan: 3 AND-kapısı
• 7 XOR-kapısı (4 tanesi iç girişli)
24/27
• Trivium
Atama:
• Load 80-bit IV into A
• Load 80-bit key into B
• Set c109 , c110 , c111 =1, all other bits 0
Şifreleme:
• XOR-Toplama her üç NLFSR çıkışı stream anahtarı si üretir.
Her saat darbesinde 64 biti paralel üretmek için düzenlenebilir
25/27
Register length Feedback bit Feedforward bit AND inputs
A 93 69 66 91, 92
B 84 78 69 82, 83
C 111 87 66 109, 110
Understanding Cryptography Öğrenci ve
Uygulamacılar İçin Ders kitabı
www.crypto-textbook.com
Ünite 3 – Veri Şifreleme Standardı (DES)
Çeviren: Selman YAKUT
2/29
Ünite içeriği
• DES‘e giriş
• DES Algoritmasına genel bakış
• DES‘in iç yapısı
• Şifre çözme
• DES‘in Güvenliği
3/29
Ünite içeriği
• DES‘e giriş
• DES Algoritmasına genel bakış
• DES‘in iç yapısı
• Şifre çözme
• DES‘in Güvenliği
• Şifrelemede DES’in sınıflandırılması
Cryptology
Cryptography Cryptanalysis
Symmetric Ciphers Asymmetric Ciphers Protocols
Block Ciphers Stream Ciphers
DES burada yer alır
4/29
5/29
• DES Gerçekleri
• DES 64 bit uzunluktaki veri bloklarını şifreler.
• Lucifer şifreleme yapısını temel alarak IBM tarafından National Security Agency
(NSA) (ulusal güvenlik acentesi)’nin etkisiyle geliştirildi, ve DES algoritmasının
tasarlama kriterleri yayınlanmadı.
• Günümüzde National Institute of Standards and Technology (NIST)
olarak ifade edilen National Bureau of Standards (NBS) tarafından
1977 de standartlaştırıldı.
• Son 30 yılın en popüler block şifreleme yapısıdır.
• Bugüne kadar en çok çalışılan simetrik algoritmadır.
• Günümüzde 56 bitlik anahtar uzunluğu güvenli değildir.
• Fakat: 3DES güvenli bir şifreleme yapısı oluşturmuştur, ve kullanımı hala yaygın.
• 2000 yılında Advanced Encryption Standard (AES) yer değiştirmiştir.
• Daha detaylı bilgi için Chapter 3.1 in Understanding Cryptography bakabilirsiniz.
6/29
• Block Şifreleme Temelleri: Confusion and Diffusion
• Claude Shannon: Güçlü şifreleme algoritmaları inşa edilebilmek için iki temel
işlem vardır :
1. Confusion (karıştırma): bir şifreleme işleminde şifreli metin ile anahtar
arasında bir ilişki olmamalıdır .
Günümüzde, confusion işlemini sağlayan en yaygın yapı, AES ve DES’te
yer alan substitution (yer değiştirme) işlemidir.
2. Diffusion (yayma): Sabit yaklaşımları engellemek amacıyla düz
metindeki bir sembolün şifreli metindeki bir çok sembolü etkilemesi
işlemidir.
Basit bir difüzyon elemanı DES içinde sıklıkla kullanılan, bit
permutasyonudur.
• İki işlemde kendi başlarına güvenliği sağlayamazlar. Buradaki amaç bu iki işlemi
art arda kullanarak güvenli şifreler oluşturmaktır.
• Ürün Şifreler
• Bu gün kullanılan blok şifrelerin çoğu bu yapıları tekrar tekrar giriş
verisine uygulayan round denilen yapılardan oluşur.
• Mükemmel difüzyon ulaşabilirsiniz: Eğer düz metindeki bir biti
değiştirdiğinizde ortalama olarak çıkış bitlerinin yarısını
değiştiriyorsa.
Örnek:
Tek bit değişti Bir çok bit değişti
7/29
8/29
Ünite içeriği
• DES‘e giriş
• DES Algoritmasına genel bakış
• DES‘in iç yapısı
• Şifre çözme
• DES‘in Güvenliği
• DES Algoritmasına genel bakış
x
64
64
y
• 64 bit uzunluktaki blokları şifreler.
• 56 bitlik anahtar değeri kullanır.
• Simetrik şifreleme: şifreleme ve deşifreleme içim aynı anahtar kullanılır.
• Aynı işlemleri yapan 16 round kullanılır
• Her roundda kullanılan farklı alt anahtarlar başlangıç anahtarından
üretilir
k
56
DES
9/29
• Bit düzeyinde ilk permutasyon, ardından 16 round
1.Düz metin 32-bitlik Li ve Ri alt parçalarına ayrılır.
2.Ri
f fonksiyonuna varilir, bunun çıkışı Li
ile XOR’lanır.
3.Sağ ve sol yarımlar yer değiştirir.
• Roundlar şöyle ifade edilebilir:
• DES Feistel Yapısı (1)
• DES‘in yapısı Feistel yapısıdır.
• Avantajı: şifreleme ve deşifrelemede
sadece anahtar tarifesi farklıdır.
10/29
• DES Feistel Yapısı (2)
11/29
• L ve R 16. roundun sonunda tekrar yer değiştirir.
Chapter 3 of Understanding Cryptography by Christof Paar and Jan Pelzl 12/29
Ünite içeriği
• DES‘e giriş
• DES Algoritmasına genel bakış
• DES‘in iç yapısı
• Şifre çözme
• DES‘in Güvenliği
• Başlangıç ve Son Permutasyon
• Bit düzeyinde Permutasyon.
• Ters işlemler.
• IP ve IP-1 tablolarında gösterilmiştir.
Başlangıç permutasyon Son permutasyon
13/29
• f-Fonksiyonu
• DES‘in ana işlemleri
• f-Fonksiyonu girişler:
Ri-1 ve round anahtarı ki
• 4 Adımlar:
1.genişletilmiş E
2. Round anahtarı ile XOR
3.S-box substitution
4.Permütasyon
14/29
• Genişletme Fonksiyonu E
1.Genişletilmiş E
• Temel amacı:
difizyonu artırmak !
15/29
• Round anahtarını ekleme
2.Round anahtarı XOR’lama
• Round anahtarı ile genişletilmiş
E‘nin çıkışı bit düzeyinde
XOR’lanır.
• Rund anahtarı DES anahtar
tarifesi ile başlangıç
anahtarından üretilir.
(ilerideki slaytlarda)
16/29
• DES S-Box‘ları
3.S-Box substitution
• 8 substitution tablosu.
• 6 bits of input, 4 bits of output.
• Linner değildir ve diferansiyel
kriptoanalize karşı dayanıklıdır.
• DES’in güvenliği için önemi yapılar
• Bütün S-Box tabloları ve S-Box tasarlama
kriterleri kaynak kitapta verilmiştir .
17/29
• P permütasyonu
4.Permutation P
• Bit düzeyinde permütasyon.
• Difizyon tanıtımı.
• S-Box bitlerinin çıkışı bir sonraki roundda bir çok
S-Boxes etkiler
• E difizyonu, S-Boxlar ve P 5 rounddan sonra
her bit düz metnin ve anahtarın fonksiyonu
olduğunu garanti eder.
18/29
• Key Schedule (1)
• 48 bitlik her ki alt anahtarı orijinal 56 bitlik anahtardan oluşur.
• DES'te anahtar boyutu 64 bittir: burada 56 bit anahtar ve 8 parity biti:
• İlk permütosyon seçiminde parity bitleri kaldırılır PC-1:
(bu kullanılmayan bitler 8, 16, 24, 32, 40, 48, 56 ve 64)
!
19/29
• Key Schedule (2)
• Anahtar C0 ve D0 denilen 28-bitlik iki parçaya ayrılır.
• Ii = 1, 2, 9 ,16, numaralı roundlarda bir bit sila
kaydırılır.
• Diğer bütün roundlarda her iki parça iki bit sola
kaydırılır.
• her runddaki anahtar değeri o rounddaki her iki
anahtar yarısını kullanarak elde edilir. Her ki alt
anahtarı k’nın bir permütasyonudur!
• Not: döndürmelerin toplam sayısı:
4 x 1 + 12 x 2 = 28 ⇒ D0 = D16 and C0 = C16
!
20/29
Chapter 3 of Understanding Cryptography by Christof Paar and Jan Pelzl 21/29
Ünite içeriği
• DES‘e giriş
• DES Algoritmasına genel bakış
• DES‘in iç yapısı
• Şifre çözme
• DES‘in Güvenliği
• deşifreleme
22/29
• Feistel şifrelemede deşifreleme için
sadece anahtar tarifesi değiştirilir.
• Aynı 16 anahtar sırası ters çevrilerek
üretilir.
• Ters anahtar üretme:
D0=D16 ve C0=C16 yapılarak ilk anahtar
üretilebilir.
Her roundda anahtar üretim işlemlerinin
tersi yapılır:
• 1. rounda döndürme yok.
• 2, 9 ve 16. roundda bir bit sağa
kaydır.
• Diğer roundlard iki bit sağa
kaydırılır.
23/29
Ünite içeriği
• DES‘e giriş
• DES Algoritmasına genel bakış
• DES‘in iç yapısı
• Şifre çözme
• DES‘in Güvenliği
24/29
• DES‘in Güvenliği
• DES önerildikten sonra iki önemli eleştiri yapıldı:
1. Anahtar uzayı çok küçük (256 anahtar)
2. S-box tasarlama kriterleri gizli tutuldu: sadece NSA tarafından
bilinen herhangi bir gizlenmiş sayısal saldırı (backdoors), var mı?
• Sayısal Saldırı: DES yayınlandığı koşullarda linner ve diferansiyel
kriptoanalize oldukça dayanıklıydı. Bu IBM ve NASA'nın 15 yıldır bu
saldırılardan haberdar olmuştu demektir!
Şimdiye kadar DES gerçekçi senaryolarla DES’i kırabilen bilinen
analitik bir saldırı yoktur.
• Ayrıntılı anahtar arama: Şifresiz-şifreli her (x, y)çifti için deneme.
256 anahtar vardırDESk
(x)=y şartı sağlayana kadar.
-1
⇒ Nispeten kolay bugünün bilgisayar teknolojisiyle!
• DES üzerindeki saldırıların tarihi
Year Proposed/ implemented DES Attack
1977 Diffie & Hellman, (under-)estimate the costs of a key search machine
1990 Biham & Shamir propose differential cryptanalysis (247 chosen ciphertexts)
1993 Mike Wiener proposes design of a very efficient key search machine:
Average search requires 36h. Costs: $1.000.000
1993 Matsui proposes linear cryptanalysis (243 chosen ciphertexts)
Jun. 1997 DES Challenge I broken, 4.5 months of distributed search
Feb. 1998 DES Challenge II--1 broken, 39 days (distributed search)
Jul. 1998 DES Challenge II--2 broken, key search machine Deep Crack built by the
Electronic Frontier Foundation (EFF): 1800 ASICs with 24 search engines each,
Costs: $250 000, 15 days average search time (required 56h for the Challenge)
Jan. 1999 DES Challenge III broken in 22h 15min
(distributed search assisted by Deep Crack)
2006-2008 Reconfigurable key search machine COPACOBANA developed at the
Universities in Bochum and Kiel (Germany), uses 120 FPGAs to break DES in
6.4 days (avg.) at a cost of $10 000.
25/29
• DES’in anahtar uzunluğunu etkili bir sayı olan 112 çıkarmak için DES
algoritmasının üç defa kullanılmasına dayanır. Çoklu şifreleme ve anahtar
uzunlukları hakkında daha fazla bilgi kaynak kitaptadır.
• 3DES‘in alternatif versiyonu:
Avantajı: k1=k2=k3 seçilirse performans tek DES gibidir.
• Günümüzde daha pratik bir saldırı yok.
• Birçok eski uygulamalarda kullanılır., örneğin, banka sistemleri.
• Üçlü DES – 3DES
26/29
27/29
• Alternatives to DES
Algorithm I/O Bit key lengths remarks
AES / Rijndael 128 128/192/256 DES ''replacement'',
worldwide used standard
Triple DES 64 112 (effective) conservative choice
Mars 128 128/192/256 AES finalist
RC6 128 128/192/256 AES finalist
Serpent 128 128/192/256 AES finalist
Twofish 128 128/192/256 AES finalist
IDEA 64 128 patented
AES
(Advanced Encryption
Standart)
AES
• AES, John Daemen ve Vincent Rijmen tarafından
Rijndael adıyla geliştirilmiş ve 2002 yılında standart
haline gelmiştir.
• AES uzunluğu 128 bitte sabit olan blok ile uzunluğu
128, 192 ya da 256 bit olan anahtar kullanır.
• Kullanılan tekniklerden bazıları baytların yer
değiştirmesi, 4x4’ lük matrisler üzerine yayılmış
metin parçalarının satırlarına uygulanan kaydırma
işlemleridir.
• 2010 yılı itibariyle en popüler simetrik
algoritmalardan biridir.
Algoritmanın Genel Yapısı
• AES algoritmasında giriş, çıkış ve matrisler 128
bitliktir. Matris 4 satır, 4 sütun (4×4), 16 bölmeden
oluşur. Bu matrise ‘durum’ denmektedir. Durumun
her bölmesine bir baytlık veri düşer. Her satırda 32
bitlik bir kelimeyi meydana getirir.
• AES algoritması, 128 bit veri bloklarını 128, 192
veya 256 bit anahtar seçenekleri ile şifreleyen bir
blok şifre algoritmasıdır. Anahtar uzunluğu bit
sayıları arasındaki farklılık AES tur döngülerinin
sayısını değiştirmektedir.
Kelime Uzunluğu Tur Sayısı
AES-128 4 10
AES-192 6 12
AES-256 8 14
NASIL ÇALIŞIR ?
Döngü Yapısı
• Her döngü tersi alınabilir dönüşümler kullanır.
• Her döngü, son döngü hariç, 4 dönüşüm kullanır: SubBytes,
ShiftRows, MixColumns ve AddRoundKey.
• Son döngüde MixColumns dönüşümü göz ardı edilir.
• Her döngüde farklı anahtar materyali kullanılır.
• Farklı anahtar materyalleri anahtar planlama evresinde gelen
anahtarlardır. Master anahtardan farklı anahtarlar elde edilerek
şifrede kullanılır.
• Deşifreleme kısmında ters dönüşümler kullanılır: InvSubByte,
InvShiftRows, InvMixColumns ve AddRounKey (tersi
kendisidir- XOR işlemi).
Şifreli Metinin Oluşumu
• Girişten gelen metin 128 bitlik parçalara bölünür. Her
parça durum matrisine yerleştirilir. Durum matrisi
oluşturulduktan sonra, artık üzerinde tüm işlemler
yapılabilir duruma gelmiş demektir. Aynı şekilde önceden
alınan 128 bitlik anahtarda bu durum matrisi halinde işlem
görür. Giriş metninin yazıldığı durum matrisi ilk olarak
anahtar ile toplanır.
Bayt Değiştirme
• İlk işlem algoritmanın tek doğrusal olmayan işlemi olan
bayt değiştirmedir. Durum matrisinin her elemanı,
değerleri önceden hesaplanarak oluşturulmuş Skutusundaki değerlerle değiştirilir.

Satır Kaydırma
• Satır kaydırma işleminde satırlar sırasıyla çevrimsel
şekilde kaydırılırlar. Yani ilk satır değiştirilmez, ikinci
satır da sola 1 ötelenir, üçüncü satır sola 2 ötelenir ve
son satır sola 3 ötelenir. Taşan bölmeler kaydırmanın
başına eklenir.
Sütun Karıştırma
• Bu işlemde eski sütunun elemanları kullanılarak yeni sütun
elde edilmektedir. Bu yapılırken yeni sütunun elemanları eski
sütunun her elemanı hesaba katılarak tek tek hesaplanır.
Yapılan hesap çarpma ve toplama işleminden oluşur. Çarpma
işleminde belirli bir sabit sayı (a(x)) kullanılır.
Tur Anahtarıyla Toplama
• Her turda daha önce saydığımız işlemlerle birlikte bir de tur
anahtarı oluşturma işlemi yapılmaktadır ve her turda sonuçta
oluşan durum ile o tur için hazırlanmış olan yeni anahtar
toplama işlemine tabi tutulur. Bu işlem sonlu alanlarda yapılan
toplama işlemidir ve bit mertebesinde özel veya (XOR)
işlemine karşılık düşer. 128 bitlik durum matrisi ile 128 bitlik
ara anahtar değeri bit bit özel veya elamanı ile toplanır.

Anahtar Oluşumu
Şekilde de görüldüğü üzere, yeni anahtarın oluşmasındaki temel işlem bir
önceki sütun ile dört önceki sütunun toplanmasıdır. Ancak bir istisna
nokta var ki o da her 4′ün katı olan sütunda toplamadan önce bir dizi
işlemden (T İşlemi) daha geçirilir. Bu işlemler öteleme, S kutusundan
geçirme ve Rc(x) vektörü ile toplama işlemidir.
AES ANİMASYONU
http://www.cs.bc.edu/~straubin/cs381-
05/blockciphers/rijndael_ingles2004.swf
Understanding Cryptography
by Christof Paar and Jan Pelzl
www.crypto-textbook.com
Chapter 4 – The Advanced Encryption
Standard (AES)
Çeviren: Selman YAKUT
2/28
Ünite içeriği
• AES algoritmasına genel bakış
• AES‘in iç yapısı
• Bayt Değiştirme katmanı
• Difüzyon katmanı
• Anahtar Ekleme katmanı
• Anahtar tarifesi
• Deşifreleme
• Pratik konular
3/28
Ünite içeriği
• AES algoritmasına genel bakış
• AES‘in iç yapısı
• Bayt Değiştirme katmanı
• Difüzyon katmanı
• Anahtar Ekleme katmanı
• Anahtar tarifesi
• Deşifreleme
• Pratik konular
4/28
• Bazı Temel Gerçekler
• AES günümüzde en yaygın kullanılan simetrik şifrelemedir.
• AES birkaç yıllık seçim süreci sonunda US National Institute of Standards
and Technology (NIST) tarafından seçildi.
• Bütün AES adayları için gerekli özellikler:
• 128-bit blok uzunluğunda blok şifreleme
• 128, 192 ve 256 bit anahtar uzunluklarıyla desteklenmelidir
• Yayınlanan diğer algoritmalara göre daha güvenli olmalı
• Yazılım ve donanımda etkinlik
5/28
• AES seçiminin kronolojisi
• Yeni bir blok şifreye ihtiyaç duyulduğu NIST tarafından Ocak, 1997 ilan
edildi.
• 15 aday algoritma Ağustos, 1998'de kabul edildi.
• Son 5 algoritma Ağustos, 1999 ilan edildi:
• Mars – IBM Corporation
• RC6 – RSA Laboratories
• Rijndael – J. Daemen & V. Rijmen
• Serpent – Eli Biham et al.
• Twofish – B. Schneier et al.
• Ekim 2000‘de, AESolarak bilinen Rijndael algoritması seçildi.
• AES, Kasım 2001 Amerika ulusal standartları tarafından onaylandı.
• AES: Genel Bakış
Round sayısı seçilen anahtar uzunluğuna bağlıdır:
6/28
Key length (bits) Number of rounds
128 10
192 12
256 14
• AES: Genel Bakış
• 10/12/14 roundlu tekrarlı şifreleme
• Her round “Layers” (Katman’lardan) oluşur
7/28
8/28
Ünite içeriği
• AES algoritmasına genel bakış
• AES‘in iç yapısı
• Bayt Değiştirme katmanı
• Difüzyon katmanı
• Anahtar Ekleme katmanı
• Anahtar tarifesi
• Deşifreleme
• Pratik konular
9/28
• AES‘in iç yapısı
• AES bayt temelli bir şifrelemedir.
• state (ifade) A 4x4 matris olarak düzenlenebilir:
A0
,…, A15 ile 16-baytlık AES giriş verisini oluşturur.
A0 A4 A8
A12
A1 A5 A9
A13
A2 A6
A10 A14
A3 A7
A11 A15
• AES‘in iç yapısı
• 1,2,…,nr-1
: round için round fonksiyonu
10/28
• Not: Son roundda, MixColumn dönüşümü çıkarılmıştır.
• Bayt Değiştirme katmanı
• Bayt Değiştirme katmanı aşağıdaki özelliklere sahip 16 SBoxtan oluşur:
S-Boxlar
• aynıdır
• AES‘teki nonlineer tek elemanlardır, örneğin,
ByteSub(Ai
) + ByteSub(Aj
) ≠ ByteSub(Ai + Aj
); i,j = 0,…,15 için
• Giriş ve çıkış baytları bire bir haritalanır
 S-Box‘lar bire bir ters çevrilebilir
• Yazılım uygulamalarında, S-Box genellikle tablolara bakılarak
gerçekleştirilir
11/28
• Difüzyon katmanı
• Difüzyon katmanı
• Bütün giriş ifade bitleri üzerinde difüzyonu sağlar
• İki alt katmandan oluşur:
• Satır Kaydırma Alt Katmanı: bayt seviyesinde veri değişimi
• Sütun Karıştırma Alt Katmanı: 4 baytlık blokları içeren matris
işlemleri
• İfade matrisleri üzerinde yapılan
lineer işlemler A, B, i.e., DIFF(A)
+ DIFF(B) = DIFF(A + B)
12/28
• Satır kaydırma alt katmanı
• İfade matrisinin satırları dönel şekilde sıralanır:
Giriş matrisi
Çıkış matrisi
13/28
kayma yok
← sola bir kayma
← sola iki kayma
← sola üç kayma
B0 B4 B8
B12
B1 B5 B9
B13
B2 B6
B10 B14
B3 B7
B11 B15
B0 B4 B8
B12
B5 B9
B13 B1
B10 B14 B2 B6
B15 B3 B7
B11
• Sütun Karıştırma Alt Katmanı
• İfade matrisindeki her bir satırı karıştıran lineer
dönüşüm.
• Sütundaki her dört bayt 4x4’lük bir matrisin çarpımıdır ve
vektör olarak ele alınabilir, örneğin,
burada 01, 02 ve 03 hexadecimal gösterimde verilmiştir
• Bütün aritmetik işlemler Galois field‘de GF(28) yapılır
10

14/28

C3  02 B15 




01 02 03
 B
03 01 01

  2 01


C
C0 
 
02

03 01 01  B0
 


C1   01 02 03 01  B5 
• Anahtar Ekleme Alt Katmanı
• Girişler:
• 16-bayt C ifade matrisi
• 16-bayt ki alt anahtarı
• Çıkış: C  ki
• Alt anahtarlar anahtar tarifesinde üretilir.
15/28
16/28
• Anahtar Tarifesi
• Alt Anahtarlar 128/192/256-bitlik giriş anahtarlarından yenilemeli olarak üretilir
• Her roundun bir alt anahtarı vardır, artı AES‘in başlangıcındaki anahtar
• Anahtar beyazlatma (Key whitening): Alt Anahtar AES‘in hem giriş
hem de çıkışında kullanılır
 # subkeys = # rounds + 1
• Farklı anahtar boyutları için farklı anahtar tarifeleri vardır.
Key length (bits) Number of subkeys
128 11
192 13
256 15
• Anahtar Tarifesi
Örnek: Key schedule for 128-bit key AES
• Kelime-tabanlı: 1 kelime = 32 bits
17/28
• 11 alt anahtar W[0]…W[3],
W[4]…W[7], … , W[40]…W[43]
şeklinde depolanır
• İlk alt anahtar W[0]…W[3] orijinal AES
anahtarıdır.
• Anahtar Tarifesi
• g fonksiyonu rotates kendi dört giriş baytını dönmeli kaydırır ve bayt düzeyinde
S-Box yer değiştirme işlemi yapar.
 nonlinearity
• Round sabiti RC‘ler sadece en sola eklenir ve her
round için değişir:
RC[1] = x
0 = (00000001)2
RC[2] = x
1 = (00000010)2
RC[3] = x
2 = (00000100)2
...
RC[10] = x
9 = (00110110)2
• x
i Galois field‘ deki elemanları gösterir
(daha fazla bilgi için Chapter 4.3 of Understanding Cryptography)
18/28
19/28
Ünite içeriği
• AES algoritmasına genel bakış
• AES‘in iç yapısı
• Bayt Değiştirme katmanı
• Difüzyon katmanı
• Anahtar Ekleme katmanı
• Anahtar tarifesi
• Deşifreleme
• Pratik konular
• Deşifreleme
• AES Feistel yapısına dayanmaz
 Deşifreleme için bütün katmanlar ters çevrilir:
• Sütun Karıştırma katmanı → Sütun Karıştırma
katmanın tersi
• Satır Kaydırma katmanı→ Satır Kaydırma
katmanın tersi
• Bayt Yer Değiştirme katmanı → Bayt
Yer Değiştirme katmanın tersi
• Anahtar Ekleme alt katmanı kendi tersidir
20/28
21/28
• Deşifreleme
• Sütun Karıştırma katmanın tersi:
• Sütun karıştırma işlemlerinin tersini almak için, C ifade matrisinin her sütunu
inverse of the 4x4 ters matrislerle çarpılmalı, örneğin,
burada 09, 0B, 0D ve 0E hexadecimal gösterimde verilmiştir
• Yine, bütün aritmetik işlemler Galois field GF(28) içindedir.
2


0E  C3 




09 0E 0B C
0B 0D 09
B 

0D
2
B3 

B0 
 
0E

0B 0D 09 

C0 


B1   09 0E 0B 0D C1

22/28
• Deşifreleme
• Satır Kaydırma katmanın tersi:
• B ifade matrisinin her satırı tarif edilen şekilde kaydırılır:
Giriş matrisi
Çıkış matrisi kayma yok
→ sağa bir birim kayma
→ sağa iki birim kayma
→ sağa üç birim kayma
B0 B4 B8
B12
B1 B5 B9
B13
B2 B6
B10 B14
B3 B7
B11 B15
B0 B4 B8
B12
B13 B1 B5 B9
B10 B14 B2 B6
B7
B11 B15 B3
23/28
• Deşifreleme
• Bayt Yer Değiştirme katmanın tersi:
• Since the S-Box is bijective, it is possible to construct an inverse, such that
Ai = S-1(Bi
) = S-1(S(Ai
))
 Ters S-Box deşifreleme için kullanılır. Bu, genellikle bir arama tablosu
olarak gerçekleşmiştir.
• Deşifreleme anahtar tarifesi:
• Alt anahtarlara ters sırayla kullanılır (şifreleme ile karşılaştırıldığında).
• pratikte, şifreleme ve deşifreleme için, aynı anahtar tarifesi kullanılır.
Burada ilk blok şifreleme başlamadan önce tüm alt anahtarların
hesaplanması gerekir.
24/28
Ünite içeriği
• AES algoritmasına genel bakış
• AES‘in iç yapısı
• Bayt Değiştirme katmanı
• Difüzyon katmanı
• Anahtar Ekleme katmanı
• Anahtar tarifesi
• Deşifreleme
• Pratik konular
25/28
• Yazılımda Uygulama
• AES’in önemli bir gereksinimi etkili bir yazılım uygulaması olmasıdır.
• Basit uygulama iyi 8-bit işlemciler için uygundur.(örneğin, smart cards), 32-bit veya
64-bitlik işlemciler için uygun değildir.
• Tipik GB hızları Modern 64-bit işlemcilerde 1.6 Gbit / s’tan daha fazladır .
26/28
• Güvenlik
• Kaba kuvvet saldırısı: 128, 192 veya 256 bitlik
anahtarlardan dolayı kaba kuvvet saldırısı mümkün değildir.
• Analytical attacks: Kaba kuvvet saldırısındn daha iyi olduğu
bilinen hiçbir analitik saldırı yoktur.
• Yan-kanal saldırıları :
• Çeşitli yan kanal saldırıları yayınlanmıştır.
• Şunu belirtmek gerekir ki yan-kanal saldırısı algoritmanın
temelleriyle değil uygulamalarıyla yapılır.
Understanding Cryptography – A Textbook for
Students and Practitioners
by Christof Paar and Jan Pelzl
www.crypto-textbook.com
Ünite 5 – Blok Şifreleme Hakkında Dahası
Çeviren: Selman YAKUT
Chapter 5 of Understanding Cryptography by Christof Paar and Jan Pelzl 2/38
Ünite İçeriği
• Blok Şifreler ile Şifreleme : İşlem Modları
• Electronic Code Book mode (ECB)
• Cipher Block Chaining mode (CBC)
• Output Feedback mode (OFB)
• Cipher Feedback mode (CFB)
• Counter mode (CTR)
• Galois Counter Mode (GCM)
• Ayrıntılı Anahtar Aramaya Göz Atma
• Blok Şifreleme Güvenlik artırılması
Chapter 5 of Understanding Cryptography by Christof Paar and Jan Pelzl 3/38
• Blok Şifreler
• Blok şifre yapıları blok şifrelemenin yanında diğer bir çok uygulamada da kullanılır...
• Blok tabanlı farklı şifreleme yapılarının tasarlanması
• Akış şifrelemeyi gerçekleştirmek
• Hash fonksiyonları oluşturmak
• Mesaj doğrulama kodu yapıları oluşturmak
• anahtar kurulması protokolleri oluşturmak
• Sözde rasgele sayı üreteci tasarlamak
• ...
• Blok şifrelerin güvenliği de artabilir
• anahtar beyazlatma
• Çoklu şifreleme
Chapter 5 of Understanding Cryptography by Christof Paar and Jan Pelzl 4/38
Ünite İçeriği
• Blok Şifreler ile Şifreleme : İşlem Modları
• Electronic Code Book mode (ECB)
• Cipher Block Chaining mode (CBC)
• Output Feedback mode (OFB)
• Cipher Feedback mode (CFB)
• Counter mode (CTR)
• Galois Counter Mode (GCM)
• Ayrıntılı Anahtar Aramaya Göz Atma
• Blok Şifreleme Güvenlik artırılması
Chapter 5 of Understanding Cryptography by Christof Paar and Jan Pelzl 5/38
• Blok Şifre ile Şifreleme
• Uzun metinleri (örneğin, e-posta veya bir bilgisayar dosya)
şifrelemenin birkaç yolu ("çalışma modu") vardır.
• Electronic Code Book mode (ECB)
• Cipher Block Chaining mode (CBC)
• Output Feedback mode (OFB)
• Cipher Feedback mode (CFB)
• Counter mode (CTR)
• Galois Counter Mode (GCM)
• Bu 6 modun hepsinin tek bir amacı var :
• Gizlilik ek olarak, doğrulama ve bütünlüğü sağlamak :
• Mesaj gerçekten orijinal göndericiden mi geliyor? (doğrulama)
• Şifreli metin iletim sırasında değişti mi? (bütünlük)
Chapter 5 of Understanding Cryptography by Christof Paar and Jan Pelzl 6/38
Ünite İçeriği
• Blok Şifreler ile Şifreleme : İşlem Modları
• Electronic Code Book mode (ECB)
• Cipher Block Chaining mode (CBC)
• Output Feedback mode (OFB)
• Cipher Feedback mode (CFB)
• Counter mode (CTR)
• Galois Counter Mode (GCM)
• Ayrıntılı Anahtar Aramaya Göz Atma
• Blok Şifreleme Güvenlik artırılması
• Electronic Code Book mode (ECB)
• ek
(xi
) ; b-bitlik xi düz metin bloğu k anahtarıyla şifrelenen yapısıdır.
• ek (yi
-1 ); b-bitlik yi şifreli metin bloğu k anahtarıyla deşifreleme yapısıdır
• Mesaj uzunluğu b bitten fazlaysa mesaj b-bitlik parçalara ayrılır.
• Her blok ayrı şifrelenir
Şifreleme : yi = ek
(xi
), i ≥ 1
Chapter 5 of Understanding Cryptography by Christof Paar and Jan Pelzl 7/38
Deşifreleme: xi = ek
(yi
) = ek
(ek
(xi
)), i ≥ 1 −1 −1
Chapter 5 of Understanding Cryptography by Christof Paar and Jan Pelzl 8/38
• ECB: avantajlar/dezavantajlar
• Avantajlar
• Gönderici ve alıcı arasınd blok eşleşmesi gerekmez
• bGürültüden dolayı oluşan bit hataları sadece bu yapıya karşı düşen
kısmı etkiler bundan sonra gelen yapıları etkilemez
• Blok şifreleme işlemi paralel olarak yapılabilir.
• Yüksek hızlı uygulamalar için avantajdır
• Dezavantajlar
• ECB yüksek seviyede deterministik bir şifreleme yapısıdır
• Aynı düz metin aynı şifreli metini oluşturur
• Aynı şifreli metin ikinci defa gönderildiğinde saldırgan bunu tanır
• Düz metin blokları birbirinden bağımsız olarak şifrelenir
• Saldırgan düz metinde geçerli olacak şekilde şifreli metindeki
sıralamayı değiştirebilir
• ECB Üzerinde Yer Değiştirme Saldırısı
• Önce düz metne karşılık üretilen şifreli metinler oluşturulur (xi → yi
)
şifreli metnin sırası kolaylıkla manipüle edilebilir
• İnternet bankacılığı transferi yapıldığını varsayalım
• İki banka arasındaki şifreleme anahtarı çok sık değişmez
• Saldırgan tekrar tekrar A bankasındaki hesabından B
bankasındaki hasabına $1.00 transfer eder
• Saldırgan tekrarlayan şifreli metin parçalarını kontrol eder ve bu
transferdeki1,3 ve 4 saklar
• Saldırgan kolaylıkla herhangi bir transferdeki 4. bloğu daha
önceki iletimlerde saklanan 4. blok ile değiştirebilir
• A bankasındaki aynı hesaptan B bankasındaki aynı hesaba gönderilen
bütün transferler saldırgan tarafından yanlış yönlendirilir ($ 1000.00,
$1.00 dolar gibi gösterilebilir)
Chapter 5 of Understanding Cryptography by Christof Paar and Jan Pelzl 9/38
• ECB modunda Bit haritalama şifreleme örneği
• Aynı düz metin aynı şifreli metne haritalanır
• Düz metindeki istatistiksel özellikler şifreli metinde de korunur
Chapter 5 of Understanding Cryptography by Christof Paar and Jan Pelzl 10/38
Chapter 5 of Understanding Cryptography by Christof Paar and Jan Pelzl 11/38
Ünite İçeriği
• Blok Şifreler ile Şifreleme : İşlem Modları
• Electronic Code Book mode (ECB)
• Cipher Block Chaining mode (CBC)
• Output Feedback mode (OFB)
• Cipher Feedback mode (CFB)
• Counter mode (CTR)
• Galois Counter Mode (GCM)
• Ayrıntılı Anahtar Aramaya Göz Atma
• Blok Şifreleme Güvenlik artırılması
• Cipher Block Chaining mode (CBC)
• CBC modu temel olarak iki düşünceden oluşmaktadır:
• Şifrelenecek bütün bloklar birbirine zincirlenir
• yi
şifreli metin bloğu sadece xi düz metin bloğuna bağlı değildir
kendisinden önceki bütün düz metin bloklarına bağlıdır
• Şifreleme bir başlatma vektörü (IV) kullanılarak randomize edilir
Şifreleme (ilk blok):
Chapter 5 of Understanding Cryptography by Christof Paar and Jan Pelzl 12/38
y1 = ek
(x1 ⊕
Şifreleme (genel block): IyV) i = ek
(xi ⊕yi−1
), i ≥
2Deşifreleme (ilk blok): x1 = ek
(y1
) ⊕
IV
−1
Deşifreleme (genel block) : xi = ek
(y ) ⊕y , i ≥ 2
−1
i i−1
• Cipher Block Chaining mode (CBC)
• İlk düz metin bloğu için (x1) herhangi şifreli metin bloğu yoktur
• IV başlangıç vektörü CBC moduna eklenerek nondeterministik bir
yapı oluşturulur.
• İlk şifreli metin bloğu (y1
), x1 düz metnine ve IV‘ ye bağlıdır
• ikinci şifreli metin bloğu (y2
) ise IV, x1 ve x2‘ ye bağlıdır
• üçüncü şifreli metin bloğu (y3)
ise IV x1
, x2 ve x3
, bağlıdır…
Chapter 5 of Understanding Cryptography by Christof Paar and Jan Pelzl 13/38
Chapter 5 of Understanding Cryptography by Christof Paar and Jan Pelzl 14/38
• CBC üzerinde yerdeğiştirme saldırısı
• Yine internet bankacılığı örneğini ele alalım
• Eğer IV her havalede uygun seçilirse bu saldırı mümkün olmaz
• Eğer IV birkaç transfer için aynı tutulursa saldırgan kendi
hesabındaki A bankasından B bankasına olan transferi tanıyabilir
• Eğer her şifreleme için yeni bir IV değeri seçilirse olasılıksal bir
CBC modu elde edilir diğer bir deyişle, aynı düz metinin şifrelenmiş
iki hali tamamen farklıdır
• IV gizli tutmak için gerekli değildir!
• Tipik olarak, IV, gizli olmayan bir değer olmalıdır (değer yalnızca bir
kez kullanılır)
Chapter 5 of Understanding Cryptography by Christof Paar and Jan Pelzl 15/38
Ünite İçeriği
• Blok Şifreler ile Şifreleme : İşlem Modları
• Electronic Code Book mode (ECB)
• Cipher Block Chaining mode (CBC)
• Output Feedback mode (OFB)
• Cipher Feedback mode (CFB)
• Counter mode (CTR)
• Galois Counter Mode (GCM)
• Ayrıntılı Anahtar Aramaya Göz Atma
• Blok Şifreleme Güvenlik artırılması
• Output Feedback mode (OFB)
• Bu yapı bir blok şifreleme yapısından bir senkron akış şifre oluşturmak için kullanılır
• Akış anahtarı bit düzeyinde üretilmez fakat bit düzeyinde kullanılr
• Şifrelemenin çıkışı anahtar akış şifreleme anahtarını (Si ) vermektedir. Bu anahtar
değeri ve düz metin şifrelenerek şifreleme işlemi gerçekleştirilir.
Şifreleme (ilk blok):
Chapter 5 of Understanding Cryptography by Christof Paar and Jan Pelzl 16/38
s1 = ek
(IV) and y1 = s1⊕
x Şifreleme 1
(genel blok): si = ek
(si−1
) and yi = si⊕xi , i ≥ 2
Deşifreleme (ilk block): s1 = ek
(IV) and x1 = s1⊕
y Deşifreleme 1
(genel blok) : si = ek
(si−1
) and xi = si⊕yi , i ≥ 2
Chapter 5 of Understanding Cryptography by Christof Paar and Jan Pelzl 17/38
Ünite İçeriği
• Blok Şifreler ile Şifreleme : İşlem Modları
• Electronic Code Book mode (ECB)
• Cipher Block Chaining mode (CBC)
• Output Feedback mode (OFB)
• Cipher Feedback mode (CFB)
• Counter mode (CTR)
• Galois Counter Mode (GCM)
• Ayrıntılı Anahtar Aramaya Göz Atma
• Blok Şifreleme Güvenlik artırılması
• Cipher Feedback mode (CFB)
• Bu yapılar asenkron bir akış şifreleme oluşturmak blok şifreleme yapısını
kullanır (OFB moduna benzer), daha doğru adı: «Ciphertext Feedback Mode»
• Akış anahtarı (Si) blok işlemlerle üretilir ve şifreli metnin bir fonksiyonudur.
• Başlangıç vektörü (IV) kullanımının bir sonucu olarak, CFB şifreleme de
nondeterministic bir yapıdadır.
Deşifreleme (genel blok) : xi = ek (yi−1
) ⊕yi
, i ≥ 2
• Kısa düz metin bloklarının şifrelenmesi durumlarda kullanılabilir
Chapter 5 of Understanding Cryptography by Christof Paar and Jan Pelzl 18/38
Şifreleme (ilk blok): y1 = ek
(IV) ⊕x1
Şifreleme (genel block): yi = ek
(yi−1
) ⊕xi
, i ≥ 2
Deşifreleme (ilk blok): x1 = ek
(IV) ⊕y1
Chapter 5 of Understanding Cryptography by Christof Paar and Jan Pelzl 19/38
Ünite İçeriği
• Encryption with Block Ciphers: Modes of Operation
• Electronic Code Book mode (ECB)
• Cipher Block Chaining mode (CBC)
• Output Feedback mode (OFB)
• Cipher Feedback mode (CFB)
• Counter mode (CTR)
• Galois Counter Mode (GCM)
• Exhaustive Key Search Revisited
• Increasing the Security of Block Ciphers
• Counter mode (CTR)
• Burada blok şifreleme akış şifreleme oluşturmak için kullanılır (OFB ve
CFB modları gibi)
• Akış anahtarı blok şeklinde oluşturulur
• Blok şifrelemenin girişi her zaman değişen bir sayacı değeridir ve böylece
her zaman farklı bir akış anahtarı hesaplanır
• CFB ve OFB modlarının aksine CTR modu parallelleştirilebilir çünkü birinci
şifreleme bitmeden önce 2nd şifreleme gerçekleştirilebilir
• Ağ yönlendiricileri gibi yüksek hız gerektiren uygulamalarda istenir
Şifreleme: yi = ek
(IV || CTRi
) ⊕xi
, i ≥ 1
Deşifreleme : xi = ek
(IV || CTRi
) ⊕yi
, i ≥ 1
Chapter 5 of Understanding Cryptography by Christof Paar and Jan Pelzl 20/38
Chapter 5 of Understanding Cryptography by Christof Paar and Jan Pelzl 21/38
Ünite İçeriği
• Blok Şifreler ile Şifreleme : İşlem Modları
• Electronic Code Book mode (ECB)
• Cipher Block Chaining mode (CBC)
• Output Feedback mode (OFB)
• Cipher Feedback mode (CFB)
• Counter mode (CTR)
• Galois Counter Mode (GCM)
• Ayrıntılı Anahtar Aramaya Göz Atma
• Blok Şifreleme Güvenlik artırılması
Chapter 5 of Understanding Cryptography by Christof Paar and Jan Pelzl 22/38
• Galois Counter Mode (GCM)
• Ibu yapı message authentication code (MAC), hesaplamada kullanılır (Ünite
12 de anlatılacaktır)
• GCM modunun kullanımıyla iki ek servis sağlanır:
• Mesaj Doğrulama
• Mesajın gerçekten gönderen tarafından geldiğini garanti eder
• Mesaj Bütünlüğü
• Mesaj iletim sırasında herhangi bir değişikliğe maruz kalmamıştır
Chapter 5 of Understanding Cryptography by Christof Paar and Jan Pelzl 23/38
• Galois Counter Mode (GCM)
• Şifreleme için
• Başlangıç sayacı IV ve bir seri sayıdan üretilir
• Şifreleme ve ilk blokla XOR’lama işleminden sonra sayacı değeri artırılır
• Sonraki düz metinler için sayacı değeri artırılır ve şifreleme işlemi
gerçekleştirilir
• Doğrulama için
• Sıralı Galois field çarpımı gerçekleştirilir (Galois field hakkında daha
fazla bilgi için bakın: Chapter 4.3 in Understanding Cryptography)
• Her bir düz metin için ara doğrulama değeri (gi
) üretilir
• gi
şimdiki şifreli metin ile son gi-1 değerinin XOR’lanmasıyla ve sabit
H değeriyle çarpılması sonucu oluşturulur
• H sabiti, blok şifreleme ile sıfır girişinin şifrelemesiyle üretilir
• Bütün çarpma işlemleri 128-bitlik Galois field GF(2128) de olmaktadır
• Galois Counter Mode (GCM)
Şifreleme:
a. IV’den CTR0 sayaç değeri üretilir ve diğer değerler CTR1 = CTR0 + 1
b. Şifreli metin hesaplama: yi = ek
(CTRi
) ⊕xi
, i ≥ 1
Doğrulama:
a. Doğrulama alt anahtarı üretilir H = ek
(0)
Chapter 5 of Understanding Cryptography by Christof Paar and Jan Pelzl 24/38
b. hesapla g0 = AAD × H (Galois field çarpma)
c. Hesapla gi = (gi−1 ⊕yi
) × H, 1 ≤ i ≤ n (Galois field çarpma)
d. Son doğrulama etiketi: T = (gn× H) ⊕ek
(CTR0
)
Chapter 5 of Understanding Cryptography by Christof Paar and Jan Pelzl 25/38
Ünite İçeriği
• Blok Şifreler ile Şifreleme : İşlem Modları
• Electronic Code Book mode (ECB)
• Cipher Block Chaining mode (CBC)
• Output Feedback mode (OFB)
• Cipher Feedback mode (CFB)
• Counter mode (CTR)
• Galois Counter Mode (GCM)
• Ayrıntılı Anahtar Aramaya Göz Atma
• Blok Şifreleme Güvenlik artırılması
• Ayrıntılı Anahtar Aramaya Göz Atma
• DES algoritmasında verilen basit bir (x1
,y1
) ikilisi için ayrıntılı anahtar arama:
DESk
(x1
) =
Chapter 5 of Understanding Cryptography by Christof Paar and Jan Pelzl 26/38
(i) y1
, i = 0,1, . . . ,2 −1
56
• Bununla beraber bir çok blok şifreleme uygulamasında bu işlem
daha karmaşıktır.
• Kaba kuvvet saldırısı yanlış pozitif sonuçlar üretebilir
• bulunan ki anahtarı şifreleme için kullanılan bir değer
olmayabilir.
• Bu olasılık göreceli olarak anahtar uzayına ve düz metin
uzayına bağlıdır
• Kaba kuvvet saldırıları hala mümkündür fakatbirkaç
tanedüz metin-şifreli metin çifti gereklidir
?
• Ayrıntılı Anahtar Aramaya Göz Atma
• Şifreleme bloğunun genişliği 64 bit ve anahtar boyutu ise 80 bit olsun
• x1 düz metni 280 farklı anahtarla şifrelenirse 280 şifreli metin oluşturulur
• Bununla beraber sadece 264 tanesi farklıdır
• Verilen bir şifresiz-şifreli metin çifti için tüm anahtarlar kullanılırsa,
ortalama 280/264 = 216 anahtar ek
(x1
) = y1 haritalama işlemini
gerçekleştirir
Chapter 5 of Understanding Cryptography by Christof Paar and Jan Pelzl 27/38
Chapter 5 of Understanding Cryptography by Christof Paar and Jan Pelzl 28/38
Ünite İçeriği
• Blok Şifreler ile Şifreleme : İşlem Modları
• Electronic Code Book mode (ECB)
• Cipher Block Chaining mode (CBC)
• Output Feedback mode (OFB)
• Cipher Feedback mode (CFB)
• Counter mode (CTR)
• Galois Counter Mode (GCM)
• Ayrıntılı Anahtar Aramaya Göz Atma
• Blok Şifreleme Güvenlik artırılması
• Çift Şifreleme ve Meet-in-the-Middle Attack
• Üçlü Şifreleme
• Anahtar Beyazlatma (Key Whitening)
Chapter 5 of Understanding Cryptography by Christof Paar and Jan Pelzl 29/38
• Blok Şifreleme Güvenlik artırılması
• Bazı durumlarda blok şifrelerin güvenliğini artırmak isteriz.
• İki yaklaşım mümkündür
• Çoklu şifreleme
• Teorik olarak daha güvenlidir fakat bazen
güvenliği az etkileyebilir
• Anahtar beyazlatma
Chapter 5 of Understanding Cryptography by Christof Paar and Jan Pelzl 30/38
Ünite İçeriği
• Blok Şifreler ile Şifreleme : İşlem Modları
• Electronic Code Book mode (ECB)
• Cipher Block Chaining mode (CBC)
• Output Feedback mode (OFB)
• Cipher Feedback mode (CFB)
• Counter mode (CTR)
• Galois Counter Mode (GCM)
• Ayrıntılı Anahtar Aramaya Göz Atma
• Blok Şifreleme Güvenlik artırılması
• Çift Şifreleme ve Meet-in-the-Middle Attack
• Üçlü Şifreleme
• Anahtar Beyazlatma (Key Whitening)
• Çift şifreleme
• x düz metni önce kL
, anhtarıyla şifrelenir daha sonra oluşan şifreli
metin kR anahtarıyla şifrelenerek oluşturulur
• Anahtar uzunluğu k bit kabul edilirse, ayrıntılı anahtar arama
2k·2k = 22k şifreleme veya deşifreleme gerektirir
Chapter 5 of Understanding Cryptography by Christof Paar and Jan Pelzl 31/38
• Meet-in-the-Middle Attack
• A Meet-in-the-Middle attack requires 2k+2k = 2k+1 operations!
• Phase I: Verilen (x1, y1) için sol şifreleme tüm kL için kaba-kuvvet olduğunu, i,
i = 1,2, ..., 2k ve 2k girişi (her n + k bit genişliğinde) ile bir arama tablosu
hesaplanır
• arama tablosu şifreleme sonucu (zL, i) göre düzenlenir
• Phase II: Doğru şifreleme brute-force (şifre çözme kullanarak) ve her Zr için, i
• o zR, herhangi zL eşit olup olmadığı kontrol edilir, birinci fazın tablosunda değer
Hesapsal karmaşıklık
number of encryptions and decryptions = 2
k +2
k = 2
k+1
number of storage locations = 2
k
• Çift şifreleme, tek bir şifrelemeden çok daha güvenli değil!
Chapter 5 of Understanding Cryptography by Christof Paar and Jan Pelzl 32/38
Chapter 5 of Understanding Cryptography by Christof Paar and Jan Pelzl 33/38
Ünite İçeriği
• Blok Şifreler ile Şifreleme : İşlem Modları
• Electronic Code Book mode (ECB)
• Cipher Block Chaining mode (CBC)
• Output Feedback mode (OFB)
• Cipher Feedback mode (CFB)
• Counter mode (CTR)
• Galois Counter Mode (GCM)
• Ayrıntılı Anahtar Aramaya Göz Atma
• Blok Şifreleme Güvenlik artırılması
• Çift Şifreleme ve Meet-in-the-Middle Attack
• Üçlü Şifreleme
• Anahtar Beyazlatma (Key Whitening)
• Üçlü Şifreleme
• Blok üç defa şifrelenir y = ek3 (ek2 (ek1 (x)))
• Pratikte genellikle farklı ŞDŞ (şifreleme-deşifreleme-şifreleme) yapıları kullanılır
y = ek3
(e
-1
k2 k1
(e (x)))
• Ortalama: k1=k2=k3 seçilirse tek DES şifreleme yapılmıştır
• Still we can perform a meet-in-the middle attack, and it reduces the effective key
length of triple encryption from 3K to 2K!
• saldırgan 3DES kullandığı zaman 2112 test yapmalıdır
• Üçlü şifreleme etkin anahtar uzunluğunu ikiye katlar
Chapter 5 of Understanding Cryptography by Christof Paar and Jan Pelzl 34/38
Chapter 5 of Understanding Cryptography by Christof Paar and Jan Pelzl 35/38
Ünite İçeriği
• Blok Şifreler ile Şifreleme : İşlem Modları
• Electronic Code Book mode (ECB)
• Cipher Block Chaining mode (CBC)
• Output Feedback mode (OFB)
• Cipher Feedback mode (CFB)
• Counter mode (CTR)
• Galois Counter Mode (GCM)
• Ayrıntılı Anahtar Aramaya Göz Atma
• Blok Şifreleme Güvenlik artırılması
• Çift Şifreleme ve Meet-in-the-Middle Attack
• Üçlü Şifreleme
• Anahtar Beyazlatma (Key Whitening)
• Anahtar Beyazlatma (Key Whitening)
• DES gibi şifreleme yapılarını kaba-kuvvet saldırılarına karşı daha
dayanıklı yapar
• k, şifreleme anahtarıyla beraber iki tane beyazlatma anahtarı (k1 ve k2
)
düz metin ve şifreli metinle XOR‘lamak için kullanılır
• Bu blok şifreleme yapısını, linner ve diferansiyel gibi bir çok analitik
saldırıya karçı güçlendiremez
• Bu doğal olarak zayıf şifrelere için bir "tedavi" değildir
• Ilave hesaplama yükü ihmal edilebilir
• Bunun başlıca uygulamaları analitik saldırılara karşı nispeten güçlü olan
ama özellikle DES gibi kısa anahtar uzayına sahip şifreleme yapılarıdır
• Anahtar beyazlatmaya sahip değişik DES‘ler DESX olarak adlandırılır
Chapter 5 of Understanding Cryptography by Christof Paar and Jan Pelzl 36/38
Understanding Cryptography – A Textbook for
Students and Practitioners
by Christof Paar and Jan Pelzl
www.crypto-textbook.com
Chapter 6 – Genel Anahtarla
Şifrelemeye Giriş
Çeviren: Selman YAKUT
Chapter 6 of Understanding Cryptography by Christof Paar and Jan Pelzl 2/29
Ünite İçeriği
• Simetrik Kriptografiyi Gözden Geçirme
• Asimetrik Kriptografi İlkeleri
• Genel Anahtarlı Kriptografinin Pratik Yönleri
• Önemli Genel Anahtar Algoritmalar
• Genel Anahtar Algoritmaları İçin Temel Sayılar Teorisi
Chapter 6 of Understanding Cryptography by Christof Paar and Jan Pelzl 3/29
Ünite İçeriği
• Simetrik Kriptografiyi Gözden Geçirme
• Asimetrik Kriptografi İlkeleri
• Genel Anahtarlı Kriptografinin Pratik Yönleri
• Önemli Genel Anahtar Algoritmalar
• Genel Anahtar Algoritmaları İçin Temel Sayılar Teorisi
Simetrik (gizli anahtar) kripto sistemlerin iki özelliği :
• Aynı gizli anahtar (K) şifreleme ve deşifreleme için kullanılır.
• Şifreleme ve deşifreleme fonksiyonları çok benzerdir (hatta aynıdır).
• Simetrik Kriptografiyi Gözden Geçirme
x eK(x) dK(y) y
x
K K
Alice Bob
Chapter 6 of Understanding Cryptography by Christof Paar and Jan Pelzl 4/29
• Simetrik Kriptografi: Benzerliği
K
Chapter 6 of Understanding Cryptography by Christof Paar and Jan Pelzl 5/29
K
Güçlü bir anahtarla Güvenli bir sistemdir, sadece Alice ve Bob
anahtarının bir kopyasına sahiptir.
• Alice kendi anahtarıyla mesajı güvenli bir şekilde şifreler (kilitler)
• Bob kendi anahtarıyla mesajı güvenli bir şekilde deşifreler (açar)
• AES, 3DES, gibi simetrik algoritmalar oldukça güvenli, hızlı ve yayındır fakat
• Anahtar dağıtım sorunu: gizli anahtar güvenli taşınmalıdır
• Anahtar sayısı: Bir ağda, kullanıcıların her çift için bir tek anahtar gerektirmektedir
ağdaki n tane kullanıcı için tane anahtar gereklidir, her kullanıcı (n-1) anahrarı saklar
• Alice ya da Bob, birbirlerine hile yapabilirsiniz çünkü ikisindede aynı tuşları var .
• Örneğin: Alice on-line olarak Bob’dan bir TV şipariş etiğini (onun sipariş uydurma
olabilir) asla iddia edemez. Bunu önlemek için "Non-repudiation": kullanılabilir.
• Simetrik Kriptografi: Eksiklikleri
Example:
6 kullanıcı (düğüm)
65
15 anahar (kenar)
Chapter 6 of Understanding Cryptography by Christof Paar and Jan Pelzl 6/29
2
Chapter 6 of Understanding Cryptography by Christof Paar and Jan Pelzl 7/29
Ünite İçeriği
• Simetrik Kriptografiyi Gözden Geçirme
• Asimetrik Kriptografi İlkeleri
• Genel Anahtarlı Kriptografinin Pratik Yönleri
• Önemli Genel Anahtar Algoritmalar
• Genel Anahtar Algoritmaları İçin Temel Sayılar Teorisi
Yeni mantık:
Eski mailbox kutuları mantığına dayanır.
Herkes mektup atabilir
Fakat sadece doğru
anahtara sahip olan açabilir
• Asimetrik Kriptografinin Mantığı
Chapter 6 of Understanding Cryptography by Christof Paar and Jan Pelzl 8/29
1976 yılında Whitfield Diffie, Martin Hellman ve Ralph Merkle tarafından böyle bir
algoritma ilk olarak yayınlandı,.
• Asimetrik (Açık Anahtarlı) Kriptografi
İlke: anahtar "Ayrılalım"
K
Açık Anahtar (Public Key) (Kpub)
(şifreleme)
Özel Anahtar(Private Key)(Kpr)
(Deşifreleme)
anahtar üretimi sırasında, bir anahtar çifti Kpub ve Kpr hesaplanır
Chapter 6 of Understanding Cryptography by Christof Paar and Jan Pelzl 9/29
• Asimetrik Kriptografi: Benzetme
açık anahtar ve özel anahtarla Güvenlik sağlanır:
Chapter 6 of Understanding Cryptography by Christof Paar and Jan Pelzl 10/29
• Alice mesajları depolar (mesajları) –gizli olmayan – açık anahtarla Kpub
• Sadece bob- gizli – özel anahtarla Kpr mesajı açabilir (deşifeleyebilir)
(Kpub) (Kpr)
Chapter 6 of Understanding Cryptography by Christof Paar and Jan Pelzl 11/29
Ünite İçeriği
• Simetrik Kriptografiyi Gözden Geçirme
• Asimetrik Kriptografi İlkeleri
• Genel Anahtarlı Kriptografinin Pratik Yönleri
• Önemli Genel Anahtar Algoritmalar
• Genel Anahtar Algoritmaları İçin Temel Sayılar Teorisi
• Açık Anahtarlı Şifreleme için Temel Protokol
Alice Bob
(KpubB,KprB) = K KpubB
x
y=eKpubB
(x) y
Chapter 6 of Understanding Cryptography by Christof Paar and Jan Pelzl 12/29
x=dKprB
(y)
Anahtar Dağıtım Sorun çözüldü
.
Chapter 6 of Understanding Cryptography by Christof Paar and Jan Pelzl 13/29
• Açık-Anahtarlı Kriptografinin Güvenlik Mekanizmaları
Burada asimetrik kriptografi ile gerçekleşebilir ana mekanizmaları şunlardır:
• Anahtar dağıtımı (e.g., Diffie-Hellman anahtar değişimi, RSA) Önceden
paylaşılan gizli bir değer olmadan (anahtar)
• Nonrepudiation ve Dijital İmzalar (RSA, DSA or ECDSA gibimesaj
bütünlüğünü sağlamak için
• Tanımlama, dijital imza ile meydan-yanıt (challenge-response) protokolleri
kullanarak
• Şifreleme (RSA / Elgamal gibi) Dezavantajı:
hesaplama çok fazla (! Simetrik algoritmalar
göre 1000 kat daha yavaş)
Chapter 6 of Understanding Cryptography by Christof Paar and Jan Pelzl 14/29
• Temel Anahtar Aktarım Protokolü 1/2
Pratikte : Hibrit sistemler kullanılır, asimetrik ve simetrik algoritmaları içeren
1. anahtar değişimi (Simetrik programları için) ve dijital imzalar asimetrik
algoritmalar (yavaş) ile yapılır
2. Veri şifreleme (hızlı) simetrik şifreleri kullanılarak yapılır, örneğin, blok şifreler
veya akış şifreleri
y1 = eKpubB(K)
K = dKprB
(y1
)
y2 = AESK (x) x = AES-1
K (y2
)
y2
Veri Şifreleme
(simetrik)
• Temel Anahtar Aktarım Protokolü 2/2
Örnek: simetrik şifreleme olarak AES ile Hybrid protokol
Chapter 6 of Understanding Cryptography by Christof Paar and Jan Pelzl 15/29
Alice Bob
(KpubB,KprB) = K
y1
Anahtar Değişimi
(asimetrik)
KpubB
Rastgele simetrik
anahtarı seçilir K
X mesajı
Chapter 6 of Understanding Cryptography by Christof Paar and Jan Pelzl 16/29
Ünite İçeriği
• Simetrik Kriptografiyi Gözden Geçirme
• Asimetrik Kriptografi İlkeleri
• Genel Anahtarlı Kriptografinin Pratik Yönleri
• Önemli Genel Anahtar Algoritmalar
• Genel Anahtar Algoritmaları İçin Temel Sayılar Teorisi
Chapter 6 of Understanding Cryptography by Christof Paar and Jan Pelzl 17/29
• Açık-anahtar algoritmaları nasıl oluşturulur
Asimetrik yapılar "tek-yönlü fonksiyon" f () dayanmaktadır:
• y = f (x) hesaplamak hesapsal olarak kolay
• x = f
-1(y) hesaplamak ise hesapsal olarak imkansızdır
Tek yönlü fonksiyonlar matematiksel zor problemlere dayanmaktadır.
Üç ana ailesi :
• Factoring integers (RSA, ...):
Bileşik bir n tamsayısı göz önüne alındığında,
bunun asal çarpanlarını bulmak (Iki asal çarpın:
kolay)
• Discrete Logarithm (Diffie-Hellman, Elgamal, DSA, …):
Verilen a, y ve m için ax = y mod m olacak şekilde x
değerleri bulunmaya çalışılır. ( ax üssünü alma: easy)
• Eliptik Eğriler (EC) (ECDH, ECDSA): Ayrık logaritma Genelleme Not:
Problemler matematiksel olarak zor kabul edilir ama bunun hiçbir kanıt (şimdiye
kadar) bulunmamaktadır.
• Anahtar Uzunlukları ve Güvenlik Seviyeleri
Chapter 6 of Understanding Cryptography by Christof Paar and Jan Pelzl 18/29
• RSA (faktoring) ve DL (Index-Hesabı) tam karmaşıklığı tahmin etmek zordur
• Kuantum bilgisayarların varlığı muhtemelen ECC, RSA ve DL sonu olurdu
(20-30 yıl sonra bazı insanların bu bilgisayarlara sahip olacağı şüphesizdir)
Symmetric ECC RSA, DL Remark
64 Bit 128 Bit  700 Bit Sadece kısa vadeli
güvenlik (birkaç saat
veya gün)
80 Bit 160 Bit  1024 Bit Orta seviyede güvenlik
(büyük saldırılara hariç
kamu kurumları vb)
128 Bit 256 Bit  3072 Bit Uzun vadeli güvenlik
(Kuantum bilgisayarlar
olmadan)
Chapter 6 of Understanding Cryptography by Christof Paar and Jan Pelzl 19/29
Ünite İçeriği
• Simetrik Kriptografiyi Gözden Geçirme
• Asimetrik Kriptografi İlkeleri
• Genel Anahtarlı Kriptografinin Pratik Yönleri
• Önemli Genel Anahtar Algoritmalar
• Açık Anahtar Algoritmaları İçin Temel Sayılar Teorisi
• Öklid Algoritması 1/2
• r0 ve r1 gibi iki tam sayının en büyük ortak bölen gcd (r0,
r1
) hesaplanır
• gcd küçük sayılar için kolaydır:
1. r0 ve r1 çarpanlarına ayrılır
2. gcd = en büyük ortak çarpan
• Örnek:
r0 = 84 = 2 . 2 . 3 . 7
r1 = 30 = 2 . 3 . 5
gcd tüm ortak çarpanların çarpımlarının ürünüdür:
2 . 3 = 6 = gcd (30,84)
• Fakat: Büyük sayılar için çarpanlara ayırma karmaşık (ve çoğu zaman olanaksız) 'dir
Chapter 6 of Understanding Cryptography by Christof Paar and Jan Pelzl 20/29
• Öklid Algoritması 2/2
• Gözlem: gcd (r0,
r1
) = gcd (r0
- r1
, r1
)
Ana fikir:
• Iki küçük sayının gcd’sini bulma problemi azaltmak azaltmak
için iki tamsayı gcd leri hesaplanır
• İşlemi tekrar et yinelemeli olarak
• Son gcd (ri, 0) = ri olursa problem çözülür !
Örneğin: gcd (r0,
r1
) , r0 = 27 ve r1 = 21 için
• Note: Daha uzun sayılar için çok etkili bir yöntem:
Karmaşıklığı bit sayısı ile doğrusal olarak büyür
Tam Öklid Algoritması görmek için bakın Chapter 6 in Understanding Cryptography.
Chapter 6 of Understanding Cryptography by Christof Paar and Jan Pelzl 21/29
• Genişletilmiş Öklid Algoritması 1/2
• Öklit algoritması genişletilir r1 mod r0 modüler tersi bulunur
• EEA computes s,t, and the gcd :
• Take the relation mod r0
-7 Modüler tersinin tanımı ile karşılaştır : t ,r1 mod r0 tersidir
• Note that gcd (r0,
r1
) = 1 in order for the inverse to exist
• Recursive formulae to calculate s and t in each step
-7 „magic table“ for r, s, t and a quotient q to derive the inverse with pen and paper
Chapter 6 of Understanding Cryptography by Christof Paar and Jan Pelzl 22/29
• Genişletilmiş Öklid Algoritması 2/2
Example:
• Calculate the modular Inverse of 12 mod 67:
• From magic table follows
• Hence 28 is the inverse of 12 mod 67.
• Check:
For the full Extended Euclidean Algorithm see Chapter 6 in Understanding Cryptography.
2812  336 1mod67
Chapter 6 of Understanding Cryptography by Christof Paar and Jan Pelzl 23/29
• Euler‘s Phi Function 1/2
• New problem, important for public-key systems, e.g., RSA:
Given the set of the m integers {0, 1, 2, …, m -1},
How many numbers in the set are relatively prime to m ?
• Answer: Euler‘s Phi function Φ(m)
• Example for the sets {0,1,2,3,4,5} (m=6), and {0,1,2,3,4} (m=5)
-7 1 and 5 relatively prime to m=6,
hence Φ(6) = 2
-7 Φ(5) = 4
• Testing one gcd per number in the set is extremely slow for large m.
Chapter 6 of Understanding Cryptography by Christof Paar and Jan Pelzl 24/29
• If canonical factorization of m known:
(where pi primes and ei positive integers)
• then calculate Phi according to the relation
• Phi especially easy for ei = 1, e.g., m = p . q -7 Φ(m) = (p-1) . (q-1)
• Example m = 899 = 29 . 31:
Φ(899) = (29-1) . (31-1) = 28 . 30 = 840
• Note: Finding Φ(m) is computationally easy if factorization of m is known
(otherwise the calculation of Φ(m) becomes computationally infeasible for large numbers)
• Euler‘s Phi Function 2/2
Chapter 6 of Understanding Cryptography by Christof Paar and Jan Pelzl 25/29
Example: a = 2, p = 7
• Fermat‘s Little Theorem works only modulo a prime p
• Verilen p asal ve a tamsayısı için
• Olarak yazılabilir
• Use: Find modular inverse, if p is prime. Rewrite to
• Comparing with definition of the modular inverse
-7 is the modular inverse modulo a prime p
• Fermat‘s Little Theorem
Chapter 6 of Understanding Cryptography by Christof Paar and Jan Pelzl 26/29
• Euler‘s Theorem
• Herhangi bir tamsayı modülüne Fermat'ın küçük teoremi Genelleştirilmesi
• a ve m : Aralarında asal iki tamsayı olsun
• Örnek: m=12, a=5
1. Euler Phi Fonksiyonu hesaplanır
2. Euler Teoremi doğrulanır
• Fermat'ın küçük teoremi = Euler Teoremi özel durum p: asal sayısı için
-7 Fermat:
Chapter 6 of Understanding Cryptography by Christof Paar and Jan Pelzl 27/29
Understanding Cryptography – A Textbook for
Students and Practitioners
by Christof Paar and Jan Pelzl
www.crypto-textbook.com
Ünite 7 – RSA Şifreleme
Çeviren: Selman YAKUT
2 /34 Chapter 7 of Understanding Cryptography by Christof Paar and Jan Pelzl
• Ünite İçeriği
• RSA Şifreleme
• Uygulama Yönleri
• Büyük Asal Sayı Bulma
• Saldırılar ve Önlemler
3 /34 Chapter 7 of Understanding Cryptography by Christof Paar and Jan Pelzl
• Ünite İçeriği
• RSA Şifreleme
• Uygulama Yönleri
• Büyük Asal Sayı Bulma
• Saldırılar ve Önlemler
4 /34 Chapter 7 of Understanding Cryptography by Christof Paar and Jan Pelzl
• The RSA Cryptosystem
• Martin Hellman ve Whitfield Diffie 1976 yılında dönüm noktası olan
Açık anahtar bildirisini yayınladı.
• Ronald Rivest, Adi Shamir ve Leonard Adleman 1977 yılında
asimetrik RSA şifrelemesini önerdi.
• Eliptik eğri şifreleme (ECC) giderek daha popüler hale olmasına
rağmen şimdiye kadar, RSA en yaygın kullanımı asimetrik
şifrelemedir.
• RSA genel olarak iki uygulama için kullanılır
• Anahtar (simetrik) taşıma
• sayısal imzalar
• Encryption and Decryption
• RSA operations are done over the integer ring Zn
(i.e., arithmetic
modulo n), where n = p * q, with p, q being large primes
• Şifreleme ve deşifreleme basitçe halkada üs almadır.
Definition
Given the public key (n,e) = kpub and the private key d = kpr we write
y = ekpub
(x) ≡ x
e mod n
x = dkpr
(y) ≡ y
d mod n
where x, y ε Zn.
We call ekpub
() the encryption and dkpr
() the decryption operation.
• Uygulama x, y, n ve d çok uzun tamsayılardır (≥ 1024 bit)
• Programının güvenliği verilen kamu-anahtar (n, e) değerlerinden d
"özel üs" türetmek zor olduğu gerçeğine dayanır.
5 /34 Chapter 7 of Understanding Cryptography by Christof Paar and Jan Pelzl
• Anahtar Üretimi
• iki büyük, farklı asal p, q seçimi (Adım 1) basit değildir.
• gcd(e, Φ(n)) = 1 bu yapı tersi olduğunu garantiler ve böylece her
zaman d gibi bir özel anahtar vardır.
• Tüm asimetrik düzenleri gibi, RSA da kamu ve özel anahtarları
hesaplanması aşaması vardır.
Algorithm: RSA Key Generation
Output: public key: kpub = (n, e) and private key kpr
= d
6 /34 Chapter 7 of Understanding Cryptography by Christof Paar and Jan Pelzl
1. Choose two large primes p, q
2. Compute n = p * q
3. Compute Φ(n) = (p-1) * (q-1)
4. Select the public exponent e ε {1, 2, …, Φ(n)-1} such that
gcd(e, Φ(n) ) = 1
5. Compute the private key d such that d * e ≡ 1 mod Φ(n)
6. RETURN kpub = (n, e), kpr
= d
Açıklama:
• Örnek: küçük numaralar ile RSA
ALICE
Message x = 4
y = x
e ≡ 43 ≡ 31 mod 33
BOB
1.Choose p = 3 and q = 11
2.Compute n = p * q = 33 3.
Φ(n) = (3-1) * (11-1) = 20
4. Choose e = 3
5. d ≡ e-1 ≡7 mod 20
y
d = 317 ≡ 4 = x mod 33
Kpub = (33,3)
y = 31
7 /34 Chapter 7 of Understanding Cryptography by Christof Paar and Jan Pelzl
8 /34 Chapter 7 of Understanding Cryptography by Christof Paar and Jan Pelzl
• Ünite İçeriği
• RSA Şifreleme
• Uygulama Yönleri
• Büyük Asal Sayı Bulma
• Saldırılar ve Önlemler
9 /34 Chapter 7 of Understanding Cryptography by Christof Paar and Jan Pelzl
• Uygulama Yönleri
• RSA şifreleme kavramsal olarak basit bir asimetrik düzeni yapan
tek bir aritmetik işlem (modüler üs alma) kullanır
• Kavramsal olarak basit olmasına rağmen, çok büyük sayıların
kullanılması nedeniyle, RSA simetrik yapılara (DES, AES) göre daha
yavaştır
• RSA uygulamalarında (örneğin akıllı kartlar veya cep telefonu
gibi kısıtlı bir cihaz üzerinde) aritmetik algoritmaların doğru
seçimine önem verilmelidir
• Kare ve-çarpım algoritması çok büyük sayılarla hızlı üs alma
sağlar ...
• Kare-ve-Çarpım Algoritması
• Basic principle: Kare / çarpma operandına göre soldan
sağa doğru üs bitlerini tarar
Algorithm: Square-and-Multiply for xH mod n
Input: Exponent H, base element x, Modulus n
Output: y = x
H mod n
1. Determine binary representation H = (ht
, ht-1
, ..., h0
)2
2. FOR i = t-1 TO 0
3. y = y
2 mod n
4. IF hi = 1 THEN
5. y = y * x mod n
6. RETURN y
• Her tekrarında kare (Adım 3) ve eğer üs bit hi = 1 (Adım 5) ise
çarpın sonucu x ile çarpılır.
• Her adımdan sonra modül azaltma y operandını küçük tutar
10 /34 Chapter 7 of Understanding Cryptography by Christof Paar and Jan Pelzl
11 /34 Chapter 7 of Understanding Cryptography by Christof Paar and Jan Pelzl
• Örnek: Kare-ve-Çarp
• Modüle azaltmayı kullanmadan x
26 hesapla
• Üssün ikili gösterimi : 26 =(1,1,0,1,0)2=(h4
,h3
,h2
,h1
,h0
)2
• Üs alma işleminin nasıl geliştiği gözlemle: x
26 = x11010
Step Binary exponent Op Comment
1 x = x1 (1)2
Initial setting, h4 processed
1a (x1)
2 = x2 (10)2 SQ Processing h3
1b x2 * x = x3 (11)2 MUL h3 = 1
2a (x3)
2 = x6 (110)2 SQ Processing h2
2b - (110)2
- h0 = 0
3a (x6)
2 = x12 (1100)2 SQ Processing h1
3b x12 * x = x13 (1101)2 MUL h1=1
4a (x13)
2 = x26 (11010)2 SQ Processing h0
4b - (11010)2
- h0 = 0
12 /34 Chapter 7 of Understanding Cryptography by Christof Paar and Jan Pelzl
• • Kare-ve-Çarp Alg Karmaşıklığı
• Kare- çarpma, algoritması logaritmik bir karmaşıklığa sahiptir, yani,
onun çalışma süresi üs bit uzunluğunun ile orantılıdır (gerçek
değerinden ziyade)
• t+1 bitlik biir üs verilsin
H = (ht
,ht-1
, ..., h0
)2
ht = 1 ile, aşağıdki işlemler takip edilir
• # Squarings
• Average # multiplications
• Total complexity: #SQ + #MUL
= t
= 0.5 t
= 1.5 t
• Üslü genellikle rastgele seçilmiş, yani 1.5 t operasyonların ortalama
sayısı için iyi bir tahmindir.
• Her kare alma ve her çarpma çok uzun sayılar ile bir operasyon
olduğunu unutmayın, örneğin, 2048 bit tamsayılar.
13 /34 Chapter 7 of Understanding Cryptography by Christof Paar and Jan Pelzl
• Hız-Artırma Teknikleri
• Modüler üs alma fazla bir hesaplama gerektirir
• Hatta çarpma kare-ve-algoritması ile RSA, akıllı kart gibi kısıtlı
cihazlarda oldukça yavaş olabilir
• Bazı önemli püf noktaları:
• Kısa genel üs e
• Çin Kalan Teoremi (CRT)
• Ön-hesaplama ile Üs alma (burada yer almıyor)
14 /34 Chapter 7 of Understanding Cryptography by Christof Paar and Jan Pelzl
• Küçük ortak üs ile hızlı şifreleme
• Küçük bir açık üstel e değeri Seçimi RSA güvenliği zayıflatmaz.
• Küçük bir açık üs RSA şifrelemenin hızını önemli ölçüde artırır
• Bu yaygın olarak kullanılan bir numara ile RSA şifreleme en hızlı
asimetrik yapı olur!
Public Key e as binary string #MUL + #SQ
21+1 = 3 (11)2 1 + 1 = 2
24+1 = 17 (1 0001)2 4 + 1 = 5
216 + 1 (1 0000 0000 0000 0001)2 16 + 1 = 17
15 /34 Chapter 7 of Understanding Cryptography by Christof Paar and Jan Pelzl
• CRT ile hızlı deşifreleme
• Küçük özel anahtarların d seçimi güvenlik zayıflıkları doğurur
• Gerçekte, d en az 0.3t bit olmalıdır, burada, t modülü
n bit uzunluğudur.
• Ancak, Çin kalan teoremi (CRT) (biraz), özel anahtar d kullanılarak
üs alma işlemini hızlandırmak için kullanılabilir
• CRT dayanarak hesaplama değiştirebilir
xd mod Φ(n) mod n
İki hesaplamayla
xd mod (p-1) mod p ve xd mod (q-1) mod q
Burada q ve p n göre "küçük» tür
• CRT tabanlı üs almanın temel ilkesi
• CRT üç farklı adımdan oluşur
(1) CRT alanı içine operand Dönüşümü
(2) CRT alanında modüler üs
(3) Problem alanı içine ters dönüşüm
• Bu adımlar problem alanında bir modüler üs eşdeğerdir
x x
d mod n
xp
xq
Xp
d mod (p-1) mod p
Xq
d mod (q-1) mod q
Problem
Domain
16 /34 Chapter 7 of Understanding Cryptography by Christof Paar and Jan Pelzl
CRT Domain
17 /34 Chapter 7 of Understanding Cryptography by Christof Paar and Jan Pelzl
• CRT: Adım 1 - Dönüşüm
• CRT alanı içine dönüşüm p ve q bilgi gerektirir
• p ve q sadece özel anahtarın sahibi tarafından bilinir, böylece CRT
şifreleme hızlandırmak için uygulanabilir olamaz.
• Bu dönüşüm CRT alanında x temsil eden (xp, xq) değerlerini
hesaplar. Onlar bilgisayar tarafından kolayca bulunabilir
xp ≡ x mod p and xq ≡ x mod q
18 /34 Chapter 7 of Understanding Cryptography by Christof Paar and Jan Pelzl
• CRT: Adım 2 - Üs
• Verilen dp ve dq
için
dp ≡ d mod (p-1) ve dq ≡ d mod (q-1)
problem alanı bir üs alma, CRT alanında iki üs almayı
gerektirir
yp ≡ xp mod p ve yq ≡ xq mod q
dp dq
• Pratikte, p ve q; n’nin yarısı bit uzunluğa sahip olacak şekilde seçilir
|p| ≈ |q| ≈ |n|/2
19 /34 Chapter 7 of Understanding Cryptography by Christof Paar and Jan Pelzl
• CRT: Adım 3 - Ters Dönüşüm
• Ters dönüşüm fazla hesaplama gerektiren, iki modüler ters almayı
gerektirir
cp ≡ q-1 mod p and cq ≡ p-1 mod q
• Inverse transformation assembles yp
, yq to the final result y mod n in
the problem domain
y ≡ [ q * cp
] * yp + [ p * cq
] * yq mod n
• Tipik olarak Asal p ve q, iki üs alma, seyrek değiştirildiği için
• ters maliyet ihmal edilebilir
[ q * cp
] and [ p * cq
]
önceden hesaplanabilir ve saklanabilir
20 /34 Chapter 7 of Understanding Cryptography by Christof Paar and Jan Pelzl
• CRT Karmaşıklığı
• Dönüşüm ve ters dönüşüm adımları Maliyetleri görmezden
gelinebilir çünkü makul varsayımlar altında bunlar ihmal edilebilir
• Farz edelim ki n, t+1 bittir, p ve q‘nun ikisi de t/2 bit uzunluktadır.
• Karmaşıklığı CRT alanında iki üs alma ile belirlenir. Operandlar
sadece 2 t bit uzunluktadır. Üs alma için çarpma kare-ve-algoritması
kullanılır:
• # squarings (one exp.): #SQ = 0.5 t
• # aver. multiplications (one exp.): #MUL = 0.25t
• Total complexity: 2 * (#MUL + #SQ) = 1.5t
• Bu, düzenli üs alma ile aynı görünüyor, ancak Operandlar
düzenli üs oranla yarı bit uzunluğunu sahip olduğundan., Her
bir işlem (örneğin, çarpma ve kare alma) 4 kat daha hızlı!
• Bu nedenle CRT basit üs alma 4 kat daha hızlıdır
21 /34 Chapter 7 of Understanding Cryptography by Christof Paar and Jan Pelzl
• Ünite İçeriği
• RSA Şifreleme
• Uygulama Yönleri
• Büyük Asal Sayı Bulma
• Saldırılar ve Önlemler
• Büyük Asal Sayı Bulma
• RSA anahtarı üretmek için p ve q gibi iki büyük asal sayı seçilir
Şöyleki n = p * q yeterince büyüktür.
• P ve q değerinin boyutu tipik olarak arzu edilen n boyutunun
yarısı büyüklüğündedir
• Asal sayılar bulmak için, rasgele tamsayılar oluşturulur ve asallık
için teste edilir:
a
• Rasgele sayı üreteci (RNG) tahmin edilebilir olmamalıdır aksi
saldırgan n sayısının çarpanlarını tahmin edilebilir
22 /34 Chapter 7 of Understanding Cryptography by Christof Paar and Jan Pelzl
RNG Primality Test
p'
candidate
prime
„p‘ is prime“
OR
„p‘ is composite“
23 /34 Chapter 7 of Understanding Cryptography by Christof Paar and Jan Pelzl
• Asallık Testleri
• Asallığı test etmek için p ve q’nun çarpanlara ayrılması genellikle
mümkün değildir
• Ancak, burada çarpanlara ayırma ile ilgilenilmiyor, sadece p ve
q’nun bileşik olup olmadığını bilinmek istenir
• Tipik asallık testler olasılık vardır yani, onlar% 100 doğru değildir
ancak çok yüksek olasılıkla doğru olduğu kabul edillir,
• Bir olasılık testi iki çıkışa sahiptir:
•
„p‘ birleşimdir“ – her zaman doğru
•
„p‘ asaldır“ –sadece belirli bir olasılık gerçektir
• Iyi bilinen asallık testlerinden birkaçı aşağıdaki gibidir
• Fermat Asallık-Testi
• Miller-Rabin Asallık-Testi
• Fermat Asallık-Testi
• Temel fikir Fermat Küçük Teoremi tüm asal için geçerlidir, yani eğer ap‘-1
≡ 1 mod p‘ olacak şekilde bir p sayısı bulunursa bu sayı asal değildir.
Algorithm: Fermat Primality-Test
Input: Prime candidate p‘, security parameter s
Output: „p‘ is composite“ or „p‘ is likely a prime“
1. FOR i = 1 TO s
2. choose random a ε {2,3, ..., p‘-2}
3. IF ap‘-1 ≡ 1 mod p’ THEN
4. RETURN „p‘ is composite“
5. RETURN „p‘ is likely a prime“
• Belirli sayılar için („Carchimchael numbers“), Bu numaralar birleşik
olmasına rağmen bu test genellikle "p 'muhtemel bir asal« gibi döndürür
•
• Bu nedenle, Miller-Rabin test tercih edilir
24 /34 Chapter 7 of Understanding Cryptography by Christof Paar and Jan Pelzl
• Miller-Rabin testi Teoremi
• Daha güçlü Miller-Rabin Testi aşağıdaki teoremi
dayanmaktadır
Theorem
Given the decomposition of an odd prime candidate p‘
p‘ – 1 = 2u *
r
where r is odd. If we can find an integer a such that
For all j = {0,1, ..., u-1}, then p‘ is composite.
Otherwise it is probably a prime.
• Bu teorem bir algoritma haline getirilebilir
ar ≡ 1 mod p‘ and ar2j
≡ p‘ - 1 mod p‘
25 /34 Chapter 7 of Understanding Cryptography by Christof Paar and Jan Pelzl
• Miller-Rabin Asallık-Testi
Algorithm: Miller-Rabin Primality-Test
Input: Prime candidate p‘ with p‘-1 = 2u * r security parameter s
Output: „p‘ is composite“ or „p‘ is likely a prime“
1. FOR i = 1 TO s
2. choose random a ε {2,3, ..., p‘-2}
3. z ≡ ar mod p’
4. IF z ≠ 1 AND z ≠ p’-1 THEN
5. FOR j = 1 TO u-1
6. z ≡ z
2 mod p’
7. IF z = 1 THEN
8. RETURN „p‘ is composite“
9. IF z ≠ p‘-1 THEN
10. RETURN „p‘ is composite“
11. RETURN „p‘ is likely a prime“
26 /34 Chapter 7 of Understanding Cryptography by Christof Paar and Jan Pelzl
27 /34 Chapter 7 of Understanding Cryptography by Christof Paar and Jan Pelzl
• Ünite İçeriği
• RSA Şifreleme
• Uygulama Yönleri
• Büyük Asal Sayı Bulma
• Saldırılar ve Önlemler
28 /34 Chapter 7 of Understanding Cryptography by Christof Paar and Jan Pelzl
• Saldırılar ve Önlemler 1/3
• Kriptosistemler üzerine saldırıların iki farklı türü vardır
• Analitik saldırılar RSA’nın altında yatan problemin matematiksel
yapısını kırmaya çalışırlar.
• uygulama saldırıları, yazılım veya donanım gerçekleştirilen RSA
yapısındaki zayıflıkları bulmaya ve bunları kullanmaya çalışan
saldırılar yapılmaya çalışır.
29 /34 Chapter 7 of Understanding Cryptography by Christof Paar and Jan Pelzl
• Saldırılar ve Önlemler 2/3
RSA genellikle bu analitik saldırı vektörleri maruz kalmaktadır
• matematiksel saldırılar
• En iyi bilinen saldırı Φ(n)’i elde etmek için n çarpanlarına ayrılmasıdır
• Yeterince büyük bir modül n kullanılarak önlenebilir
• Geçerli faktoring kaydı 664 bittir. Böylece, n 1024 ile 3072 bit
arasında bir bit uzunluğu olması tavsiye edilir
• protokol saldırılar
• RSA dayanıklılığını yararlanmak, yani Özel anahtarı bilmeden
bir şifreli metni çözmek için yapılan saldırılar ilgili şifreli metni başka bir
şifreli dönüştürür
• Uygun dolgu ile önlenebilir
30 /34 Chapter 7 of Understanding Cryptography by Christof Paar and Jan Pelzl
• Saldırılar ve Önlemler 3/3
• Uygulama saldırıları aşağıdakilerden biri olabilir
• Yan kanal analizi
• Fiziksel RSA uygulama sızıntı (örneğin, güç tüketimi,
EM fışkırma, vb) yararlanmak
• Arıza enjeksiyon (Fault-injection) saldırıları
• CRT çalışırken bu cihazda arızaları neden olan özel
anahtarında tam bir sızıntıya yol açabilir
Saldırılar hakkında daha fazla bilgi Bölüm 7.8 de bulunabilir (Understanding Cryptography)
Understanding Cryptography
by Christof Paar and Jan Pelzl
www.crypto-textbook.com
Çeviren: Selman YAKUT
Chapter 8 – Ayrık Logaritma Problemine
dayalı Açık-Anahtar Kriptosistemler
2/19 Chapter 8 of Understanding Cryptography by Christof Paar and Jan Pelzl
• Ünite İçeriği
• Diffie-Hellman Anahtar Değişimi
• Ayrık Logaritma Problemi
• Diffie-Hellman Anahtar Değişiminin Güvenliyi
• Elgamal Şifreleme Yapısı
3/19 Chapter 8 of Understanding Cryptography by Christof Paar and Jan Pelzl
• Whitfield Diffie ve Martin Hellman tarafından 1976 yılında önerildi
• Yaygın olarak kullanılır, örneğin Secure Shell (SSH) in, Transport Layer
Security (TLS) ve Internet Protokolü Güvenliği (IPSec)
• Diffie-Hellman Anahtar Değişimi (The Diffie–Hellman Key Exchange (DHKE)) bir
anahtar değişim protokolü olup şifreleme için kullanılmaz.
(DHKE göre şifreleme amacıyla, ElGamal kullanılabilir.)
• Diffie-Hellman Anahtar Değişimi: Genel Bakış
4/19 Chapter 8 of Understanding Cryptography by Christof Paar and Jan Pelzl
• • Diffie-Hellman Anahtar Değişimi: ayarlama
1. Büyük bir asal p seçin.
2. Tamsayı seçin α ∈ {2,3,. . . , P-2}.
3. P ve α yayınlayın.
Alice
Choose random private key
kprA=a ∈{1,2,…,p-1}
5/19 Chapter 8 of Understanding Cryptography by Christof Paar and Jan Pelzl
• Diffie-Hellman Anahtar Değişimi
Bob
Choose random private key
kprB=b ∈ {1,2,…,p-1}
Compute corresponding public key
kpubA= A = αa mod p
Compute correspondig public key
kpubB= B = αb mod p
Compute common secret
kAB = Ba = (αa)
b mod p
Compute common secret
kAB = Ab = (αb)
a mod p
A
B
y
y = AES (x) kAB x = AES-1 (y) kAB
We can now use the joint key kAB
for encryption, e.g., with AES
• Diffie-Hellman Anahtar Değişimi: Örnek
Alice
Choose random private key
kprA= a = 5
6/19 Chapter 8 of Understanding Cryptography by Christof Paar and Jan Pelzl
Bob
Choose random private key
kprB=b = 12
Compute corresponding public key
kpubA= A = 25 = 3 mod 29
Compute correspondig public key
kpubB= B = 212 = 7 mod 29
Compute common secret
kAB = Ba = 75 = 16 mod 29
Compute common secret
kAB = Ab = 312 = 16 mod 29
A
B
Domain parameters p=29, α=2
Proof of correctness:
Alice computes: Ba = (αb)
a
Bob computes: Ab = (αa)
b
mod p
mod p
i.e., Alice and Bob compute the same key kAB !
7/19 Chapter 8 of Understanding Cryptography by Christof Paar and Jan Pelzl
Ayrık Logaritma Problemi (Discrete Logarithm Problem (DLP)) in Zp
*
• Given is the finite cyclic group Zp
* of order p−1 and a primitive element α ∈ Zp
*
and another element β ∈ Zp
*.
• The DLP is the problem of determining the integer 1 ≤ x ≤ p−1 such that
αx ≡ β mod p
• This computation is called the discrete logarithm problem (DLP)
x = logα β mod p
• Example: Compute x for 5x ≡ 41 mod 47
Remark: For the coverage of groups and cylcic groups, we refer to Chapter 8 of
Understanding Cryptography
• Ayrık Logaritma Problemi
• Given is a finite cyclic group G with the group operation ◦ and cardinality n.
• We consider a primitive element α ∈ G and another element β ∈ G.
• The discrete logarithm problem is finding the integer x, where 1 ≤ x ≤ n, such
that:
β = α ◦ α ◦ α ◦. . .◦ α = αx
• The Generalized Discrete Logarithm Problem
x times
8/19 Chapter 8 of Understanding Cryptography by Christof Paar and Jan Pelzl
9/19 Chapter 8 of Understanding Cryptography by Christof Paar and Jan Pelzl
The following discrete logarithm problems have been proposed for use in
cryptography
1. The multiplicative group of the prime field Zp or a subgroup of it. For instance,
the classical DHKE uses this group (cf. previous slides), but also Elgamal
encryption or the Digital Signature Algorithm (DSA).
2. The cyclic group formed by an elliptic curve (see Chapter 9)
3. The multiplicative group of a Galois field GF(2m) or a subgroup of it. Schemes
such as the DHKE can be realized with them.
4. Hyperelliptic curves or algebraic varieties, which can be viewed as
generalization of elliptic curves.
Remark: The groups 1. and 2. are most often used in practice.
• The Generalized Discrete Logarithm Problem
10/19 Chapter 8 of Understanding Cryptography by Christof Paar and Jan Pelzl
• Security of many asymmetric primitives is based on the difficulty of computing
the DLP in cyclic groups, i.e.,
Compute x for a given α and β such that β = α ◦ α ◦ α ◦. . .◦ α = αx
• The following algorithms for computing discrete logarithms exist
• Generic algorithms: Work in any cyclic group
 Brute-Force Search
 Shanks‘ Baby-Step-Giant-Step Method
 Pollard‘s Rho Method
 Pohlig-Hellman Method
• Non-generic Algorithms: Work only in specific groups, in particular in Zp
 The Index Calculus Method
• Remark: Elliptic curves can only be attacked with generic algorithms which are
weaker than non-generic algorithms. Hence, elliptic curves are secure with
shorter key lengths than the DLP in prime fields Zp
• Attacks against the Discrete Logarithm Problem
11/19 Chapter 8 of Understanding Cryptography by Christof Paar and Jan Pelzl
Summary of records for computing discrete logarithms in Zp
*
• Attacks against the Discrete Logarithm Problem
In order to prevent attacks that compute the DLP, it is recommended to use primes
with a length of at least 1024 bits for schemes such as Diffie-Hellman in Zp
*
Decimal digits Bit length Date
58 193 1991
68 216 1996
85 282 1998
100 332 1999
120 399 2001
135 448 2006
160 532 2007
12/19 Chapter 8 of Understanding Cryptography by Christof Paar and Jan Pelzl
• Which information does Oscar have?
• α, p
• kpubA = A = αa mod p
• kpubB = B = αb mod p
• Which information does Oscar want to have?
• kAB = αba = αab = mod p
• This is kown as Diffie-Hellman Problem (DHP)
• The only known way to solve the DHP is to solve the DLP, i.e.
1.Compute a = logα A mod p
2.Compute kAB = Ba = αba = mod p
It is conjectured that the DHP and the DLP are equivalent, i.e., solving the
DHP implies solving the DLP.
• To prevent attacks, i.e., to prevent that the DLP can be solved, choose
p > 21024
• Security of the classical Diffie–Hellman Key Exchange
13/19 Chapter 8 of Understanding Cryptography by Christof Paar and Jan Pelzl
• Proposed by Taher Elgamal in 1985
• Can be viewed as an extension of the DHKE protocol
• Based on the intractability of the discrete logarithm problem and the Diffie–
Hellman problem
• The Elgamal Encryption Scheme: Overview
• The Elgamal Encryption Scheme: Principle
Alice Bob
choose d = kprB ∈ {2,…,p-2}
compute β = kpubB= αd mod p
choose i = kprA ∈ {2,…,p-2}
compute ephemeral key
kE = kpubA= αi mod p
compute kM = kE mod p
d
compute kM = βi mod p
encrypt message x ∈ Zp
*:
y = x·kM mod p
kE
y
β
14/19 Chapter 8 of Understanding Cryptography by Christof Paar and Jan Pelzl
decrypt x = y·kM mod p
-1
This looks very similar to the DHKE! The actual Elgamal protocol re-orders
the computations which helps to save one communication (cf. next slide)
• The Elgamal Encryption Protocol
Alice Bob
choose large prime p
choose primitive element α ∈ Zp
*
or in a subgroup of Zp
*
choose d = kprB ∈ {2,…,p-2}
compute β = kpubB= αd mod p
choose i = kprA ∈ {2,…,p-2}
compute kE = kpubA= αi mod p
compute masking key kM = βi mod p
encrypt message x ∈ Zp
*:
y = x·kM mod p
compute masking key kM = kE mod p
d
(kE, y)
k = (p, α, β)
15/19 Chapter 8 of Understanding Cryptography by Christof Paar and Jan Pelzl
pubB
decrypt x = y·kM mod p
-1
16/19 Chapter 8 of Understanding Cryptography by Christof Paar and Jan Pelzl
• Anahtar üretimi
• asal p Üretimi
• p en az 1024 bit büyüklüğündedir
• cf. Section 7.6 in Understanding Cryptography for prime-finding algorithms
• Şifreleme
• Iki modüler üs alma ve modüler çarpma gerektirir
• Tüm Operandlar log2p bit uzunluğundadır.
• Etkili çalıştırma çarpma square-and-multiply algoritması (bkz. Bölüm 7) gibi
yöntemleri gerektirir
• Deşifreleme
• Bir modüler üs ve bir modulare ters çevirme gerektirir
• Understanding Cryptography gösterildiği gibi, ters çevirme geçici anahtarından
hesaplanabilir
• Hesaplamalı Yönleri
17/19 Chapter 8 of Understanding Cryptography by Christof Paar and Jan Pelzl
• Passive attacks
• Attacker eavesdrops p, α, β = αd , kE = αi
, y = x· βi and wants to recover x
• Problem relies on the DLP
• Active attacks
• If the public keys are not authentic, an attacker could send an incorrect
public key (cf. Chapter 13)
• An Attack is also possible if the secret exponent i is being used more than
once (cf. Understanding Cryptography for more details on the attack)
• Security
Understanding Cryptography
by Christof Paar and Jan Pelzl
www.crypto-textbook.com
Çeviren: Selman YAKUT
Chapter 9 – Eliptik Eğri Şifreleme
• Ünite İçeriği
• Giriş
• Eliptik Eğriler üzerinde Hesaplamalar
• Eliptik Eğri Diffie-Hellman Protokolü
• Güvenlik Yönleri
• Yazılım ve Donanımda Uygulama
2 Chapter 9 of Understanding Cryptography by Christof Paar and Jan Pelzl /24
• Ünite İçeriği
• Giriş
• Eliptik Eğriler üzerinde Hesaplamalar
• Eliptik Eğri Diffie-Hellman Protokolü
• Güvenlik Yönleri
• Yazılım ve Donanımda Uygulama
3 Chapter 9 of Understanding Cryptography by Christof Paar and Jan Pelzl /24
• Problem:
RSA ve ElGamal gibi asimetrik yapılar 1000'den fazla bitlik parametreler ile tamsayı
halkalar ve alanlarında üs alma işlemini gerektirir.
• 32-bit veya 64-bit aritmetik işlemcilerden yüksek hesaplama çabası.
• Büyük parametre küçük ve gömülü depolama için kritik boyutadır.
• Motivasyon:
Eşdeğer güvenliği sağlayan küçük alan boyutları arzu edilir
• Çözüm :
Eliptik Eğri Kriptografi, 160-256 bitlik katsayı boyutları ile şifreleme programları için
noktaları grubunu (tamsayılar yerine) kullanır böylece önemli ölçüde hesaplama yükü
azaltılır.
4 Chapter 9 of Understanding Cryptography by Christof Paar and Jan Pelzl /24
• motivasyon
• Ünite İçeriği
• Giriş
• Eliptik Eğriler üzerinde Hesaplamalar
• Eliptik Eğri Diffie-Hellman Protokolü
• Güvenlik Yönleri
• Yazılım ve Donanımda Uygulama
5 Chapter 9 of Understanding Cryptography by Christof Paar and Jan Pelzl /24
• Eliptik Eğriler Üzerinde Hesaplamalar
• Eliptik eğriler (basitleştirilmiş) Weierstrass
denkleme dayalı noktaları tanımlamak
polinomlardır:
y2 = x3 + ax + b
a ve b parametre için, bu eğrinin şeklini tam olarak
belirtmek
• gerçek numaraları ve parametreleri ile a, b
R, bu -7 gibi bir eliptik eğri görünüyor
• Eliptik eğriler sadece reel sayılar R üzerinde
tanımlanamaz ama sonlu alanların diğer birçok
türleri üzerinde tanımlanabilir.
6 Chapter 9 of Understanding Cryptography by Christof Paar and Jan Pelzl /24
Example: y2 = x3 −3x+3 over R
• Computations on Elliptic Curves (ctd.)

• Kriptografide, biz eliptik eğrileri bir asal p modül
ilgileniriz:
Tanım: asal cisimler üzerinde eliptik eğriler
Zp üzerinde eliptik eğri, p> 3 bütün (x, y) çift
kümeleri dizi Zp yerine getirilir
y2 = x3 + ax + b mod p
bir sanal sonsuzluk θ noktası ile,a, b  Zp
ve durum
4a3+27b2 ≠ 0 mod p.
• Zp = {0,1, ..., s -1} modül p aritmetik
tamsayıların bir dizi olduğunu unutmayın
7 Chapter 9 of Understanding Cryptography by Christof Paar and Jan Pelzl /24
• Computations on Elliptic Curves (ctd.)
• Eliptik Eğri x ekseni boyunca simetriktir
• Eliptik eğrinin her kuadratik kalan x için y ve -y
kadar iki çözüm vardır.
• Her bir nokta P = (x, y) için, ters ya da negatif
noktasıdır olarak-P = (x,-y) tanımlanmıştır

θ
• Bazı özel durumlar noktaları grubunu eliptik eğrilere
dönüştürmek için gereklidir.
• Her grupta, özel bir eleman kimlik çalışması
için izin vermek için gereklidir, örneğin,
Verilen PE: P + θ = P = θ + P
• Bu kimlik noktası (eğrinin üzerinde değil) ek
olarak grup tanımına eklenir.
• Bu (sonsuz) kimlik nokta θ ile gösterilir

P
-P
point at
infinity
8 Chapter 9 of Understanding Cryptography by Christof Paar and Jan Pelzl /24
• Eliptik Eğriler üzerinde hesaplamalar
• Nokta toplama işlemi P + Q = R dayalı eliptik eğriler
üzerindeki noktaların bir grup oluşturuluyor, yani,
(xP,yP)+(xQ,yQ) = (xR,yR)
• Nokta toplama işlemi geometrik yorumu
• P ve Q ile düz bir çizgi çizin; P = Q yerine teğet
kullanırsanız
• X-ekseni boyunca eliptik eğrisi ile çizilen hattın
mirror üçüncü kesişme noktası
• Eliptik Eğri Nokta Toplama ve Katlama Formülleri
Point Addition
Point Doubling
x3 = s2 −x1−x2 mod p and y3 = s(x1 −x3
)−y1 mod p
where
s =
y2  y1
mod p
x2  x1
2
9 Chapter 9 of Understanding Cryptography by Christof Paar and Jan Pelzl /24
3x1  a
mod p
2y1
; if P ≠ Q (point addition)
; if P = Q (point doubling)
=P+P
• Eliptik Eğriler üzerinde hesaplamalar
• Example: Given E: y
2 = x
3+2x+2 mod 17 and point P=(5,1)
Goal: Compute 2P = P+P = (5,1)+(5,1)= (x3
,y3
)
Finally 2P = (5,1) + (5,1) = (6,3)
s = 3x1  a = (2 · 1)
−1(3 · 52 + 2) = 2−1
· 9 ≡ 9 · 9 ≡ 13 mod 17
x3 = s
2 − x1 − x2 = 132 − 5 − 5 = 159 ≡ 6 mod 17
y3 = s(x1−x3
) − y1 = 13(5 − 6) − 1= −14 ≡ 3 mod 17
2y1
2
10 Chapter 9 of Understanding Cryptography by Christof Paar and Jan Pelzl /24
• Eliptik Eğriler üzerinde hesaplamalar
• Bir eliptik eğri noktaları ve sonsuzluk θ noktasında döngüsel alt gruplar oluşturur
2P = (5,1)+(5,1) = (6,3)
3P = 2P+P = (10,6)
4P = (3,1)
5P = (9,16)
6P = (16,13)
7P = (0,6)
8P = (13,7)
9P = (7,6)
10P = (7,11)
11P = (13,10)
12P = (0,11)
13P = (16,4)
14P = (9,1)
15P = (3,16)
16P = (10,11)
17P = (6,14)
18P = (5,16)
19P = θ
θ
Bu eliptik eğri # E = | E | = 19 düzene sahiptir. Çünkü
onun döngüsel grubunda 19 puanla içeren 19 beri.
11 Chapter 9 of Understanding Cryptography by Christof Paar and Jan Pelzl /24
P
• Bir Eliptik eğri üzerinde nokta sayısı
• Kaç sayı rasgele bir eliptik eğri üzerinde olabilir?
• Önceki örneği düşünün: E: y2 = x3 +2 x +2 mod 17 19 noktası vardır
• Ancak, genel olarak eliptik eğriler üzerindeki nokta sayısını belirleme zordur
• Ama Hasse teoremi sınırlı bir aralıktaki noktaları sayısını sınırlamaktadır
Tanım: Hasse Teoremi:
Bir eliptik eğri modülü p göz önüne alındığında, eğri
üzerinde nokta sayısı # E ile belirtilir ve şu şekilde
sınırlandırılır:
p+1-2 p≤ #E ≤ p+1+2
• Yorumlama : noktaların sayısı asal p sayısına "yakın" olanlardır
• Örnek : Yaklaşık 2160 nokta ile bir eğri oluşturmak için, yaklaşık 160 bit
uzunluğunda bir asal gereklidir
p
12 Chapter 9 of Understanding Cryptography by Christof Paar and Jan Pelzl /24
• Eliptik Eğri Ayrık Logaritma Problemi
• Kriptosistemler Eliptik Eğri Ayrık Logaritma Problemi zorluğuna
güvenir
Tanım: Eliptik Eğri Ayrık Logaritma Problemi (ECDLP)
Verilen E Eliptik bir eğri üzerinde bir asal elemanı P ve başka bir eleman T. Bu
problem d tamsayısı için, 1 ≤ d ≤ # E aralığında bulunur.
P + P +…+ P = dP = T.
d times
• Kriptosistemler d sayısıın büyük ve gizli olmasına ve saldırganlar tarafından
kolayca hesaplayabilir olamaması fikrine dayanmaktadır
• d biliniyorsa, çarpma noktası dP hesaplamak için etkili bir yöntem, uygun
şifreleme sistemini oluşturmak için gereklidir
• Bilinen Square-and-Multiply Yöntem Eliptik Eğriler uyarlanabilir
• Eliptik eğriler üzerindeki etkili nokta çarpma için yöntem: ekle Çift ve-Algoritma
13 Chapter 9 of Understanding Cryptography by Christof Paar and Jan Pelzl /24
• Nokta Çarpma için Double-and-Add Algoritması
• Double-and-Add Algoritması
Giriş: Eliptik eğri E için, bir eliptik eğri P noktası ve bit di ile bir skaler d
Çıkış: T = d P
Başlatma :
T = P
Algorithm:
FOR i = t −1 DOWNTO 0
T = T +T mod n
IF di = 1
T = T +P mod n
RETURN (T)
Example: 26P = (110102
)P = (d4d3d2d1d0
)2 P.
Step
#0
#1a
#1b
#2a
#2b
#3a
#3b
#4a
#4b
P = 12P
P+P = 2P = 102P
2P+P = 3P = 102 P+12P = 112P
3P+3P= 6P = 2(112P) = 1102P
inital setting
DOUBLE (bit d3
)
ADD (bit d3=1)
DOUBLE (bit d2
)
noADD (d2 = 0)
DOUBLE (bit d1 6P+6P= 12P = 2(110 ) 2P) = 11002P
12P+P= 13P = 11002P+12 P = 11012P ADD (bit d1=1)
13P+13P= 26P= 2(11012P) = 110102P DOUBLE (bit d0
)
noADD (d0 = 0)
14 Chapter 9 of Understanding Cryptography by Christof Paar and Jan Pelzl /24
• Ünite İçeriği
• Giriş
• Eliptik Eğriler üzerinde Hesaplamalar
• Eliptik Eğri Diffie-Hellman Protokolü
• Güvenlik Yönleri
• Yazılım ve Donanımda Uygulama
15 Chapter 9 of Understanding Cryptography by Christof Paar and Jan Pelzl /24
• Eliptik Eğri Diffie-Hellman Anahtar Değişimi
• Verilen bir asal p, uygun bir eliptik eğri E ve P noktası = (xp, yp)
• Eliptik Eğri Diffie-Hellman Anahtar Değişimi aşağıdaki protokolle tanımlanır:
• Alice ve Bob arasındaki ortak sırrı: TAB = (xAB, yAB)
• Doğruluğu için kanıt:
• Alice hesaplar aB=a(bP)=abP
• Bob hesaplar bA=b(aP)=abP çünkü grup birleşmelidir
• Nokta koordinatlarından biri TAB (genellikle x-koordinatı) oturum anahtarı olarak kullanılabilir
(genellikle bir hash fonksiyonu uygulandıktan sonra)
Alice
Choose kPrA= a  {2, 3,…, #E-1}
Compute kPubA= A = aP = (xA,yA)
Compute aB = Tab
Bob
Choose kPrB= b  {2, 3,…, #E-1}
Compute kPubB= B = bP = (xB,yB)
16 Chapter 9 of Understanding Cryptography by Christof Paar and Jan Pelzl /24
Compute bA = Tab
A
B
• Eliptik Eğri Diffie-Hellman Anahtar Değişimi
• Bu protokol sıklıkla (simetrik) şifreleme için oturum anahtarlarını elde etmek için kullanılır
• Nokta TAB (genellikle x-koordinatı) ve koordinatlarının bir oturum anahtarı olarak alınır
• Bazı durumlarda, bir hash fonksiyonu (sonraki bölümlerine bakınız) oturum anahtarı türetmek için kullanılır
Alice
Choose kPrA= a  {2, 3,…, #E-1}
Compute kPubA= A = aP = (xA,yA)
Compute aB = Tab = (xT
,yT
)
Define key kAES = xT
Given a message m:
Encrypt c = AESkAES(m)
Define key kAES = xT
Received ciphertext c:
Decrypt m = AES-1
kAES(c)
Bob
Choose kPrB= b  {2, 3,…, #E-1}
Compute kPubB= B = bP = (xB,yB)
Compute bA = Tab= (xT
,yT
)
A
B
c
ECD
H
17 Chapter 9 of Understanding Cryptography by Christof Paar and Jan Pelzl /24
Simetrik şifreleme /
deşifreleme
• Ünite İçeriği
• Giriş
• Eliptik Eğriler üzerinde Hesaplamalar
• Eliptik Eğri Diffie-Hellman Protokolü
• Güvenlik Yönleri
• Yazılım ve Donanımda Uygulama
18 Chapter 9 of Understanding Cryptography by Christof Paar and Jan Pelzl /24
• Güvenlik Yönleri
• Neden parametreler RSA (1024-3076 bit) göre eliptik eğriler (160-256 bit) için daha
küçüktür?
• Eliptik eğriler grupları üzerinde yapılan saldırılar mevcut faktoring algoritmaları veya
tamsayı DL saldırılar daha zayıftır
• (Kriptografik kriterlere göre seçilen) eliptik eğriler üzerindeki en iyi bilinen saldırılar
Baby-Step Giant-Step ve Pollard-Rho yöntemleridir.
• Bu yöntemlerin karmaşıklığı: ortalama olarak, yaklaşık
başarılı bir şekilde çözülebilir
• Eliptik eğriler için pratik parametre boyutları Etkileri:
• 160 bit (kabaca 2160 nokta) ile bir asal p kullanarak bir eliptik eğri bir saldırgan
tarafından gerekli 280 seviyede bir güvenlik sağlar
• 256 bit ile bir asal p kullanarak bir eliptik eğri(kabaca 2256 nokta) 2128 seviyede bir
güvenlik sağlar
p adımla önce gerekli olan
19/24 Chapter 9 of Understanding Cryptography by Christof Paar and Jan Pelzl
• Ünite İçeriği
• Giriş
• Eliptik Eğriler üzerinde Hesaplamalar
• Eliptik Eğri Diffie-Hellman Protokolü
• Güvenlik Yönleri
• Yazılım ve Donanımda Uygulama
20/24 Chapter 9 of Understanding Cryptography by Christof Paar and Jan Pelzl
• Donanım ve Yazılım Uygulamaları
• Eliptik eğrisi hesaplamalar genellikle dört
katmandan oluşur:
• Temel modüler aritmetik işlemler
hesaplama en pahalıdır
• Grup çalışma noktası ikiye katlanması
ve nokta ekleme uygular
• Çarpma noktası eklenir ve Double-andAdd yöntemi kullanılarak
gerçekleştirilebilmektedir
• Eliptik Eğri Ayrık Logaritma
Problemi Eliptik Eğrisi gibi üst
katman protokolleri.
• En çok çalışmaları, modüler aritmetik işlemleri
optimizasyonlar gibi alanlara gitmektedir
• Modüler toplama ve çıkarma
• modüler çarpma
• modüler ters çevirme
P ro t o c
o l
(ECDSA
)
Po in t
Mu lt ip lica t io
n ( kP)
Gro u p
Op e ra t io n
P+ Q, 2 P
Mo d u la r
Arit h m e t ic ( +
, -,
x ,
÷ )
21/24 Chapter 9 of Understanding Cryptography by Christof Paar and Jan Pelzl
• Donanım ve Yazılım Uygulamaları
• Yazılım uygulamaları
• 3GHz 64-bit CPU üzerinde optimize
edilmiş 256-bit ECC uygulama noktası
çarpma başına yaklaşık 2 ms gerektirir
• daha az güçlü mikroişlemciler
(SmartKartların veya cep telefonları
örneğin) önemli ölçüde daha uzun sürer (>
10 ms)
• Donanım uygulamaları
• 256-bit özel asal ile yüksek performanslı
uygulamalar yeniden yapılandırılabilir
donanım üzerinde birkaç yüz mikrosaniye
bir çarpma nokta sıhesaplayabiliriz
• ECC için özel çipleri bile yirmi otuz
mikrosaniye bir nokta çarpma
hesaplayabiliriz
22/24 Chapter 9 of Understanding Cryptography by Christof Paar and Jan Pelzl
Understanding Cryptography – A Textbook for
Students and Practitioners
by Christof Paar and Jan Pelzl
www.crypto-textbook.com
Chapter 10 – Digital Signatures
ver. October 29, 2009
These slides were prepared by Georg Becker, Christof Paar and Jan Pelzl
Chapter 10 of Understanding Cryptography by Christof Paar and Jan Pelzl 2/26
Some legal stuff (sorry): Terms of Use
• The slides can used free of charge. All copyrights for the slides remain with
Christof Paar and Jan Pelzl.
• The title of the accompanying book “Understanding Cryptography” by
Springer and the author’s names must remain on each slide.
• If the slides are modified, appropriate credits to the book authors and the
book title must remain within the slides.
• It is not permitted to reproduce parts or all of the slides in printed form
whatsoever without written consent by the authors.
Chapter 10 of Understanding Cryptography by Christof Paar and Jan Pelzl 3/26
Content of this Chapter
• The principle of digital signatures
• Security services
• The RSA digital signature scheme
• The Digital Signature Algorithm (DSA)
Chapter 10 of Understanding Cryptography by Christof Paar and Jan Pelzl 4/26
Content of this Chapter
• The principle of digital signatures
• Security services
• The RSA digital signature scheme
• The Digital Signature Algorithm (DSA)
Chapter 10 of Understanding Cryptography by Christof Paar and Jan Pelzl 5/26
• Motivation
• Alice orders a pink car from the car salesmen
Bob
• After seeing the pink car, Alice states that she
has never ordered it:
• How can Bob prove towards a judge that Alice
has ordered a pink car? (And that he did not
fabricate the order himself)
⇒ Symmetric cryptography fails because both
Alice and Bob can be malicious
⇒ Can be achieved with public-key cryptography
• Basic Principle of Digital Signatures
Chapter 10 of Understanding Cryptography by Christof Paar and Jan Pelzl 6/26
Chapter 10 of Understanding Cryptography by Christof Paar and Jan Pelzl 7/26
• Main idea
• For a given message x, a digital signature is
appended to the message (just like a conventional
signature).
• Only the person with the private key should be
able to generate the signature.
• The signature must change for every document.
⇒The signature is realized as a function with the
message x and the private key as input.
⇒The public key and the message x are the inputs
to the verification function.
Chapter 10 of Understanding Cryptography by Christof Paar and Jan Pelzl 8/26
Content of this Chapter
• The principle of digital signatures
• Security services
• The RSA digital signature scheme
• The Digital Signature Algorithm (DSA)
• Core Security Services
The objectives of a security systems are called
security services.
1. Confidentiality: Information is kept secret from all but
authorized parties.
2. Integrity: Ensures that a message has not been modified in
transit.
3. Message Authentication: Ensures that the sender of a
message is authentic. An alternative term is data origin
authentication.
4. Non-repudiation: Ensures that the sender of a message can
not deny the creation of the message. (c.f. order of a pink car)
Chapter 10 of Understanding Cryptography by Christof Paar and Jan Pelzl 9/26
Chapter 10 of Understanding Cryptography by Christof Paar and Jan Pelzl 10/26
• Additional Security Services
5. Identification/entity authentication: Establishing and
verification of the identity of an entity, e.g. a person, a
computer, or a credit card.
6. Access control: Restricting access to the resources to
privileged entities.
7. Availability: The electronic system is reliably available.
8. Auditing: Provides evidences about security relevant
activities, e.g., by keeping logs about certain events.
9. Physical security: Providing protection against physical
tampering and/or responses to physical tampering attempts
10. Anonymity: Providing protection against discovery and misuse
of identity.
Chapter 10 of Understanding Cryptography by Christof Paar and Jan Pelzl 11/26
Content of this Chapter
• The principle of digital signatures
• Security services
• The RSA digital signature scheme
• The Digital Signature Algorithm (DSA)
• Main idea of the RSA signature scheme
To generate the private and public key:
• Use the same key generation as RSA encryption.
To generate the signature:
• “encrypt” the message x with the private key
s = sigKpriv
(x) = x
d mod n
• Append s to message x
To verify the signature:
• “decrypt” the signature with the public key
x’=verKpub(s)=s
e mod n
• If x=x’, the signature is valid
Chapter 10 of Understanding Cryptography by Christof Paar and Jan Pelzl 12/26
• The RSA Signature Protocol
Alice Bob
Kpr
= d
Kpub = (n, e)
Compute signature:
d s = sigkpr
(x) ≡ x mod n
Kpub
(x,s)
Verify signature:
x‘ ≡ s
e mod n
If x‘ ≡ x mod n → valid signature If
x‘ ≡ x mod n → invalid signature
Chapter 10 of Understanding Cryptography by Christof Paar and Jan Pelzl 13/26
Chapter 10 of Understanding Cryptography by Christof Paar and Jan Pelzl 14/26
• Security and Performance of the RSA Signature Scheme
Security:
The same constrains as RSA encryption: n needs to be at
least 1024 bits to provide a security level of 80 bit.
⇒ The signature, consisting of s, needs to be at least 1024 bits
long
Performance:
The signing process is an exponentiation with the private key
and the verification process an exponentiation with the public
key e.
⇒ Signature verification is very efficient as a small number can
be chosen for the public key.
• Existential Forgery Attack against RSA Digital Signature
Alice Bob
Kpr
= d
Kpub = (n, e)
1. Choose signature:
s Zn
2. Compute message:
x ≡ s
e mod n
(x,s)
Verification:
s
e ≡ x‘ mod n
since s
e = (x
d)
e ≡ x mod n
→ Signature is valid
(n,e)
Oscar
(n,e)
Chapter 10 of Understanding Cryptography by Christof Paar and Jan Pelzl 15/26
• Existential Forgery and Padding
• An attacker can generate valid message-signature
pairs (x,s)
• But an attack can only choose the signature s and
NOT the message x
⇒ Attacker cannot generate messages like „Transfer
$1000 into Oscar‘s account“
Formatting the message x according to a padding scheme can be used to
make sure that an attacker cannot generate valid (x,s) pairs.
(A messages x generated by an attacker during an Existential Forgery
Attack will not coincide with the padding scheme. For more details see
Chapter 10 in Understanding Cryptography.)
Chapter 10 of Understanding Cryptography by Christof Paar and Jan Pelzl 16/26
Chapter 10 of Understanding Cryptography by Christof Paar and Jan Pelzl 17/26
Content of this Chapter
• The principle of digital signatures
• Security services
• The RSA digital signature scheme
• The Digital Signature Algorithm (DSA)
Chapter 10 of Understanding Cryptography by Christof Paar and Jan Pelzl 18/26
• Facts about the Digital Signature Algorithm (DSA)
• Federal US Government standard for digital
signatures (DSS)
• Proposed by the National Institute of Standards
and Technology (NIST)
• DSA is based on the Elgamal signature scheme
• Signature is only 320 bits long
• Signature verification is slower compared to RSA
Chapter 10 of Understanding Cryptography by Christof Paar and Jan Pelzl 19/26
• The Digital Signature Algorithm (DSA)
Key generation of DSA:
1. Generate a prime p with 21023 < p < 21024
2. Find a prime divisor q of p-1 with 2159 < q < 2160
3. Find an integer α with ord(α)=q
4. Choose a random integer d with 0<d<q
5. Compute β ≡ αd mod p
The keys are:
kpub = (p,q,α,β)
kpr
= (d)
Chapter 10 of Understanding Cryptography by Christof Paar and Jan Pelzl 20/26
• The Digital Signature Algorithm (DSA)
DSA signature generation :
Given: message x, signature s, private key d and public
key (p,q,α,β)
1. Choose an integer as random ephemeral key kE
with 0<kE<q
2. Compute r ≡ (αkE mod p) mod q
3. Computes s ≡ (SHA(x)+d · r) kE mod q -1
The signature consists of (r,s)
SHA denotes the hashfunction SHA-1 which computes
a 160-bit fingerprint of message x. (See Chapter 11 of
Understanding Cryptography for more details)
• The Digital Signature Algorithm (DSA)
DSA signature verification
Given: message x, signature s and public key (p,q,α,β)
1. Compute auxiliary value w ≡ s
-1 mod q
2. Compute auxiliary value u1 ≡ w · SHA(x) mod q
3. Compute auxiliary value u2 ≡ w · r mod q
4. Compute v ≡ (αu1 · β u2 mod p) mod q
If v ≡ r mod q → signature is valid
If v ≡ r mod q → signature is invalid
Chapter 10 of Understanding Cryptography by Christof Paar and Jan Pelzl 21/26
Chapter 10 of Understanding Cryptography by Christof Paar and Jan Pelzl 22/26
Proof of DSA:
We show need to show that the signature (r,s) in fact satisfied the
condition r ≡ v mod q:
s ≡ (SHA(x))+d ·r) · kE
-1 mod q
  kE ≡ s
-1 SHA(x) + d · s
-1 r mod q
  kE ≡u1+d · u2 mod q
We can raise α to either side of the equation if we reduce modulo p:
  αkE mod p ≡ αu1+d·u2 mod p
Since β ≡ αd mod p we can write:
  αkE mod p ≡ αu1 βu2 mod p
We now reduce both sides of the equation modulo q:
  (αkE mod p) mod q ≡ (αu1 βu2 mod p) mod q
Since r ≡ αkE mod p mod q and v ≡ (αu1 βu2 mod p) mod q, this expression is
identical to:
  r ≡ v
• Example
Alice Bob
Key generation:
1. choose p = 59 and q = 29
2. choose α = 3
3. choose private key d = 7
4. β = αβ = 37 ≡ 4 mod 59
Sign:
Compute has of message H(x)=26
1. Choose ephermal key kE=10
2. r = (310 mod 59) ≡ 20 mod 29
3. s = (26 + 7 · 20) · 3) ≡ 5 mod 29
Chapter 10 of Understanding Cryptography by Christof Paar and Jan Pelzl 23/26
(p, q, α, β)=(59, 29, 3, 4)
(x,(r, s))=(x,20, 5)
Verify:
w ≡ 5-1 ≡ 6 mod 29
u1 ≡ 6 · 26 ≡ 11 mod 29
u2 ≡ 6 · 20 ≡ 4 mod 29
v = (311 · 44 mod 59) mod 29 = 20
v ≡ r mod 29 → valid signature
Chapter 10 of Understanding Cryptography by Christof Paar and Jan Pelzl 24/26
• Security of DSA
To solve the discrete logarithm problem in p the powerful index
calculus method can be applied. But this method cannot be
applied to the discrete logarithm problem of the subgroup q.
Therefore q can be smaller than p. For details see Chapter 10 and
Chapter 8 of Understanding Cryptography .
Standardized parameter bit lengths and security levels for the DSA
p q hash output
(min)
security levels
1024 160 160 80
2048 224 224 112
3072 256 256 128
Chapter 10 of Understanding Cryptography by Christof Paar and Jan Pelzl 25/26
• Elliptic Curve Digital Signature Algorithm (ECDSA)
• Based on Elliptic Curve Cryptography (ECC)
• Bit lengths in the range of 160-256 bits can be chosen
to provide security equivalent to 1024-3072 bit RSA
(80-128 bit symmetric security level)
• One signature consists of two points, hence the
signature is twice the used bit length (i.e., 320-512 bits
for 80-128 bit security level).
• The shorter bit length of ECDSA often result in shorter
processing time
For more details see Section 10.5 in Understanding
Cryptography
Chapter 10 of Understanding Cryptography by Christof Paar and Jan Pelzl 26/26
• Lessons Learned
• Digital signatures provide message integrity, message authentication and nonrepudiation.
• RSA is currently the most widely used digital signature algorithm.
• Competitors are the Digital Signature Standard (DSA) and the Elliptic Curve
Digital Signature Standard (ECDSA).
• RSA verification can be done with short public keys e. Hence, in practice, RSA
verification is usually faster than signing.
• DSA and ECDSA have shorter signatures than RSA
• In order to prevent certain attacks, RSA should be used with padding.
• The modulus of DSA and the RSA signature schemes should be at least 1024-
bits long. For true long-term security, a modulus of length 3072 bits should be
chosen. In contrast, ECDSA achieves the same security levels with bit lengths in
the range 160–256 bits.
Understanding Cryptography – Öğrenci ve
Uygulamacılar İçin Ders kitabı
www.crypto-textbook.com
Ünite 11 – Hash Fonksiyonları
Çeviren: Selman YAKUT
2/22
Ünite İçeriği
• Hash fonksiyonlarına neden ihtiyaç duyarız
• Bu fonksiyonlar nasıl çalışır
• Güvenlik özellikleri
• Algoritmalar
• Örnek:Secure Hash Algorithm SHA-1
3/22
Ünite İçeriği
• Hash fonksiyonlarına neden ihtiyaç duyarız
• Bu fonksiyonlar nasıl çalışır
• Güvenlik özellikleri
• Algoritmalar
• Örnek: Secure Hash Algorithm SHA-1
Motivasyon
Problem:
Uzun bir mesajı imzalamak mesaj kadar uzun bir imza gerektirir.
• Üç problem
• Hesaplama yükü
• Mesaj yükü
• Güvenlik kısıtlamaları
• Daha fazla bilgi için “Understanding Cryptography” kitabının 11
ünitesine bakabilirsiniz.
Çözüm:
Bütün mesaj yerine sadece özetini(=hash) imzalamak
Hem güvenli hemde çok daha hızlı
Gereken şey:
Hash fonksiyonları
4/22
Notes:
• Xi sabit uzunluktadır
• z, y sabit uzunluktadır
• z, x genellikle aynı uzunlukta değiller
• h(x) anahtar gerekmez.
• h(x) geneldir.
sig z)
kpr
x
xi
zi = h( xi
|| zi-1
)
z
5/22
y = sigkpr
(z)
• Hash Fonksiyonuyla Sayısal İmza
• Hash Fonksiyonuyla Sayısal İmza Gösterimi
Alice Bob
z = h(x)
(z)
s = sigKpr
(x, s)
z' = h(x)
verK (s,z')=true/false
pub
K
6/22
pub
• Hash fonksiyonlarının temel giriş çıkış karakteristiği
7/22
8/22
Ünite İçeriği
• Hash fonksiyonlarına neden ihtiyaç duyarız
• Bu fonksiyonlar nasıl çalışır
• Güvenlik özellikleri
• Algoritmalar
• Örnek: Secure Hash Algorithm SHA-1
• Hash fonksiyonlarının üç temel özelliği
9/22
10/22
• Hash Fonksiyonları: Güvenlik Özellikleri
• Preimage resistance: verilen bir z çıkışı için, h(x) = z gibi bir
girişi bulmak imkansız olmalı, i.e., h(x) tek yönlüdür.
• Second preimage resistance: verilen x1
, ve üretilen h(x1
) için
h(x1
) = h(x2
) olan ikinci bir x2 değerini hesaplamak hesapsal
olarak mümkün olmamalı.
• Collision resistance: x1 ≠ x2 gibi herhangi farklı iki çıkış için
h(x1
) = h(x2
) olan bir çift oluşturmak hesapsal olarak mümkün
olmamalı.
11/22
• Hash işlevselliği: Güvenlik
Collison resistance bir çok probleme sebep olmaktadır
• 0.5 olasılıkla bir çarpışma bulmak ne kadar zordur ?
• İlgili Problem: bir partide iki kişinin 0.5 olasılıkla aynı günde
doğma ihtimalinin olması için ne kadar insana ihtiyaç var ?
• Hayır ! 365/2=183kişi değil.
23 kişi yeterli !
Bu doğum günü çelişkisi olarak ifade edilr (Search takes ≈√2n steps) .
• Daha fazla bilgi için şu kaynağa bakabilirsiniz:
Chapter 11.2.3 in Understanding Cryptography.
• Bu paradoxla baş etmek için , hash fonksiyonları en az 160 bitlik çıkışa
ihtiyaç duyar.
12/22
Ünite İçeriği
• Hash fonksiyonlarına neden ihtiyaç duyarız
• Bu fonksiyonlar nasıl çalışır
• Güvenlik özellikleri
• Algoritmalar
• Örnek: Secure Hash Algorithm SHA-1
• Hash İşlevleri: Algorithms
• MD5 – Ailesi
• SHA-1: çıkış - 160 Bit; giriş - 512 bit olan x mesajının yığınları;
işlemler – bit düzeyinde AND, OR, XOR, tam ve dönmeli kayma.
• RIPE-MD 160: çıkış - 160 Bit; giriş - 512 bit x mesaj yığınları; işlemler
SHA-1 e benzer, fakat her roundan sonra parallel ve birleştirilmiş iki yapı
vardır.
Hash Algorithms
based on
block ciphers
SpecialAlgorithms,
e.g. MD5 - family
13/22
14/22
Ünite İçeriği
• Hash fonksiyonlarına neden ihtiyaç duyarız
• Bu fonksiyonlar nasıl çalışır
• Güvenlik özellikleri
• Algoritmalar
• Örnek: Secure Hash Algorithm SHA-1
15/22
• SHA-1
• MD-4 ailesinin bir parçasıdır.
• Merkle-Dåmgard yapısına dayanır.
• Giriş olarak maximum 264 bit alır ve 160-bitlik çıkış
verir.
• Geniş bir alanda kullanılır ( bazı zayıflıkları
olduğu bilinmesine rağmen)
• SHA-1 yüksek seviyeli Diagram
• Sıkıştırma Fonksiyonu her biri 20 rounddan oluşmuş dört
temel seviyeye bölünmüş olan 80 rounddan oluşur.
16/22
• SHA-1: Ekleme
• X mesajını 512 nin katına tamamlamak için değer eklenir.
• k ≡ 512 − 64 − 1 − l = 448 − (l + 1) mod 512.
17/22
18/22
• SHA-1: Hash Hesaplaması
• Her xi mesaj bloğu processed in four stages with 20 rounds each
SHA-1 uses:
• Mesaj tarifesi 80 roundun her biri için 32-bitlik kelimeler kullanır
W0,W1,...,W79
• 32 bit boyutunda beş çalışan kaydedici A,B,C,D,E
• Hi hash değeri32-bitlik beş kelimeden oluşur Hi
(0)
, Hi
(1)
, Hi
(2)
, Hi
(3)
, Hi
(4)
• Başlangıçta, hash değeri H0
, başlangıç değerlerini atar, daha sonra her mesaj
bloku işlendikten sonra eski hash değeri yeni hash değerleriyle yer değiştirir.
• Hn son mesajın çıkışındaki hash değeri SHA-1 nın hash değerlerine h(x) eşittir.
• SHA-1: dört seviyenin hepsi
19/22
• SHA-1: raundun iç yapısı
20/22
Stage t Round j Constant Kt Function ft
1 00…19 K=5A827999 f(B,C,D)=(B∧C)∨(¯ B∧D)
2 20…39 K=6ED9EBA1 f(B,C,D)=B⊕C⊕D
3 40…59 K=8F1BBCDC f(B,C,D)=(B⊕C)∨(B⊕D)∨(C⊕D)
4 60…79 K=CA62C1D6 f(B,C,D)=B⊕C⊕D
Understanding Cryptography
by Christof Paar and Jan Pelzl
www.crypto-textbook.com
Çeviren: Selman YAKUT
Ünite 12 – Message Authentication Codes (MAC) (Mesaj Doğrulama Kodu)
2 Chapter 12 of Understanding Cryptography by Christof Paar and Jan Pelzl
• MAC‘in temel prensipleri
• MAC‘le sağlanabilen güvenlik özellikleri
• MAC hash fonksiyonları ve blok şifrelerle nasıl gerçekleştirilir.
 Ünite İçeriği
• Sayısal imza gibi, MAC‘te de doğrlama etiketi mesajın sonuna eklenir.
• MAC üretim ve doğrulama için k simetrik anahtarını kullanır.
• MAC hesaplama: m = MACk
(x)
 Mesaj Doğrulama Kodları Prensibi
3 Chapter 12 of Understanding Cryptography by Christof Paar and Jan Pelzl
4 Chapter 12 of Understanding Cryptography by Christof Paar and Jan Pelzl
1. Kriptografik sağlama toplamı
MAC, verilen bir mesaj için, kriptografik olarak güvenli kimlik doğrulama etiketi üretir.
2. Simetrik
MAC gizli simetrik anahtarlara dayanmaktadır. İmzalama ve doğrulama taraflarının
bir gizli anahtarı paylaşması gerekir.
3. Rastgele mesaj boyutu
MAC istenile uzunlukta bir giriş mesajı alabilir.
4. Sabit çıkış uzunluğu
MAC sabit uzunlukta doğrulama etiketi üretir.
5. Mesaj bütünlüğü
MAC mesaj bütünlüğünü sağlar: iletim sırasında mesaj üzerinde herhangi bir değişim
alıcı tarafından fark edilir.
6. Mesaj doğrulama
Alıcı taraf mesajın doğruluğundan emindir.
7. inkar edememezlik
MACs simetrik ilkelerine dayalı olduğundan, onlar inkar edememezliği sağlamaz.
 Mesaj Doğrulama Kodları Özellikleri
5 Chapter 12 of Understanding Cryptography by Christof Paar and Jan Pelzl
• MAC, kriptografik hash functions (SHA-1 gibi) gerçekleştirilebilir
• HMAC, hash fonksiyonlarından oluşturulan bir MAC yapısıdır
• Temel düşünce: anahtar mesajla birlikte hashlenir
• İki olası yapı:
• secret prefix MAC: m =MACk
(x) = h(k||x)
• secret suffix MAC: m =MACk
(x) = h(x||k)
• Saldırılar:
• secret prefix MAC: x = (x1,x2, . . . ,xn,xn+1)şeklinde , xn+1 isteğe bağlı bir blok eklenebilir
ve gizli anahtar bilinmeden mesaj yeniden yapılandırılabilir
• secret suffix MAC: çakışma bulunur şöyle ki x için h(x) = h(xO), then m = h(x||k) =
h(xO||k) olacak şekilde X0 bulunabilir
• Fikir: secret prefix ve suffix birleşimi: HMAC ( sonraki slayt)
 Hash Fonksiyonlarıyla MAC
• Mihir Bellare, Ran Canetti ve Hugo Krawczyk tarafından 1996
önerilmiştir
• Yapı bir iç ve dış hashten oluşur
• k
+ genişletilmiş k anahtarıdır
• k
+ genişletilmiş k anahtarı iç ekleme değeri ile XORlanır
• ipad = 00110110,00110110, . . .,00110110
• opad = 01011100,01011100, . . .,01011100
• HMACk
(x) = h[(k
+⊕opad)||h[(k
+⊕ipad)||x]]
• HMAC‘in güvenliği: sadece hash fonksiyonu için bir çakışma olursa, HMAC
fonksiyonu kırılabilir.
 HMAC
6 Chapter 12 of Understanding Cryptography by Christof Paar and Jan Pelzl
• MAC blok şifrelerden (AES gibi) oluşturulabilir
• Popüler: AES'in CBC modda kullanımı
• CBC-MAC:
 Blok şifrelerle MAC
7 Chapter 12 of Understanding Cryptography by Christof Paar and Jan Pelzl
8 Chapter 12 of Understanding Cryptography by Christof Paar and Jan Pelzl
• MAC Üretimi
• x mesajı xi alt bloklarına ayrılır
• İlk iterasyon hesaplanır y1 = ek
(x1⊕IV)
• Sonraki bloklar için hesaplama yapılır yi = ek
(xi⊕yi−1)
• Son blok MAC değeridir: m =MACk
(x) = yn
• MAC Doğrulama
• MAC hesaplanması tekrarlanır (m‘)
• Sonuçlar kıyaslanır: eğer m’= m, ise doğrulama işlemi doğru olarak gerçekleşir
• Eğer m’ ≠ m değilse, mesaj ve/veya mesajın MAC değeri iletim sırasında
değişmiştir
 CBC-MAC
Understanding Cryptography
by Christof Paar and Jan Pelzl
www.crypto-textbook.com
Chapter 13 – Key Establishment
ver. Jan 7, 2010
These slides were prepared by Christof Paar and Jan Pelzl
2/27 Chapter 13 of Understanding Cryptography by Christof Paar and Jan Pelzl
• The slides can used free of charge. All copyrights for the slides remain with
Christof Paar and Jan Pelzl.
• The title of the accompanying book “Understanding Cryptography” by Springer
and the author’s names must remain on each slide.
• If the slides are modified, appropriate credits to the book authors and the book
title must remain within the slides.
• It is not permitted to reproduce parts or all of the slides in printed form
whatsoever without written consent by the authors.
Some legal stuff (sorry): Terms of Use
3/27 Chapter 13 of Understanding Cryptography by Christof Paar and Jan Pelzl
• Introduction
• The n2 Key Distribution Problem
• Symmetric Key Distribution
• Asymmetric Key Distribution
 Man-in-the-Middle Attack
 Certificates
 Public-Key Infrastructure
• Content of this Chapter
• Classification of Key Establishment Methods
4/27 Chapter 13 of Understanding Cryptography by Christof Paar and Jan Pelzl
In an ideal key agreement protocol, no single party can control
what the key value will be.
5/27 Chapter 13 of Understanding Cryptography by Christof Paar and Jan Pelzl
It is often desirable to frequently change the key in a cryptographic system.
Reasons for key freshness include:
 If a key is exposed (e.g., through hackers), there is limited damage if the key is
changed often
 Some cryptographic attacks become more difficult if only a limited amount of
ciphertext was generated under one key
 If an attacker wants to recover long pieces of ciphertext, he has to recover several
keys which makes attacks harder
• Key Freshness
• Key Derivation
6/27 Chapter 13 of Understanding Cryptography by Christof Paar and Jan Pelzl
• In order to achieve key freshness, we need to generate new keys frequently.
• Rather than performing a full key establishment every time (which is costly in
terms of computation and/or communication), we can derive multiple session
keys kses from a given key kAB.
• The key kAB is fed into a key derivation function together with a nonce r („number
used only once“).
• Every different value for r yields a different session key
• Key Derivation
• The key derivation function is a computationally
simple function, e.g., a block cipher or a hash
function
Alice Bob
generate nonce r
r
7/27 Chapter 13 of Understanding Cryptography by Christof Paar and Jan Pelzl
derive session key
Kses
= ekAB (r)
derive session key
Kses
= ekAB (r)
• Example for a basic protocol:
8/27 Chapter 13 of Understanding Cryptography by Christof Paar and Jan Pelzl
• Introduction
• The n2 Key Distribution Problem
• Symmetric Key Distribution
• Asymmetric Key Distribution
 Man-in-the-Middle Attack
 Certificates
 Public-Key Infrastructure
• Content of this Chapter
• The n2 Key Distribution Problem
• Simple situation: Network with n users. Every user wants to communicate
securely with every of the other n-1 users.
• Naïve approach: Every pair of users obtains an individual key pair
9/27 Chapter 13 of Understanding Cryptography by Christof Paar and Jan Pelzl
• The n2 Key Distribution Problem
Shortcomings
• There are n (n-1) ≈ n2 keys in the system
• There are n (n-1)/2 key pairs
• If a new user Esther joins the network, new
keys kXE have to be transported via secure
channels (!) to each of the existing usersa
⇒ Only works for small networks which are
relatively static
10/27 Chapter 13 of Understanding Cryptography by Christof Paar and Jan Pelzl
Example: mid-size company with 750 employees
• 750 x 749 = 561,750 keys must be distributed securely
11/27 Chapter 13 of Understanding Cryptography by Christof Paar and Jan Pelzl
• Introduction
• The n2 Key Distribution Problem
• Symmetric Key Distribution
• Asymmetric Key Distribution
 Man-in-the-Middle Attack
 Certificates
 Public-Key Infrastructure
• Content of this Chapter
• Key Establishment with Key Distribution Center
Alice
KEK: kA
Bob
KEK: kB
derive session key
Kses
= eKA (yA)
KDC
KEKs: kA , kB
RQST (IDA ,IDB) generate session key k
yA = eKA (kses
)
yB = eKB (kses
)
ses
yA yB
derive session key
Kses
= eKB (yB)
message y
y= eKses (x)
12/27 Chapter 13 of Understanding Cryptography by Christof Paar and Jan Pelzl
y
x= e-1 (y) Kses
• Key Distribution Center (KDC) = Central party, trusted by all users
• KDC shares a key encryption key (KEK) with each user
• Principle: KDC sends session keys to users which are encrypted with KEKs
13/27 Chapter 13 of Understanding Cryptography by Christof Paar and Jan Pelzl
• Key Establishment with Key Distribution Center
• Advantages over previous approach:
 Only n long-term key pairs are in the system
 If a new user is added, a secure key is only needed between the user
and the KDC (the other users are not affected)
 Scales well to moderately sized networks
• Kerberos (a popular authentication and key distribution protocol) is based on
KDCs
• More information on KDCs and Kerberos: Section 13.2 of Understanding
Cryptography
14/27 Chapter 13 of Understanding Cryptography by Christof Paar and Jan Pelzl
• Key Establishment with Key Distribution Center
Remaining problems:
• No Perfect Forward Secrecy: If the KEKs are compromised, an attacker
can decrypt past messages if he stored the corresponding ciphertext
• Single point of failure: The KDC stores all KEKs. If an attacker gets
access to this database, all past traffic can be decrypted.
• Communication bottleneck: The KDC is involved in every
communication in the entire network (can be countered by giving the
session keys a long life time)
• For more advanced attacks (e.g., key confirmation attack): Cf. Section
13.2 of Understanding Cryptography
15/27 Chapter 13 of Understanding Cryptography by Christof Paar and Jan Pelzl
• Introduction
• The n2 Key Distribution Problem
• Symmetric Key Distribution
• Asymmetric Key Distribution
 Man-in-the-Middle Attack
 Certificates
 Public-Key Infrastructure
• Content of this Chapter
Alice
• Recall: Diffie–Hellman Key Exchange (DHKE)
Bob
Choose random private key
kprA= a ∈ {1, 2,…, p-1}
16/27 Chapter 13 of Understanding Cryptography by Christof Paar and Jan Pelzl
Choose random private key
kprB = b ∈ {1, 2,…, p-1}
Compute public key
kpubA = A = αa mod p
Compute public key
kpubB = B = αb mod p
Compute common secret
kAB = Ba = (αa)
b mod p
Compute common secret
kAB = Ab = (αb)
a mod p
A
B
• Widely used in practice
• If the parameters are chosen carefully (especially a prime p > 21024),
the DHKE is secure against passive (i.e., listen-only) attacks
• However: If the attacker can actively intervene in the communciation,
the man-in-the-middle attack becomes possible
Public parameters α, p
Alice
kprA= a
kpubA = A = αa mod p
• Man-in-the-Middle Attack
Bob
kprB = b
kpubB = B = αb mod p
kAO = (B´)
a mod p
A
kAO = A mod p
kBO = Bo mod p
• Oscar computes a session key kAO with Alice, and kBO with Bob
• However, Alice and Bob think they are communicationg with each other !
• The attack efficiently performs 2 DH key-exchanges: Oscar-Alice and Oscar-Bob
• Here is why the attack works:
Oscar
A´
substitute A´ = αo mod p
B´ B
substitute B´ = αo mod p
kBO = (A´)
b mod p
17/27 Chapter 13 of Understanding Cryptography by Christof Paar and Jan Pelzl
o
Alice computes: kAO = (B´)
a = (αo)
a
Oscar computes: kAO = Ao = (αa)
o
Bob computes: kBO = (A´)
b = (αo)
b
Oscar computes: kBO = Bo = (αa)
o
Alice
kprA= a
kpubA = A = αa mod p
• Implications of the Man-in-the-Middle Attack
Bob
kAO = (B´)
a mod p
A
kBO = Bo mod p
• Oscar has no complete control over the channel, e.g., if Alice wants to send an
encrypted message x to Bob, Oscar can read the message:
kprB = b
kpubB = B = αb mod p
Oscar
A´
substitute A´ = αo mod p
B´ B
substitute B´ = αo mod p
kBO = (A´) kAO = A mod p b mod p
o
y = AESkA,O (x)
y
decrypt x = AES-1 (y) kA,O
re-encrypt y´= AESkB,O (x)
y´
x = AES-1
18/27 Chapter 13 of Understanding Cryptography by Christof Paar and Jan Pelzl
kB,O (y´)
• Very, very important facts about the Man-in-the-Middle Attack
• The man-in-the-middle-attack is not restricted to DHKE; it is
applicable to any public-key scheme, e.g. RSA encryption.
ECDSA digital signature, etc. etc.
• The attack works always by the same pattern: Oscar replaces the
public key from one of the parties by his own key.
• The attack is also known as MIM attack or Janus attack
• Q: What is the underlying problem that makes the MIM attack possible?
• A: The public keys are not authenticated: When Alice receives a public key which is
allegedly from Bob, she has no way of knowing whether it is in fact his. (After all, a key
consists of innocent bits; it does not smell like Bob‘s perfume or anything like that)
Even though public keys can be sent over unsecure channels, they
require authenticated channels.
19/27 Chapter 13 of Understanding Cryptography by Christof Paar and Jan Pelzl
20/27 Chapter 13 of Understanding Cryptography by Christof Paar and Jan Pelzl
• Introduction
• The n2 Key Distribution Problem
• Symmetric Key Distribution
• Asymmetric Key Distribution
 Man-in-the-Middle Attack
 Certificates
 Public-Key Infrastructure
• Content of this Chapter
21/27 Chapter 13 of Understanding Cryptography by Christof Paar and Jan Pelzl
• Certificates
• In order to authenticate public keys (and thus, prevent the MIM attack) , all public keys
are digitally signed by a central trusted authority.
• Such a construction is called certificate
certificate = public key + ID(user) + digital signature over public key and ID
• In its most basic form, a certificate for the key kpub of user Alice is:
Cert(Alice) = (kpub, ID(Alice), sigKCA(kpub,ID(Alice) )
• Certificates bind the identity of user to her public key
• The trusted authority that issues the certificate is referred to as certifying authority (CA)
• „Issuing certificates“ means in particular that the CA computes the signature sigKCA
(kpub)
using its (super secret!) private key kCA
• The party who receives a certificate, e.g., Bob, verifies Alice‘s public key using the public
key of the CA
Alice
kprA= a
kpubA = A
Cert(Alice) = ((A, IDA), sigKCA
(A,IDA))
Cert(Alice)
• Diffie–Hellman Key Exchange (DHKE) with Certificates
Bob
kprB = b
kpubB = B = αb mod p
Cert(Bob) = ((B, IDB), sigKCA
(B,IDB))
verify certificate
verKpub,CA (Cert(Bob))
if verification is correct:
Compute common secret
kAB = Ba = (αa)
b mod p
verify certificate
verKpub,CA (Cert(Alice))
if verification is correct:
Compute common secret
kAB = Ab = (αb)
a mod p
Cert(Bob)
CA
22/27 Chapter 13 of Understanding Cryptography by Christof Paar and Jan Pelzl
23/27 Chapter 13 of Understanding Cryptography by Christof Paar and Jan Pelzl
• Note that verfication requires the public key of the CA for verKpub,CA
• In principle, an attacker could run a MIM attack when kpub,CA is being distributed
• ⇒ The public CA keys must also be distributed via an authenticated channel!
• Q: So, have we gained anything?
• After all, we try to protect a public key (e.g., a DH key) by using yet another
public-key scheme (digital signature for the certificate)?
• A: YES! The difference from before (e.g., DHKE without certificates) is that
we only need to distribute the public CA key once, often at the set-upt
time of the system
• Example: Most web browsers are shipped with the public keys of many
CAs. The „authenticated channel“ is formed by the (hopefully) correct
distribution of the original browser software.
• Certificates
24/27 Chapter 13 of Understanding Cryptography by Christof Paar and Jan Pelzl
• Introduction
• The n2 Key Distribution Problem
• Symmetric Key Distribution
• Asymmetric Key Distribution
 Man-in-the-Middle Attack
 Certificates
 Public-Key Infrastructure
• Content of this Chapter
Definition: The entire system that is formed by CAs together with
the necessary support mechanisms is called a public-key
infrastructure (PKI).
25/27 Chapter 13 of Understanding Cryptography by Christof Paar and Jan Pelzl
• Public-Key Infrastructure
• In the wild certificates contain much more information than
just a public key and a signature.
• X509 is a popular signature standard. The main fields of
such a certificate are shown to the right.
• Note that the „Signature“ at the bottom is computed over all
other fields in the certifcate (after hashing of all those
fields).
• It is important to note that there are two public-key
schemes involved in every certificate:
1. The public-key that actually is protected by the signature
(„Subject‘s Public Key“ on the right). This was the public
Diffie-Hellman key in the earlier examples.
2. The digital signature algorithm used by the CA to sign the
certificate data.
• For more information on certificates, see Section 13.3 of
Understanding Cryptography
• Certificates in the Real World
26/27 Chapter 13 of Understanding Cryptography by Christof Paar and Jan Pelzl
27/27 Chapter 13 of Understanding Cryptography by Christof Paar and Jan Pelzl
There are many additional problems when certificates are to be used in systems
with a large number of participants. The more pressing ones are:
1.Users communicate which other whose certificates are issued by different CAs
 This requires cross-certification of CAs, e.g.. CA1 certifies the public-key of
CA2. If Alice trusts „her“ CA1, cross-certification ensures that she also
trusts CA2. This is called a „chain of trust“ and it is said that „trust is
delegated“.
2.Certificate Revocation Lists (CRLs)
 Another real-world problem is that certificates must be revoced, e.g., if a
smart card with certificate is lost or if a user leaves an organization. For
this, CRLs must be sent out periodically (e.g., daily) which is a burden on
the bandwidth of the system.
More information on PKIs and CAs can be found in Section 13.3 of
Understanding Cryptography
• Remaining Issues with PKIs
Bilgi Güvenliği Dersi
SON
Ağ Güvenliği Dersi
Giriş
1
AĞ GÜVENLİĞİ
GİRİŞ
2017-18- Güz Dönemi
“Eğer siz kendinizi ve düşmanınızı tanıyorsanız, yüzlerce savaştan galip
çıkarsınız…..
Eğer kendinizi biliyorsanız fakat düşmanınızı tanımıyorsanız , her
kazandığınız zafer için bir yenilgiye katlanırsınız….
Eğer siz kendinizi ve düşmanınızı tanımıyorsanız, devamlı olarak
kaybedeceksiniz…..”
Savaş Sanatı - Sun TZU
Ağ Güvenliği
• Bilgi güçtür, her zaman değerlidir. Sadece gerekli
kişiler tarafından elde edilebilmeli, kullanılmalıdır…
• Özel bilgi yetkisiz kişilerin eline geçmemelidir,
istenmeyen kişilerin eline geçmesi durumunda
kullanılabilir olmaması gerekir…
• Kısacası durağan haldeki (Örn. Hafızalanmış) veya
işlenme sürecindeki veya seyahat halindeki
(Örn.Ağ ortamında iletilen) bilginin güvenliği
önemlidir.
2
Görevler ve Tanımlamalar
Bilginin sayısal kodlanmış şekli Veri (Data)’dir. Bir sayısal cihazda
hafızalanmış olan veya işlenen veya bir ağda seyahat eden veriler için;
 Confidentiality (Gizlilik)
 İntegrity (Bütünlük)
 Non-repudiation (İnkar edememe)
 Availability (Faydalanılabilirlik-kullanılabilirlik)
özelliklerini garanti edilmiş, yani güvenliğinin sağlanmış olması gerekir.
Kısacası üzerinde çalışılan veya iletişim sürecindeki veya statik
haldeki veri (işlenebilir veya saklanabilir haldeki kaynak verisi- text, resim, hareketli resim, ses,
online veriler, e-mail mesajı v.b) sadece yetkili kişiler tarafından okunabilmeli ve
üzerinde işlem yapılabilmelidir.
3
SALDIRI(ATTACK) , TEHDİT(Thread),
SALDIRGAN (Hacker)?
 TEHDİT: Belirli durum veya olayın oluştuğu anlarda, güvenlik
fonksiyonunun yerine getirilmesini engellemeye hazır, potansiyel
bir güvenlik bozucusudur.
 SALDIRI: Sistemin güvenlik servislerini etkisiz hale getirmeyi
amaçlayan, akıllı bir tehditten oluşturulan ani bir hucum
(Attack)’tır.
 SALDIRGAN: Saldırgan , ağ üzerinde ki genelde bazı servisler
veren makinalara; hiçbir hakkı olmadan erişip zarar veren kişidir.
Bilgi hırsızı olarak ta tarif edilir.
4
Güvenlik
Fiziksel güvenlik
İletişim güvenliği
Sinyal güvenliği
Bilgi Güvenliği
Bilgisayar Güvenliği
Ağ Güvenliği
Ağ Güvenliği = Bilgisayar Güvenliği + Haberleşme Güvenliği
5
Fiziksel Güvenlik
 Bilgi güçtür, çünkü bilgi kaybı genellikle, kritik varlıkların kaybı
anlamına gelir.
 Taşa oyulmuş veya sonraki zamanlarda kağıda yazılmış bilgiler
önemlidir.
 Mısırlılar M.Ö 2.000 'de kilitleri kullanırdı.
 Taşınabilir olmayan bilgileri fiziksel olarak korumak için Gardiyanlar,
duvarlar, köpekler, güvenlik noktaları ve çitler kullanıldı.
 Bilgisayar sistem odalarına kartlı giriş veya giriş çıkış kontrolu da
fizksel korumanın bir parçası olarak görülebilir.
6
İletişim güvenliği
İletişim güvenliği için şifreleme keşfedildi.
-Skytale :Yunanlılar, M.Ö. 5-3. yüzyılda “Skytale” adlı Şifreleme aletini savaşta
kullandı. Kalın bir sopaya deri şerit sarılırdı. Mesaj şeritin üzerine sopa
boyunca yazılır ve şerit açık olarak yollanırdı. Karşı taraf, şeridi aynı kalınlıkta
bir sopaya sarıp mesajı okurdu .
Yunanlılar’ın Skytale adlı şifre aleti
- ATBASH : İbrani peygamber Yeremya, M.Ö. 600-500’lerde ATBASH şifresini
kullandı. şifrede, alfabenin ilk harfi son harfle, ikinci harf sondan ikinci harfle yer
değişir. Böylece alfabenin ilk yarısındaki harfler, ikinci yarıdaki uygun harfle yer
değiştirmiş olur. AĞAÇ kelimesinin Şifrelenmiş hali “ZRZÜ” dür.
7
8
ABD Başkanı Thomas Jefferson’un
1790’da geliştirdiği şifreleme diski
Almanlar’ın Şifresi Kırılamayan Makinesi: ENIGMA
Frekans analiziyle Şifre kırma tekniğini,
Müslüman matematikçi El Kindi (801-873)
buldu. Sezar şifresi ve benzerlerinin
çözümünü anlatan eser, Süleymaniye
Osmanlı Arşivi’ndedir.
William Frederick Friedman; tüm zamanların
en iyi kriptologu olarak tanınır. Japon
şifreleme düzenlerini kırmaya yardım etti.
Sinyal güvenliği
 Telsiz telefonlar için hiçbir güvenlik söz konusu
değildi. Bu konuşmayı izinsiz dinleme veya kesmek
çok kolaydır.
Spread Spectrum teknolojisi güvenlik ve güvenilirliği
artırır.
Doğrudan dizili Spread Spectrum (DSSS)
Frekans atlamalı yaygın spektrum (FHSS)
9
Bilgisayar Güvenliği
Bilgisayarların içerisindeki kaynakların,
dosyaların, verilerin çalınmaya değiştirilmeye,
izlenmeye, izinsiz kullanılmasına v.b karşı
korunması önemli bir sorundur.
Bilgisayarlardaki kaynakları, dosyaları ve
veriyi korumak ve saldırıları engellemek için
tasarlanmış sistem ve araçlar bu konuda
değerlendirilir.
10
Bilgisayar Güvenliği
 Orange Book
"
(DoD rainbow serisi) olarak bilinen,
Trusted Computing System (Güvenilir Bilgisayar
sistemi) Değerlendirme Kriterleri (TCSEC)
aşağıdaki cetvellere göre bilgisayar sistemlerinin
gizliliğini tanımlar
:
 A(A
1
)
: Verified Protection (Doğrulanmış
-
Onaylanmış Koruma)
: En yüksek güvenlik
bölümlemesi
.
 B(B
1
-
B
3
)
: Mandatory Security
(Zorunlu
Güvenlik
)
: Büyük ve güvenilir olması gereken
Bilgi işlem merkezlerinin
(
Trusted
Computing
base
–TCB
) zorunlu olarak güvenliğidir.
 C(C
1
-
C
2
)
: Discretionary Protection
(İsteğe Bağlı
koruma)
: TCB’lerde isteğe bağlı korumadır.

D
: Minimal Protection
(Minumum düzeyde
koruma
)
: A,B,C düzeylerinden herhangibirindeki
başarısılık için güvenlik kontroludur.
11
Ağ güvenliği
 Ağ güvenliği kavramı, verinin iletimi esnasındaki
korunması anlamındadır.
 Ancak Ağ güvenliği kavramı; resmi, özel, akademik,
kişisel ağların biribiyle iletimde bulunması için
oluşturulmuş ortak ağa bağlı tüm birimlerinde
korumasını da kapsamaktadır.
12
Bilgi güvenliği
 Sadece fiziksel güvenlik, haberleşme güvenliği, sinyal güvenliği,
bilgisayar güvenliği ve ağ güvenliği tüm güvenlik riskleri çözmek için
yeterli değildir.
 Bilgi güvenliği açısından incelendiğinde, sadece biz tam bir güvenlik
resmini oluşturmak için bunların hepsini kullanarak bilgi güvenliğini
sağlamalıyız.
 Ayrıca bilgi güvenliği;
Üst yönetim desteği,
İyi güvenlik politikaları,
Risk yönetimi,
Personel eğitimi,
Güvenlik açığı testleri,
Yama yönetimi,
İyi bir kod tasarımı, ve benzeri
gibi işlevleri de gerektirir.
13
Güvenlik Açığı TESTLERİ (Vulnerabilty testing)
Güvenlik açığı testi süreci, bir kuruluşun ağını, güvenlik politikalarını ve güvenlik
kontrollerini sistematik olarak incelemektedir. Amaç, güvenlik önlemlerinin
yeterliliğini belirlemek, güvenlik eksikliklerini tespit etmek, potansiyel güvenlik
önlemlerinin etkililiğini önceden tahmin etmek için veri sağlamak ve onaylamaktır.
 Security Audits (Güvenlik Denetimleri): Belirlenmiş güvenlik politikalarına
uyulup uyulmadığını test eder.
 Vulnerability Scanning (Güvenlik Açığı Taraması): Hostlarda veya aktif
cihazlarda güvenlik açıklarının aranmasıdır. Nessus v.b aryazılım araçlarıyla
 Ethical Hacks (Penetration Testing) : Etik Hackleme (Nufuz etme deneyi)
Kurum ağına her seviyede yapılabilecek atakları simüle eder ve dener
 Stolen Equipment Attack(Çalıntı Ekipman Saldırı):Fiziksel ve iletişim
güvenliği
 Physical Entry(Fiziksel Girdi):Kurumun fiziksel olarak kontrolu , kapılar
CCTV
 Signal Security Attack(Sinyal Güvenlik Saldırı): Özellikle Wireless erişim
için
 Social Engineering Attack(Sosyal Mühendislik Saldırı): Organizasyon
işleyişini öğrenmek için yapılan saldırıların öğrenilmesi için…
14
• Yukarıda açıklanan testler farklı metodlar ile
yapılabilir. En çok bilinenen metodoloji: Açık Kaynak
Güvenlik Testi Metodolojisi Kılavuzu (Open Source
Security Testing Methodology Manual -OSSTMM)
güvenliği altı temel kısma böler.
• Fiziksel Güvenlik
• Internet güvenliği
• Bilgi Güvenliği
• Kablosuz Güvenlik
• İletişim Güvenliği
• Sosyal Mühendislik
15
Ağ güvenliği nedir?
 Ağ güvenliğinin amacı, insanların kendi hak ve çıkarlarını zedeleme korkusu
olmadan bilgisayar ağlarından, serbestçe ve korkusuzca yararlanmasının
sağlanabilmesidir.
 Dolayısıyla Ağ güvenliği; ağa bağlı bilgisayar sistemlerini ve ağdaki
bilgisayarlarda saklanan veya ağ üzerinde iletilen elektronik verileri korumak
içindir. Not:İnternet(public network)’in kullandığı IPV.4 TCP/IP protokolu güvensiz bir protokol topluluğudur.
Niye?
 Internet üzerindeki (public network) veriler, routerdan router’a store-end
forward anahtarlamaya göre geçerek hedefe ulaşmaktadırlar. İnsanlar
tarafından yönetilen Routerlarda, bu veriler korumasız şekildedir. Örneğin bu
verileri Routerı konfigüre eden birisi kolaylıkla ele geçirebilir.
 Veya network trafiğini dinleme programlarından birisini kullanarak, iletişim
halindeki verilerin algılanması rahatlıkla yapılabilir. V.s……V.s…
 Dolayısıyla bir ağ üzerindeki bir kişi veya bir şirket, bir saldırgan
(Attacker), bir hedef veya her ikisi konumundada olabilir.
 Buna göre network güvenliğinde amac, ilk olarak atak saldırganları ve saldırı
tiplerin tanıyabilmek ve onlara hedef olmamak için gerekli işlemleri yapmak
olmalıdır.
16
• Bilgisayar Güvenliği, bilgisayar içerisindeki kaynakları,
veriyi korumak ve saldırganları (hacker) engellemek için
alınacak tedbirlerin tümünü içerir. Bunları sağlayan
sistemler Bilgisayar Güvenlik Sistemleri’dir.
• Ağ güvenliği hem ağdaki bilgisayarların hem de ağın
güvenliğinin (İletişim sürecindeki veri, ağ aktif cihazları)
sağlanmasını gerektir.
• Biz; ağ güvenliği anlamında, daha çok ağın güvenliğini
(İletim halindeki veriler ve aktif cihazların güvenliği) ön
plana çıkaracağız.
“Ağ Güvenliği Sistemleri “
Ağ Güvenliği = Bilgisayar Güvenlik sistemi + İletişim Güvenliği
17
Ağ ve genel Güvenlik
General Security
Network
Security
Cryptography
Forensics
Secure
Coding
Ağ Güvenliği
 Ağ güvenliği çözümlerini;
- Kriptografik
-Sistem tabanlı
çözümler olarak ikiye ayırmak mümkündür.
 Sistem tabanlı çözümler kriptografik işlemler
içermeyen, sistem bilgilerini kullanarak güvenliği
sağlamaya çalışan çözümlerdir.
 Bunlara örnek olarak yerel ağı dışarıdan gelecek
saldırılardan korumayı amaçlayan güvenlik
duvarları ve olası başarılı saldırıları anlamaya
yönelik sızma denetim sistemleri verilebilir.
19
Ağ Erişim Güvenlik Modeli (Sistem Tabanlı Çözüme Örnek)
Bilgi sistemlerine (ağlara, Bilgisayarlara, Server’lara v.b)
istenmeyen erişimin engellenmesi işlemidir.
Bu modeli için:
 Kullanıcıları tanıyan uygun bir ağ geçidi denetleyici seçmek (pasword
temelli erişim, erişim yetkisi ve seviyesi belirleme )
Dahili Güvenlik Kontrolü uygulaması (Sistemi devamlı izleyerek
anormal olayları sezmek ve tehditleri önceden belirleyebilmek- STS v.b)
20
Kriptografik Çözüm mimarisi
 Bu genel güvenlik mimarisi güvenlik servislerinin
tasarımında dört temel işi göstermektedir.
 Güvenlik ilişkili dönüşümler için bir algoritma
tasarımı
 Algoritma ile kullanılacak gizli bilginin üretimi
 Gizli bilginin dağıtımı ve paylaşımı için yöntem
geliştirme
 Güvenlik algoritmasını ve güvenlik servisini
sağlayacak gizli bilginin kullanımını sağlayacak
protokol belirleme
21
Bir Ağ Güvenliği Modeli (Kriptografik tabanlı Güvenlik)
Gönderici ve alıcı mesajları gizli olarak iletirken,
güvenli bir üçüncü şahıs gizli bilgilerin dağıtıcısı
olarak hizmet vermekte, her iki taraf arasında
noter görevi görmektedir.
22
Bir networkte, bir hedefe varma sürecindeki veriye , iletişim durumundaki
veri, data denir. Bir storage’da veya bir lokal bilgisayarda saklanan veriye
ise statik veri veya storage verisi denir.
Buna göre verinin, gizliliği ve bütünlüğünün anlamı;
1- İletişim halindeki verinin gizililiğinden kasıt, yetkisiz kişiler tarafından okunamamlıdır.
İletişim halindeki verinin bütünlüğünden kasıt iletişim sürecinde, yetkisiz kişiler
tarafından değiştirilememeli, üretilememelidir.
2- Statik haldeki datanın giziliğinden kasıt, bir lokal cihazda saklanan verinin yetkisiz kişiler
tarafından okunamamasıdır. Statik heldeki verinin bütünlüğünden kasıt ise, yetkisiz
kişiler tarafından değiştirilememesi, üretilememesidir.
 İletişim halindeki veya statik haldeki verilerin inkar-edememe özelliği ise, kendisine ait
olan veriyi kişinin benim değil diye inkar edememesidir.
 Verinin kullanılabilirliği ise, yasal kullanıcıların Ağa bağlı bir bilgisayarın mevcut
kaynaklar ve hizmetlerinden yararlanabilmesinin saldırganlar tarafından
engellenmesine mani olmaktır. Örneğin, virüs bulaşmış bir bilgisayar sistemi üzerinden
çok kısa zamanda virüsü tespit etmek ve dezenfekte etmektir. Veya DoS saldırısına
uğramış sunucunun, hala kullanıcılara hizmet sunabilmesi işlemidir.
23
 İletişim Protokol özelliklerinden dolayı, protokolun yürütülmesi
sürecinde, veya diğer yazılımların istenmeyen özelliklerinden
yararlanarak saldırganlar saldırılarını yapabilirler. Bunlar iletişim
protokollarının veya işletim yazılımlarının boşlukları, kusurları,
zayflıkları olarak isimlendirilir.
 Onlar bir protokol tasarımı esnasındaki gözden kaçmış küçük bir
adım, veya bir programdaki belirli bir talimatın öngörülemeyen bir yan
etkisi ya da bir sistemde bir yanlış konfigirasyon olabilir.
 Ağ güvenliği prensipleri, bir pasif savunma işlevidir. Çünklü ağdaki
kurban (mağdur-victim) bilgisayar saldırıya uğramadan önce, saldırıyı
kimin yaptığını, nereden yapıldığının bilemez.
 Ağ güvenliğinde Derin bir katmanlı savunma sistemi oluşturmak,
mümkün olan en iyi savunma taktiğidir.
 Savunma sistemi, çoklu katmanlı yapısıyla mümkün saldırılara karşı
korumayı yapabilmelidir.
24
 Ağ güvenliği bilgi güvenliğinin (information security)
önemli bir parçasıdır.
 Ağ güvenliğine ek olarak, bilgi güvenliği; güvenlik politikaları,
Güvenlik denetimi,
Güvenlik değerlendirmesi,
Güvenilir işletim sistemleri,
Veritabanı güvenliği,
Güvenli kod,
Acil müdahale,
Adli bilişim, adli tıp,
Felaket kurtarma ve Güvenlik eğitimi
dahil olmak üzere diğer birçok güvenlik sorunları ile ilgili konularla
da ilgilenir.
25
OSI Güvenlik Mimarisi X.800
 Veri güvenliğinde sistematik bir yaklaşım olarak;
ITU-T ( İnternational Telecomunication Union - Telecommunication Standardization
Sector ) kuruluşunun X.800 olarak adlandırdığı standartlara
uyulur.
 X.800 Aynı zamanda yedi katmanlı OSI Temel
Referans Modelinde güvenlik hizmetlerinin
uygulanması içinde uygundur.
26
27
X.805 Standartı
 ITU-T ‘nin X.805 standartı ise,
“Uçtan uca haberleşme hizmeti sağlayan
iletişim sistemleri için güvenlik mimari
yapısını” tarif eder.
 Güvenlik mimarisi, servis sağlayıcıların, işletmelerin ve son
kullanıcıların global güvenlik zorluklarını gidermek için
oluşturulmuştur.
 Kablosuz, optik ve kablolu ses, veri ve hibrit ağlar için geçerlidir. Bu
güvenlik mimarisi, ağ altyapısının, servislerinin ve uygulamalarının
yönetimi, denetimi ve kullanımı ile ilgili güvenlik kaygılarını giderir.
 Güvenlik mimarisi, güvenlik açıklarını tespit etmek, öngörmek ve
düzeltmek için ağ güvenlik unsurlarını kapsamlı, yukarıdan aşağıya,
uçtan uca bir perspektifle sunar ve ağ öğeleri, hizmetleri ve
uygulamaları için uygulanabilir.
 Güvenlik mimarisi, karmaşık bir yapı olan ‘uçtan-uca güvenlik ‘
problemini katmanlara (mantıksal bileşenlere) böler. Uçtan uca
güvenliğin çok karmaşık yapısı, katmanlara paylaştırılarak karmaşıklık
azaltılır ve katmanlara, yeni görev atamaları yapılabilir. Böylece uçtan
uca güvenlik için çok karmaşık yapı daha basit şekilde katmanlarda
çözülür ve biribinden soyutlanabilir.
28
Güvenlik mimarisi uçtan uca güvenlikle ilgili üç temel soruyu ele
alır;
1) Ne tür bir korumaya ihtiyaç duyuluyor ve hangi tehditlere karşı
gerekli?
2) Korunması gereken farklı ağ teçhizatı türleri ve tesis grupları
nelerdir?
3) Korunması gereken farklı ağ faaliyetleri türleri nelerdir?
 Bu sorular güvenlik boyutları (security dimensions), güvenlik
katmanları (security layers) ve güvenlik planları (security planes)
olmak üzere üç mimari bileşen tarafından ele alınmaktadır.
 Güvenlik mimarisi tarafından açıklanan ilkeler, ağın teknolojisi
veya protokol yığını içindeki konumundan bağımsız olarak çok
çeşitli ağlara uygulanabilir.
29
30
Access Control
(Erişim Kontrolu)
Authentication
(Kimlik Doğrulama)
Non-repudiation
(İnkar edememe)
Data Confidentiality
(Veri gizliliği)
Communication Security
(İletişim Gizliliği)
Data Integrity
(Veri Bütünlüğü)
Availability
(Kullanılabilirlik)
Privacy
(Gizlilik)
• Ağ elemanlarına, servislere,
uygulamalara erişimin limitlenmesi
ve kontrolu. Yetkisiz erişimleri
önlemek için.
Örnek:password, ACL, firewall
• Ağda oluşan tüm aktivitelerin
inkar edilememesinin
sağlanması.
Örnek: sistem log’ları, digital
imzalar.
• Verilerin, sadece kaynaktan
hedefe aktığından emin
olunması.
• Örnek.: VPN, MPLS, L2TP
Meşru kullanıcıların, anormal işletme
şartlarında bile ağ elemanlarını,
servisleri, uygulamaları kullanabilme
yetkisinin belirlenmesi.
Örn: IDS/IPS, network redundancy,
BC/DR (İş sürekliliği/Felaket kurtarma)
İletişim kuracak varlıkların biribirlerinin
kimliklerini doğrulamaları içindir.
Örnek: Paylaşılan gizli kod dizisi, PKI,
digital imza, digital sertifika.
Verilerin gizliliğinin sağlanması. Veri
içeriğinin yetkisiz kişiler tarafından
anlaşılmamasını sağlar.Örn:Kriptolama
• Datanın gönderildiği veya
saklandığı şekliyle alındığında
emin olunması.
• Örnek: MD5, digital imza,
anti-virus yazılımları.
Kimlik Tanımlamanın ve ağ
kullanımının gizli tutulduğundan
emin olunması.
• Örnek: NAT, Kriptolama
8 adet Güvenlik Boyutu, Ağın güvenlik açıklarının bütününü kapsar. 8 adet Güvenlik boyutunun
herbiri ağ saldırılarının belirli bir kısmının önlenmesi için gereken önlemleri açıklar.
Sekiz güvenlik boyutu, herbir güvenlik perspektifine (Katmanlar ve planlara) uygulanır.
Uçtan-Uca İletişim Sistemleri için Güvenlik Mimarisi X.805
 Bu güvenlik mimarisi iki temel kavram üzerine kurulmuştur.
Katmanlar (Layers) ve Düzlemler(Plains).
 Bir güvenlik düzleminde (Plane), üç güvenlik katmanı da
kullanılır.
31
32
Her düzlemdeki Güvenlik katmanları, güvenli ağ çözümleri için bir dizi etkinleştiricidir.
Altyapı katmanı (Infrastructure), Hizmetler (services) katmanına hizmet sağlar. Hizmetler
katmanı, Uygulama (Application) katmanını etkinleştirir.
Altyapı güvenlik katmanı, ağ şebeke iletim elemanları ve belirli güvenlik boyutlarıyla
korunan bireysel şebeke elemanlarında (router,switch, server v.b) oluşur.
Hizmetler güvenlik katmanı, servis sağlayıcıların müşterilerine sağladığı hizmetlerin
güvenliğini sağlar. İnternet Servis Sağlayıcıların sunmuş olduğu hizmetler ve bu
hizmetlerden yararlanan müşteriler, güvenlik tehditlerinin potansiyel hedefleridir. Bu
güvenlik katmanı hizmet sağlayıcıları ve müşterilerini korumak için kullanılır.
Uygulamalar güvenlik katmanı, servis sağlayıcı müşterileri tarafından erişilen ağ tabanlı
uygulamaların güvenliğine odaklanır. Bu uygulamalar ağ servisleri tarafından etkinleştirilir ve
temel dosya aktarımını (örneğin FTP) ve web tarama uygulamalarını, ağ tabanlı sesli
mesajlaşma ve e-posta gibi temel uygulamalar v.b olabilir. Veya 3. parti uygulamalar olabilir.
Güvenlik düzlemi, güvenlik boyutlarıyla korunan belirli bir ağ etkinliği türüdür.
Yönetim güvenlik düzlemi, ağ elemanlarının, iletim tesislerinin, arka ofis
sistemlerinin (operasyon destek sistemleri, iş destek sistemleri, müşteri bakım
sistemleri, vb.) ve veri merkezlerinin korunmasıyla ilgilenmektedir. Yönetim
düzlemi hata, kapasite, yönetim, sağlama ve güvenlik (FCAPS) işlevlerini
destekler.
Kontrol güvenlik düzlemi, bilgi, servis ve uygulamaların ağ üzerinden verimli
bir şekilde iletilmesini sağlayan faaliyetlerin korunmasıyla ilgilidir. Genellikle
makinelerin (örneğin, anahtarlar veya yönlendiriciler) temel aktarım ağı
üzerinden trafiği en iyi nasıl yönlendireceğini veya değiştirdiğini belirlemesine
olanak tanıyan bilgilerin makinadan-makineye iletilmesini içerir.
Son kullanıcı güvenlik düzlemi, servis sağlayıcı ağının müşterilerin erişim ve
kullanım güvenliğini ele alır. Bu düzlem, aynı zamanda gerçek son kullanıcı veri
akışlarını da temsil eder. Son kullanıcılar yalnızca bağlantı sağlayan bir ağ
kullanabilir, bunu VPN'ler gibi katma değerli hizmetler için kullanabilir veya ağ
tabanlı uygulamalara erişmek için kullanabilirler.
33
34
ITU-T X.800 ile tarif edilmiş Threat (Tehdit) Modeli
X
X
1 – Destruction (Yoketme-İmha) (Kullanılabilirliğe
karşı yapılan atak):
– Bilgi ve/veya ağ kaynaklarının imha edilmesi.
2 – Corruption (Bozma- yolsuzluk) (Bütünlük
üzerine yapılan atak)
– Yetkisiz biri tarafından tahrif etme.
3 – Removal (Giderme- Kaldırma)
(Kullanılabilirliğe karşı yapılan atak):
– Bilgi ve/veya kaynakların kaldırılması veya
kaybedilmesi hırsızlığıdır.
4 – Disclosure (Açığa vurma, ifşa) (Bütünlük
üzerine yapılan atak):
– Bir varlığa yetkisiz erişim.
5 - Interruption (Kesintiye uğratma)
(Kullanılabilirliğe karşı yapılan atak):
– Hizmetlerin kesintiye uğramasıyla. Ağın
kullanılamıyor veya kullanılamaz hale
getirilmesi.
35
Güvenlik Boyutları ve Tehdidlerin kapsanması
Security
Dimension
(Güvenlik Boyutu)
X.800 Security Threats
Destruction
(Yok etme)
Corruption
(Bozma )
Removal
(Kaldırma,
giderme)
Disclosure
(Açığa vurma,
ifşa)
Interruption
(Kesinti)
Access Control
(Erişim Kontrol)
   
Authentication
(Kimlik Doğrulama)
 
Non-Repudiation
(İnkar edememe)     
Data Confidentiality
(Ver Gizliliği)
 
Communication
Security
(İletişim Güvenliği)
 
Data Integrity
(Veri Bütünlüğü)
 
Availability
(Kullanılabilirlik)
 
Privacy
(Gizlilik)

Güvenlik Mekanizmaları
 Güvenlik servislerinin gereğini yerine getirmek için kullanılan
yöntemlerdir.
 Şifreleme Mekanizmaları(Encipherment Mechanisms)
• veri gizliliği hizmet verirler.
• Asimetrik / Simetrik algoritmalar
 Sayısal İmzalar (Digital Signatures)
• Islak imzanının, elektronik ortamdaki sayısal eşdeğeridir.
• Genellikle asimetrik şifreleme uygulayanır.
 Erişim Kontrol Mekanizmaları (Access Control Mechanisms)
• Doğrulanmış kimlik bilgilerini kullanarak , bir varlığa veya varlıkla
ilgili bilgilere erişim kontrol hizmetlerinin sağlanması.
36
 Veri Bütünlüğü Mekanizmaları (Data Integrity Mechanisms):
• Veri bütünlüğünün sağlandığını kanıtlamak için, değişik ispat
algoritmalarını kullanmak.
• Mesaj kimlik doğrulama kodları (MAC), dijital imzalar v.b
 Kimlik doğrulama mekanizmaları (Authentication Mechanisms):
• Temel bir kimlik temini, kimlik doğrulama hizmetleri sağlanması.
• Ortak anahtar altyapısı (PKI - public key infrastructure) gibi şifreleme
teknikleri ve güven altyapısı dayanarak.
 Trafik-Dolgu Mekanizmaları (Traffic-Padding Mechanisms)
• Trafik analizi saldırılarına karşı koruma sağlama
 Yönlendirme Kontrol Mekanizması(Routing Control Mechanisms)
• Belirlenmiş yollardan dinamik veya statik olarak, iletişim veri için belirli
bir güzergah seçimi izini.
37
Saldırıların Sınıflandırılması
Süreçsel Sınıflama: Ağdaki veri transferiyle ilgili
olarak güvenlik sorunları 4 kategoride incelenir.
1-Engelleme
2-Dinleme
3-Değiştirme
4-Oluşturma
38
Ağ Güvenlik politikası
 Kurumların kendi kurmuş oldukları ve İnternet’e
uyarladıkları ağlar ve bu ağlar üzerindeki kaynakların
kullanılması ile ilgili kuralların genel hatlar içerisinde
belirlenerek yazılı hale getirilmesi ile ağ güvenlik
politikaları oluşturulur.
 Güvenlik politikasının en önemli özelliği yazılı
olmasıdır ve kullanıcıdan yöneticiye kurum genelinde
tüm çalışanların, kurumun sahip olduğu teknoloji ve
bilgi değerlerini nasıl kullanacaklarını kesin hatlarıyla
anlatmasıdır.
39
 Ağ güvenlik politikaları, kurumların yapılarına ve gereksinimlerine
göre değiştiğinden bir şablondan söz etmek mümkün değildir. Bu rada
bildiride politikası oluştururken dikkat edilmesi gerekenler
belirtilmiştir. Ağ güvenliğinin sağlanması için gerekli olan temel
politikalar aşağıda sıralanmıştır :
 1. Kabul edilebilir kullanım (acceptable use) politikası
 2. Erişim politikası
 3. Ağ güvenlik duvarı (firewall) politikası
 4. İnternet politikası
 5. Şifre yönetimi politikası
 6. Fiziksel güvenlik politikası
 7. Sosyal mühendislik politikası
40
Katmanlı güvenlik planı
41
Bölümlenmiş güvenlik kavramı
 Farklı hassasiyet seviyesindeki IT sistem
kaynaklarının (örneğin, farklı risk tolerans değerleri
ve tehdit yatkınlık), farklı güvenlik bölgelerinde yer
alması gerekir. Bu durum Şekil 2'de gösterilmiştir.
 Bu kuralın bir uzantısı "bilgi gizleme”dir. Sadece bu
işi yürütmek le görevlendirilmiş IT sistemleri bu işi
yapar. (örneğin, İnternette resmi kayıtlı DNS
sunucuları sorgulaması için kullanılan public DNS
sunucuları sadece bu hizmeti sağlamak içindir)
42
Bilgi Bölümlendirme: IT sistem kaynakları ve bilgi farklı hassasiyet
seviyelerinde farklı güvenlik bölgelerinde yer almalıdır.
43
Anlatılacaklar
• Bilgisayar ağlarında güvenlik konusu, ağa bağlı aktif cihazlara ve iletişim halindeki
veriye, illegal olarak erişme, değiştirme, okuma, bütünlüğünü bozma, inkar etme v.b
saldırıların öğrenilmesi ve önlenmesidir.
• Bu saldırılar, iletişim protokollarının açıklarından, ağ cihazlarına erişimin
engellenmemesinden, güvenlik politikalarının iyi oluşturulamamasından
kaynaklanmaktadır.
• Özellikle TCP/IP Version 4 iletişim protokol kümesiyle çalışan internet gibi dinlenmeye
çok müsait ağ yapılarında seyahat eden verilerin her türlü saldırıya açık olduğu
bilinmektedir.
• Ağ güvenliği (Sistematik ağ güvenliği) konusu üç farklı segment’te incelenecektir.
1- İletişim protokolları açıklarından yararlanarak yapılan saldırılar ve tedbirler.
2- Güvenlik protokollarının uygulanması
3- TCP/IP protokol verilerinin Clear text olmasının getirdiği dezavantajlar ve tedbirler.
• Bu derste TCP/IP ve OSI katmanlı ağ modeli ve ilgili katman protokolları ve bunların
zayıflıkları üzerinde durulacaktır. Bu zayıflıklardan yararlanılarak yapılacak saldırılar ve
tedbirleri nelerdir? Tartışılacaktır….
• İlgili ağ cihazlarının korunması ve cihazların uygun konfigürasyonları ile ağ güvenlik
açıklarının azaltılması, sistematik ağ güvenliği üzerinde durulacaktır.
45
46
Derste anlatılacaklar….
 OSI/TCP-IP ağ modelinin kısa özeti
 Ağ modeli katmanı protokollarının incelenmesi açıkları, saldırı tipleri,
önlemleri.
 Ağ aktif cihazlarında alınması gereken önlemler.
 Ağ güvenlik protokollarının açıklanması.
 Güvenlik duvarları, İç Ağ/Dış ağ koruması
 Şifreleme, e-imza konularına genel bakış.
 Penetrasyon (Nüfuz etme-sızma ) Testleri
Konular işlenirken sanal ortamda gerekli uygulamalar ve projeler ile
desteklenecektir. Bunun için kullanılacak yardımcı yazılım araçlar;
-GNS3 sanal ağ emülatör yazılımı
-Ağ güvenlik yazılım araçları ()Wireshark, NMAp v.b)
-Penetrasyon testleri için Kalli yazılım aracı
Vize ve Final Notu:Konu sonlarında verilecek projelerin
değerlendirilmesinden oluşacaktır.
47
Güvenlik Saldırısı: Bir kuruluşun bilişim sistemlerine
karşı yapılan Engelleme, Dinleme, Değiştirme ve
Yeniden oluşturma tipindeki saldırı çeşitleridir.
Güvenlik Mekanizması: Güvenliğe karşı yapılan
Atakların, anlaşılması, bu atağa karşı korunma veya
tahribatını onarmak için kullanılan yöntemlerdir.
Güvenlik Servisi : Bilgi işleme veya iletme
sistemlerinin güvenliğinin arttırılması için gerekli
hizmetleri kapsar. Örneğin saldırı engelleme servisleri
için farklı güvenlik mekanizmalarından yararlanılır.
1-Sistematik Güvenlik
2-kriptografik Güvenlik
2
Access Control
(Erişim Kontrolu)
Authentication
(Kimlik Doğrulama)
Non-repudiation
(İnkar edememe)
Data Confidentiality
(Veri gizliliği)
Communication Security
(İletişim Gizliliği)
Data Integrity
(Veri Bütünlüğü)
Availability
(Kullanılabilirlik)
Privacy
(Gizlilik)
• Ağ elemanlarına, servislere,
uygulamalara erişimin
limitlenmesi ve kontrolu.
• Örnek: : password, ACL,
firewall
• Ağda oluşan tüm aktivitelerin
inkar edilememesinin
sağlanması.
• Örnek: sistem log’ları, digital
imzalar.
• Verilerin, sadece kaynaktan
hedefe aktığından emin
olunması.
• Örnek.: VPN, MPLS, L2TP
• Sadece meşru kullanıcıların ağ
elemanlarını, servisleri,
uygulamaları kullandığından
emin olunması. Örn: IDS/IPS,
network redundancy, BC/DR
• Kimlik kanıtı (Kimlik Doğrulama)
• Örnek: Paylaşılan gizli kod
dizisi, PKI, digital imza, digital
sertifika.
• Verilerin gizliliğinin sağlanması
• Örnek: Kriptolama
• Datanın gönderildiği veya
saklandığı şekliyle alındığında
emin olunması.
• Örnek: MD5, digital imza,
anti-virus yazılımları.
• Kimlik Tanımlamanın ve ağ
kullanımının gizli
tutulduğundan emin olunması.
• Örnek: NAT, Kriptolama
8 adet Güvenlik Boyutu, Ağın güvenlik açıklarının bütününü kapsar.
Sekiz güvenlik boyutu, herbir güvenlik perspektifine (Katmanlar ve planlara) uygulanır.
Ağ Güvenliği Dersi
(2018-19-Güz)
2.hafta
Günümüz ağ ortamında yaygın tehditler
Virüs: Belleğe yerleşerek, çalışan programlara
kendisini ekleyebilen ve sürekli çoğalabilen zararlı
programcıklardır.
Bilgisayar virüsleri,
* bilgisayarın çalışmasını engelleyecek,
*verileri kaybedecek, bozacak veya silecek
*kendilerini Internet üzerinden diğer bilgisayarlara
yayarak yavaşlamalara neden olacak
şekilde tasarlanmışlardır.
Virüs’ler e-posta, veri taşıma ortamları (disket,
cd, dvd vb.) ve web sayfaları ile yayılabilir (Melisa,
CIH, Gauss). yazılım programlarıdır.
Günümüz ağ ortamında yaygın tehditler
Günümüz ağ ortamında yaygın tehditler
Worm (Solucan):
*IP adreslerini rastgele tarayarak, internete bağlı
kullanıcıların yerel ağ için paylaşıma açık dosyalar olup
olmadığına bakarlar. Yazmaya açık dosya bulduğunda
kendisini oraya yazar.
*Worm bir sızma ve çoğalma mekanizmasıdır.
Worm’lar, Virüs’lerin kullandıkları yöntemlere ek
olarak, uygulama / işletim sistemi zayıflıkları ile saldırılar
düzenleyebilir ve bu şekilde de yayılabilir (Code Red,
Nimda, Sasser, Blaster).
Solucanlar yayılmak için bir "taşıyıcı" programa veya
dosyaya gereksinim duymadıklarından, sisteminizde bir
tünel de açabilir ve başka birinin uzaktan bilgisayarınızın
denetimini eline geçirmesini sağlayabilir.
Trojan (Truva atları):
Bulaştıkları bilgisayarlardaki şifreleri, dosyaları veya
herhangibir veriyi ele geçirmek üzere tasarlanmışlardır.
Virüslerden ayrıldıkları temel nokta, verilere zarar
vermekten çok casusluk yapmalarıdır.
Trojanlar sonradan bilgisayarımıza girerek, yazarı
tarafından belirtilen portu açan veya yazarın belirlediği bir
mail adresine veya v.b yazarın istediği bilgileri aktaran
programlardır (Kredi kartı no, key log’ları, dosya bilgilerimiz
v.b v.b).
Trojan’lar ancak ilgili uygulama çalıştırıldığında etkili
olmaktadır (Netbus, Subseven).
Denial of Service Atakları
DoS ( Denial of Services - Servis Dışı Bırakma) atakları temel olarak sistem kaynaklarını
veya bant genişliği tüketerek servislerin hizmet dışı bırakılmasıdır. Bu atakların amacı bilgiyi
çalmak değildir. Bu atakları 3 başlıkta toplamak mümkündür.
1. DoS - Denial Of Service :
-Paket direk olarak hedef sistem gönderilir.
-Tek bir kaynaktan tek bir hedefe yöneliktir.
2. DDoS - Distributed Denial of Service :
-Zombi kaynaklardan tek bir hedefe çoklu ataklardır.
-Anlık gönderilen paket sayısı zombilerin sayısı ile doğru orantılıdır.
-Çoğunlukla saldırıyı yapan kaynak tespit edilemez.
3. DRDoS - Distributed Reflective DoS:
- DDoS'tan farklı olarak daha sık
ataklar için ek ağlar kullanır
4 çeşit temel DoS atağı vardır:
1. TCP/IP uygulamasındaki kusurları istismar eden ataklar: Örneğin
Ping of Death ve Teardrop.
Ping-of-Death :Çok büyük boyuttaki (genelde 65,536 dan daha büyük)
ICMP paketleri direk olarak hedefe gönderilir. Paketin büyüklüğüne
göre sistemin donmasına, çökmesine yada reset atmasına sebep
olabilir.
TearDrop :Parçalanmış UDP paketleri bozuk ofsetler ile hedefe
gönderilir. Hedef paketleri tekrar birleştirmeye çalıştığında bozuk veya
hatalı bir paket üretmiş olur ve sistem çöker.
2. TCP/IP’deki zayıflıkları kullanan ataklar. Örneğin SYN Flood ve
LAND atakları.
SYN Flood :TCP'nin 3 yollu handshake açığını kullanır. Kaynak
(Saldıran) SYN paketlerini hedefe gönderir.(1. el sıkışma) .
Hedef SYN paketine SYN ACK olarak cevap verir (2. el sıkışma).
Saldıran (Kaynak) gelen pakete cevap vermeden yeni bir SYN paketi
yollar ve hedef sürekli cevap bekler konumda kalır.
Land Attack :Kaynak ve Hedef adresi değiştirilmiş paketlerdir. Paket
içerisindeki kaynak ve hedef gönderilecek hedef adresidir. Paket
hedefe ulaştığında hedef kendi paketini sürekli cevaplayarak çöker.
3. Brute-force (Kaba kuvvet) atakları: Web yazılımlarının login
kısımlarına yapılan deneme yanılma yöntemidir. Bu işlem yazılmış olan
programları kullanılarak otomotik bir şekilde yapılır. Sürekli login sayfasına
atak yapılarak deneme yanılma yöntemiyle bir kullanıcı adına ait şifreyi
bulmak ve yönetimi ele geçirmektir. Bu tip ataklar networkü gereksiz data
ile istila ederler. Örneğin Smurf atağı.
Smurf :ICMP paketlerindeki kaynak adresi değiştirir. ICMP paketlerini
zombilere gönderir. Zombiler paketleri hedefe yollar. Hedef kendisinin
göndermediği bir sürü cevap mesajları alarak şişer.
4. IP Spoofing (IP Sahtekarlığı) : Sistemlere girmek için,
saldırganın kimliğini gizleyebilmesi için veya DoS atağının etkisini
büyütmek için kullanılır. Saldırganın kendisini gizleyebilmesine
sebep olan şey, HTTP, DNS gibi Internet servislerinde, IP
numaralarını doğrulayacak bir denetim (authentication)
bulunmamasıdır. IP spoofing’de, saldırgan, IP paketlerine kendi gerçek
IP numarası yerine, var olmayan bir IP numarasını veya kurban
sitenin numarasını koymaktır. Zombiler veya kurban siteler bu
paketlerdeki gönderen IP numarasını doğrulayamadıkları için saldırgan
kendisini gizleyerek istediği siteye saldırabilmektedir. Bu saldırının
temel alındığı DDoS saldırıları SYN-flood , smurf v.b
İntrusion Attacks ( Sızma Atakları)
Bir ağ ortamında, ağ kaynaklarına izinsiz erişim
yapan veya yapmaya çalışan, sistemi kötüye
kullanan kişiler saldırgan kapsamındadır. Bunlara
cracer veya hacker denir.
Saldırısını sonuçlandırarak sisteme girmeyi
başaran saldırgana ise sızan-nüfüz eden (intruder)
olarak tanımlanır. Sızma işleminin sonucunda;
sistemde yetkisiz kullanım, kaynaklara izinsiz erişim,
bilgi çalınması, sadece sistemi meşgul ederek servis
dışı kalması gibi kötü olaylar oluşur.
Sisteme sızma için gerçekleştirilen ataklara
ise intrusion attacks (Sızma Atakları) denir.
İLLEGAL CONTENT (yasadışı içerik)
Yasadışı içerik tanımı ülkeden ülkeye değişir. Özellikle internet
üzerinden yapılan illegal içerikli en yaygın yayınlardan bazıları ;
• Pornografi görüntüleri ve web siteleri
• Yasadışı faaliyet sohbet odaları
• Online nefret ve yabancı düşmanlığı web siteleri
ZOMBİ’ler (İç atak)
Zombiler genellikle güvenliği zayıf olan sistemlere
yerleştirilirler. Hack'lenen sisteme yerleştirilen zombiler,
belirli bir porttan (1524 tcp, 27665 tcp, 2744 udp,
31335 udp, 33270 tcp) gelecek olan DDoS isteklerini
gerçekleştirirler.
Unix , Linux, Windows tabanlı sistemlerde
zombiler kullanılmaktadır.
DDoS ataklarını gerçekleştirirken yakalanmamak
için "zombi" (küçük programcıkları) kullanılır.
SQL İnjection (SQL Atakları)
Sql Injection atakları, web uygulamalarında yer alan veri
girişleri için kullandığımız TextBox form elemanlarının içine
yazılan bazı sql komut deyimlerinin yazılması ile olur.
Web uygulamalarının en zayıf bölümü kullanıcı
girişlerinin yapıldığı ve sonucunda yetkilendirme yapıldığı
bölümlerdir. Buradan yapılan kaçaklar ile veri tabanında
istenmeyen işlemlerin yapılması sözkonusudur.
İçeriğin Kanunsuz olarak ele geçirilmesi
(Unlawful capture of content)
DNS Önbellek zehirlenmesi, bir DNS sunucusuna yetkisiz
bir kaynaktan veri yüklenmesine verilen genel isimdir. Hatalı
yazılımla, yapılandırma hatalarıyla ya da DNS protokolünün
açıklarıyla başarıyla iletilen özgün olmayan veri, saldırılan
sunucunun önbelleğine gelir ve böylece önbellek “zehirlenmiş” olur.
Bu tür saldırılar, sorgu yapıldığında asıl yanıt vermesi
beklenen DNS sunucusundan önce saldırganın yanıt vermesi
esasına dayanır.
Spyware (Spy software) (Casus) programlar bilgisayarınızda
casusluk yapmak için yaratılmış programlardır. Tam anlamı ile
virüs olarak adlandırılamayan bu programların temel amaçları
kuruldukları bilgisayarda bilgi toplamak ve bu bilgileri bu
programları yaratan kişilere göndermektir. Spyware (casus)
programların tehlikeli olan türevleri sizin bilgisayar ve/ya
internet ayarlarınızı kendi istedikleri gibi değiştirirler ve sizleri
kendi istedikleri sitelere yönlendirirler.
Redirect (URL-Redirect): Bir URL’e gelenleri başka bir URL’e
iletme işlemi yönlendirmedir. Birçok sebep için yönlendirmeler
kullanılmaktadır.
Dns Poisioning (DNS zehirlenmesi): Yanlış DNS bilgileri
Birincil DNS sunucuya tanıtılır. Tüm istekler değiştirilmiş DNS
sunucusuna yönlendirilir
AĞ güvenliğine katmanlı bakış
Level 1- Çevresel (Bütünsel) Güvenlik seviyesi
• Çevresel güvenlik, güvenli olmayan ağlarda
savunmanın ilk basamağıdır.
• Çevresel güvenlik ,bir ağı korumak için ilk (giriş) ve
son(çıkış) temas noktası olarak değerlendirilir.
• İç ağın dış ağdan ayrıştığı bir yer olarak
değerlendirilir. Ağın dünyaya açıldığı kapısıdır.
• Çevresel (perimeter) güvenlik bir veya birkaç
firewall’dan ve bölgelerden oluşur.
• Network’te çevresel güvenlik için, FİREWALL, Ağ
Tabanlı anti-virüs yazılımları, VPN şifreleme gibi
teknolojiler kullanılır.
Firewall - Güvenlik duvarı
• Firewall - Güvenlik duvarı, genellikle bağlı bir
sunucu üzerinde yüklü bir yazılımdır veya
donanımsal bir kutudur.
• İç ve dış ağı biribirnden ayıran noktadır.
Genellikle iç ağı dış ağdan korur.
• Güvenlik duvarı üç genel işlevleri gerçekleştirir;
1) Trafik kontrol,
2) IP Adresi çevirisi (NAT),
3) VPN (Virtual Private Network) sonlandırma.
• Güvenlik duvarı, gelen ve giden trafikteki hedef ve
kaynakları inceleyerek sadece izin verilen trafiğin
akışını sağlar.
• Ayrıca, güvenlik duvarları iç IP adreslerini farklı IP
adreslerine çevirerek iç ağı Internetten koruyabilir.
• Güvenlik duvarı, VPN tünelleme işlemini yaparak,
genel bir ağ üzerinden şifreli bir yol elde edilmesini
sağlayabilir.
• Bu yetenekleri, bir güvenlik duvarını ağ güvenliği için
bir vazgeçilmez parça yapar.
Ağ tabanlı anti-virüs (Network-based anti-virus)
• DMZ’de Yüklü, ağ tabanlı anti-virüs yazılımı gelen ve giden e-posta
mesajını, içeriği bilinen bir virüs profilleri veritabanı ile karşılaştırır.
• Ağ tabanlı antivirüs ürünleri, şüpheli ve virüslü e-posta mesajları
karantinaya alır ve virüslü e-posta trafiğini engeller. Bu durumu
alıcılara ve yöneticilere bildirir.
• e-posta sunucusu üzerinde yapılan bir Ağ tabanlı anti-virüs
koruması, bireysel masaüstü bilgisayarlar için bir tamamlayıcı
etkendir.
• Bu işlem e-posta ile giren bir virüs ile enfekteyi ve virüslü emaili’in ağ üzerinden yayılmasını önler.
• Etkin çalışması için, veritabanının güncel virüsleri tanıması
gerekir.
Özel Sanal Ağ (Virtual private network (VPN))
• VPN - Sanal özel ağ (VPN), dizüstü bilgisayarlar,
ve hedef ağ gibi uzak cihazlar arasında güvenli
bir bağlantı oluşturmak için yüksek düzey bir
şifreleme tekniği kullanır.
• Aslında özel ağın güvenliğine ve gizliliğine
yaklaşılan bir uygulamadır. Internet(Genel bir
ağ) üzerinden şifreli bir haberleşme şekli
olarakta düşünülebilir.
• VPN tüneli, DMZ içinde bir VPN-etkin
yönlendirici, güvenlik duvarı, ya da sunucu
üzerinden sona erdirilir.
•
Çevresel güvenlikle ilgili
• Kullanılan ağın karmaşıklığı, çevresel güvenlik teknolojilerinin etkinliğini
etkiler. Yani Birden fazla dış bağlantı durumu, büyük olasılıkla birden fazla
güvenlik duvarını ve anti-virüs yazılımlarını gerektirebilir.
• Karmaşık mimarinin tek bir noktadan korunabilmesi için kullanılan
teknolojilerde mevcuttur.
Çevresel güvenliğin pozitifleri
• İyi kurulmuş ve konfigüre edilmiş çevre düzey
teknolojileri, uzun yıllar kullanılabilir ve iyi IT
profesyonellerinin yetenekleri ve işletme bilgilerine
gereksinim duyar. Aynı zamanda onların
tecrübesinide arttırır.
• Bunun için , üreticiler makul fiyatlı, etkin uygulamalı
yazılım ve donanım seviyesinde çözümler geliştirip
sunuyorlar.
Çevresel güvenlikle ilgili olarak Dikkat edilecek konular
• Bir anti-virüs yazılımı, veritabanında olmadığı sürece bir virüsü
tespit edemez.
• VPN etkili şifreleme, sağlamasına karşın , şifreleme gibi, BT
personelinin idari bir yük bindirip tuşları ve kullanıcı gruplarının
sürekli olarak yönetilmesi gerekir.
• Ayrıca VPN'ler sizi enfekte olmuş cihazlardan koruyamaz, veya
VPN bağlantısı kullanarak, kötü niyetli trafiği önleyemezsiniz.
• DMZ’de bulunan cihaz türleri de önemli bir faktördür. Ayrıca
ağda yaptığınız işin önemide bu cihazlarla ilgilidir. Işiniz önemi
ve kritikliği ne kadar yüksek ise , çevresel güvenlikten daha sıkı
güvenlik önlemleri ve politikaları ve cihazları uygulanmalıdır.
Level2- Ağ güvenlik seviyesi
• Katmanlı yapıdaki ağ güvenliği seviyesi; biribiriyle iletişim
içindeki LAN ve WAN sistemlerini kasdeder. Uzak LAN’ların
FrameRelay v.b servislerle biribirine bağlantısı buna dahildir.
• Çoğu ağlar bugün oldukça saldırıya açık bir yapıdadır. Ağ içine
sızıp hiçbir engele takılmadan istediğiniz işlemi yapabilirsiniz.
• Bu durum internete bağlı orta ölçekli ağları saldırganların
kolay ve cazip bir hedefi haline getiriyor.
• Ağ seviyesinde güvenlik için,
a-) IDS (Saldırı tespit sistemleri),
b-Güvenlik açığı yönetimi,
c-) ağa erişim teknolojileri,
d-) Erişim kontrol ve kimlik doğrulama teknolojileri
kullanılabilir.
Level 2: IDS-IPS’ler
• Saldırı Tespit Sistemleri (Intrusion detect sysytems – IDS -STS )
ve Saldırı Önleme Sistemleri (Intrusion Prevention systems- IPSSÖS) , ağınızdaki hareketli trafik analizi açısından güvenlik
duvarı ‘na oranla çok daha fazla ayrıntı verir.
• IDS’ler saldırıları uyarır.
• IPS’ler saldırıları belirler ve engeller.
• IDS ve IPS cihazları, çalışma prensibi olarak anti-virüs sistemine
benzerdir. Yani trafik analizi ve paketler bilinen saldırı
profillerinin tutulduğu veritabanı ile karşılaştırılır.
• Anti-virüsler dosyaları, IDS’ler paketleri inceler.

Level 2: Güvenlik açığı yönetimi
İki farklı fonksiyonu gerçekleştirir.
1- Ağı güvenlik açıkları için sürekli tarar.
2- Güvenlik açıklarının giderilmesi sürecini
yönetirler.
• Güvenlik açıklarını giderici gelişmiş cihazlar piyasada
mevcuttur.
• Güvenlik açığı yönetici cihazları korsanlardan önce
güvenlik açıklarını bulup giderebilmelidir.
• Daha çok bilinen açıkların var olup olmadığı
konusunda etkendirler.
Level 2: Network access control
(Ağ erişim kontrol)
• Ağ erişim kontrol çözümleri, önceden
tanımlanmış ve müsaade edilmiş ağ uç
noktalarına (Sunucular, network cihazları v.b)
girişleri kontrol etmek üzerinedir.
• Bu da ağ üzerinden 'içerden' saldırıya
uğrayabilecek, tehlikeye açık masaüstü ve
dizüstü bilgisayarlar, yüklenici makineleri,
VPN ve RAS aygıtlarını korumak içindir.
Level 2: Access control/authentication
• Erişim kontrol / kimlik doğrulama , Ağa Erişmek isteyen
kullanıcılar için kimlik doğrulama kontrolu gerektirir.
Erişim kontrolu üç aşamalı olarak gerçekleştirilebilir. Bu
kontrol hostlar için de kullanılır.
1.Tanımlama (Identification)
2.Kimlik Sınama (Authentication)
3.Yetkilendirme (Authorization)
• Kimlik Doğrulama genellikle RADIUS, LDAP, ya da
Windows Active Directory’deki kullanıcı bilgilerine karşı
gerçekleştirilen erişimler için yapılır.
Ağ güvenlik seviyesinin pozitifleri
• IDS, IPS, ve güvenlik açığı yönetim teknolojileri,
gerçekleştirmek ağ tehditleri ve güvenlik açıklarının
analizleri için önemli ve yeni analizlerin başarılmasına
yol açar.
• Güvenlik duvarı sonuçta, hedefe ait trafiğe izin veren
veya vermeyen kaba bir analiz yöntemi olmakla beraber,
IPS ve IDS araçları çok daha derin bir analiz yapar ve
dolayısıyla daha iyi koruma sağlar.
• Bu ileri teknolojiler sayesinde, bir legal network
trafiğindeki gömülü ataklar, ki onlar bir güvenlik duvarı
üzerinden - tespit edilebilir ve hasar meydana
getirmeden önce potansiyel olarak - iptal edilebilir.
Ağ güvenlik seviyesinin pozitifleri
• Güvenlik Açığı yöneticileri, bir ağdaki güvenlik açıklarını kontrol
sürecini otomatikleştirmek için kullanılırlar.
• Bu tür kontroller manuel olarak yapılsaydı – güvenliği sağlamak
için gerekli olan çalışma- pratik olmazdı. Ayrıca, ağlar
dinamiktir. Yeni cihazlar, uygulama yükseltmeleri ve yamalar, ve
kullanıcı ekleme ve çıkarma, yeni güvenlik açıkları tanıtmak v.b.
• VA (Vulneratibilty assestment – Güvenlik açığı değerlendirme)
araçları, yeni tanıtılan ağ için sık sık ve iyice güvenlik açıkları
taraması sağlar.
• Ağ erişim kontrolü çözümleri, ağ içine tehlikeli bir arka kapıları
kapatmak açısından da çok önemlidir.
DİKKAT EDİLECEK HUSUSLAR
• Ağ düzeyi güvenlik önlemlerinin başarısı biraz dahili ağ bağlantı
hızına bağlıdır. Çünkü, IDS / IPS, güvenlik açığı yönetimi ve ağ
erişimi/ kimlik kontrol araçları korunacak ağların kaynaklarını
tüketir.
• Artan bağlantı hızları , genel ağ performansı üzerinde bu
koruma performansını düşürür.
• Bu teknolojilerin uygulanmasında geliştirilmiş güvenlik ve
fiyatlandırma ilişkisini düşünmek gerekir.
• Bu ürünlerin çoğu sürekli olarak yönetilmesi gereken, kullanım
kolaylığı , etkin bir şekilde gerçekleştirme, ağ üzerinde rahat
hareket, ölçeklenebilme gibi özellikleri gözetilmelidir.
Level3- Host Güvenliği
• Katmanlı güvenlik modelinde, Host seviyesi ile
bireysel cihazlar, sunucular, masaüstü bilgisayarlar,
switchler, routerlar gibi cihazların güvenliği
kasdedilir.
• Host seviyesi güvenliği; Host tabanli saldırı tespit
sistemleri (IDS), Host-tabanlı güvenlik açığı
değerlendirmesi (VA), Network erişim kontrolu,
anti-virüs yazılımları, Erişim kontrolü / kimlik
doğrulama gibi teknolojilerle sağlanır.
Host-based intrusion detection systems (IDS)
(Host temelli saldırı tespit sistemleri (IDS))
• Ana bilgisayar tabanlı(host) IDS'ler, ağ
IDS'lerine benzer şekilde çalışırlar. Tek farkı
biri ağ trafiğini biri host trafiğini izler.
• Ana bilgisayar tabanlı IDS'ler belirli
operasyonel özellikleri , ince ayarlanma özelliği
ile doğru uygulandığında yüksek dereceli
güvenik sağlar.
Host-based vulnerability assessment (VA)
(Host-tabanlı güvenlik açığı değerlendirme (VA))
• Host-tabanlı VA araçları, güvenlik açıkları için tek bir
ağ aygıtını tarar.
• Host-tabanlı VA araçları ince ayarlı ve son derece
doğru monitör cihazlarıdır.
• Bunlar son derece doğru olarak ve en az
performansla host kaynaklarını tararlar.
• Sadece Host cihazları için üretildiklerinden, düzgün bir
şekilde yönetildiklerinde mükemmel bir kapsama alanı
sunarlar.
Ağ erişim kontrolu – (Network access control)
• Ağ erişim kontrol çözümleri çifte görev
üstlenirler. Hem ağ korunması olarak (önceki
bölümde) hemde bireysel host cihazları için.
• Bu çözümler, ana makinayı, zararlı uygulamalar
ve enfeksiyonlar için sürekli kontrol eder.
• Bir çeşit anti-virüs, bireysel firewall gibi
güvenlik tedbirlerini ve güncelliğini’de denetler.
Anti-virus
• Ağ tabanlı anti-virüs araçlarının
yanısıra; Cihaza özel bir anti-virüs
uygulamaları, host’lar için önemli bir
defans uygulamasıdır..
Access control/authentication
(Erişim Kontrol/Kimlik Doğrulama)
• Kontrol / kimlik doğrulama, erişim kontrolü
tedbirleri , cihaz düzeyinde, cihaza yetkili
erişimi hakkı sağlayan en iyi uygulamadır.
• Sadece yetkili kullanıcılar için, yüksek düzeyde
bir güvenlik sağlanır.
Level3- Host Güvenliği seviyesinin pozitifleri
• Host tabanlı güvenlik teknolojileri; tek bir
cihazın fonksiyonel karekteristiğini karşılamak
için konfigüre edilebidiklerinden mükemmel
koruma sağlarlar.
• Host ortamı, yöneticilere ,Onların hassasiyeti
ve yanıt hızlı, güvenli çalışmasını sağlamak için
cihaz ayarlarını güncelleştirme için izin verir.
DİKKAT EDİLECEK HUSUSLAR
• Kendi giderleri ve işletme masrafları söz konusu
olduğundan; host tabanlı güvenlik cihazları mantıklı
dağıtılabilir olmalıdır.
• Genel bir kural olarak, önemli kuruluşlar bu önlemleri
almadan önce, sadece 'taç mücevherlerinin‘
bulunduğu kendi özel ağ yapılarını kurarlar.
• Bu kuralın istisnası, bir ağ erişim kontrolü
çözümü, genellikle her masaüstü ve çıkış arasında
görev yapacak bir dizüstü ağa erişim sağlamak için
çalıştırılır..
LEVEL 4: APPLICATION SECURITY (Uygulama seviyesi güvenlik)
• Uygulama düzeyinde güvenlik, şu anda büyük bir ilgi alanıdır. Çünkü
Kötü korunan uygulamalar gizli verilere ve kayıtlara kolay erişim
sağlar.
• Acı bir gerçektir ki; birçok programcı programını yazarken güvenlik
kodlamasını aklına bile getirmemektedir.
• Çoğu kimsede yazdığı programın saldırılara karşı güçsüz olduğunu
bildiği halde tedbir düşünmez.
• Uygulamalar, Web ‘e müşteriler tarafından erişim için konuyor.
Satış gücü, müşteri ilişkileri gibi kolaylıklar sağlayabilen bu
uygulamalar, saldırganlar için hazır bir hedef sağlayabilir.
• Bu nedenle, özellikle her biri için kapsamlı bir güvenlik stratejisi
empoze etmek, önemli bir güvenlik uygulamasıdır.
• Uygulama zırhı (Application shield), Erişim kontrol/Kimlik
denetlemesi, Giriş Doğrulama (Input validation) gibi teknolojiler bu
katmanda koruma sağlamak içindir.
Application shield (Uygulama Zırhı)
• Uygulama seviyesi güvenlik duvarı olarak
görülebilir.
• Bu gelen ve giden legal istekler için uygulama
izininin verilmesini sağlar.
• Genellikle Web sunucuları, e-posta sunucuları,
veritabanı yüklü sunucular, ve benzeri
makinelerde uygulama koruması için en uç
cihazlar ile bütünleşik kullanıcılar için yapılır.
• Bir uygulama kalkanı, ana cihazdan beklenen
işlevselliğin ince bir şekilde ayarlanmasıdır.
• Örneğin, bir e-posta sunucusundaki uygulama
kalkanı muhtemelen gelen bir e-posta iletisi
yasaklamak için yapılandırılabilir değildir.
Çünkü otomatik olarak, herhangi bir
yürütülebilir başlatıyor tipik veya Email işlevini
gerekli .
Access control / authentication
• Erişim kontrol / kimlik doğrulama teknolojisi -
ağ ve host seviyesinde olduğu gibidir.
• Kimlik doğrulama, yalnızca yetkili kullanıcıların
erişebildiği uygulamadır.
Input Validation (Giriş Doğrulama)
• Giriş doğrulama tedbirleri , ağın üzerinde seyahat
eden uygulama girişlerini denetlemek , doğrulamak
içindir.
• Bu Web tabanlı giriş için hayati önem taşır.
• Genel olarak, Web sunucusu ile herhangi bir etkileşim
için güvenli olmalıdır.
• Bir örnek olarak, bir posta kodu alanı olan bir Web
formu düşünün. Sadece bu alanda kabul edilebilir bir
giriş, beş karakter olmalıdır. Yalnızca rakam. Diğer tüm
giriş engellenmeli ve bir hata mesajı üretilmelidir. Giriş
doğrulama birden fazla seviyelerde sağlanabilir.
Uygulama güvenlik düzeyinin pozitifleri.
• Uygulama düzeyinde güvenlik önlemleri, genel
güvenliğini artırmak ve uygulamaları daha iyi
kontrol etmek için izin verirler.
• Ayrıca birçok eylemleri izlemek,
kaydedebilmek için daha yüksek düzeyde bir
hesap sağlanır
Uygulama güvenlik düzeyinde dikkat edilecekler.
• Kritik noktalar için uygulamaları öncelik ve
uzun vadeli planlama.
• Uzun vadeli planlama kontrollü bir şekilde
güvenlik önlemleri sağlar.
• Ağınız büyüdükçe ve ek masrafları ortadan
kaldırır güçlendirme muhtemelen gerekecektir.
LEVEL 5: DATA SECURITY (Veri Güvenliği)
• Veri düzeyi güvenlik, bir şifreleme politikası gerektirir.
• Network’te seyahat eden Şifrelenmiş veri diğer
güvenlik önlemleri aşılmış olsa bile güvenlik sağlayan
bir yöntem olarak görülebilir.
• Güçlü şifreleme programı, özel verileri korur.
• Veri güvenliği, organizasyon çapındaki güvenlik
politikalarına son derece bağımlıdır.
• Verilere erişimi kimin idare edeceği, kullanıcılar hangi
yetkilere sahip olacağı, kendi bütünlüğü v.b
• Şifreleme , erişim kontrol / Kimlik doğrulama
teknolojileri bu sevide koruma işlemi yapan teknoloji…
Encryption (Şifreleme)
• Veri şifreleme programları yaygın olarak ,
veri, uygulama ve işletim sistemi
seviyelerinde uygulanmaktadır.
• Tüm şemalarda, veriye erişebilmek için
şifreleme / şifre çözme anahtarlarını
gerekir.
• Ortak şifreleme stratejileri PKI, PGP, RSA
Kriptografi (Şifreleme)
• Kriptografi, veriyi yalnızca okuması istenen şahısların okuyabileceği bir
şekilde saklamak ve göndermek amacıyla kullanılan bir teknolojidir.
• Şifreleme, iletişim sırasında verinin güvenliğini sağladığı gibi,
değiştirilmesini önleyici bir tedbirdir (İçerik tabanlı koruma). Şifreleme
de veriler şifrelenerek anlamsız hale getirilip hedefe gönderilir. Hedefte
ise tam tersi işlem yapılarak (Deşifreleme) orijinal haline çevrilir.
• TCP/IP protokolu verinin doğru adresi bulup ulaşmasını ön plana
aldığından ağ güvenliği konusu pek düşünülmez. Bu protokol, paket
verilerini açık metin olarak gönderir. Dolayısıyla, ağda dinleme yapan
bir nokta bu verilerin içeriğini görebilir veya değiştirme işlemi yapabilir.
• Aşağıda bazı açık metin(Clear text ) kullanan protokollar görülmektedir.
•Şifreleme, bu açıkları büyük ölçüde giderebilir.
• Kriptografi’de veri, matematiksel yöntemler kullanılarak kodlanır ve başkalarının
okuyamayacağı hale getirilir. Bu matematiksel kodlamaya “kripto algoritması” adı
verilir.
• Bir şifreli haberleşme için mekanizma aşağıdakilerden oluşur.
• 1-Şifreleme Algoritması
• 2-Deşifreleme Algoritması
• 3-Anahtar
Ödev: Simetrik ve Asimetrik algoritma kullanılan şifreleme
tekniklerinin incelenmesi (Rapor ve en az 25 slayt’lık sunu)
• Kripto sistemleri,Gizlilik, Veri Bütünlüğü, Kimlik Sınaması ve
İnkâr Edememe hizmetlerinde kullanılır.
Sayısal İmza ve PKI
• Sayısal imza , Kimlik Sınaması ve Veri Bütünlüğü prensiplerinin
gerçekleştirilmesinde kullanılırlar (İçerik Tabanlı Güvenlik).
• Bir sayısal imza, şifrelenmiş bir özet (hash) değeridir. Sayısal
imzalar yardımıyla, alıcı taraf göndericinin kimliğinin sınamasını
yapar ve göndericinin kim olduğundan tam olarak emin olur.
• Bunun yanında, sayısal imza teknolojisi, gönderilen verilerin
bütünlük sınamasında da kullanılabilir.
• Sayısal imzalar, gerçek hayatta kullanılan ve elle atılan imzanın
(ıslak imzanın) bilişim dünyasındaki karşılığı olarak görülebilir.
• Bir sayısal imza, imzaladığı içeriğin, imzalandığı andan itibaren
değişmediğinin kanıtlanmasında kullanılabilir
Ödev: sayısal İmza teknolojisi, yapısı
Algoritmaları?
• Sayısal İmza oluşturma Süreci
Erişim kontrol / kimlik denetimi
(Access control/authentication)
• Erişim kontrol /Kimlik denetimi; ağ, host
ve uygulama düzeyinde kimlik
doğrulaması, yalnızca yetkili kullanıcıların
verilere erişimi için kullanılır.
pozitifleri
• Şifreleme, verileri korumak için kanıtlanmış bir
yöntem sağlar.
• Davetsiz misafirlerin bilgisayarınızdaki tüm
diğer güvenlik önlemlerinden sonra
şifrelemeyle koruyan bir son, etkili bir bariyer
sağlar.
• Özel bilgi ve fikri mülkiyet.
Dikkat edilmesi gereken husular
• Verileri Şifrelemek ve deşifrelemek işlemleri, önemli
performans etkilerine (negatif yönde) neden olabilir.
• Ayrıca, anahtar yönetimi, büyük bir idari yük haline
gelebilir veya kuruluşlar büyüdükçe bu işlemler
dahada karmaşıklaşır.
• Derinlemesine veri şifreleme dikkatle yönetilmesi
gerekir. Şifreleme anahtarları etkilenen tüm cihazlar
için senkronize olmalıdır.
Örnek
• Bir banka, müşterilerine internet bankacılığı
hizmeti sağlamak istiyor.
• Bu hizmetler; önceden programlanmış web
sayfaları ve uygulamalarıdir.
• Her müşteri, kendi hesabına erişmek için bir id ve
şifre bilgisine sahiptir.
- Tehditler(Threads) nelerdir?
- Önlemek için güvenlik mekanizmaları nelerdir?
- Güvenlik Servisleri nelerdir?
Örnek bir seneryao
Güvenlik Atakları
• Pasif Ataklar – İletişimin dinlenmesi veya izlenmesi
(eavesdropping on, or monitoring of, transmissions to)
– Mesaj içeriklerinin elde edilmesi için
– Ağ trafiğini izlemek veya durdurmak
• Aktif Ataklar: – Veri akışının değiştirilmesi
– Bir olayın diğerlerinden maskelenmesi.
– Bir mesajın uydurulması (fazladan)
– Önceki mesajların tekrarlanması
– Yoldaki mesajların değiştirilmesi
– Servilerin aksatılması.
Tehditler
Saldırı Hedefleri
• Müşteri bilgisayarı
- DoS
- Kötü amaçlı kodları: Virüs, Worms
- Saldıran bilgisayarın kontrolünü alabilir
• Müşteri - Web Sunucu iletişim
- Dinleme
- Man-in-the-middle
- mesajları, değiştirme, ekleme ve silme
- Session Hijacking
- DoS: SYN saldırı
• Internet Altyapısı
- Dinleme
- BGP saldırıları
- Router OS saldırılar
- DoS
Saldırı hedefleri
• Web Sunucusu
- Yığın (Stack) parçalanması
- Taşınabilir programlar
- IP spoofing
- Güvensiz Hizmetler
- Kötü amaçlı kodları: Virüs ve solucanlar
- DoS: SYN saldırısı, ping sel.
• Banka Network ve Sunucular
- Erişmek için arka kapı kullanımı.
- Dinleme,
Man-in-the-middle: Bankacılık Server Web Server
- Session Hijacking
- DoS
- DNS saldırısı
- Diğer sunucuların güvensiz servisleri kullanması
- Diğer sunuculara kötü niyetli kodların yüklenmesi.
• DNS sunucuları
- DNS önbellek zehirlenmesi
- DNS DoS atakları
Müşteri Bilgisayarındaki önlemler
• Fiziksel güvenlik
• Güçlü Şifreleme
• OS(İşletim sistemi) güvenlik yamaları
• Uygulama güvenlik yamaları
• Güvensiz hizmetlerin yerine göre iptali.
- Telnet, ftp, nfs
- Rpc, uzaktan komutları (rlogin, rsh, ...)
- Dns, web
• Tarayıcı (Browser) konfigürasyonu:
- Cep telefonu kodları otomatik olarak kabul etmemek
- Varsayılan olarak güçlü kripto algoritmaları Seçimi
• Personel Güvenlik Duvarı
- İsviçre peyniri değildir!!! dikkatli bir şekilde
yapılandırılmış olması gerekir
• Virüs koruma ve tarayıcılar
Müşteri-Web Sunucu iletişimi için önlemler
• Kimlik Doğrulama
- UserID / Password: "Bildiğiniz"
- İstemci Sertifikası: "Size verilen“
- Çalıntı istemci sertifikalarını önlemek için;
• Kısa yaşam süresi, Kullanışlı değil!
• Ön sertifikalı Kullanıcı Kimliği (ID) : Aşağıdaki şatlarda kabul edilir.
»Yetkisi kontrol edilir
»Son kullanma tarihi kontrol edilir
»Kara liste kontrol edilir. (sertifika iptal listesi)
»Kullanıcının doğruluğu, sertifikayla ilişkili özel anahtardaki
kendi bilgisi ile kanıtlanır.
- Kullanıcı, sertifikada saklanan kullanıcı kimliği ile eşleşen bir
kullanıcı ID’si ve doğru şifreyi girmişse;
- Sunucu bunu onaylar: Bir oturum zamanlık anahtar üretir.
(Gizliliği sağlayan şifre veya özel anahtarın üretilmesinin istenmiyorsa )
Müşteri-Web Sunucu iletişimi için önlemler
•Gizlilik ve Bütünlük (Confidentialty ve integrity)
- Anahtar değişimi;
• Kimliği doğrulanan, kimlik doğrulama işlemi
sürecinin bir parçası olmalıdır.
• Sadece “Bir oturum yaşam sürelik” olmalıdır.
- Güçlü kripto algoritmaları;
• Müşteri ve banka tarafında erişim kontrolu
için.
Müşteri-Web Sunucu iletişimi
Internet Altyapısı için düzenlemeler
• Router OS düzeltmeleri
• Güvensiz yönlendiriciler servisler
• Saldırı Tespit Sistemleri
• Erişim listeleri
• Omurga güvenlik duvarları
• Güvenli BGP
• Alternatif bağlantılar ve yollar
• Dikkatli sistem yöneticileri için: aksilikler
oluşamaz!!!!!!!!!!!!!
Şirket Ağının Korunması
• Router, anahtar ve sunucuların Fiziksel güvenliği.
• Router, switch, dosya ve uygulama sunucusu
- OS güvenlik düzeltmeleri
- Uygulama güvenlik düzeltmelerini
• Güvensiz dosya ve uygulama sunucuları servisler
• Virüs koruma ve istemciler ve sunucular üzerindeki tarayıcılar
• Arkakapıları yoketmek
- DMZ Erişim sunucularının güvenlik duvarları arkasında
- VPN / IPSEC, bir kez şifreler ve erişim kontrol Belgesi
- Erişim kontrolleri
•Dahili istemci-Sunucu iletişiminde kimlik doğrulama ve gizliliğin
- IPSEC
- Kerberos
- Ithal uygulaması ile dikkatli olun
• Bankacılık sunucuları için Firewall koruması
• Dikkatli sistem ve ağ yöneticileri, aksilikler. Olmaz!!!!!!
• Güvenli DNS
• Intrusion Detection System
WEB Server Koruması
•Fiziksel güvenlik
• OS güvenlik düzeltmeleri
• Uygulama güvenlik düzeltmelerini
• Güvensiz hizmetleri tanıma
• Virüs koruma ve tarayıcılar
• Güvenli müşteri erişimi
- SSL
- sunucu sertifikası
- Zayıf olanları silme, varsayılan olarak güçlü bir kripto fonksiyonlarının ayarı
• Yerel depolama yok
- Bankacılık ve finansal veriler
- Güvenlik ile ilgili kritik bilgileri
• Güvenlik duvarı arkasında De militarize Zone (DMZ) bulundurulması
• Güvenli Web sunucusu banka sunucu iletişimi
- IPSEC
- İşlem tabanlı kimlik doğrulama, işlem çift kontrolleri
•Secure DNS
DNS Sunucularda durum
• En son BIND sürümleri, güvenlik yamaları
• DNS yapılandırması
- Zone aktarımı yapmayınız.
- DNS sunucularında OS, Uygulama, güvensiz
hizmetlerini takip ediniz.
• DNS DMZ güvenlik duvarı arkasında olmalı
• Secure DNS
• Dikkatli sistem yöneticileri hiçbir aksilikle
karşılaşmazlar!
Sonuç Resim
3- OSI MODELİ KATMANLARAÇIKLAR-SALDIRILAR-ÖNLEMLER
Fiziksel + Veri Bağı Katmanı
Açıklar-Saldırılar-Önlemler
Bilgisayar Ağlarında Katmanlı Modelleme açısından Güvenlik
• Bilgisayar ağlarında güvenlik konusu, ağ bilgisayarlarındaki ve iletişim halindeki verinin
Gizlilik, Bütünlük, İnkar edememe ve kullanılabilme özelliklerini bozmak için yapılan
(illegal olarak) saldırılar ı önlemektir.
• Bu saldırılar, ağ iletişim protokollarının açıklarından, ağ cihazları ve iç/dış ağ
erişiminin tam olarak denetlenememesinden, güvenlik politikalarının iyi
oluşturulamamasından kaynaklanmaktadır.
• Özellikle TCP/IP iletişim protokol kümesiyle çalışan internet gibi dinlenmeye çok
müsait ağ yapılarında seyahat eden verilerin hertürlü saldırıya açık olduğu
bilinmektedir.
• Ağ güvenliği konusu üç farklı segment’te incelenecektir.
1- İletişim protokolları açıklarından yararlanarak yapılan saldırılar ve tedbirler.
2- İlgili Güvenlik protokollarının uygulanması
3- Sistematik güvenlik (İç ağ/Dış Ağ koruma)
• Bu derste TCP/IP ve OSI katmanlı ağ modeli ve ilgili katman protokolları ve bunların
zayıflıkları üzerinde durulacaktır. Bu zayıflıklardan yararlanılarak yapılacak saldırılar ve
tedbirleri nelerdir?
• İlgili ağ cihazlarının korunması ve cihazların uygun konfigürasyonları ile ağ güvenlik
açıklarının azaltılması üzerinde durulacaktır.
TCP/IP ve OSI Modeli
TCP/IP beş katmanlı bir mimariye sahiptir. TCP/IP protokol teknolojisinden farklı
çalışan ağlar içinde modelleme yapabilmek için OSI modeli kullanılır.OSI
modeli 7 katmanlı bir modeldir.
OSI mimarisi TCP/IP mimarisine oldukça benzer. OSI’nin uygulama ve sunum
katmanı TCP/IP ‘nin Uygulama katmanına denk düşer. OSI’nın sunum ve
Transport katmanı TCP/IP’nin Transport katmanına denk düşer. Diğer katmanlar
aynıdır. Her iki modelin yapısı ve özeti aşağıda verilmektedir.
Farklı iletişim protokollu ağlar arası geçiş için GATEWAY’lar kullanılır.

Katman Tarif ve Anahtar Kelime Protokol Ağ elemanı Kapsülasyon
Uygulama
Application
* Kullanıcının ağdan istediği
hizmetlerin tarif edilmesi için yazılım
arayüzleri.
* İletişim partnerinin tanımı
• HTTP
• Telnet
• FTP
• TFTP
• SNMP
Kullanıcı bilgisi ve
DATA
Sunum
Presentation
*Veri formatlama (dosya formatları)
*Şifreleme, Deşifreleme,
dönüştürme, sıkıştırma ve açma
*Veri formatı değiştirme
* İleteşek düğümler arasındaki format
ve işlem dönüşümleri yaparak
gönderici ve alıcı uygulama
katmanlarının kendi bildiği dili ve
formatı kullanmasını sağlar.
• JPEG,
BMP,
TIFF,
PICT
• MPEG
WMV,
AVI
• ASCII,
EBCDIC
• MIDI,
WAV
DATA
Oturum
Session
* Farklı hizmet istekleri için oturum
tanımları yapılarak veri akışlarının
biribirine karışmamasını sağlar.
* İletişim oturumlarının bakımını ve
kontrolunu yapar
• SQL
• NFS
• ASP
• RPC
• X
window
DATA
Taşıma
Transport
*Güvenilir (bağlantı yönlü) ve güvenilmez
(bağlantısız) iletişim
*Uçtan uca akış kontrolü
*Bağlantı noktası ve soket numaraları
*Segmentasyon, sıralama ve kombinasyon
• TCP
(Bağlantılı)
• UDP
(Bağlantısız)
SEGM
ENT
Ağ
Network
*Mantıksal adresler (IP v.b)
*Yol (Rota) belirleme ve seçme
* Ağlar arası Paket gönderme
• IP
• IPX
• AppleTalk
• DECNET
• Routers
• Layer 3 switches
PACKET
Veri Bağı
Data Link
LLC
*Bitleri bayt’a baytları Çerçeveye çevirir.
*MAC adresi, fiziksel adresi kullanır.
* LAN teknolojilerini tarif eder
* Ortama erişimi kotarır
* Akış kontrolunu yapar Flow control
* ACK/Buffer
* Pencereleme
* Parity ve CRC kontrol işlemeleri
• LAN protocols
802.2 (LLC),
802.3 (Ethernet),
802.5(Token
Ring),
802.11(Wireless)
• WAN protocols
HDLC,PPP,
Frame Relay,
ISDN
• (NIC)
transceivers
• Switch
• Bridge
FRAME
MAC
Fiziksel
Physical
* Bit düzeyinde medyada hareket
* Kablo,konnektör,pin bağlantı pozisyonları
* Sinyal senkronizasyonu, bit düzeyinde
* Fiziksel ağ topolojisi
• EIA/TIA 232
(serial
signaling)
• V.35 (modem
signaling)
• Cat5
• RJ45
• Transmission media
(cable and wires)
• Mediaconnectors
• Transceivers built
into NICs)
• Modems
• Repeaters
• Hubs
• Multiplexers
• CSUs/DSUs
• Wireless Access P
BİT
Fiziksel Katmanda Gizlilik/Bütünlük
Fiziksel Çevreden kaynaklanabilen sorunlar (Açıklar)
• Ağ ortamının çok katlı binalarda oluşturulması veya herkesin
ulaşabileceği yerlerden geçmesi.
• Ağ cihazlarının konulduğu oda veya kabinlerin güvenlik altına
alınmaması.
• Herkesin erişebileceği bir ağ altyapısı veya elektrifikasyon
altyapısı.
• Elektromanyetik ortam
• Elektrik Kesintilerine karşı önlemlerin alınmayışı (KGK’lar)
• Tehdit: Ağ hizmetlerinin verilememesi, verilerin
dinlenmesi, değiştirilmesi yok edilmesi ihtimalinin
varlığı.
THİN ETHERNET (çok az kullanılmaktadır)
• Tek bir kablo ile iletişimin sağlanması
Güvenlik Açığı: Tüm cihazlar için bilgi yayını.
Tehdit: Bilgi Sızıntı, Yanlış Kullanım
Güvenlik Açığı: Bir kablo arızası ağı devre dışı bırakır.
Tehdit: Denial of Service
• Kolay yükleme ve ek aygıtlar takabilme
Güvenlik Açığı: Herkes ağa dahil olabilir.
Tehdit: Yanlış kullanım.
Thin Ethernet
UTP ve Hub
• Hub ve cihaz arasındaki ortam tek bir kablodur.
• Ek cihazlar sadece hub’a eklenebilir.
• Ayırma / kablo kopması nadiren diğer aygıtları etkiler
• Kolay kurulum
– Kablonun indüktansından dolayı veri işaretleri etkilenebilir.
– Ethernet kablosuna, herhangi bir yerden girilerek bilgiler dinlenebilir.
– Uygun kablo kullanılmamışsa, Kablo bir manyetik alandan geçiyorsa veri
işaretlerinde bozulmalar olabilir.
hub
10/100BASE-T
UTP
HUB
• HUB’da veri herkese (Broadcast) yayınlanır.
Güvenlik Açığı: tüm cihazlar için bilgi yayını.
Tehdit: Bilgi kaçağı, Yanlış Kullanım
Güvenlik Açığı: Herkes hub'a takabilirsiniz.
Tehdit: Yanlış kullanın.
Fiziksel Katmandaki diğer medya
• Radyo frekanslı dalgalar ( Wireless LAN)
– Ağ iletişimi kullanılan radyo dalgaları 1-20GHz arasındaki
mikrodalgalardır. Bu işaretler taşıyıcı işaretlerdir .
– Radyo sinyalleri, girişime, tahribata, dinlenmeye uygundurlar.
– Bulunduğu yayın alanında izinsiz dinlemelerin (Jamming)
engellenmesi çok zordur.
– Eğer taşıyıcının frekansı aralıklı olarak değiştirilirse, bilginin
başkası tarafından dinlenmesi engellenmiş olabilir.
• Fiber Optik
Hub ve cihaz arasındaki kablo tek ortamdır.
- Kablo kurulumu ve çekilmesi zordur. Ek yapılması zordur.
-Çok yüksek hızlarda çalışır.
– Dinlenmesi zordur.
– Magnetik ortamdan etkilenmez.
Veri bağı (Data Link Layer) Katmanı
Protokollar – açıklar- Saldırılar-Savunmalar
 Hostlar ve routerlara node
diyeceğiz.
 Komşu düğümler arasındaki
fiziksel iletişim ortamlarına
(yollarına - kanallarına) LİNK
diyeceğiz.
 Telli linkler
 Telsiz Linkler
 LAN’lar
DLL katmanı PDU = frame (Çerçeve)
“link”
Veri bağı katmanı, bir düğümden bitişik düğüme
bir LİNK üzerinden datagram aktarmakla yükümlüdür
12
DATA LİNK LAYER (DLL)’in önemi
Veri bağı katmanı (DLL) ağdan, ağ cihazına (Switch, router, host,
sunucu v.b) gelen çerçevelerin; kimlik filtreleme, erişim kontrol listeleri, kimlik
doğrulama, çerçevenin hatalı gelip gelmediği v.b uygulamaların ilk yapıldığı
katmandır. Çerçevenin üst katmanlara erişimini filtreleyen katmandır.
Ağ cihazındaki veya ağa bağlı hostların ağa göndereceği verilerin en
son olarak kontrol edilip kapsüllendiği (çerçeve haline getirmek) yerdir.
Ağ katmanına ara servisi sağlanması
Çerçeveleme işlemi
İletim hatalarının sezilmesi ve kontrolu
Veri akışının düzenlenmesi
Yavaş Alıcılar hızlı göndericiler tarafından sıkıştırılmaz.
Ortama erişimin kotarılması (fiziksel adresleme),
Fiziksel katmandaki bit dizisi akışını
anlamlı bit guruplarına (Çerçeve-Frame) dönüştürme
Veri bağı katmanı Protokolları
Veri Bağı katmanı protokoları, LAN ve WAN ağ yapıları için
farklı farklıdır. Saldırı ve açıklar ve güvenlik protokollarının’da
LAN veya WAN DLL protokollarına göre incelenmesi uygundur.
En çok kullanılan Veri bağı LAN protokolları
– Ethernet
– Token Ring
– FDDI
Sık kullanılan WAN veri bağı protokolları
• PPP (point to point protocol)
• HDLC (High Level Data Link Control)
• Frame Relay
• ATM (Asychronus Transmısion Mode)
TCP/IP açısından Veri bağı katmanına bakış (LAN)
Application Layer
Transport Layer Network Layer (Data) Link Layer
•Aslında OSI başvuru modelindeki
Fiziksel katman ve Veri bağı
katmanı, bir yerel ağdaki süreci
tanımlamaya yeterlidir.
Logical Link
Control (LLC)
Media Access Control (MAC)
Sublayer in Local Area Networks
Network katmanından aldığı veri paketlerine
hata kontrol bitlerini ekleyerek çerçevelere
(frame) bölünmüş halde fiziksel katmana
iletme işinden sorumludur.
Yani iletim ortamına erişim Veri bağı
katmanının görevidir.
• Veri bağı katmanı ağ üzerindeki diğer bilgisayarları tanımlamasını, kablonun o anda
kimin tarafından kullanıldığının tespitini yapabilir.
• Ayrıca iletilen çerçevenin doğru mu yoksa yanlış mı iletildiğini kontrol eder, eğer
çerçeve hatalı iletilmişse çerçevenin yeniden gönderilmesini sağlar. Yani hat üzerinde
oluşan hata bu katmanda sezilir (ARQ ).
• Bu katmanda iletilen çerçevenin hatalı olup olmadığını anlamak için CRC (Cyclic
Redundancy Check yöntemi kullanılır.
• Veri bağı katmanı iki alt bölüme ayrılır:
Media Access Control (MAC)
MAC alt katmanı veriyi hata kontrol kodu(CRC), alıcı ve gönderenin MAC adresleri ile
beraber oluşturup, fiziksel katmana aktarır. Alıcı tarafta da bu işlemleri tersine yapıp
veriyi veri bağlantısı içindeki ikinci alt katman olan LLC'ye aktarmak görevi yine MAC
alt katmanına aittir. MAC katmanı, aynı zamanda fiziksel adresleme bazında, verinin
çoklu ortam üzerinden alıcısına ulaşmasından da sorumludur.
Logical Link Control (LLC)
LLC alt katmanı bir üst katman olan ağ katmanı için geçiş görevi görür. Protokole özel
mantıksal portlar oluştururarak (Service Access Points, SAPs) gönderici ve alıcı tarafın
aynı protokoller iletişime geçebilmesin sağlar(örneğin TCP/IP<-->TCP/IP). LLC ayrıca
veri paketlerinden bozuk gidenlerin(veya karşı taraf için alınanların) tekrar
gönderilmesinden sorumludur. Flow Control yani alıcının işleyebileğinden fazla veri
paketi gönderilerek boğulmasının engellenmesi de LLC'nin görevidir.
• Veri bağı katmanı saldırılarının büyük bir kısmı;
iletişim sırasında doğru kimlik doğrulama eksikliğine
dayanır.
• Bir LAN’da (İkinci katman) en yaygın saldırılar, örneğin
CAM (Content Address Table – Switch MAC tablosu)
tablosu taşması, VLAN hoping, Spanning Tree
Protokolü (STP) manipülasyonu, ARP önbellek
zehirlenmesi, DHCP Starvation, Cisco Keşif Protokolü
(CDP) saldırıları olarak sayılabilir..
Local Area Networks
• LAN’larda ortama erişim paylaşımlı kullanım şeklidir. Birçok
ortama erişim yöntemi (Ethernet, Token Ring, ATM v.b)
mevcuttur.
Bus LAN Ring LAN
IEEE 802 Standartları
•IEEE 802 bir LAN
standartıdır. Bu
standartta LLC katmanı
ve değişik MAC alt
katmanlar tanımlanır.
•802.3 Ethernet
•802.4 Token Bus
•802.5 Token Ring
•902.11 Wireless LAN
802.3
802.4
802.5
802.11
802.2 802.1
IEEE 802 standard
Medium Access Control Physical Layer
Logical Link Control
IEEE Reference Model
Physical Layer
Data Link Layer
Higher Layer
Ethernet Çerçeve Formatı
CRC Dest.
Addr
.
Src.
Addr Data
IP datagram
ARP request/reply
RARP request/reply
Type
6 6
2 18
PAD
46-1500
28
0800
0806
8035
Type
Type
Type
28 18
PAD
2
2
2
46-1500
4
LANLAR’DA Adresleme
• Bir Ağ içerisindeki iki bilgisayarın biribirleriyle
haberleşebilmesi için Fiziksel Adreslerinin
bilinmesi gerekir.
Fiziksel Adresleme
• Ağdaki cihazların değişmez gerçek adresleri olarak tarif edebiliriz. NIC
kartlarının belleklerinde yazılırlar. Ethernet teknolojisinde 48 bit
uzunluğunda MAC (Media Acces Control)dır.
• Veri bağı katmanında adresleme sağlanır.
• Aynı ağ içerisinde bu adreslemeye göre çerçeveler yerine ulaşır.
SWİTCH’ler
• Veri bağı katmanının en önemli görevlerinden
birisi de lokal adresleme yapmaktır. Bu katmanda
bu işi Switch’ler yapar.
- Fiziksel Adreslere (MAC v.b) göre.
• Ethernet, paketleri herkese yayınlar.
2. katmanda paket süzme işlemi;
– Hangi MAC adresi switc’hin hangi portunun arkasında
olduğunun öğrenilmesi.
– Paketi sadece uygun porta geçirme işlemi.
24
Switch işlemleri
• Bir çerçeve Switc’he geldiğinde
– Switch, tablosundan bu çerçevenin gideceği hedef
adresin hangi portta olduğuna bakar. İlgili porta
çerçeveyi gönderir.
• Switch’lerin (Transparent v.b) MAC tablolarının nasıl
doldurduklarının hatırlayınız????????
• Switc’ler akıllı cihazlardır.
– Traffik izleme, fiziksel adres bazında yönlendirme ve
uzaktan konfigüre edilebilme özelliğine sahiptir.
• Switch 2.katman cihazıdır.
Switch’ler
•Switch’ler veriyi sadece hedef alıcıya (Fiziksel adrese)
gönderir. Switch’in üzerinde bir adres-port tablosu tutulur.
Buna CAM (Content Addressable Memory) de denir.
Örnek: Cisco 3550 serisi switch MAC adres tablosunda
8192 tane MAC adresi bulundurabilmektedir.
• MAC adresleri MAC adres tablosunda belirli bir süre
(Örneğin 300 saniye) tutulur sonra silinir.
00:0e:81:10:19:FC
MAC address
2 00:0e:81:32:96:af
Device
1
3 00:0e:81:31:2f:d7
4 00:0e:81:97:03:05
8 00:0e:81:10:17:d1
•Ağ saldırıları denince öncelikle OSI’nin üçüncü (Ağ Katmanı) ve daha yukarı
katmanlarıyla ilgili ataklar akla gelmektedir. Fakat ikinci katman atakları da en az
üst katmanlara yönelik yapılan ataklar kadar etkili olabilmektedir.
• İkinci katman atakları yerel alan ağlarının içinden (LAN) yapıldığı için güvenlik
duvarı ya da saldırı engelleme / tespit etme sistemleri tarafından
engellenememektedir / tespit edilememektedir. Çünkü bu sistemler genellikle
üçüncü ve daha üst katmanların güvenliği için tasarlanmıştır.
• Ayrıca saldırı tespit veya engelleme sistemleri genellikle dış ağdan iç ağa
gelebilecek saldırıları tespit ya da engellemek için kullanılmaktadır. Bu sistemlerin
iç ağda yer alan bir saldırganın, yine iç ağda yer alan anahtarlara yapılacak
saldırıları tespit edebilme / engelleme gibi bir şansı yoktur.
•Ağ güvenliği tüm OSI katmanlarının güvenliğinin ele alınmasıyla asıl amacına
ulaşacaktır. Üst katmanların güvenliğinin alınıp, ikinci katman güvenliğinin ele
alınmaması ağ güvenliğinin tam anlamıyla anlaşılamadığını gösterir.
İkinci Katman Saldırıları
1. MAC Adres Atağı
• Anahtar, portlarına gelen bir çerçevenin (frame) hedef MAC adres
kısmına bakarak bu hedef MAC adresinin kendi MAC adres
tablosunda olup, olmadığına karar verir. MAC adresini tabloda
bulursa çerçeveyi ilgili porta gönderir. Yapılan bu işleme switching
denir. Tüm ikinci katman anahtarları bu prensibe göre çalışır.
•Anahtarlama cihazlarının önemli bir zafiyeti, MAC adres
tablosunun dolması durumunda ortaya çıkar. Anahtarların MAC
adres tablolarının kapasitesi, cihazın marka, model ve donanımına
bağlı olarak değişebilir.
1. MAC Adres Atağı
• Anahtara gelen çerçevenin hedef MAC adresi, anahtarın MAC
adres tablosunda bulunmadığı durumlarda, anahtar çerçeveyi
(frame) tüm portlarına yollayacaktır. Peki bu nasıl gerçekleşir?
• Anahtarın MAC adres tablosunun tamamen dolu olduğunu
düşünelim ve anahtarın, beşinci portuna bağlı bir bilgisayardan
gönderilen çerçevenin (frame) hedef MAC adresinin, anahtarın
MAC adres tablosunda bulunmadığını düşünelim. Bu durumda
anahtar, beşinci portundan gelen çerçeveyi (frame) diğer tüm
portlarına yollayacaktır. Bu da ilgili beşinci porttan çıkan tüm
bilginin diğer portlara da gönderilmesi sonucunu doğuracaktır.
• Bu da saldırganın, anahtar üzerinde herhangi bir port
yönlendirmesi yapmadan, sadece anahtarın MAC adres tablosunu
sahte MAC adresleriyle doldurmak suretiyle, anahtar üzerindeki
tüm trafiği dinleyebilmesine yol açacaktır. Ayrıca anahtarın
performansı da düşecektir.
3. Sahte MAC (MAC Spoofing) Atağı
• Bu atak türünde saldırgan, anahtara gönderdiği
çerçevelerin (frame) içerisindeki “kaynak MAC adres”
kısmına, dinlemek istediği bilgisayarın MAC adresini
yazar.
• Anahtar MAC adres tablosunu bu duruma göre
günceller. Böylece anahtarın MAC adres tablosunda,
saldırganın bağlanmış olduğu anahtarın portu için iki
adet MAC adresi yer almış olur. (Saldırganın MAC
adresi ve hedef bilgisayarın MAC adresi) Hedef
bilgisayara gönderilen çerçeveler de (frame) de
böylece saldırganın bilgisayarına gönderilmiş olur.
• Hedef bilgisayar ağa paket gönderene kadar bu
durum devam edecektir.
Switch tablolarını sahte MAC adresleriyle doldurmak
(MAC FLOODİNG)
Buna MAC flooding (MAC taşması) atağı’da denir. Aşağıda normal bir switching tablosu
verilmiştir.
vlan mac address type protocols port
——- ————— ——– ——————— ——————–
20 000a.2281.61e4 dynamic ip GigabitEthernet1/1
20 000a.2201.9079 dynamic ip GigabitEthernet1/1
20 000a.22c0.ddf9 dynamic ip GigabitEthernet1/1
61 001b.2461.09f6 dynamic ip GigabitEthernet1/2
61 0040.ca79.8821 dynamic ip GigabitEthernet1/15
61 00d0.b7bc.3d2c dynamic ip GigabitEthernet3/34
61 0800.8e05.1bbc dynamic ip GigabitEthernet3/33
61 0800.8e05.39b7 dynamic ip GigabitEthernet3/35
Anahtarın MAC adres tablosunu sahte MAC adresleriyle doldurabilecek yazılımlar
mevcuttur. Anahtara bu yazılımlar ile saldırılıp MAC adres tablosu sahte adreslerle
doldurulabilir. Bu saldırıdan sonra anahtarın MAC adres tablosu aşağıdakine benzer bir
durumda olacaktır. Saldırganın portunun GigabitEthernet3/33 olduğunu düşünüyoruz.
vlan mac address type protocols destination port
——- ————— ——– ——————— ——————–
20 000a.2281.61e4 dynamic ip GigabitEthernet1/1
20 000a.2201.9079 dynamic ip GigabitEthernet1/1
20 000a.22c0.ddf9 dynamic ip GigabitEthernet1/1
61 001b.2461.09f6 dynamic ip GigabitEthernet1/2
61 0040.ca79.8821 dynamic ip GigabitEthernet1/15
61 00d0.b7bc.3d2c dynamic ip GigabitEthernet3/34
61 0800.8e05.1bbc dynamic ip GigabitEthernet3/33
61 0800.8e05.1aaa dynamic ip GigabitEthernet3/33
61 0800.8e05.1aab dynamic ip GigabitEthernet3/33
61 0800.8e05.1aac dynamic ip GigabitEthernet3/33
61 0800.8e05.1aad dynamic ip GigabitEthernet3/33
61 0800.8e05.1aae dynamic ip GigabitEthernet3/33
61 0800.8e05.1aaf dynamic ip GigabitEthernet3/33
61 0800.8e05.1ab0 dynamic ip GigabitEthernet3/33
……………………………………………………………………………………..
……………………………………………………………………………………..
61 0800.8e05.39b7 dynamic ip GigabitEthernet3/35
ÇÖZÜM:
• Bu saldırıdan korunmanın yolu çok basittir: MAC adresi kilitlemesi
( belirli bir MAC adresini kayıtlı bir IP adrsine eşleştirme). Ancak
bunun için elimizdeki anahtarın MAC adres kilitlemesi özeliğinin
olması gerekmektedir.
• Anahtarlarımızın portlarına MAC adresi kilitlemesi uygularsak bu
olası saldırıdan kurtulmuş oluruz. Aşağıda Cisco anahtarlar için MAC
adresi kilitlemesi örnek konfigürasyon satırları bulunmaktadır:
• (Aşağıdaki konfigürasyonlar sizin sistemlerinize uygun olmayabilir.)
• CISCO konfigürasyonu
• Anahtar(config)#interface range GigabitEthernet 3/2 – 48
• Anahtar(config-range)# switchport mode access
• Anahtar(config-range)# switchport port-security
• Anahtar(config-range)# switchport port-security maximum 3
• Anahtar(config-range)# switchport port-security violation restrict
• Anahtar(config-range)#switchport port-security mac-address sticky
Switchlerin önemli bir zafiyeti, MAC adres tablosunun dolması durumunda
ortaya çıkmaktadır.
Gelen çerçevenin (frame) hedef MAC adresi, anahtarın MAC adres tablosunda
bulunduğu takdirde anahtar bu çerçeveyi ilgili porta gönderecektir. Fakat anahtara
gelen çerçevenin hedef MAC adresi, anahtarın MAC adres tablosunda
bulunmadığı durumlarda, anahtar çerçeveyi tüm portlarına yollayacaktır.
Bu da saldırganın, anahtar üzerinde herhangi bir port yönlendirmesi
yapmadan, sadece anahtarın MAC adres tablosunu sahte MAC adresleriyle
doldurmak suretiyle, anahtar üzerindeki tüm trafiği dinleyebilmesine yol açacaktır.
Bu durum ayrıca anahtarın performansına da olumsuz etki edecektir.
Switch’lerde güvenlik Açıkları
… …
00:0e:81:10:19:FC
MAC address
4 00:0e:81:32:96:af
Device
1
00:0e:81:32:96:b1
4 00:0e:81:32:97:a4
1
2
4
9999
4
00:0e:81:32:96:b0 3 4
34
Koruma?
• Switchlerde fiziksel güvenlik
• Switchler çok sayıda gelen çerçeve süresince (su baskını) hata
yapabilirler.
– Tehdit: Denial of Service
Önlem:
1. Switch Tablosuna sadece statik olarak MAC adresleri
ekleyebiliriz.
2. MAC adres tablosunda bir port karsisina gelebilecek
maksimum MAC adres sayisini belirli bir sayida sinirlayabiliriz.
3. Belirledigimiz kurallarin disina çikildiginda switchin önlem
almasini saglayabiliriz.
• Not: Bunun için Switch’in Acces (erişim) portu olmalı ve
yönetilebilir Switch olmalıdır.
VLAN (Virtual LAN)
VLAN’lar Farklı veya aynı swithclerin (2.Katman) farklı
portlarına bağlı hostlar ile bir broadcast domaini (farklı Subnet’te
denebilir) oluşturmasına izin verir.
Farklı VLAN’lere üye olan bilgisayarlar ağ üzerinden
birbirlerine erişemezler. Bir VLAN’in ARP isteği diğer VLAN’lere
normalde hiçbir şekilde ulaşamaz. Çünkü herbir VLAN farklı bir
“broadcast domain”idir.
• VLAN’lerin birbirlerine erişebilmeleri için, VLAN arayüzleri oluşturmak, bu
arayüzlere birer IP numarası vermek ve sonrasında da “Inter-VLAN
routing (VLAN’ler arası yönlendirme)” yapmak gerekir.
• Bunun için de ya bir yönlendiriciye ya da yönlendirici özelliği bulunan bir
anahtarlama cihazına ihtiyaç vardır.
VLAN atlama (Hopping) atağı
• Fakat anahtarlar üzerinde bazı güvenlik önlemleri
alınmadığı takdirde VLAN’ler arası geçiş sağlanıp, bir
VLAN’e bağlı bir bilgisayar, kendi VLAN’inin haricinde
farklı bir VLAN’de yer alan başka bir bilgisayara
erişebilmektedir.
•
• Saldırganın, bağlı bulunduğu anahtardan farklı bir
anahtar üzerinde kendi VLAN’i haricindeki, normalde
erişememesi gereken bir VLAN’e erişmesine VLAN
atlama atağı denmektedir.
• VLAN atlama atakları ikinci katmanda (Layer 2)
gerçekleştirildiği için IP tabanlı (Layer 3) saldırı tespit
ya da engelleme sistemleri tarafından yakalanmaları
mümkün değildir.
2. VLAN Hopping Atakları
a) Anahtar Sahtekarlığı (Switch Spoofing)
• Bu atak türü, Cisco marka anahtarlara yönelik bir ataktır. Cisco anahtarlarının
portları ya “access port” ya da “trunk port” olarak tanımlanabilirler. “access
port”, bir adet VLAN’e atanmış port olarak bilinir. “access port”ların, bağlı
bulundukları VLAN haricindeki diğer VLAN portlarına erişimi yoktur. “trunk port”
ise anahtar üzerinde yer alan tüm VLAN’lere üyedir ve farklı anahtarlar üzerinde
tanımlı olan farklı VLAN’lere üye portların birbirleriyle iletişimini sağlar.
• Anahtarlar arasındaki trafiğin ayırt edilebilmesi için “trunk port”, üzerinden
geçen çerçevelere (frame) bir etiket ekler. Bu etiketleme mekanizması iki türlü
yapılır. Bunlardan birisi IEEE 802.1q ve diğeri de sadece Cisco anahtarlarda
çalışabilen ISL (InterSwitch Link) etiketlemesidir.
•Anahtarlar arası VLAN erişiminin sağlanması için anahtarları birbirine bağlayan
“trunk port”ların aynı etiketleme türüne sahip olması gereklidir. (Karşılıklı
bağlanmış olan “trunk port”ların ya IEEE 802.1q ya da ISL etiketli olması
gereklidir.)
• Bu ön bilgilendirmeden sonra şimdi de anahtar kandırma atağının nasıl
yapıldığını inceleyelim:
• Cisco anahtarların portları beş modda çalışırlar: “on”, “off”,
“desirable”, auto” ve nonegotiate”. Cisco anahtarların portları ön
tanımlı (default) olarak “dynamic desirable” modundadırlar. Bu da
şu anlama gelmektedir: Bu portun karşısındaki port “access port”
ise port kendisini otomatik olarak “access port” olarak
tanımlayacaktır. Karşısındaki portun modu “on”, “auto” ya da
“dynamic desirable” ise port kendisini “trunk port” olarak
tanımlayacaktır.
• Şimdi; bir saldırgan “dynamic desirable” modundaki bir porta
kendisini “trunk port”muş gibi gösteren bir bilgisayar bağlandığı
takdirde anahtarın ilgili portu “trunk port” olacaktır. Böylece
saldırganın bilgisayarı tüm VLAN’lere erişebilecek duruma
gelecektir. Çünkü bütün VLAN’lere gidecek olan çerçeveler (frame)
saldırganın portuna da gelecektir. Saldırgan, bu sayede bütün
VLAN’lere giden trafiği dinleme imkanına sahip olacaktır.
b) Çift Etiketleme (Double Tagging)
• Bu saldırının anlaşılabilmesi için “native(yerel) VLAN” ve IEEE 802.1q kavramlarının
iyi bilinmesi gereklidir. Bu kavramları biraz açıklamaya çalışalım:
• Normalde anahtar üzerindeki her bir port sadece bir VLAN’e üye yapılabilir. Bir
porttan birden fazla VLAN’e iletilm için ilgili porta IEEE 802.1q tanımlamasının
yapılması gereklidir. IEEE 802.1q tanımı yapılmış olan port, kendisine gelen
çerçevenin “MAC adresi” ve “EtherType” alanlarının arasına 32-bitlik bir başka alan
ekler. Bundan da anlaşılabileceği üzere, IEEE 802.1q tanımı, aslında bir
etiketlemeden (tagging) ibarettir. IEEE.802.1q portu, sadece etiketlenmiş (tagged)
çerçeveleri iletir. Etiketlenmemiş (untagged) çerçeveler IEEE 802.1q portundan
geçemezler.
• Bunun istisnası “native VLAN”e üye olan çerçevelerdir. IEEE 802.1q portuna gelen ve
“native VLAN”e üye olan çerçeveler, herhangi bir etiketlenme yapılmaksızın IEEE
802.1q portu üzerinden karşıdaki anahtara iletilirler.
• Karşılıklı bağlanmış olan anahtarlar arasında VLAN iletişiminin yapılabilmesi için
karşılıklı olarak bağlanmış bu anahtarların IEEE 802.1q portlarının “native VLAN”
numaralarının aynı olması gereklidir.
• IEEE 802.1q portuna etiketlenmemiş çerçeve gelirse bu çerçeveler “native VLAN”e
üye kabul edilirler. Özetle, IEEE 802.1q tanımı yapılmış olan portlar “native VLAN”
için normal bir port gibi davranır.
“native VLAN” özelliği çift etiketlenmiş VLAN atlama saldırılarına açıktır. Şimdi çift
etiketleme saldırısının nasıl yapıldığına bakalım:
Herhangi bir tanımlama yapılmadığı takdirde, bir IEEE 802.1q portunun
“native VLAN” numarası “1”dir (VLAN 1). Saldırgan, oluşturmuş olduğu çift VLAN etiketli
çerçevenin, dış VLAN etiket numarasına “native VLAN”in numarasını verir. İç VLAN
etiket numarası olarak da hedef anahtarda yer alan hedef VLAN’in numarasını verir.
örnekle açıklayalım:
Saldırgan, kendisini “native VLAN”e üyeymiş gibi gösteren bir çerçeve
oluşturur. Tabii ki bu saldırıyı yapabilmesi için saldırganın, bağlı olduğu anahtarın “native
VLAN” numarasını bilmesi gereklidir. Yukarıda da belirtildiği gibi “native VLAN” için
herhangi bir tanım yapılmamışsa, VLAN 1 “native VLAN”dir ki “native VLAN” numarası
da anahtarlarda genellikle değiştirilmemektedir.
Bu durumda saldırgan kendisinin VLAN 1’de olduğunu belirten bir çerçeve
oluşturur. Bu çerçeveye 32-bitlik bir etiket ekler (IEEE 802.1q etiketi). Bu ilk etiketin
içindeki VLAN değerine de (VID) “1” verir.
Bundan sonra saldırgan, çerçeveye ikinci bir 32-bitlik etiket daha ekler. Bu
etiketin içine de saldırıyı yapacağı VLAN’in numarasını yazar. Bu şekilde saldırgan çift
etiketli bir çerçeve oluşturmuş olur. (Bu şekilde özel çerçevelerin (frame)
oluşturulabildiği programlara internet üzerinden ulaşmak zor değildir.)
Önlem
• Anahtar kandırma (switch spoofing) atağını engellemek için anahtarın
portlarından DTP (DynamicTrunking Port) özelliğini kaldırmak gerekir.
• IEEE 802.1q portuna ihtiyacımız olduğu takdirde bunun manuel olarak
yapılması tavsiye edilir. Aşağıdaki komut satırı girilmek suretiyle
anahtarın portlarından DTP kaldırılmış olur:
ANAHTAR(config)# interface range FastEthernet 0/1 – 24
ANAHTAR(config-if)# switchport mode access
• Çift etiketleme atağından korunmak için de aşağıdaki maddeler tavsiye
edilir:
1. “native VLAN”i kullanıcılar için kullanmayın,
2. “default VLAN” numarasına “1”den farklı bir değer verin ve bu VLAN’i
kullanıcılar için kullanmayın,
3. Kullanılmayan portları kapatın ve bu portları “default VLAN” haricinde
başka bir VLAN’e dahil edin.
43
IP Adresleme
• IP adresleri 32 bit uzunluğundadır. (IPV4)
• Örnek.
• 62.49.67.170
• RFC 1918’e göre aşağıdaki ağ adresleri özel
ağlarda kullanılmak için ayrılmışlardır.
– 10.0.0.0 to 10.255.255.255
– 172.16.0.0 to 172.31.255.255
– 192.168.0.0 to 192.168.255.255
44
IP Adresten Ethernet Adresine dönüş
• Address Resolution Protocolü (ARP)
– 3.katman protokolüdür.
– IP adreslerin MAC karşılıklarını haritalar.
– Ağ katmanı, bir çerçeve hazırlanırken ARP’yi kullanır.
• ARP Sorgusu
– 192.168.0.40 kimdir? 192.168.0.20 cevap verir.
• ARP Cevabı
– 192.168.0.40 ‘nin MAC’ı 00:0e:81:10:19:FC
• ARP cache’ları hızlı çalışma için gereklidir.
- Önceki ARP cevaplarını kayıt eder.
- En eski sorgular silinir.
4. Sahte ARP (ARP Spoofing, ARP Poisoning) Atağı
• Normalde ağdaki bir bilgisayar, paket göndereceği başka bir bilgisayarın
MAC adresini öğrenmek için anahtara ARP isteği (ARP request) paketi
gönderir ve anahtar bu paketi tüm portlarına gönderir. Sadece paketin
gönderileceği hedef bilgisayar bu ARP isteğine cevap verir. Paketi
gönderen bilgisayar da bu IP – MAC eşleşmesini kendi ARP tablosunda
tutar.
•Sahte ARP ataklarında saldırgan, paketin gönderileceği bilgisayarın
yerine ARP isteğine cevap verir. Böylece paketi gönderen bilgisayarın
ARP tablosunda (IP – MAC eşleşmesi tablosu) saldırgan bilgisayarının IP
ve MAC adresleri bulunacaktır. Böylece hedefteki bilgisayar gönderilecek
olan paketler saldırganın bilgisayarına gönderilir.
•Saldırgan varsayılan ağ geçidinin (default gateway) yerine ARP isteklerine
cevap verecek olursa da, ağdan dışarı çıkacak olan tüm paketler,
varsayılan ağ geçidi (default gateway) yerine saldırganın bilgisayarı
üzerinden dışarı çıkacaktır. Böylece saldırgan hem ağdan çıkan tüm
paketleri dinleyebilecektir hem de bilgisayarının donanım özelliklerine
bağlı olarak ağda performans düşüklüğüne sebep olacaktır.
PROTOKOLLAR VE BUNLARA YAPILAN SALDIRILAR
ARP PROTOKOLU VE YÖNELİK SALDIRILAR:
• Adres Çözümleme Protokolü (ARP) Fiziksel (Ethernet MAC)
arayüz adresi ile ağ IP adreslerini eşleştirme için kullanılır.
• Veri bağı katmanında Broadcast yayın yoluyla işlem yapar.
• Bu protokolda ençok kullanılan ARP istek (Request) ve ARP
Cevap (reply) paketleri’dir.
• Bilinen MAC adresine karşılık gelen IP adresi ise RARP
protokolu ile gerçekleşir.
• RARP protokolu daha çok ağa bağlı fakat HARD Diskİ olmayan
bilgisayarların ağa dahil olduktan sonra kendi IP No’larnı
bulmak için kullanılan protokoldur. (HD’si olan bilgisayarlar
kendi IP adreslerini kendi HD’leri üzerinde barındırılar))
• Bunun için ortamda RARP veritabanı tutucu bilgisayarlar
olmalıdır.
• RARP protokolu sunucu-istemci etkileşimi ile çalışırlar.
• ARP protokolu IP protokolu altında
çalışır. ARP paketleri sadece
bulundukları ağ içerisinde yayın
yapabilir.
• ARP isteğinden önce, bilgisayarlar
kendi ARP tablolarına bakarlar.
•Bilgisayarlar genellikle ilk açıldıklarında ağa dahil olduktan sonra ARP Broadcast paketi yayınlarlar:
Niçin?
-Aynı ağ içerisindeki IPV4 IP çakışmalarını belirlemek için.
-Başka bilgisayarlardaki ARP tablolarının güncellenmesi için
48
ARP Sorgusu & ARP Cevabı
Web Browser
IP 192.168.0.20
MAC 00:0e:81:10:17:D1
Web Server
IP 192.168.0.40
MAC 00:0e:81:10:19:FC
(1) ARP Query
Who has
192.168.0.40?
(2) ARP Reply
192.168.0.40 is at
00:0e:81:10:19:FC hub
10/100BASE-T
ARP tablosunu görmek için bilgisayarınızda “arp –a” komutu kullanılabilirsiniz.
C:\> arp -a
Arabirim: 192.168.1.70 --- 0x4
Internet Adresi Fiziksel Adres Tipi
192.168.1.1 00-02-xx-yy-ad-15 dinamik
192.168.1.253 00-0c-tt-zz-6b-5d dinamik
49
ARP Güvenlik kusurları
ARP protokolunun işleyişi ve tasarım mekanizmasından dolayı
önemli kusurlardan bazıları;
• ARP önbellekleri kapasitesinin sınırlı oluşu.
ARP önbellekleri bir şekilde lüzumsuz olarak doldurulabilir.
• ARP Kimlik Doğrulama eksikliği
– ARP cevapları, genellikle kabul edilen ve alınanın kim
olduğu fazla önemsenmeden önbelleğe alınır.
– Meşru ve gayri meşru mesajları ayırt etmek için hiçbir
yöntem yoktur.
Kimlik doğrulama eksikliğinden dolayı;
• Geçersiz ARP cevapları: Bir ARP sorgusuna ki bu bir broadcast yayındır.
Alakasız kimseler cevap verebilir. Bu durumda sorgulanan IP’ye ilgisiz
kişiler kendisini eşleştirebilir.
• Karşılıksız - Sebepsiz (Gratuitous) ARP cevapları:
Sorgu olmadan, saldırganın yönlendireceği ağın eşleştirilmesini sağlayan
ARP cevaplarının ön belleğe yazılabilir olması.
SECURITY INNOVATION ©2003 50
ARP Güvenlik Açıkları
• ARP spoofing (ARP Kimlik Sahtekarlığı- ARP taklidi)
– Sebepsiz, nedensiz ARP işlemleri.
– Orijini doğrulanmayan ARP yanıtları.
– Kötü niyetli bir cihaz herhangi bir MAC adresini
talep edebilir.
51
ARP Saldırıları
• ARP önbelleklerindeki mevcut adreslerin değiştirilmesi
(ARP tablosunda IP-MAC eşleşmesinin değiştirilmesiyle)
ARP sahtekarlığı (ARP spoofing, ARP flooding, ARP poisoning)
saldırısı lokal ağlarda gerçekleştirilebilen bir saldırıdır.Bu saldırı,
üç şekilde gerçekleştirilmektedir:
–Birincisi; hedef bilgisayarın ARP tablosunun yanlış bilgilerle
dolmasını sağlayarak, hedef bilgisayarın göndereceği paketlerin
saldırganın istediği adreslere gitmesini sağlamak.
–İkincisi; hedef bilgisayarın göndereceği tüm paketlerin,
saldırganın bilgisayarı üzerinden geçmesini sağlamak (Man in the
Middle).
–Üçüncüsü de; hedef bilgisayarın, paketlerini bir başka bilgisayara
göndermesini sağlayarak bu bilgisayara servis dışı bırakma
(Denial of Service) saldırısı yapmak şeklindedir.
52
ARP Saldırıları
• ARP Önbelleğinin aşırı kalabalık olması
– Bazı uygulamalardaki hedef, çok sayıda gereksiz
ARP yanıtları gönderilerek ARP belleğinin
doldurulmasıdır.
• Bu durumda önbellek maksimuma erişir. Switchler ya
HUB gibi çalışır. Veya tekrardan öğrenme moduna girer.
Paketlerin Monitor edilmesi (Sniffing)
• HUB’lar bir portundan gelen paketleri diğer paketlere
broadcast yaparlar. Bunun anlamı aynı Hub’ı paylaşan
bilgisayarların paketleri monitor etmesine sebep olur.
• Switch’ler ise gelen paketin “Hedef MAC adresini”
inceleyerek o paketi yalnızca ilgili porta yönlendirirler. Bu
iş için oluşturdukları “MAC Adresi-Port no’ tablolarını
kullanırlar.
• Switch kullanılan ağlarda, bu sayede bilgisayarların
biribirlerine giden paketleri monitor etme olasılığı bir
ölçüde önlenebilir.
• Switchler her ne kadar dinlenmemek üzere tasarlansa da
değişik yöntemlerle bu durum aşılabilir.
• Gelişmiş switchler’de (kontrol edilebilir SWitch’ler) bu
dinlenme problemi aşılabilir.
Paketlerin Monitor edilmesi (Sniffing)-II
• Gelişmiş olmayan switchler’in dinlenmesi için değişik
yöntemler uygulanır. Bunlardan en önemlisi ARP
Tablo(önbellek) zehirlenmesidir.
• ARP Tablo Zehirlenmesi ( ARP SPOOFİNG – Cache Poisoning) : Bu
yöntem, Ortadaki Sessiz Adam - Man in the Middle- saldırısı
şeklinde etkisini gösterir.
• Saldıgan haberleşen iki bilgisayar arasına kendisini yerleştirerek bir
köprü gibi veri akışının kendisi üzerinden sağlanmasını sağlar.
Böylece gelen paketleri okuyan saldırgan paketleri iki makine
arasında yönlendirir. Ortadaki adam ile DNS zehirlenmesi de yapılır.
• Man-in-the-Middle Saldırıları: Bu tür saldırılarda saldırgan kurban ile kurbanın gitmek istediği
hedef noktası arasına girerek bütün iletişimi istediği gibi kontrol eder. Bu saldırılar birçok
değişik şekilde karşımıza çıkabilir.(ARP Zehirlenmesi, DNS Ön Bellek Zehirlenmesi vb.)
55
ARP Tablo Zehirlenmesinden (ARP Spoofing) önce
IP 192.168.0.20 (A)
MAC 00:0e:81:10:17:d1
IP 192.168.0.40 ( B)
MAC 00:0e:81:10:19:FC
Saldırgan
IP 192.168.0.1 (C)
MAC 00:1f:42:12:04:72
switch
IP address MAC address
192.168.0.40 00:0e:81:10:19:FC
192.168.0.1 00:1f:42:12:04:72
IP address MAC address
192.168.0.20 00:0e:81:10:17:d1
192.168.0.1 00:1f:42:12:04:72
Bağlantı yapan iki makine A, B olsun. C Saldırgan olsun. Makinaların IPMAC adres ikililerini değiştirmek amacıyla C Taklit edilmiş ARP Yanıt
paketi gönderir.
56
ARP Spoofing’den sonra
(2) Sebepsiz ARP
192.168.0.20 is at
00:1f:42:12:04:72
(1) Sebepsiz ARP
192.168.0.40 is at
00:1f:42:12:04:72
IP 192.168.0.20 (A)
MAC 00:0e:81:10:17:d1
IP 192.168.0.40 (B)
MAC 00:0e:81:10:19:FC
Attacker
IP 192.168.0.1 ©
MAC 00:1f:42:12:04:72
switch
IP address MAC address
192.168.0.40
192.168.0.1 00:1f:42:12:04:72
IP address MAC address
192.168.0.20
192.168.0.1 00:1f:42:12:04:72
00:1f:42:12:04:72
00:1f:42:12:04:72
Bağlantı yapan iki makine A, B olsun. C Saldırgan olsun. Makinaların IPMAC adres ikililerini değiştirmek amacıyla C Taklit edilmiş ARP Yanıt
paketi gönderir (Sebepsiz ARP).
57
ARP Spoofing’in Etkisi (Ortadaki Adam etkisi)
IP datagram
Dest: 192.168.0.40
MAC: 00:1f:42:12:04:72
IP 192.168.0.20
MAC 00:0e:81:10:17:d1
IP 192.168.0.40
MAC 00:0e:81:10:19:FC
Attacker
IP 192.168.0.1
MAC 00:1f:42:12:04:72
switch
IP address MAC address
192.168.0.40
192.168.0.1 00:1f:42:12:04:72
IP address MAC address
192.168.0.20
192.168.0.1 00:1f:42:12:04:72
00:1f:42:12:04:72
00:1f:42:12:04:72
IP address MAC address
Attackers relay index
192.168.0.40 00:0e:81:10:19:FC
192.168.0.20 00:0e:81:10:17:d1
Her iki bilgisayar arasındaki veriler, artık saldırgan üzerinden olacağından,
saldırgan veriler üzerinde oynayabilir. Hatta haberleşen iki bilgisayar
• Ortadaki adam etkisi ile iki bilgisayarın
biribirleriyle haberleşmesi sürecinin
saldırganın bilgisayarından geçmesi
durumunda, bu iki bilgisayar arasındaki
kurulacak üst seviye işlemlerinin de , örneğin
“Bağlantıya yönelik saldırı” ele geçirilmesi söz
konusudur. Bu işlem iki makine arasındaki
iletişimde TCP katmanında bağlantı sıra
numarasını kullanarak bağlantı içerisine veri
gönderebilir.
Toplu yayın (Broadcast) Saldırısı
• Eğer ARP tablosu içerisindeki belirli bir IP adresine karşılık gelen MAC adresi, ARP
spoofing (taklit ARP yanıtı) mesajı yoluyla değiştirilip FF.FF.FF.FF.FF.FF ile
değiştirilirse, bu bilgisayara gönderilecek paketler tüm noktalar tarafından monitör
edilebilir okunabilir.
• Eğer bir bilgisayarın ARP tablosunun içindeki ağ geçidinin IP’sine karşıkıl gelen MAC
adresi toplu yayın adresi olarak değiştirilirse, bu bilgisayarın dış dünya ile olan
bağlantısı rahatlıkla izlenebilir.
TAKLİT ARP REPLY PAKETİ OLUŞTURMAK
ARP PROTOKOLU İLE DOS Saldırıları
• Taklit edilmiş “ARP yanıt Paketi” kullanarak tablo içerisinde
varolmayan MAC adresi değerlerine karşılık gelen IP adrteslerine
sahip olan girdiler yapılır. Böylelikle tablo içerisinde yer alan IP
adresine gönderilecek datagramlar hedeflerine varamaz. Bu durum
ağı meşgul eder hem de MAC adresi değiştirilmiş bilgisayarla olan
iletişim sonlandırılmış olur.
ARP SALDIRILARINA KARŞI ÖNLEMLER
Eski bir protokol olan ARP’ın çalışma yapısından (Tablosunun düşük
kapasiteli olması, ARP mesajları için herhangi bir durum tablosunun
tutulmaması, ARP’ta herhangi bir kimlik doğrulama mekanizması olmadığı
için, bilgisayar gelen ARP mesajlarının doğru bilgisayardan gelip-gelmediği
kontrol edemeyecektir. Tüm bilgisayarlar kendisine gelen ARP mesajlarıyla
ARP tablosunu herhangi bir kontrole tabi tutmadan güncellemek
durumundadır v.b) kaynaklanan bu sorunların protokol bazında bir çözümü
bulunmamaktadır.
• Alınacak tedbirlerden ilki ARP tabloları içerisine statik girdiler yaratmaktır.
Bu statik değerler saldırı sonucunda değişmeyeceği için belirli bir düzeyde
güvenlik sağlanmış olur. Ancak bu yöntem ağdaki tüm bilgisayarların ARP
tablolarına manuel olarak “ IP-MAC adresi” tanımlaması yapmaktır.
Mantıklı değildir. Kaldı ki Windows işletim sistemi, ARP tablosu içerisindeki
statik eşleşmeleri kabul etmeyebilir. Aldığı Yanıt paketleri ile tabloyu
değiştirebilir.
ARP SALDIRILARINA KARŞI ÖNLEMLER-2
• ARP’ nin açıklarından yararlanılarak yapılan saldırıları SWİTCH cihazları
üzerinde alınacak bazı önlemlerle kapatmak mümkündür.
Çözüm -1
• Switch’lerin IP adresi – MAC adresi eşleşmelerini (ARP tablosu) port bazında
tutmalarıdır. (Bu işlem gelişmiş yapıda switch’ler üzerinde gerçekleştirilebilir
(VLAN özellikli switchler v.b) . Bu durumda SWİTCH, üzerinden akan ARP
paketlerini sürekli olarak denetler. Geçerli veya taklit paketleri bulur. Buna
“Dynamic ARP Inspection (DAI) –Değişken ARP denetimi-, Dynamic ARP
Protection”denir. CİSCO Catalyst 4500 serisi Switch’de bu özellik vardır.
• Switch üzerinde port bazındaki IP adresi – MAC adresi eşleştirmesi
yapıldığından, saldırgan bağlı olduğu switch portundan farklı IP adresi – MAC
adresi eşleşmelerine sahip olan ARP mesajları gönderemez.
• Bu yöntem DHCP sunuculu sistemlerde uygulanır.
• DAI MAC adresi-IP adresi eşleşmelerini sürekli takip ederek “Ortadaki Adam”
saldırılarının önlenmesine yardım eder.
Çözüm – 2:
• Bir DHCP sunucusunun bulunmadığı bir ortamda (IP
adreslerinin statik olduğu) IP adresi – MAC adresi
eşleşmelerinin anahtarlama cihazları üzerinde el ile birer birer
yapılması gerekmektedir. Yani DHCP sunucusundan hazır
olarak alınan IP adresi – MAC adresi eşleştirmelerinin switch’e
el ile girilmesi gerekmektedir. Bunun için anahtarlama
cihazları üzerinde ARP erişim kontrol listeleri (ARP access
control lists - ARP ACLs) tanımlanır.
Çözüm – 3:
• Saldırı için bir başka çözüm de, anahtarlama cihazının
portlarına birim zamanda gelen ARP mesajlarını sınırlamaktır.
Bu şekilde, ARP servis dışı bırakma saldırılarının da (ARP DoS)
önüne geçilmiş olunur. Bu özellik, sadece Cisco marka
anahtarların bazı modellerinde aktif hale getirilebilmektedir.
Network Katmanı (3.Katman)
Atakları - Güvenliği - 1
TCP/IP protokol yapısı
Ağ katmanı - IP
• Farklı Fiziksel segmentlerdeki (LAN- veya farklı
ağ) bilgisayarlar arasındaki paketleri taşımak
için yapılması gerekenleri tarif eder.
• Bunun için kullanılan temel işlemler;
– Routing (Yönlendirme): Rota keşfi ve mantıksal
adreslemeye göre ağlar arası seyahat.
– Düşük katmanlardaki adres keşfi işlemi : (Alt
katman adresleri arama)
– Error Messages (ICMP) (Hata mesajlaşma)
Ağ katmanı- data seyahatı
4
NETE4630: Advanced Network Security
and Implementation
5
IP Paket yapısı
6
Başlık uzunluğu satır cinsinden (32bit) verilir. En kısa
başlık 5 satır (20 oktet) uzunluğundadır.
Servis tipi (TOS) Paketin servis sınıfını belirtir.
Toplam Uzunluk başlık ve verinin toplam uzunluğunu
byte cinsinden verir.
Tanıtıcı ;parçalanmış IP datagramlarının
birleştirilmesinde yardımcı olur.
DF (Don’t Fragment) biti datagramın
parçalanmaması gerektiğini gösterir.
MF (MoreFragments) biti arkadan aynı datagrama ait
başka bir parça gelip gelmediğini gösterir.
Son parça dışındaki tüm parçalarda 1 değerine sahiptir.
Parça No (Fragment kayıklığı olarak da adlandırılır)
ilgili parçanın bütündeki yerini gösterir.
Yaşam Süresi : Bu değer her sekmede bir azaltılır.
Değer sıfıra eriştiğinde paket hala varış düğümüne
ulaşmadıysa yok edilir.
Protokol :hangi ulaşım protokolünün kullanıldığını
gösterir.
Başlık Sınaması başlıktaki hataları farketmek için
kullanılır..
Seçenekler :protokolün daha sonraki sürümlerine
kolaylık tanımak için tasarlanmıştır. Sürüm 4 için
planlanan seçenekler güvenlik, kaynak yönlendirme,
yolun kaydedilmesi, zaman bilgilerinin tutulması
içindir.
IP Router’lar
• Router’lar ağ katmanında çalışırlar ve ağ adreslerine göre
ağdaki paketleri yönlendirirler.
• Router’lar IP datagramlarının yerine teslimini direkt veya
dolaylı olarak desteklerler.
• Hedefe varabilecek olası yolları kullanmak için Yönlendirme
tablolarını kullanırlar.
• Bir datagram için 3 olası durum sözkonusudur.
– Doğrudan hedef Host’a gönderilme.
– Bilinen hedef yolundaki bir sonraki router’a gönderilme.
– Default Router’a gönderilme.
• IP Routerlar, katman 3’te çalışırlar.
8
192.168.1.254
62.49.147.169
Router’lar
switch
Router
switch
Router
192.168.1.10 192.168.1.11
192.168.0.40
192.168.0.254
62.49.147.170
IP address
192.168.0.20
Subnet mask
255.255.255.0
Default router
192.168.0.254
Internet
9
Routers
switch
Router
switch
Router
192.168.1.10 192.168.1.11 192.168.0.40
192.168.0.254
62.49.147.170
62.49.147.169
IP datagram
Dest: 192.168.0.40
IP address
192.168.0.20
Subnet
255.255.255.0
Default router
192.168.0.254
192.168.1.254
Internet
10
Routers
switch
Router
switch
Router
192.168.1.10 192.168.1.11 192.168.0.40
62.49.147.170
IP datagram
Dest: 192.168.1.11
IP address
192.168.0.20
Subnet
255.255.255.0
Default router
192.168.0.254
Internet
192.168.0.254 192.168.1.254
62.49.147.169
11
Routers
switch
Router
switch
Router
192.168.1.10 192.168.1.11 192.168.0.40
192.168.0.254
62.49.147.170
62.49.147.169
IP datagram
Dest: 134.219.200.69
IP address
192.168.0.20
Subnet
255.255.255.0
Default router
192.168.0.254
192.168.1.254
Genel bakış
• IP, ICMP, and Routing protokolları önemlidir.
• IP bağlantısız bir protokol olduğu için DOS
saldırılarına açıktır.
• Saldırganlar tarafından IP protokoluna
saldırılar için ICMP kullanılabilir.
• Routing protokolları data yığınlarına maruz
kalırlar.
12
IP Saldırıları(Atakları)
• Spoofing (Kimlik Sahtekarlığı- Kimlik Adatması)
• Fragmentation (Parçalanma)
• Port Scanning (Port tarama)
• Redirection (Yeniden yönlendirme)
13
IP Spoofing (Yanıltma-Aldatma)
• Internet veya ağa bağlı sisteminizle başka bir sisteme bağlanacaksınız, fakat
bu bağlantın sizin tarafınızdan yapıldığını gizlemek istiyorsunuz. Bunun için
bağlantı sırasında kimliğinizi (ki TCP/IP protokollerinde kimliğiniz IP
adresinizdir), yanlış gösteriyorsunuz. Bu IP spoofing işlemidir.
• Bu saldırının amacı bir makinenin IP adresini ele geçirmektir. Saldırgan bu iş
için genelde iki bilgisayar arasındaki güvenilir ilişkiden yararlanır.
• Bu saldırıyla, saldırgan, kendi IP paketlerinin sahtekarlığını yaparak ( nemesis
v.b gibi programlar ile) diğer paketlerin arasınaki kendi paketinin kaynak IP
alanını değiştirir.
• Kaynak değiştirildiğinden, sahte pakete karşılık gelen cevaplar saldırganın
makinesine gidemez. Spoof edilen makinaya gider.
• Saldırganın bu cevabı kendi makinasına alabilmesi için kullandığı
önemli teknik ”Kaynak yönlendirme-Source routing”’dir.
14
Spoofing (cont.)
• Yerel spoofing: Saldırgan(attacker) ve mağdur
(victim-kurban) aynı alt ağdadır.
• Saldırgan, bir saldırı başlatmak için gerekli temel
bilgi parçalarını bulmak amacıyla trafik koklama
(sniffing - izleyici) ile işe başlar.
• Blind spoofing: Saldırgan ile mağdur aynı
altağ’da değildir.
• Daha karmaşık ve gelişmiş saldırıdır. Saldırının
başarılması için gerekli bilgi miktarı mevcut değildir.
Anahtar parametreleri tahmin edilmelidir.
• Modern işletim sistemleri bu şekildeki saldırıları
başlatmayı zor hale getirmek için, oldukça rastgele
sıra numaraları kullanır.
15
Paketlerin Parçalanması (IP fragmentation)
• Veri bağı katmanı kullanılarak gönderilebilecek en büyük datagramın
boyutuna MTU ( Maximum Transmission Unit) denir. Değişik ağ
teknolojilerindeki MTU’lar farklıdır.
• Paketlerin MTU’yu geçmeyecek şekilde ağlar arasında iletimin sağlamak için
boyutlandırılması işlemine parçalama (fragmentation).
• IP başlığı, parçalanan bu paketin tekrar birleştirilmesi için gerekli bilgileri
parçaların her birine aktarır.
• Paketlerin birleştirilme işlemi (reassemmly)a ra yönlendiricilerde yapılmaz.
Son noktalar tarafından yapılır.
Ağ Türü MTU(Oktet)
Ethernet 1500
IEEE 802.3 1492
Token Ring 4440-17940
FDDI 4352
x.25 100
Ağ Katmanı
Network Layer
4-17
IP Datagram Parçalama/Birleştirme
 Ağdaki hatların taşıma
kapasitesi MTU ile sınırlıdır
(max.transfer size) – en
büyük olası bağlantı katmanı
çerçevesi.
 Farklı hat tipleri, farklı
MTUlar
 büyük IP datagram ağda
bölünür (“fragmented”-
“parçalanır”)
 Bir datagram pek çok
datagram haline gelir
 Sadece son hedefte
“reassembled”-
”birleştirilir”
 IP başlık bitleri ilgili
fragment-veri parçalarını
tanımlama ve sıralamada
kullanılır
Fragmentation (parçalama):
girişte: bir büyük datagram
çıkışta: 3 daha küçük datagram
Reassembly (birleştirme)
Ağ Katmanı
Network Layer
4-18
IP Datagram Parçalama/Birleştirme
ID
=777
öteleme
=0
bayrak
=0
uzunluk
=4000
ID
=777
offset
=0
fragflag
=1
length
=1480
ID
=777
offset
=185
fragflag
=1
length
=1480
ID
=777
offset
=370
fragflag
=0
length
=1020
Bir büyük datagram pek çok
daha küçük datagrama dönüşür
Örnek
 4000 byte
datagram
 MTU = 1500 bytes
Veri alanında 1480 bytes
offset
(öteleme)=
1480/8
Ağ Katmanı
Network Layer
4-19
IP Datagram Parçalama/Birleştirme
ID
=777
öteleme
=0
bayrak
=0
uzunluk
=4000
ID
=777
offset
=0
fragflag
=1
length
=1500
ID
=777
offset
=1480
fragflag
=1
length
=1500
ID
=777
offset
=2960
fragflag
=0
length
=1040
Büyük bir datagram birkaç
küçük datagrama dönüşür
Örnek
 4000 byte
datagram
 MTU = 1500 bytes
Veri alanında 1480 bytes
ICMP ?
Her IP paketi ?
Parçalama (Fragmentation)
20
Paketlerin, farklı MTU değerleri olan farklı ağlarda iletirken Parçalanması
gerekebilir. Her bir fragment kendi IP başlığını alır ve farklı bir yol üzerinden
seyahat edebilir.
 Parçalanmış paketlerin hedefe ulaştığında doğru sırada birleştirilmesi gerekir.
Paketler hedefe ulaştığında tekrar birleştirilip orjinalinin elde edilmesi için her
pakette bulunması gereken bazı alanlar vardır. Bunlar
•Parçalanmış her paket datagramın hangi kısmını taşıdığını (Offset değeri) ve sırasını bilmelidir. Kendisinden sonra
ek parça paket varsa bu alan flags[1], paketin kendisi son paket ise değer flags [none] olur.
21
Hangi Byte’dan itibaren bu verinin ekleneceği de “Fragment Offset” değeri ile belirtilir. Yani önceki paket
2960 byte tasımıstır, biz de buna ek 1500 byte yapıp göndereceğiz, bir sonraki pakette offset değeri
2960+1500 olacaktır(aslında 2960+1480)
Parçalanmış her paket taşıdığı veri boyutunu ve hangi byte’dan itibaren taşıdığını bilmelidir.
Ne kadarlık bir veri taşıdığı Total Lenght ile belirtilir.
Dikkat !!!!!!
• Parçalanmış paketlerde sadece ilk
paket protokol başlık bilgisini(TCP,
UDP, ICMP vs) taşır.
NETE4630: Advanced Network Security
and Implementation 22
• Reassembly ( Tekrar Birleştirilme İşlemleri): IP protokolü
belirtimindeki bazı belirsizlikler nedeniyle, özel durumlarda
farklı parçalama işlemleri meydana gelebilir ve bu parçaların
yeniden birleştirilmesi gerekir. Bu özel parçalama işlemleri;
• Fragment retransmission (parçaların yeniden iletilmesi),
• Fragment overlays (parçaların üstüste gelmesi -
bindirmeler)
• Fragments with non-neighbouring offsets.(Komşu
olmayan ofsetli parçalar.)
• Eğer ağı koruyan cihazlardaki parçalar ile hedef hosttakiler
farklılıklar gösterir ise; bu durum tutarsızlıklara yola açabilir.
• Dolayısıyla insertion ve evasion atakaları yapılabilir.
23
• Bu birleştirme sürecindeki olabilecek ataklar;
• Time out (Zaman aşımı) : Parçalanmış paket; yalnızca
tüm parçalarının parçalanma zaman aşımı süresi içinde
alınmış ise yeniden birleştirilir.
• Hedef host ve IDS’de farklı zaman aşımı uzunluklarının
kullanılması, saldırgana evasion atak gerçekleştirmesine
izin verebilir.
• TCP header division: TCP oturumunu izleyip ve
parçalanmış paketleri yeniden birleştirmeyi başaramayan
IDS’ler, saldırgan tarafından oluşturulmuş daha küçük
fragmentleri atlayabilirler. Bunlar TCP başlıkları ikiye üçe
bölünmüş fragmentler olabilir.
• Bu şekilde oluşmuş her bir bağımsız fragment, imzayla uyuşmaz
dolayısıyla atak sayılmaz.
Fragmentation Atakları
• Parçalanmış paketlerin üst üste çakışması (Overlay),
saldırganlara IDS, Firewall ve Routerlarda eski
paketlerin kaydırılması imkanını sunar.
• Bir routerdan, windows temelli bir sisteme paket
gönderildiğinde;
• Eğer alınan paket duplike bir paket ise;
– Router (veya IDS veya Firewall) en son gönderilen
fragmenti tercih eder.
– Windows orijinal (ilk gönderileni) tercih eder.
25
• Parçalanmış paketler konusunda en sıkıntılı sistemler IDS/IPS’lerdir.
Bunun nedeni bu sistemlerin temel işinin ağ trafiği inceleme
olmasıdır. Saldırı tespit sistemleri gelen bir paketin/paket grubunun
saldırı içerikli olup olmadığını anlamak için çeşitli kontrollerden
geçirir. Eğer bu kontrollere geçmeden önce paketleri birleştirmezse
çok rahatlıkla kandırılabilir.
• Mesela HTTP trafiği içerisinde “/bin/bash” stringi arayan bir saldırı
imzası olsun. IDS sistemi 80.porta gelen giden her trafiği inceleyerek
içerisinde /bin/bash geçen paketleri arar ve bu tanıma uyan
paketleri bloklar. Eğer IDS sistemimiz paket birleştirme işlemini
uygun bir şekilde yapamıyorsa, saldırgan paket bölme araçlarından
birini kullanarak /bin/sh stringini birden fazla paket olacak şekilde
(1. Paket /bin, 2.paket /bash) gönderip IDS sistemini atlatabilir.
26
Fragmentation Attacks (cont.)
27
#1 #2 #3
#1 #2
#2 #3
Windows and router
accepts #1 and #2
Attacker modifies #2
And transmits #2 and #3
Windows keeps #1 #2 #3
Router keeps #1 #2 #3
Same size, same offset
Fragmentation Attacks (cont.)
• Saldırgan mesajını 3 parçaya böler.
• O hem yönlendiriciye hemde windows tabanlı sisteme 1. ve
2. parçayı gönderir. Her ikisi de parçaları kabul eder.
• Saldırgan 2 . Ve 3. parçaları gönderir. Yeniden gönderilen
2.parça ilki ile aynı boyut ve offsettedir. Fakat payload’ı
farklıdır (Saldırı imzası taşımaz).
• Windows 2. parçanın orijinalini (saldırı mesajı bundadır) kabul
ettiği halde router (veya IDS) yeniden (Son) gönderileni kabul
eder. Dolayısıyla birleştirdiğinde bu mesajların saldırı
olmadığına karar verir.
28
Parçalanmış Paket Oluşturma Araçları
• Paket parçalama işlemi normalde bizim (kullanıcılar) tarafımızdan
yapılmaz. Ağlar arası geçişleri sağlayan yönlendirici sistemler (router)
gerektiğinde bu işlemi gerçekleştirir.
• Fakat internette bulunan çeşitli araçlar kullanılarak kendi isteğimize göre
paketleri parçalayıp gönderebiliriz.
• Bunları öğreniniz!!!!!!!!!!!!
• Dikkat !!!!Parçalanmış paket saldırılarına sebep olan güvenlik açıklıkları
uzun zaman önce işletim sistemi geliştirici firmalar tarafından kapatılmıştır
fakat paket parçalama ile yapılan Firewall/IDS/IPS atlatma yöntemleri hala
bazı sistemler üzerinde çalışabilmektedir.
29
Source Routing (Kaynak Rotalama) atakları:
• Source routing, TCP/IP suitinde paket göndericisine,
netwokte paketi rotaya göre ilerletmek için imkan
veren bir seçenektir.
• Saldırganlar bu özelliği , belirli bir alt ağı ele geçirmek
için yapacakları saldırı için kullanabilirler.
• Şöyleki; saldırgan, gönderici adresini aldatarak, o
paketi bir alt ağdan geliyormuş gibi set edebilirler.
• Bunu önlemenin yolu, router’ın kaynak adresi hedef
makinaya varmadan kimseye göstermemesidir.
• Bu işlem Cisco cihazlarda “no ip source-route”
komutuyla yapılabilmektedir.
Teardrop Saldırıları
• Teardrop, targa, NewTear, Nestea Bonk, Boink, TearDrop2, ve SynDrop
gibi bazı saldırı araçları, IP atakları için açıklara sahip makinaları
çökertebilirler.
• Teardrop atağı IP paketlerinin tekrar birleştirilmesindeki zayıflıktan yararlanır.
Mesaj, ağlar arasında iletilirken genellikle daha küçük parçalar ayrılır. Herbir parça
orjinal paket gibi görünür. Fakat offset alanları farklıdır. Teardrop programı bir dizi
IP paket parçaları oluşturur. Bu parçalar örtüşen offset alanlarına sahiptir. Bu
parçacıklar varış noktasında tekrar birleştirildiklerinde bazı sistemler çökebilir,
durabilir veya kapanıp açılabilir. Teardrop saldırısı bir DOS saldırısıdır.
• Overlapping, over-sized, payload paketler gönderilerek sistem bozulur.
31
Ping of Death Atağı
• Ping of Death, IP paketlerine gömülü olarak ICMP ile
gönderilen “echo request” mesajları ile yapılır. Bu
mesajlar 65.535 bayt’tan daha büyük mesajlar
halinde sürekli olarak gönerilirse Buffer kapasitesi
küçük olan makinalarda buffer taşmasına sebep
olarak makinanın çökmesine sebep olur. Ping of
death bir DoS atağı çeşididir.
32
IP Katmanı genel Atak Tipleri
Paket bazlı ağ katmanındaki savunma sistemleri genelde IDS’lerledir. Saldırganlar ise bu yapıyı
3 tip genel atakla geçmek isterler.
1- Evasion attack (Atlatma Atakları):
Bu ataklarda paketler hem IDS’ye hem de hedefe gönderilir. IDS bu paketleri reddeder
(dikkat atak olduğu için değil !!!!!) , hedef host kabul eder.
•IDS reddetiği, düşürdüğü bu paketlerin payload’ını kontrol etmediği için atak olup
olmadığına karar vermez.
•Böylece saldırgan, kötü niyetli trafiğin bir kısmını veya tamamını IDS’nin
denetiminden kaçırarak ağa göndermiş olur.
Evasion Attack (Atlatma Atakları)
• Bir saldırgan ilk fragmenti, timeout’u 15s olan IDS’ye ve
timeout’u 30s olan hedef sisteme gönderir.
• Saldırgan 15s ile 30 s arasında bir zamanda ikinci fragmenti
gönderir.
• IDS 2.fragmenti iptal eder. Çünkü timeout’u 15 s’den
büyüktür. Fakat hedef sistem bu fragmenti kabul eder. Oysa
bunun içinde bir atak olma ihtimali vardır.
• Böylece IDS atağı kayıt edemez. IDS atlatılmış olur.
34
#2 #1
#1
15 s
#2
30 s
2- İnsertion attack (Araya koyma, Ekleme Atakları) :
•Bu ataklarda; hem son kullanıcıya hem IDS’ye gönderieln paketlerden, Son
kullanıcının kabul etmediği, IDS tarafından kabul edilenler olabilir.
•Paket sadece IDS’de geçerlidir. Bu durumu uygun kullanabilen saldırgan; uygun bir
paket trafiği ekleyerek imza analizi ile saldırı tespitindeki analizi önleyebilir (Son
kullanıcı trafından kabul edilmeyen paket ile, o paket gurubunun saldırı olmadığı
IDS’ye inandırılır.)
3- DOS(Deniel of Service) Atakları
• IDS veya sistem kaynaklarını tüketmek için
veya tamamen devreden çıkarmak için
yapılan saldırılardır. Bu şekilde IDS gelen
trafiğin hepsini analiz edemez hale gelir.
• DoS saldırısının en yaygın türü veya özelliği,
istekleri ile mağduru bunaltmasıdır.
• Bu istekler bir seferde birden fazla kaynaktan
gönderiliyor ise, buna dağıtık DoS (DDoS)
saldırısı denir.
Çok bilinen ataklardan bazıları
Time to live field attacks : IP başlığının TTL alanı bir paketin düşürülmeden önce,
yönlendirildiği rota üzerinde kaç atlama yapabileceğini ifade ediyordu. Her yönlendirici
kendisine gelen paketi yönlendirdiğinde TTL alanındaki değeri bir eksiltiyordu.
•Buna göre , ağ yapısı (topolojisi) hakkında önceden bilgi sahibi olan saldırganlar, paketleri
öyle ustalıkla düzenleyebilir ki paketler, ağdaki IDS’ler tarafından düşürülmeden önce (IDS
tarafından TTL’den dolayı) hedef hosta normal (TTL değeri 0’lanmadan) gibi ulaşır.
Maximum transmission unit (MTU) : Saldirgan hedef host ile kendisinin kullandığı en düşük
MTU değerini, "yol MTU Keşfi" olarak adlandırılan bir teknik ile öğrenebilir.
•Eğer bu minimum MTU değeri IDS ile hedef host arasındaki bağlantıda geçerli ise; saldırgan
b u minimum MTU değerinden daha büyük bir boyutlu paket yaratıp “Dont Fragment “
bayrağını 1 yapar. Böylece bu paketler IDS tarafından kabul edilir. Fakat daha düşük MTU’lu
ağın başındaki router TARAFINDAN (hedef bilgisayar bu Router’ın arkasındaki ağdadır)
tarafından reddedilir.
•Bu bir “IDS insertion” atağıdır. Böylece, IDS bu paket gurubu için imza analizi yapamaz.
IP checksum verification : IP checsum doğrulaması yapmayan bir IDS sistemi (performans
kaybı olmasın diye genlede yapmazlar), insertion ataklarına karşı duyarlıdır. Çünkü bu
sistemler hedef host’un reddettiği paketleri kabul edip işleyebilirler.
•IP checksum doğrulama, parçalanma (fragmentasyon) ) veya taşıma katmanı saldırıları ile
birlikte kullanılır.
Ağ katmanı Saldırıları ve Koruma
2
YÖNLENDİRME Protokollarına VE Routerlara
ATAKLAR
• Routerların (Yönlendiricilerin) görevlerini tekrar hatırlarsak;
• Yerel ağdan gelen paketleri filtrelemek : Paket filtreleme, network
adresi (IP), servisi ve protokolüne göre bilgi transferini kontrol etmektir.
Yönlendirici bu kontrolleri ACL’ler (Access-Control List –Erişim Listesi)
yardımı ile sağlar. ACL’ler kendisine gelen verinin kaynak, hedef ip
adreslerine, bilginin gideceği port adresine veya kullanılmak istenen
protokole göre kısıtlamalar yapabilmektedir.
• Paketlerin nereye gideceğine karar vermek: Yönlendirici, kendine
bağlı olan bilgisayarların network adreslerini tuttuğu gibi, kendisine bağlı
veya kullanılan protokole göre bağımsız yönlendiricilerin network adreslerini
de routing tablolarında tutmaktadır. Yönlendirici kendisine gelen paketlerin
nereye gideceğini öğrendikten sonra bu adresi routing tablolarıyla
karşılaştırarak hangi port’undan yollayacağına karar vermektedir.
• Böylece ROUTER ,yerel ağları birbirine bağladığı gibi kurumun WAN’a
bağlantı noktasını da oluşturmakta ve internet erişimini de sağlamaktadır.
IP Datagramların Yönlendirilmesi
• Farklı ağlar üzerindeki bilgisayarların haberleşmesi için ağlar
arasında datagramların yönlendirilmesi gerekir.
• Router’larda en az iki adet farklı ağa bağlanmak için iki ağ
donanım arabirimi bulunmalıdır.
• Routerlar datagramları yönlendirebilmek için hafızalarında IP
Datagram yönlendirme tabloları bulundurmalıdırlar. Bu
tablolarda hedef ağa ulaşabilmek için uygun yönlendiricilerin
bilgileri bulunur
Statik ve dinamik yönlendirme tabloları
İki şekilde yönlendirme tablosu oluşturulur.
1-Dinamik yapılandırma: Routarlar bünyelerindeki
yönlendirme tablo algoritmalarını çalıştırarak,
komşularının durumuna göre en uygun ve hızlı yolları
belirleyip tablolarını oluşturur ve güncellerler.
2- Statik yapılandırma : Hedef bilgisayar ağına bağlantı
kurulabilmesi için tablo el ile doldurulur. Küçük ve yapısı
değişmeyen ağlarda bu yöntem kullanılabilir.
IP datagram yönlendirme bilgilerinin routerlar
arasında değişiminin etkin bir şekilde gerçekleşmesi için
yönlendirme protokolları tanımlanmıştır. Bu protokolların
devamlılığını sürdürebilmesi için mesaj değişiminin sürekli
olması gerekir.
DATAGRAM Yönlendirme protokolları
• Otonom sistemlerin kendi içindeki, temel yönlendirme değişim bilgisi
için kullandıkları protokollara IGP( Interior Gateway Protokolu) denir.
• Otonom sistemler arasındaki haberleşme için kullanılan routerların
temel yönlendirme değişim bilgisi için kullandıkları protokollara EGP(
Exterior Gateway Protokolu) denir.
43
Yönlendirme Protokolleri
IGP Protokollarından en çok bilinenleri
-RIP (Routing İnformation Protocol - Yönlendirme Bilgi
değişimi protokolu) : Tablolarını güncellemek için Uzaklık Vektör
(Distance Vector) Algoritması kullanır.
-OSPF (Open Shortest Path First- İlk önce en kısa yolu seç):
Tablolarını güncellemek için Link State algoritmasını kullanırlar.
EGP Protokollarından en fazla bilineni;
-BGP (BGP(Border Gateway protocol – Sınır geçit protokolu)
• Yönlendiriciler arasında, yönlendirme bilgileri IP
datagramlar aracılığı ile taşınır. Yönlendirme
protokolları IP, TCP,UDP protokollarını
kullanarak mesaj alış-verişini gerçekleştirir.
• OSPF Protokolu : IP datagramalarını kullanarak
• RIP Protokolu : UDP protokolunu kullanarak;
• BGP protokolu: TCP protokolunu kullanarak
Yönlendirme bilgisi mesaj alış-verişini sağlarlar.
RIP Versiyon 1 Mesaj Yapısı
IP V4 ağları içerisindeki Routerların diğer routerlara erişimi için en iyi rotayı sağlayan tablo
bilgilerinin değişimi için kullanılan RIP mesajları UDP protokolunu kullanır.RIP’ı kullanan
Routrelar, yönlendirme bilgilerini güncellemek ve yönlendiricilerden yönlendirme bilgilerini
istemek için 520 nolu UDP portunu kullanırlar.
2 tip RIP protokol mesajı vardır.
1-Yönlendirme bilgi yanıt mesajı
2-Yönlendirme bilgi isteği mesajı
RIP Versiyon 2 mesaj yapısı
birincinin biraz gelişmiş halidir.
Versiyon 1 ‘deki sıfır alanlarıda
kullanım alanı içine girmiştir.
OSPF Genel Mesaj Başlığı
Routing Protokollarına ataklar
• Distance-vector ve link-state routing protokolları
özellikle DOS saldırılarına çok uğrarlar.
• RIP bir doğrulanmaz servis hizmeti olduğundan DoS
saldırılarına karşı korumasızdır.
• Sahte RIP paketleri göndermek , ağ geçitleri ve
hostların rotalarını değiştirmek ve onlardan bilgi
sızdırmak için yapılır.
• Saldırganlar, yönlendirme bilgisini, networkte
yeniden yönlendirmek için (onun şifrelerini analiz
etmek için veya yolunu değiştirmek için veya
zamanının değiştirmek için) değiştirebilir.
47
• Saldırgan yönlendiricinin routing protokolünü bozmadan
yollanan paketlerin bir kopyasının kendine de yollanmasını
sağlayabilir (kredi kart numaraları gibi verileri almak için) veya
protokolleri kaldırarak yönlendiricinin diğer yönlendiricilerle
haberleşmesini kesebilir.
• Haberleşmenin yok olması, yönlendiricinin aldığı paketleri
nereye göndereceğini bilmemesi ve servis dışı kalması(DoS)
anlamını taşımaktadır.
ROUTER
NETE4630: Advanced Network Security
and Implementation 49
Router (Yönlendirici) yapısı
50
Temel donanımsal elemanları, donanımsal arayüzler (WAN,LAN), CPU,
Flash, RAM, NVRAM, ROM’dur.
CPU: Bu işlemci yönlendirme parametrelerini ve ağ arayüzlerini kontrol eder.
FLASH: Kalıcı hafıza birimidir. Her yönlendirici belirli bir işletim sistemine ihtiyaç duyar.
İşletim sistemi imajı (IOS-ROS) ise “flash”da tutulur.
ROM: Fiziksel olarak sinyal yollayıp, donanımları test eden ve yönlendiriciyi başlatmaya
yarayan program olan "Bootstrap – Mini IOS”ı içerir. Boostrap: Yönlendiricinin
çalışmasını sağlayan bir yazılımdır.
RAM: Yönlendiricinin aktif bilgilerinin bulunduğu geçici hafıza birimidir. Yönlendirici
açılırken bootstrap, flash’tan işletim sistemi imajını ve NVRAM’den başlangıç
konfigirasyonunu RAM bölgesine yükler. Çalışan yapılandırma (running -config) bu
alanda tutulur. Ayrıca RAM’de yönlendirme tabloları ve gelen fakat iletilmemiş
verilerde tutulmaktadır. Yapılan konfigirasyon, running-config dosyası olarak kayıt edilir
ve RAM’de tutulur. RAM'deki running-config dosyası NVRAM'e kaydedilmezse
yönlendiricinin kapatılması durumunda, çalışan yapılandırma bilgileri kaybolur.
NVRAM: Kalıcı hafıza birimidir. Burada başlangıç (startup) ve yedek (backup)
konfigirasyon dosyaları tutulur. Enerji kesilse bile bu bilgiler bellekte kalmaktadır.
Router’ın konfigirasyon bilgilerinin kalıcı olarak tutulduğu hafızadır.
Interfaces: Her yönlendiricinin kendisine gelen bilgileri alması, göndermesi ve
yapılandırmasının yapılması için kullanılan bağlantı noktalarına arayüz (interface) denir
(Örneğin ethernet 0, consol gibi). Arayüz her zaman fiziksel bir olgu değildir
NETE4630: Advanced Network Security
and Implementation 51
ROS Yazılımı
Bir yönlendirici, donanımı ve yazılım olmak üzere iki ana parçadan oluşur.
Yönlendirici işletim sistemi (ROS: Router Operating System) yazılımı oldukça
önemlidir. ROS’un işlevi, desteklediği 3. katman protokolları ve kullandığı
yönlendirme algoritması için gerekli fonksiyonları sağlamaktır. Bunun yanı sıra
ağ yöneticisine, yapılandırılmasını sağlamak için bir ara yüz sunar.
Cisco yönlendiriciler, IOS (Internetwork Operating System) kullanırlar.
Aşağıda Cisco IOS yazılımının görevleri bulunmaktadır:
• Network protokol ve fonksiyonlarını taşımak
• Cihazlar arasındaki yüksek hızda trafiği bağlamak
• Erişimi kontrol etmek için güvenlik sağlamak ve izinsiz network kullanımını
engellemek
• Ağın büyümesini ve kullanılabilirliğini kolaylaştırmak için ölçeklenebilirlik
sağlamak.
• Network kaynaklarına bağlanmak için güvenliği sağlamak
NETE4630: Advanced Network Security
and Implementation 52
Routerların konfigirasyon (yapılandırma ) ayarlarını görmek ve değiştirmek için
farklı kullanıcı seviyeleri (mod’ları) bulunmaktadır
NETE4630: Advanced Network Security
and Implementation 53
User EXEC Mod: Yönlendirici açılıp
arayüze erişildiği anda karşınıza çıkan
moddur. Burada yönetimsel işlemler
yapılamaz, bir sonraki modlara geçiş için
kullanılır.
Privileged EXEC Mod: User EXEC
modda iken “enable” yazıp “Enter”a
basıldığında bu moda geçilir. Bu moda
enable mod da denir ve önerilen davranış
bu moda geçerken şifre konulmasıdır.
Zira bir kullanıcı bu moda geçtikten sonra
yönlendiriciye tamamen hâkim olur.
Priviledge mod işaret “#” şeklindedir.
Global Configuration Mod: Config
Mod diye de anılan bu moda geçmek için
enable modda iken “configure terminal”
yazılır ve “Enter”a basılır. Bu modda
yapılan değişiklikler bütün yönlendiriciyi
etkiler. Bu modayken işaretçi
“(config)#”şeklinde gözükür.
Yönlendirici çalışma modları arası geçiş
NETE4630: Advanced Network Security
and Implementation 54
Router’ların GÜVENLİĞİ
Fiziksel Güvenlik:
Yönlendiriciler için ayrı bir oda ayırılamıyorsa en azından kilitli dolaplar (kabinet)
içine koyulmalıdır. Bu odanın enerjisi hiç kesilmemelidir . Bu UPS (Uninterupted
power supply) kullanarak sağlabilmektedir. Yönlendirici yakınlarına şifre veya ip
bilgileri gibi bilgileri yazmaktan kaçınmaktır.
2.Yönlendiriciye Erişim Hakları
Yönlendiriciye kimlerin erişeceğinin bir politikayla belirlenmesi ve erişimlerin
loglanması gerekmektedir. Bu politikada; kimin konfigürasyon yedeklerini
alacağının, kimin yeni bir parça alımında yönlendiriciye yerleştireceğinin, kimin
logları düzenli takip edileceğinin açık bir şekilde belirtilmesi gerekmektedir.
Temelde yönlendiricilere, kullanıcı (user) ve yönetici (enable) olarak iki çeşit
erişim hakkı vardır. Kullanıcı modunda sadece kontroller yapılabilirken, yönetici
modda ek olarak cihaz konfigürasyonu da yapılabilmektedir.
Router güvenliği-2
3.Şifrelerin Güvenliği
Günümüzde büyük oranda kırma (hacking) işlemi “password quessing”
(parola tahmin etme) yöntemiyle yapılmaktadır bu sebepten şifre
seçimine gerektiği önem verilmelidir.
Cisco yönlendiricilerde kullanıcı adı ve parolasının konfigürasyon
dosyasında gözükmemesi için “service password-encription” komutu
kullanılmalı.
Zayıf şifreleme algoritması kullanan “enable password” kaldırılmalı,
MD5-tabanlı algoritmayla şifreyi koruyan “enable secret” komutu
kullanılmalıdır. “no enable password” komutu kullanılarak enable
password’ler silinmeli yerine “enable secret yeni_şifreniz” ile yeniden
şifreler girilmelidir
Router güvenliği-3
4.Erişim Protokollerinin Güvenliği
Routerlara fiziksel erişim konsol portundan yapılmaktadır. Bunun için
fizikselgüvenliğin sağlanması gerekmektedir.
Diğer erişim yöntemleri olan HTTP, Telnet, SSH,TFTP, ve FTP kullanıldığında
TCP/IP protokolünün zayıflıklarına karşı önlem alınması gerekmektedir.
Alınması gereken önlemler aşağıdaki gibidir.
a) Belirli IP’lerin Cihaza Erişimine İzin Vermek:
Cihazlara sadece belirli IP adreslerinin ulaşmasına izin
verilmelidir. Bu da erişim listesi (access-list) yazılarak sağlanır.
Örneğin Cisco IOS’de sadece 200.100.17.2 ve 200.100.17.3
IP’lerin erişimine izin verilmesi ve diğer ip’lerin engellenmesi ve
bu erişimlerin kaydının tutulması aşağıdaki erişim listesi ile
sağlanmaktadır.
access-list 7 permit 200.100.17.2
access-list 7 permit 200.100.17.3
access-list 7 deny any log
R.Güvenliği -4
HTTP Erişimi:
HTTP protokolü ile web arayüzünden erişim, cihaza interaktif bağlantı demektir.
Yönetilebilir cihazlarının birçoğunun üzerinde web sunucusu çalışır. Bu da 80
nolu portta bir web sunucunun kurulu beklediğini gösterir.
HTTP servisi verilecekse bu ağ yönetimini sağlayan belirli IP’lere kısıtlı olarak
verilmelidir. Cihaz güvenliği nedeniyle mümkün olduğunca bu tür web üzerinden
yönetimin kullanılmaması gerektiği önerilmektedir.
Ama web üzerinden yönetim gerekiyorsa web sunucusu sadece sistem
yöneticisinin bileceği başka bir port üzerinden, örneğin “ip http server port 500”
komutuyla 500 nolu portta çalıştırılabilecek şekilde ayarlanmalıdır.
R.güvenliği-5
Telnet, SNMP protokolleri ile cihaza erişimde, doğrulama mekanizması ağda
şifrenin düz metin (clear text) şeklinde gönderimi ile sağlandığı için güvenlik açığı
oluşmaktadır. Özellikle hub bulunan ortamlarda saldırganın ağ üzerinden dinleme
(sniff) yoluyla iletilen bilgiyi elde etmesi mümkün olabilmektedir. Bunu
engellemek için aşağıdaki önlemler alınabilir :
- - Telnet yerine Secure Shell (SSH) Erişimi Vermek: İletilen veriyi şifreleyen
SSH protokolü mümkün olduğunca kullanılmalıdır.
- Güncel SNMP Versiyonlarını Kullanmak: SNMP Versiyon 1, düz metin
doğrulama dizileri (string) kullandığından bu doğrulama dizilerinin spoof edilmesi
söz konusu olabilmektedir. Bu yüzden MD5’a dayanan öz (digest) doğrulama
şeması kullanan, yönetim verilerine kısıtlı erişim sağlayan SNMP Versiyon 2 veya
3’ün kullanılması gerekmektedir.
- Doğrulama Mekanizmaları Sağlamak: Doğrulama mekanizması, onay
sunucuları(Tacacs+, Radius …vb) kullanılarak yapılabilir. Cisco IOS’de
doğrulama mekanizması “ip http authentication” komutuyla sağlanmaktadır.
R.Güvenliği-6
5.Gereksiz Servisleri Kapatmak
Yönlendiricide kullanılmayan servisler kapatılmalıdır. Örneğin
kullanılmayan ve güvenlik açığı oluşturabilecek TCP/UDP services
echo, chargen ve discard kapatılmalıdır:
no service tcp-small-servers
no service udp-small-servers
Bu cihaza bağlı kişiler hakkında saldırgana bilgiler sağlayabilecek
“finger” servisi de kapatılmalıdır:
no service finger
Daha önceden de belirtildiği üzere yönlendiricide web sunucusu da
çalıştırılmamalıdır:
no ip http server
R.Güvenliği-7
6.İşletim Sistemi
Yönlendirici için işletim sistemi (Operating System)
seçilirken ağın ihtiyaclarına uygun ve aynı zamanda
donanımın desteklediği bir versiyon olmasına dikkat
edilmelidir. Her ne kadar işletim sistemleri güvenlik
testlerine tabi tutulup daha sonra piyasaya sürülüyorsa da
daha sonradan güvenlik açıkları bulunabilmektedir. Bu
nedenden dolayı çıkan yamaları takip edip upgrade yapmak
gerekebilmektedir.
AĞI ROUTER ile Korumak
Yönlendirici, bazı ağlarda yönlendirici görevinin yanı sıra
güvenlik duvarı gibi çalışacak şekilde de ayarlanabilmektedir.
güvenlik duvarı işlevi, basit bir paket filtreleme fonksiyonundan
oluşmaktadır ve günümüzdeki güvenlik duvarlarına oranla
oldukça ilkel kalmaktadır.
Yönlendiricinin temel görevinin yönlendirme (routing) olduğu
unutulmamalı, bu tür bir güvenlik duvarı işlevinin cihazın
performansını düşüreceği dikkate alınmalıdır.
Yönlendiriciyi aynı zamanda detaylı paket filtreleme özellikleri
ile kullanmak, sadece küçük ağlarda veya güçlü omurga
cihazlarının bulunduğu kampüs ağlarındaki iç yönlendiricilerde
tercih edilmelidir.
Ağı R ile korumak-2
Bu bölümde yönlendirici ile ağdaki bilgisayarlara gelebilecek
saldırıların engellenmesi için bazı ipuçları verilecektir.
1. Riskli portları kapatmak:
İnternet üzerindeki servisler, kullanıcılara hizmet götürebilmek için
bazı sanal port numaraları kullanırlar (örn: http için 80 numaralı port
kullanılmaktadır). Saldırganlar veya kötü yazılımlar servislerin
açıklarını kullanarak hizmet verilen port numarası üzerinden
bilgisayar ağına sızabilirler.
Bunu önlemenin bir yolu riskli portları yönlendirici ile kısıtlamaktır.
Riskli portların listesi [http://www.nsa.gov/snac/cisco/guides/cis2.pdf] adresteki referansının 38 ve 39 sayfalarında listelenmiştir.
Aşağıdaki örnekte 445 nolu UDP portu ile finger servisi
bloklanmaktadır:
access-list 101 deny udp any any eq 445
access-list 101 deny tcp any any eq finger
access-list 101 permit ip any any

Ağı R ile korumak-3
2.Bazı saldırı tekniklerine karşı önlemler
IP spoofing : Kötü niyeli kişi hattı dinler giden paketlerin kaynak ve hedef
adresini alır. Hedef adresini kendi ip’si yaparak kaynak adrese cevap verir. Böylece
erişim listesine takılmadan bilgisayar ağına sızmış olur.
Bunu önlemenin yolu, yönlendiricinin kaynak adresi hedef makinaya
varmadan kimseye göstermemesidir. Bu işlem Cisco cihazlarda “no ip sourceroute” komutuyla yapılabilmektedir .
Routing Protokole olan saldırılar: Saldırgan yönlendiricinin routingprotokolünü
bozmadan yollanan paketlerin bir kopyasının kendine de yollanmasını sağlayabilir
veya protokolleri kaldırarak yönlendiricinin diğer yönlendiricilerle haberleşmesini
kesebilir. Haberleşmenin yok olması, yönlendiricinin aldığı paketleri nereye
göndereceğini bilmemesi ve servis dışı kalması(DoS) saldırısıdır. Bunu önlemenin
yolu ise gönderilen ve alınan routing protokolu paketlerini filitrelemektir. Örneğin
IGRP routing protokolünü filtrelemek için yazılmış ACL aşağıda verilmiştir.
router eigrp
network 200.100.17.0
distribute list 20 out ethernet 0
distance 255
distance 90 200.100.17.0 0.0.0.255
access-list 20 permit 200.100.17.0 0.0.0.255
Ağı R ile korumak-4
Çıkış (Egress) ve Giriş (Ingress) Erişim Listeleri
Bu erişim listeleriyle yönlendiriciye gelen paketlerdeki kaynak IP
adresleri kontrol edilmektedir.
Dış ağdan iç ağa gelen paketlerde, gelen paketlerdeki kaynak ip’lerin
kontrolüne giriş (ingress) filtreleme denmektedir. Bu kontrolde gelen
paketlerdeki ip’lerde internet ortamında kullanılmayan (rezerve
edilmiş) adresler bulunduğunda bu paketler kabul edilmeyecektir.
Ağ adresimiz 200.100.17.0/24 ise, dış dünyadan böyle bir IP
aralığına ait bir paket gelmemesi gerekmektedir. O zaman ingress
kısıtlamaları aşagıdaki gibi olacaktır:
access-list 101 deny ip 10.0.0.0 0.255.255.255 any
access-list 101 deny ip 172.16.0.0 0.15.255.255 any
access-list 101 deny ip 192.168.0.0 0.0.255.255 any
access-list 102 deny ip 200.100.17.0 0.0.0.255 any
access-list 101 permit ip any an
Ağı R ile korumak-5
İAğdan dış ağa giden paketlerde, gelen paketlerdeki kaynak ip’lerin
kontrolüne çıkış (egress) filtreleme denmektedir. Kendi ağ ip adresi aralığında
olmayıp da internete çıkmak isteyen ip’ler kısıtlanmalıdır. Böylece kurumun
ağı kullanılarak başka kurumlara yapılabilecek kaynak IP adresi değiştirme
tabanlı saldırılar engellenecektir. Bazı reserve edilmiş IP lerin kısıtlanması
aşağıdaki gibidir:
access-list 102 permit ip 200.100.17.0 0.0.0.255 any
access-list 102 deny ip any any
Örnekte dışardan gelen trafik ingress erişim listesi ile seri arayüzde, içeriden
gelen trafik de egress erişim listesi ile ethernet arayüzünde tanımlanmıştır.
interface serial 0
ip access-group 101 in
interface ethernet 0
ip access-group 102 in
Ağı R ile korumak-6
“Reverse Path” Kontrolü: Gönderdiğimiz paket “ethernet 0”
arayüzünden gönderiliyor fakat cevabı “ethernet 1” arayüzünden
geliyorsa bu işte bir yanlışlık var demektir. Bunu önlemek için
geliş gidiş istatiğini tutan CEF routing tablolarından yararlanmak
gerekmektedir. Bunu sağlamak için de seri arayüzde bu komutun
uygulanması gerekmektedir.
İp cef disributed
!
interface serial 0
ip verify unicast reverse-path
Ağı R ile lorumak-7
Smurf attack: IP adresi kandırmacası ve broadcast (aynı
subnetteki herkese yollama) ilkelerine dayanır. Saldırgan,
saldırmayı hedeflediği bilgisayarın IP’sinden paket geldiğinin
sanılması için, kaynak adresi bu IP olan “broadcast ping”
paketleri oluşturur ve gönderir.
Gönderilen ping paketlerinin cevabı gerçekte bu IP’ye sahip olan
bilgisayara gider ve orada gereksiz trafik yaratarak bilgisayarın
ağa ulaşması engellenir. Bu olayı yönlendiriciden önlemenin bir
yolu da yönlendiricideki arayüzlere
“no ip directed-broadcast” komutunu girmektir.
ICMP (İnternet Control Message protocol) Protokolu
• IP protokolu bağlantısız bir protokol olduğundan, ağda seyahat eden
datagramların iletim ve teslimat sürecinde meydana gelen hataları, uyarı
ve kontrol bilgilerinin alışverişi için ICMP protokolu kullanılır. Bu mesajlar
ağ yöneticileri tarafından değerlendirilerek ağ içerisindeki aksaklıklar
belirlenir.
• ICMP iletileri IP datagramları içerisinde Kapsüllenerek seyahat eder.
• ICMP mesajları aşağıdaki fonksiyonlar içindir:
- İstekler (Request)
- Yanıtlar(Responses)
- Hata mesajları : ICMP hata mesajı; başlık ve
soruna neden olan IP datagram payload’ının bir kısmını içerir ( ilk 8 byte).
ICMP Hata mesajları aşağıdaki durumlarda üretilir.
- IP datagramların hedefe ulaşamaması durumunda
- Ağ geçitlerinin, datagramları hedefe yönlendiremeyecek kadar yoğun
olmaları durumunda
- Datagramların hedeflerine gidebileceği daha uygun bir yol olması
durumunda.
• Routerlar, datagramları yönlendirirken oluşabilecek problemleri
bildirmek için ICMP mesajı üretebilirler.
• Bilgisayarlar; protokol ve servis problemleri yaşadıkları zaman ICMP
mesajı üretirler.
• Bilgisayar veya ağ testleri için veya ağdan bilgi elde etmek içinde
ICMP mesajları kullanılır. (Request ve Response)
• Sadece IP datagramlarla ilgili olaylarda ICMP mesajı üretilir.
• Parçalanmış IP datagramlarda oluşacak hatalarda sadece ilki için
ICMP mesajı iletilir.
• ICMP mesajlarının seyahat ile ilgili problemler için ICMP mesajı
üretilmez.
ICMP Mesaj Formatı
Çok kullanılan ICMP Mesajları
Type
0 Echo Reply (Yankı): hedefin ulaşılabilir olduğu denetimi için.
3 Destination Unreachable: hedefin erişilemez olduğunu belirler
4 Source Quench: Rotadaki router’ın çok yoğun olduğunu belirtir.
5 Redirect: Routerlar rota belirlemek için kullanır.
8 Echo Request
11 Time Exceeded : Zaman aşımı- TTL’in 0’landığı bilgisi
12 Parameter Problem : IP datagramda oluşan problemleri bildirir.
13 Timestamp :Paketlerin iki nokta arasındaki gidiş geliş süreleri için.
14 Timestamp Reply:
15 Information Request
16 Information Reply
En çok kullanılan mesaj türüdür (Echo 0 - 8) . “Yanıt-istek-yanıt” mesajları
olarak bilinir. Ping komutunun kullandığı mesaj’dır.
Ping ile sorgulanan bilgisayara echo istek (8) ile bir miktar bilgi gönderilir.
Hedef bilgisayardan ise kendisinin gönderdiği verinin aynısını içeren yankı yanıt
(echo reply 0) ICMP mesajını göndermesini ister. Bu bildirim yapılmış ise iki
nokta arasında iletişimin yapılabilir olduğu anlaşılır.
Zaman Damgası istek / cevap: saatleri senkronize etmek için
kullanılır.
• Source quench (Sıkışık Ağ Trafiği): trafik yükleniminden
hakkında bilgilendirmek için kullanılır
• Parametre sorunu: Bilgisayar veya router, başlık üzerinde IP datagramın
iletilmesine mani bir durum olduğunu tespit ederse, datagramı yo edip
karşıya bildirmesi içinir.
ICMP mesajlarını kullanan programlar
• Ping ve traceroute uygulamaları ICMP protokolunu kullanır.
• Ping: en çok kullanılan ağ analiz programlarından birisidir.
• Ping, hedef bilgisayara “yankı (echo) istek” mesajı gönderir. Eğer hedef
bilgisayardan “yankı(echo)” yanıtı gelirse, Ağ üzerinde erişilebilir olduğu
anlaşılır.
• Ping her gönderdiği mesaj üzerine gönderilme zamanını ekler. Alınan yanıtı
kullanarak paket iletimi için geçen zamanı bulabilir.
• Traceroute: Datagramların hedeflerine ulaşıncaya kadar izledikleri rotanın
belirlenmesi için kullanılan bir analiz programıdır.
ICMP ATAKLARI
• ICMP mantıksal hataları teşhis ve bildirim için
kullanılır.
• ICMP kimlik doğrulaması sunmaz.
• Böylece ICMP, ağdaki cihazları tarama ve istismar
etmek için kullanılabilir.
• ICMP kullanımı ile, backdoor, port scan, redirect trafik, echo
gibi DoS atakları düzenlenebilir.
77
ICMP Format
78
ICMP Echo Atakları
• Ping (ICMP ile gerçekleşir) bombardımanı saldılarının amacı,
büyük miktarda ICMP yankı istek paketilerini ağa yollayarak
bant genişliğini kullanıp ağ kaynaklarını tüketmektir.
• Alınan her ICMP yankı istek (request) paketine karşılık, ICMP
yankı cevap paketininde yayınlandığına dikkat ediniz.
• Özellikle bant genişliği düşük olan ağlarda bu ataklar
önemlidir.
79
Port Scanning
• ICMP, “hangi portların açık olduğunu keşfetmek için”,
saldırganlar tarafından büyük oranda kullanılır.
• Çünkü TCP protokolu gibi bağlantılı bir protokol
olmadığından saldırganlar için paha biçilmez bir
araçtır.
• Bir bağlantı noktasına bir ICMP paket gönderilmesi
ile portun açık olup olmadığını bildiren bir yanıt
alırsınız.
– Eğer port açık ise; bir cevap gelmeyecektir.
– Eğer port kapalı ise; ICMP tip3 code3 olan bir ICMP mesajı
alınacaktır. (Hedef ulaşılamaz, Port ulaşılamaz).
80
Port Scanning (cont.)
81
Type 3 (Destination Unreachable)
Code 3 (Port Unreachable)
ICMP Nuke Atakları
• Bilgisayarlar çoğu zaman aralarındaki bağlantının
sağlamlığını birbirlerine ICMP paketleri göndererek
anlarlar.
• ICMP Nuke Atağı; Sahte adresler (spoof edilmiş)
kullanarak, bir saldırgan; iki host arasındaki düzgün
iletişimi “Time Exceeded” (Type 11) veya
“Destination Unreachable” (ICMP Type 3)
mesajlarını her iki hosta’da göndererek, sanki hata
varmış gibi gösterebilir, bozabilir.
• Bu bir DOS atağıdır. Eski bir atak türüdür.
• ICMP Types and Codes ‘lar konusuna bir gözat.
82
ICMP Redirect Attack
(ICMP yeniden yönlendirme atağı)
• Bir saldırgan; ICMP “redirect” mesajları göndererek, bir hedef
router’a yönlendirilmiş mesajları, IP adresi saldırganın adresi olan
bir host’a forward eder.
83
ICMP Redirect Ataklarını Önleme
• Linux işletim sisteminde, kernel’de değişiklik yaparak
redirect mesajlarının kabul edilmemesini
sağlayabiliriz.
root@router# echo 0 >
/proc/sys/net/ipv4/conf/eth0/accept_redirects
84
ICMP Flood (ICMP Taşkını-Sel basması Bombardımanı)
• Ping Flood, bir ping (ICMP üzerinden yapılır) broadcast fırtınası yaratarak hedef
sistemi bunaltabilir. Bu bir DoS saldırısıdır.
• Linux’ta, ping –f kullanılarak herhangibir host’a bir taşkın oluşturulabilir.
root@router# ping –f 10.10.10.12 –c 1000
ile 10.10.10.12 IP’li host’a 1,000 paket gönderilir.
IP ping paketinin işleyişinden yararlanan “Smurf saldırıları” da ICMP FLOOD’un özel bir halidir. Çok
sayıda reply paketi ile hedefin gerçek trafiği alması engellenir. Smurf ataklarında; kurban bilgisayarın
IP adresinden network'ün broadcast adresine Internet (ICMP) isteği (ping) gönderilir ve network
üzerindeki bütün bilgisayarlardan kurban bilgisayara yanıt göndermesi sağlanır.
85
Resim: saldırgan , Spoof ettiği 1.2.3.4 Ip adresli
hostun adresi ile , ağdaki tüm bilgisayarlara ping
atar..
Ping Flood’dan korunma
• Ping flood, IPTable ‘ın konfigirasyonu ile “ICMP echorequest messages” larının sayısını sınırlayarak
durudurulabilir.
root@router# iptables –A FORWARD –p icmp –icmptype echo-request –m limit –limit 10/s –j
ACCEPT
(saniyede 10 tane gelen icmp echo request paketlerini kabul et)
root@router# iptables –A FORWARD –p icmp –icmptype echo-request –j DROP
(Icmp echo-request paketlerini düşür)
Not:iptables, Linux veya Unıx’te NAT’lama veya
paket filtreleme için bir araçtır.
86
Ping of Death
• Ping of Death, IP paketlerine gömülü olarak ICMP ile
gönderilen “echo request” mesajları ile yapılır. Bu
mesajlar 65.535 bayt’tan daha büyük mesajlar
halinde sürekli olarak gönerilirse Buffer kapasitesi
küçük olan makinalarda buffer taşmasına sebep
olarak makinanın çökmesine sebep olur. Ping of
death bir DoS atağı çeşididir.
Windows komut satırından:
ping -1 65550 192.168.1.X
Linux komut satırından:
ping -s 65550 192.168.1.X
87
TCP/IP Zayıflıkları Ve Çözümleri
Hedefe ulasan veri, IP paketlerinden olusmaktadır. Bu paketlerde:
• Gizlilik (Confidentiality): Paketin seyrettigi yol boyunca içerigi okunmus
olabilir.
Önlem: İçerigin sifrelenmesi.
• Paket Dogrulama (Authentication): Paketin kaynak adresi degistirilmis
olabilir (Örn:spoof saldırıları).
Önlem: Daha kuvvetli dogrulama yöntemlerinin kullanılması.
• İçerik bütünlügü (integrity): Paketin içerigi degistirilmis olabilir.
Önlem: Daha gelismis data bütünlügü kontrollerinin yapılması.
• YÖNLENDİRİCİ GÜVENLİĞİ
• Sedat Kulduk, Enis Karaaslan,
• kulduk@bornova.ege.edu.tr,
enis@bornova.ege.edu.tr
• Ege Üniversitesi Network Güvenlik Grubu
OSI 4.katman
(Transport - İletim layer)
Güvenliği
İletim katmanı protokolları
OSI modelinde, farklı ana sistemler üzerindeki uygulamalar arasındaki iletişimi
sağlayan katman transport katmanıdır. Bu katman bünyesinde, TCP ve UDP gibi
veri iletişimini farklı şekillerde sağlamak üzere iki protokol barındırır.
•TCP (Transmission Control Protocol); bağlantıda olan iki ucun senkonize olarak
çalışmasını sağlar, hata denetimi yapar, güvenli veri akışını sağlar.
•UDP(User datagram Protocol) ise iletişim içinde olan iki nokta arasında
senkronizasyon öngörmez, güvenilir olmayan veri akışı gerçekleştirir.
• Tek başına TCP ve UDP protokollerini kullanarak uzaktaki makinalara doğrudan veri
iletimi yapılamaz. Fakat aynı bilgisayarda çalışan uygulamalar arasında veri iletişimi
yapılır.
TCP protokolu, iki uç arasında
bağlantıya dayalı güvenilir bir veri
akışı sağlanırken, UDP protokolunda
gönderilen veri paketlerinin hedef
bilgisayara ulaşacağı garanti
edilemez. Akış kontrolu sağlanmaz.
UDP genellikle, gönderilen paketlerin
sadece belirli bir aktif cihazı hedef
aldığı uygulamalarda kullanılır.
TCP Protokolu
• TCP protokolu; bilgisayarlarda çalışan uygulamalar arasında;
<İstemci IP adresi, Port No>, <Sunucu IP adresi, Port no> ikililerini temel
alan bağlantı kurar. Her TCP bağlantısı bu ikililerle ifade edilir.
• IP protokolu bağlantısızdır. Dolayısıyla gönderilen paketlerin yerlerine
ulaştığını garanti etmez. Bu açığı kapatmak için, bağlantılı ve güvenli veri
akışını sağlayan TCP protokoluna ihtiyaç duyulur.
• TCP protokolunu kullanan uygulamalar veri göndermeden önce bağlantı
kurmak zorundadaırlar.
• TCP , bağlantıda olan bilgisayarlar arasındaki güvenli veri iletişimini
sağlayan, sanal devre mantığıyla çalışan bir protokoldur.
• Hata denetimi yapar
• Güvenli veri iletimi sağlar.
• Bağlantıda olan bilgisayarlar arasında akış, tıkanıklık kontrolu sağlar.
• Çoklama (Multiplexing) yöntemiyle birden fazla bağlantıya izin verir.
• Sadece bağlantı kurulduktan sonra veri iletimi sağlar.
• Gönderilen mesaj parçaları için, önceli, güvenlik tanımlamaları yapılabilir.
• Veriler, 8 bitlik guruplar halinde (bunlar 1 bayt olabileceği gibi
binlerce bayt’lık guruplar şeklinde de olabilir) işaretlenerek
(numaralanarak) gönderilir. Örneğin bir TCP uygulamasının 1024
oktetlik bir veri yollaması gerekiyorsa, bu bilgiler 1024 tane 1
oktetlik veya 256 tane 4 oktetlik parçalar halinde gönderilebilir.
• İşaretlenerek gönderilen her parça için , alıcı uçtan cevap
beklenir.
• TCP gönderdiği her parçayı numaralandırır. Bu no’lar kullanılarak,
verilerin gönderildiği sıra ile alıcı tarafından alınması sağlanır.
• Gönderilen her veriye atanan dizi numarası sayesinde hangi
verinin hedefe ulaşıp ulaşmadığı kontrol edilir. Dizi no TCP
başlığı kısmındadır.
• Alıcı ise TCP bağlantısı ile aldığı her pakete karşılık yeni bir mesaj
parçasını göndericiye bildirir. Bu mesajın başlığındaki ACK no’su
ise gönderilmesi beklenen bir sonraki parçanın sıra numarasını
da barındırır.
• TCP protokolu her iki yönde de veri akışına imkan sağlar (yani her iki
trafta biribirlerine veri gönderebilirler. Gönderilen veriler byte(8 bitlik)
gurupları şeklinde değerlendirilir.
• Bağlantı kurulması < [ IP adres1, port no 1], [ IP adres2, portno2 ]>
gibi iki uç nokta arasında gerçekleşir. Seçilen port no’lar uçlardaki
uygulamalar tarafından farklı şekilde seçilmiş olabilir. Biribirleriyle aynı
olma zorunluğu yoktur.
• Yukarıdaki parametreler sayesinde bilgisayarlar arasında birden fazla
TCP bağlantısı sağlanabilir.
PORT KAVRAMI
• Bir Hos’tun diğer host üzerindeki değişik servisleri (hizmetleri)
kullanabilmesi için veya değişik bilgisayarların aynı
bilgisayardaki bir servisi kullanabilmesi için bu servisi
tanımlayan adreslemeler vardır.
• TCP protokolunda her uçta 216 tane farklı TSAP adresi
tanımlıdır. Bu adreslere PORT denir.
• Uç düğümün 32 bitlik IP adresi ve 16 bitlik port adresinin
beraber kullanılmasına soket no denir. Bir soketin blok şeması
aşağıda verilmektedir.
(TSAP Adresi) IP Adresi Port no

Transport (Ulaşım )Katmanı
Port atama (Multiplexing-Çoklama)
• Aşağıdaki şekil’de, Birinci olayda, A host`u, C host`una bir TCP segmenti
gönderir. Bu segment bir yüksek-seviye prosesi ile haberleşmek için bir TCP
bağlantısı isteğidir. Burada SMTP`ye atanmış port 25 istenmektedir. Varış
port değeri 25 olarak sabitlenmiştir. Ancak, kaynak port tanımlayıcısı
bölgesel bir sorundur. Bir host cihazı iç işlemleri için herhangi bir uygun
numara seçebilir.
• İkinci bağlantı ise, (şekilde 2 rakamı ile gösterildi) SMTP`yi kullanmak
üzere C host`una yapılmıştır. Neticede, varış portu 25 aynıdır. Kaynak port
tanımlayıcısı farklıdır; bu durumda 401`e set edilmiştir. SMTP erişimi için
iki farklı numaranın kullanılması A host`u ve C host`undaki iki oturum
arasında bir karışıklık olmasını engeller.
Port atama-2
• Şekil de, bir önceki iki segmentin nasıl bağlantı kurduğu
gösterilmektedir. A ve C host`ları tipik olarak TCP bağlantıları
ile ilgili bilgileri port tablolarında saklarlar.
• Dikkat edilirse bu tabloların kaynak ve varış değerleri arasında
ters bir ilişki vardır. A host`unun port tablosunda, kaynaklar
400 ve 401, ve iki varış da 25`dir. C host`unda ise iki kaynak da
25, ve varışlar 400 ve 401`dir. Bu suretle, TCP modülleri ileri ve
geri haberleşebilmek için kaynak ve varış port numaralarını
terslerler.
Port atama -3
• Başka bir host`un C host`una aynı kaynak ve varış port değerleri ile bir bağlantı
isteği göndermesi olasıdır. Varış port değerlerinin aynı olması olağandışı değildir.
çünkü iyi-bilinen portlara sıklıkla ulaşım isteği vardır. Bu durumda, varış portu 25
SMTP`yi tanımlayacaktır. Kaynak port tanımlayıcıları bölgesel bir olay olduğundan
Şekil’de gördüğümüz gibi B host`uda kaynak portunu 400 olarak seçmiştir.
• Ek bir tanımlayıcı olmaksızın, A ve C host`ları arasındaki ve B ve C host`ları
arasındaki bağlantılarda çakışma olacaktır çünkü her iki bağlantı da aynı varış ve
kaynak port numaralarını kullanmaktadır. Bu gibi durumlarda, C host`u
datagramların IP başlıklarındaki IP adreslerini kullanarak ayrımı kolayca başarır. Bu
durumda kaynak portları ikilenir ancak internet adresleri oturumları farklılaştırır.
TCP Protokolu Mesaj Yapısı
Kaynak ve hedef portlar, servis noktalarının sağlanması içindir. İlk 1023 port no’su IANA tarafında
kullanılan standart port nolarıdır.Uygulamalar diğer port nolarını diledikleri gibi seçerler.
Sıra (dizi) no ve onay (Ack-Bilgi) no kısımları bağlantı güvenliği için kullanılan parça sıra no ve alıcı
tarafından beklendiği bildirilen (alıcı tarafında) parça no kısımlarıdır.
Bayrak alanı
ACK =1 bilgi numarasının geçerli olduğunu belirtir.
SYN =1 Bu durum TCP bağlantısının kurulacağını belirtir.
FIN =1 Bağlantının sonlanacağını bildirir.
RST = 1 bağlantının fazla hatalı olduğu, sonlandırılacağı anlamındadır.
PSH =1 TCP modülü aldığı veriyi acilen üst katmana gönderir.
URG =1 alıcıya, aldığı dataları işlemeden band dışı veri gönderilmesine izin verir.
TCP bağlantıları,”üç adımda
uzlaşma” Three Way
handshaking yöntemiyle kurulur.
SYN=1 ve ACK=0 bağlantı açma
isteği
SYN=1 ve SYN=1 bağlantı açma
onayı
SYN=0 ve ACK=1 Veri Paketi
veya ACK paketi
Pencere (Window) Alanı:
• Bu alan alıcı tarafından kullanılır ve veri akışını kontrol eder. Bu alan
gönderilmesi gereken oktet miktarını belirler. Pencere alanı kullanılarak
alınan paketler için tekbir bilgi paketi gönderilmesi sağlanır. Bu durum veri
akışını hızlandırır.
• Alıcı gelen verileri aldıktan sonra, karşı tarafa bilgi paketi ile beraber, kabul
edebileceği büyüklükteki dizi numarasının da gönderir. Kabul edilebilir dizi
numarası aralığına pencere denir. Pencere, alıcı tarafının onayı ile ,
göndericinin iletebileceği oktet sayısını belirler.
• Böylece, gönderici verilerin alındığına dair bilgi messajı almadan belirtilen
miktarda veri transferi yapabilir. Buda protokolun veri iletim hızını arttırır.
TCP protokolunda bağlantı açma (Three way handshake)
TCP bağlantı başlatma yordamı iletişim noktaları arasında üç paket iletim gerektirdiğinden
genellikle üç-yollu el sıkışma denir. Başlatan bilgisayar (A), yeni bağlantı için bir rastgele
başlangıç sıra numarası (ISN –İnital service-sıra no) seçer ve daha sonra SYN biti=1 ve
ACK biti =0 olarak ayarlanmış ilk paket gönderir. Bu pakete SYN denir
SYN alan B (yanıt veren), yeni bir bağlantı
için bir ISN (Başlangıç dizi no- örn.550)
seçer ve sonra SYN biti=1 ve ACK biti =1
olacak şekilde cevap gönderir. Bu paket
SYN / ACK Onay paketidir. ACK no alanına
ise A (oturumu başlatan)’ın SYN paketindeki
SEQ’ no +1 yapar.
A bu SYN / ACK onay paketini aldıktan
sonra; oturumun kabul edildiğini anlar. SYN
bit=0 ve ACK biti= 1 yaparak, yeni segmenti
B’ye gönderir. AN no’sunu 1 arttırır (551-
Alıcının gönderdiği paketteki ISN No’sunu).
Sıra Numarası (SN) alanına veri
olmamasına rağmen, A’nın paketindeki
ISN’yi bir arttırır. Bu ACK segmentinin tek
amacı A ve B ’nin bu işle ilgili sayaçlarının
senkronizasyonudur. Daha sonraki paketler
veri taşır.
Bağlantının koparılması
• Gönderilen herbir veri parçasının (segmentin) ağ üzerinde
kalabileceği bir belirli yaşam süresi vardır. Buna MSL
(maximum Segment Life) denir.
• TCP segmentleri alıcısına iletildiği zaman , datagramları
gönderen bilgisayar pencere alanını ilerletebilmek için , karşı
tarafın bilgi paketi (ACK) göndermesini bekler. Bu bekleme
süresine “zaman aşımı” (time –out interval)denir.
• TCP bağlantısnın sonlandırılması isteği için FIN bayrağı =1 olan
bir segmentler oluşturulup gönderilir.
• Bağlantının koparılması için her ,ki uç noktanın da FIN
bayrağını kullanması gerekir.
• Her iki ucun birlikte karar vererk bağlantının kesilmmesi
işlemine; zarif kapanış (graceful close) denir.
• Eğer taraflardan birisi diğerine haber vermeden bağlantıyı
sonlandırırsa veri kaybı olabilir.
Kısa özet
Hizmet veren bir TCP portu açıksa
kendisine gelen SYN paketine karşılık olarak
ACK+SYN paketi döner. Dönen paketlerden ACK
(onay paketi), SYN ise hizmet veren tarafın istek
başlatma paketidir.
Port kapalıysa RST döner, SYNflood
saldırısının başarılı olabilmesi için portun açık ve
dinlemede (LISTEN mod) olması gerekir.
UDP (User Datagram Protocol)
Gelişmiş bilgisayar ağlarında paket anahtarlamalı bilgisayar iletişiminde bir
datagram modu oluşturabilmek için UDP protokolü yazılmıştır. Bu protokol
minimum protokol mekanizmasıyla bir uygulama programından diğerine mesaj
göndermek için bir prosedür içerir.
UDP güvenilir olmayan bir aktarım protokolüdür. UDP protokolü ağ
üzerinden paketi gönderir ve gidip gitmediğini takip etmez ve paketin yerine ulaşıp
ulaşmayacağına onay verme yetkisi yoktur.
• Geniş alan ağlarında (WAN) ses ve görüntü aktarımı gibi gerçek zamanlı veri
aktarımlarında UDP kullanılır.
• UDP bağlantı kurulum işlemlerini,akış kontrolü ve tekrar iletim işlemlerini
yapmayarak veri iletim süresini en aza indirir.
• UDP ve TCP aynı iletişim yolunu kullandıklarında UDP ile yapılan geçek zamanlı veri
transferinin servis kalitesi TCP'nin oluşturduğu yüksek veri trafiği nedeniyle azalır.
UDP paket formatı
• kaynak port: Opsiyonel bir alandır.
Gönderilen işlemin portunu gösterir.
Eğer gönderen host bir kaynak
numarasına sahip değilse bu alan “0”
ile doludur
• hedef port: Hedef host içerisinde,
işlemlere uygun ayrımları yapmak için
kullanılır. Hedef port internet
adresleri parçalarının genel
durumunu içerir.
• Uzunluk: UDP veri ve UDP başlığının
bayt cinsinden toplam
uzunluğudur.minimum 8 bayttır
• Checksum: IP ve UDP başlığı ve
verinin bilgisini içeren yalancı
başlıgın toplamı olan birbirinin
tamamlayıcısı 16 bitten oluşur.
Opsiyonel bir alandır. Hata kontrol
mekanizması sağlar. Eğer hata
kontrolü yapılmayacaksa bu alan “0”
ile doludur.
• Veri:Opsiyonel
UDP ile TCP 'nin farkları
TCP protokoluna yönelik saldırılar
• TCP protokolunun tasarım özelliklerinden dolayı iki
önemli zayıf noktası vardır.
- Protokol, TCP bağlantısı kurma isteği “SYN BombardımanıSYN Flooding” karşısında zayıf kalır : SYN flooding genellikle
serverlara yapılan bir saldırı türüdür. Amacı çok sayıda
“ Bağlantı istek Paketi” hazırlayıp sunucuya göndererek
hizmetleri aksatmaktır .
- Protokol “TCP oturumu ele geçirme “ saldırıları karşısında
zayıf kalır. “TCP oturumunu ele geçirme”; iki bilgisayar
arasında üç adımda sağlanan TCP bağlantısının birtakım
yöntemlerle ele geçirilmesi veya veri akışına ; bağlantı
içerisinde yer almaması gereken verileri eklemektir.
SYN FLOOD atakları
• SYN Flooding (SYN Bombardımanı) sunucunun başedemiyeceği kadar
fazla “bağlantı kurma isteği” paketlerinin ağ üzerine bırakılması ile
gerçekleştirilir.
• Saldırganlar, sunucuya sadece 1. syn paketini gondererek gelen 2.
pakete karsilik 3. syn onay mesajini gondermeden araliksiz olarak 1.
syn paketi (oturum acma istegi) gonderebilir.
•Sunucunun kapasitesinde acilabilecek oturum sayisi rakamlarla ifade
edilmis ise kisa sure icerisinde bu syn paketleri ile oturum acma istekleri
tamamen rezerve hale getirilir.
• Sunucu 3. syn paketini almadiğı sürece belirtilen zaman kadar
bekleyerek oturum islemini rezerve eder ve belirtilen sure dolmadan bu
oturum isteğini kapatamaz.
•Yuzlerce hatta binlerce oturum acma istegi karsisinda sunucu kısa süre
sonra yanit veremez hale gelir ve artik islevini yerine getiremez.
• Bu saldırı türü, sunucunun mümkün olduğu kadar pasif çalışmasını
hatta bağlantı isteklerine hiçbir şekilde cevap verermemesini amaçlar.
•Bu bir DOS saldırısıdır.
Syn Flood saldırısı, açık bir porta (dinlemede olan port), sistemin kapasitesinden fazla gönderilecek SYN
paketleriyle gerçekleştirilir. Bu kapasiteye Backlog Queue denilmektedir. İşletim sistemleri aldığı her SYN
paketine karşılık üçlü el sıkışmanın tamamlanacağı ana kadar bellekten bir alan kullanırlar, bu alan TCB
(Transmission Control Block) olarak adlandırılır . Bu alanların toplamı Backlog queue (Birikim
kuyruğu) olarak adlandırılır. Başka bir ifadeyle işletim sisteminin half-open olarak ne kadar bağlantı
tutabileceğini backlog queue veriyapısı belirler. Bu değer her işletim sisteminde vardır ve ön tanımlı olarak
düşük bir değerdir(256 gibi).
Synflood saldırılarında tüm mesele backlog queue’nin dolması ve yeni gelen bağlantıların reddedilmesidir.
Backlog queue değerinin büyük olması demek daha fazla half-open(SYN paketi) bağlantı kabul edebilmek
demektir. SYNFlood saldırılarında backlog değeri arttırılarak saldırıya karşı ek önlem alınabilir
Backlog queue dolmasıyla birlikte işletim sistemi yeni bağlantı kabul edemez ve bu esnada sunucuya
bağlanmaya çalışanlar bağlanamazlar ki bu da SYN Flood saldırısına denk gelir.
• SYN flood saldırısı için spoof edilmiş (taklit edilmiş) IP datagramlar kullanılır. Yani
bağlantı kurma istek segmentini taşıyan paketlerin gönderici IP’sine spoof edilmiş veya
yapay olarak yaratılmış adresler atanır.
• Taklit edilmiş paketler ile pasif bigisayar saldırısı için, seçilen IP adresine, IP
datagramların yönlendirilebilir olması fakat , bilgisayarın erişilebilir olmaması gerekir (
Sunucu onay segmentini gönderip oturumun senkronizasyonunu sağlayan üçüncü
paketi bekleyecektir.)
• Taklit edilmiş paketler için aktif bigisayar saldırılarında; Sunucunun gönderdiği
SYN/ACK paketlerine, aktif bigisayar, RST =1 olan datagramlar gönderir. Bu paketi alan
sunucu bağlantı isteğini sonlandırır. Hafızadaki yerini temizler.
Synflood Önleme Yöntem ve Çeşitleri
SynFlood saldırılarına karşı çeşitli önlemler
geliştirilmiştir. Bunlar arasında önemlileri;
• Syncookie
• Syncache(FreeBSD default)
• SynProxy
• TCP Authentication
SynCookie
Normal TCP bağlantılarında gelen SYN bayraklı pakete karşılık ACK paketi ve
SYN paketi gönderilir. Gönderilen ikinci (sunucunun gönderdiği) SYN paketinde
ISN (Sıra no) değeri random olarak atanır ve son gelecek ACK paketindeki sıra
numarasının bizim gönderdiğimizden bir fazla olması beklenir, son paket gelene
kadar da sistemden bu bağlantı için bir kaynak ayrılır (backlog queue).Eğer
bizim gönderdiğimiz SYN paketine dönen ACK cevabı bizim ISN+1değilse paket
kabul edilmez.
Syncookie aktif edilmiş bir sistemde gelen SYN paketi için sistemden bir kaynak
ayrılmaz, bunun aksine SYN paketine dönecek cevaptaki ISN numarası özel
olarak hesaplanır (kaynak.ip + kaynak.port + hedef.ip + hedef.port + x değeri)
ve hedefe gönderilir, hedef son paket olan ACK’i gönderdiğinde ISN hesaplama
işlemi tekrarlanır ve eğer ISN numarası uygunsa bağlantı kurulur, değilse
bağlantı kurulmaz.
Böylece spoof edilmiş binlerce ip adresinden gelen SYN paketleri için
sistemde bellek tüketilmemiş olacaktır ki bu da sistemin SYNflood saldırıları
esnasında daha dayanıklı olmasını sağlar.
Syncookie mekanizması backlog queue kullanmadığı için sistem
kaynaklarını daha az tüketir. Syncookie aktif iken hazırlanan özel
ISN numarası cookie olarak adlandırılır.
İstemci tarafı syncookie özelliği İnverse syn cookie (Scanrand
aracı) araçları kullanılarak syncookie engellemesi aşılabilir. Bu
durumda da bir ip adresinden gelecek max bağlantı sayısı
limitlenerek saldırı engellenmiş olur.
Syncookie’de özel hazırlanacak ISN’ler için üretilen random
değerler sistemde matematiksel işlem gücü gerektirdiği için CPU
harcar ve eğer saldırının boyutu yüksekse CPU performans
problemlerinden dolayı sistem yine darboğaz yaşar. DDOS
Engelleme ürünleri(bazı IPS’ler de ) bu darboğazı aşmak için
sistemde Syncookie özelliğini farklı özel bir CPU’ya devredeler.
SynCache nasıl çalışır?
LISTEN modundanki bir portun gelen SYN paketlerinde bellekten
bir alan ayırdığını ve bu alanın belirli boyutlarda olduğundan
bahsetmiştik. SynCache özelliği , gelen SYN paketleri için TCB
değerinden daha az yer kaplayan başka bir veri yapısı kullanmayı
önerir. Böylece sisteme gelen SYN paketlerinde daha az bellek
alanı harcanır(Normalde 700 Byte civarı, 160 Byte Syncache
kullanıldığında). Fakat yoğun bir saldırı da bu özellik kısa sürede
işe yaramaz hale gelecektir. Bu sebepledir ki Syncache tek başına
synflood saldırılarına karşı efektif bir koruma sağlamaz.
Syncookie’i tetikleyici olarak kullanılır. Yani sistemde öntanımlı
olarak syncookie aktif edilmez, syncache aktif edilir. Syncache
belli bir değerin üzerinde SYN paketi almaya başladığında
SYNCookie’ei tetikler vesistem koruma moduna geçer.
SynProxy
SynProxy, SYN paketlerine karşı proxylik yapmaya yarayan bir özelliktir.
Güvenlik duvarlarında ve Syncookie’nin kullanımının sıkıntılı olduğu
durumlarda rahatlıkla kullanılabilir. Syncookie gibi arkasında korumaya aldığı
sistemlere gelecek tüm SYN paketlerini karşılar ve üçlü el sıkışma
tamamlandıktan sonra paketleri koruduğu sistemlere yönlendirir
TCP Oturumunu ele geçirme saldırıları
• Sunucu –istemci arasında açılmış olan bir oturumu ele geçirmek için birkaç
adımlı işlem yapmak gerekir.
- Sunucu-İstemci arasındaki var olan TCP bağlantısının belirlenmesi: Hangi
kullanıcıların ne kadar süreyle nerelerle bağlantı kurduklarının bilinmesi için
bilgi toplama çalışması yapılmalıdır. Sunucu/İstemci arasındaki bağlantı
tespiti için; “NBTSTAT, Fingerprint, ve uzak sistemler için rpcinfo bu
komutlardan bazılarıdır. komutlardır.
- Sunucunun bağlantı sırasında datagramları için atadığı dizi numarasının tepit edilmeye
çalışılması : TCP protokolu diğer bilgisayarlardan gelen doğru dizi numarasına
sahip bütün paketleri “güvenilir” ve bağlantısı yapılmış bilgisayardan geliyor
kabul eder. ISN no’sunun tahmin edilebilir olması, bağlantı içerisinde yer
alan bilgisayarlara ait taklit edilen paketlerin oluşturulmasına sebep olabilir.
Bazı işletim sistemlerinde ISN kodlarını yaratan algoritmalar bilindiğinden bu
no’ların tespit edilmesi kolaylaşabilir.
- “SYN Flooding” ile sunucunun susturulması ve oturumun ele geçirilmesi.
UDP Portlarından Saldırılar
• UDP güvenilir olmayan bir aktarım protokolüdür. UDP
protokolü ağ üzerinden paketi gönderir, gidip gitmediğini takip
etmez ve paketin yerine ulaşıp ulaşmayacağına onay verme
yetkisi yoktur.
UDP Portlarından Saldırılar
• Bir bilgisayar üzerinde veya birkaç bilgisayar
arasında,UDP portlarına yöneltilecek yoğun paket
akışıyla gerçekleştirilen bu saldırılar, tek bir bilgisayar
üzerinde gerçekleştiriliyorken bu bilgisayarın
performansının düşmesine, birden fazla bilgisayar
arasında gerçekleştiriliyorken ise, ağ performansının
düşmesine sebep olacaktır.
• Birbiriyle haberleşmekte olan iki UDP servisinden birisi
veya her ikisi üreteceği yoğun paket akışıyla, karşısındaki
bilgisayarın servisini kilitlemeyi, bilgisayarın
performansını kötüleştirmeyi başarabilir.
UDP Portlarından Saldırılar
• Örneğin 7 numaralı portu kullanan UDP echo servisi,
karşısındaki bilgisayardan (istemci) aldığı bilgileri
olduğu gibi geri gönderir.
• 19 numaralı port üzerinden servis veren UDP chargen
servisi ise, istemci bilgisayardan her paket alışında,
rastgele sayıdaki verilerden oluşan paketi geri gönderir.
• Bu iki servise ilişkin UDP portlarının aynı bilgisayar
üzerinde veya değişik bilgisayarlar arasında birbirine
bağlanması, sonsuz bir trafiğin oluşmasına sebep
olacaktır.
• Bu hem servisi veren bilgisayarı hem de trafiğin aktığı
ağı etkileyecektir.
Bir ana bilgisayarda chargen hizmeti çalışıyor ise; Chargen servisi, test ve
ölçüm amaçlıdır ve hem TCP hem de UDP protokollerini dinleyebilir.
TCP bağlantısı açıldıktan sonra, sunucu bağlanan ana makineye rastgele
karakter göndermeye başlar ve ana bilgisayarlar bağlantıyı kapatana kadar
devam eder.
Protokolün UDP sürümünde, sunucu, bağlanan ana bilgisayardan bir UDP
paketi aldığında rastgele bir sayı (0 ila 512 arasında) içeren bir UDP paketi
gönderir. Sunucu tarafından alınan herhangi bir veri atılır.
Chargen hizmeti, bir bilgisayardaki bir hizmetten başka bir bilgisayardaki
başka bir hizmete veri göndermek için taklit edilebilir. Bu eylem sonsuz bir
döngüye neden olur ve bir hizmet reddini saldırısı yaratır.
Echo servisi kendisine gönderilen her şeyi tekrarlar ve chargen hizmeti sürekli
bir veri akışı oluşturur. Birlikte kullanılırsa, sonsuz bir döngü oluşturur ve hizmet
reddine neden olur.
EK BİLGİ

UDP Portlarından Saldırılar
• Böyle bir saldırı sonucunda doğabilecek sonuçlar
şunlardır:
– Saldırının yöneltildiği servisler kilitlenebilir.
– Bu servisleri veren bilgisayarların performansı
düşebilir
– Servisleri veren bilgisayarların bulunduğu ağın trafiğini
arttırır.
• Bu saldırı tipinden korunmak için alınabilecek
önlemlerin başında saldırıda kullanılan servisleri
bilgisayarın üzerinden kaldırmak gelir.
UDP Portlarından Saldırılar
• Bu yaklaşımı kullanırken iptal edilecek servislerin ne
kadar gerekli olduğu da önemlidir.
• Bu saldırılarda en çok kullanılan UDP servisleri chargen
ve echo servisleridir. Bu servisler neredeyse hiç
kullanılmazlar. Dolayısıyla bu servislerin iptal edilmesi
ya da güvenlik duvarı üzerinden filtrelenmesi, normal
çalışmayı etkilemeyecektir.
• Saldırıların daha çok hangi servislere yapıldığının tespiti
için ağa saldırıları kontrol edip raporlayan programların
kurulması faydalı olacaktır.
UDP Flood Saldırısı
• UDP Flood saldırısı host tabanlı servis dışı
bırakma saldırılarından biridir.
• UDP Flood atağı saldırganın hedef sistemin
rastgele bir portuna UDP paket göndermesiyle
yapılır.
• Saldırgan, saldırının etkisini arttırmak için zombi
bilgisayar denilen, saldırganın önceden üzerine
casus yazılım yükleyerek ele geçirdiği sistemleri
kullanır.
• Böylece hem kendi IP adresini saklamış olup
yakalanma riskini azaltır hem de binlerce zombi
bilgisayarı kullanarak atağın kuvvetini arttırır.
UDP Flood Saldırısı
• Hedef sistem bir UDP paket aldığında hedef portta hangi
uygulamanın beklediği hesaplanır.
• Portta bekleyen uygulama olmadığı anlaşılınca erişilemeyen
sahte IP adreslerine bir ICMP paketi üretilir ve her paket için
60 sn beklenir. Bu saldırı ağda tıkanıklık ya da kaynak
doluluğuna sebep olur.
• UDP trafiğinin TCP trafiğine önceliği vardır. TCP protokolünün
uzun sürede gelen paket onayları karşısında tıkanıklığı kontrol
eden bir mekanizması vardır: bu mekanizma gönderme
aralığını düzenleyerek tıkanıklık oranını azaltır.
• UDP protokolü bu mekanizmaya sahip değildir. Bir süre sonra
tüm bant genişliğini kullanarak TCP trafiğine çok az yer bırakır.
• Eğer yeterli UDP paket hedef sistemdeki porta gönderilirse
sistem çöker ve servis dışı bırakılır.
Uygulama katmanı ve protokolları
(Uygulama+Sunum+Oturum)
• Hem OSI hem TCP/IP modelindeki uygulama
katmanındaki, uygulama programları, servisler ve
protokollar “insan - bilgisayar ağı” arasında bir arayüz
sağlamak içindir.
• Bir web tarayıcısı veya bir e-mail penceresini
açtığınızda, bir uygulama programı başlatılmış olur.
(program hafızasına yüklenen bu program bir
executable programdır).
• Hafızaya yüklenmiş herbir uygulama programı
(executable program) bir prosess olarak isimlendirilir.
User Applications, Services, and Application Layer Protocols
• Uygulama katmanı uygulamaları ve servislerini gerçekleştirmek için
belirlenmiş standartlara protokol denir.
• Uygulama programları , kullanıcıya; mesajları oluşturmak için bir yol , araç
sunar.
• uygulama katmanı servisleri, ağa bir arayüz oluşturmak için vardır.
• Protokolleri ise bu işlemlerin nasıl yapılacağını yöneten kuralları ve
formatları sağlamak içindir.
• Bir tek process, bu üç komponenetin hepsini birlikte kullanabilir. Örneğin
“Telnet”, bir uygulamadır, bir servistir, bir protokoldur.
• Uygulama Katmanı Protokolleri (Uygulama katmanı için tanımlı olan
prokoller), bir üst katmanda bulunan işletim sisteminin kullanıcıya
sunduğu program arayüzlerine (web tarayıcı, e-mail gönderici v.b) hizmet
verir. Kullanıcıya hizmet veren programın türüne göre uygulama
katmanında farklı protokoller çalıştırılır. SMTP, http, SNMP V.b
Uygulama Katmanı (Application Layer)
• Uygulama katmanı; kullanıcılar tarafından sıkça kullanılan protokolleri
içerir. Örneğin WWW’e erişimi sağlayan HTTP (HyperText Transfer
Protocol) bunlardan birisidir. Bir tarayıcı (browser) bir web sayfasını
görüntülemek istediğinde sunucuya istediği sayfanın ismini gönderir.
Sunucu da cevap olarak o sayfayı geri döndürür.
• Uygulama katmanında 2 önemli fonksiyonu yerine getirmek için yapılması
gerekenler açıklanır.
1-Çok değişik uç birimlerin (farklı editör kullanan farklı ekran düzenleri, metin
yazma ve silme sistemleri farklı olan) tanınmasının sağlanması. Bunun için
bir SANAL AĞ UÇ BİRİMİ oluşturulur. İşte tüm uç birimlerinin tanıyabileceği
bu sanal ağ uç birimi oluşturma işlemi protokolları doğurur. Tüm sanal
terminal (Uç birimi) yazılımları uygulama katmanında belirlenmiştir.
2-Bu katmanın diğer bir görevi ise uç birimler arasındaki dosya transferinin
sağlanmasıdır. Farklı dosya sistemleri, farklı adlandırma v.b değişik özellikler
gösterebilir. İşte bu farklı sistemler arasındaki dosya transferinin sağlanması
için gerekli protokoller, (e-mail v.b) bu katmanda tanımlı görevleri yapmak
içindir.
Uygulama katmanı protokolları
• Bu protokollar (SMTP, TELNET, HTTP v.b) bir üstte çalışan kullanıcı
programlarına hizmet verirler. Uygulama katmanı protokollarının herbiri,
biri kullanıcı (Client- hizmet alan) diğeri sunucu (server- hizmet veren) da
çalışmak üzere yapılandırılır.
• Web Browser, E-mail, Print Services, SIP, SSH and SCP, NFS, RTSP, Feed,
XMPP, Whois, SMB; DNS; FTP; TFTP; BOOTP; SNMP;RLOGIN; SMTP; MIME;
NFS; FINGER; TELNET; NCP; APPC; AFP; SMB
• SMTP (Simple mail transport protocol): Ağ içerisindeki kullanıcılar arasındaki
e-mail alışveriş kurallarını düzenler.
• SNMP( Simple network managment protocol): Ağ içerisindeki ağ aktif
cihazlarının yönetimi için kullanılan protokol.
• TELNET : Uzak bağlantı şeklidir. Sistem üzerindeki bir kullanıcının başka bir
sisteme bağlanarak onun terminali gibi o sistemin kullanılmasını sağlar.
• FTP (File Transfer Protocol): Bir bilgisayardan başka bilgisayara dosya aktarımı
için kullanılan protokol
• HTTP ( hyper Text Transfer Protocol): WEB sahifelerinin alış-verişini sağlayan
protokoldur.
• DNS(Domain Name Server): İnternet isimlerini IP noya çeviren protokoldur.
Sunuş Katmanı (Presentation layer)
• Alttaki katmanların bitlerle ve veri paketleriyle ilgilenen yapısının tersine
sunuş katmanı gönderilen bilginin sözdizimi ve anlambilimsel yapısıyla
(semantics) ilgilenir. Yani alt katmandan gelen verileri bilgi haline
dönüştürür.
• Değişik veri yapılarına sahip bilgisayarlar arasındaki bağlantıyı sağlamak
için soyut veri yapıları tanımlamak gerekebilir. Sunuş katmanı bu soyut veri
yapılarını idare eder ve üst-seviye veri yapılarının (örn. banka kayıtları)
tanımlanmasını ve bilgisayarlar arasında alışverişine izin verir.
• Farklı bilgisayarlar, karakterli farklı kodlamalarla kullanıyor olabilirler. Bu
farklı gösterime sahip bilgisayarların iletişimini mümkün kılmak için iletişim
standart kodlamayla yapılır ve gideceği yerde ise kendi kodlamasına
dönüşüm yapılır (örneğin bir taraf ASCII diğer taraf UnICODE kullanabilir).
• Ayrıca veri sıkıştırması, kriptografi v.b işlemler bu katmanda yapılır.
• SMB, AFP, NCP, MIDI, HTML, GIF, TIFF, JPEG, ASCII,
EBCXDR, ASN.1DIC
Oturum Katmanı (Session Layer)
• Farklı bilgisayarlardaki kullanıcıların biribirleri üzerinde
oturum açması hizmetini düzenler.
• Trafiğin tek veya çift yönlü olmasını düzenler.
• İletişimin senkronizasyonunu sağlar. Yani bir iletişimin
kopmasından sonra iki tarafın kaldıkları yerden iletişime
devam edebilmeleri için bir sağlama noktası (checkpoint)
kullanma), vs.
• TLS, SSH, X.225, RPC, NetBIOS, ASP, Winsock, BSD
• TCP-IP modelindeki uygulama kartmanı
da OSI’nin ilk üç katmanının görevlerini
tarif eder.
Bazı Ağ Uygulamaları Ağ Uygulaması oluşturma
Uygulama Mimarileri
• Client-Server (İstemci –Sunucu)
• Peer-To-Peer ( Eş düzey)
• Hibrid (C-S, P2P)
Uygulama oluşturma Süreci
İşlemlerin İletişimi (Process comunications)
Soketler
Process Adresleme
Uygulama katmanı protokolleri (devam)
API: uygulama program arayüzü
(application programming
interface)
o Uygulama ve aktarım
(transport) katmanı arasında
arabirimleri tanımlar
o soket: Internet API
o İki süreç sokete veri
göndererek ve soketten
veri okuyarak haberleşirler
Soru: haberleşen süreçler
birbirlerini nasıl “tanıyabilirler” ?
o IP adres: başka süreçleri de
çalıştırabilen ana sistemin
(host) IP adresi
o “port numarası” – ana
sistemlere gelen mesajların
hangi lokal süreçlere
gönderilmesi gerektiğini
belirlemesinde yardımcı olur
Sürec’in (Process) ihtiyaç duyduğu aktarım (ulaşım) servisi nedir?
Bilgi kaybı
o bazı uygulamalar (ör., audio)
kayıplara karşı çok hassas
değildir
o diğer uygulamalar (ör., dosya
aktarımı, telnet) %100
güvenilir bilgi aktarımı
gerektirir
Zamanlama
o bazı uygulamalar (ör.,
Internet telephony,
interaktif oyunlar) efektif
olabilmek için küçük
gecikmelere ihtiyaç
duyarlar
Band genişliği
o bazı uygulamalar (ör.,
multimedya) en az
miktarda band genişliği
gerektirir
o diğer uygulamalar (“elastik
uygulamalar”) ne kadar
band genişliği mevcut ise o
kadar kullanabilirler
Bazı genel uygulamaların aktarım(transport)
servisi gereklilikleri
Uygulama
Dosya aktarımı
e-posta
Web dökümanları
Gerçek zaman
audio/video
kaydedilen audio/video
interaktif oyunlar
Finansal uygulamalar
Bilgi Kaybı
kayıpsız
kayıpsız
tolerans
tolerans
tolerans
tolerans
kayıpsız
Band genişliği
elastik
elastik
elastik
audio: 5Kb-1Mb
video:10Kb-5Mb
yukarıda ki gibi
~ Kbps daha fazla
elastik
Zamana
duyarlılık
yok
yok
yok
var, ~100 msec
var, birkaç sec
var, ~100 msec
Var ve yok
Internet uygulamaları: uygulama, aktarım
protokolları RFC(Request of Comments)
Uygulama
e-posta
uzak terminal erişim
Web
Dosya aktarımı
streaming multimedia
uzak dosya servis sağlayıcı
Internet telefon
Uygulama
katmanı protokolu
smtp [RFC 821]
telnet [RFC 854]
http [RFC 2068]
ftp [RFC 959]
özel
(ör., RealNetworks)
NSF
özel
(ör., Vocaltec)
Aktarım (transport)
protokolu
TCP
TCP
TCP
TCP
TCP veya UDP
TCP veya UDP
UDP


Web: http protokolu
http: hypertext aktarım
protokolu
o Web uygulama katmanı
protokolu
o kullanıcı/sunucu modeli
o Kullanıcı: WWW
nesnelerini isteyen, alan ve
gösteren “browse” tarayıcı
o Sunucu: Web sunucusu
isteklere karşılık olarak
nesneleri gönderir.
o http1.0: RFC 1945
o http1.1: RFC 2068
PC
Explorer
Server
NCSA Web
sunucusu
Mac
Navigator
http protokolu: (devam)
o http: TCP aktarım servisi:
o kullanıcı, sunucu ile port 80
üzerinden TCP bağlantısını
(soket oluşturur) kurar
o sunucu kullanıcının TCP
bağlantısını kabul eder
o tarayıcılar arasında (http
kullanıcı) ve WWW sunucu
(http servis sağlayıcı)
arasında http mesajları
(uygulama katmanı protokol
mesajları) değiştirilir
o TCP bağlantısı kapatılır
o http önceki bağlantılardaki
durumları gözönüne almaz
o sunucu daha önceki kullanıcı
istekleri hakkında bilgi
saklamaz
o daha önceki durumları
gözönünde bulunduran
protokoller karmaşıktır!
o geçmiş (durumlar) muhafaza
edilmelidir
o sunucu/kullanıcı bağlantısı
kopar ise son bağlantı
durumları tutarsız olabilir ve
yeniden oluşturulmalıdır
farkli olarak
URL(Uniform Resource Locators) Kavramı
İnternet üzerindeki sunucu bilgisayarlarda milyonlarca web sayfası, milyonlarca
dosyalara nasıl ulaşılacak? Nerde olduğunu bilmediimiz bir sunucudaki web sayfasına
nasıl ulaşıyoruz?
Web, web sayfalarını ve diğer kaynakları tanımlamak için URL (Uniform Resource
Locators) adında bir şema kullanır. Bir URL şemasında neler bulunur?
http://www.mbe.com.tr/mbe/yapı.html
Bu URL’de bizi World Wide Web birliğindeki bir web sayfasına götüren kısımlar
Kullanılan protokol HTTP’dir
Tam domain adı “www.mbe.com.tr”
Dizin “mbe”
Alınacak dosya “yapı.html”
Çoğu zaman yalnızca tam domain ismi kullanılır. Web sunucular domain ismi ile
çağırılan web sayfalarında otomatik olarak “index.html, default.html, home.htm,
index.htm” sayfalarından hangisi varsayılan olarak belirlenmişse o dosyayı getirir. Bu
nedenle çoğu zaman dosya adı yazmadan yalnızca http://www.mbe.com.tr yazmamız
yeterli olmaktadır.



İki tip http mesaj formatı
mevcuttur
Request mesaj formatı


http cevap durum kodları
200 OK
o istek başarılı, istenilen nesne bu mesajın sonrasında
301 Moved Permanently
o istenilen nesne yer değiştirdi, yeni konumu bu mesajın devamında
belirtildi (Konum:)
400 Bad Request
o İstek mesajı servis sağlayıcı tarafından anlaşılmadı
404 Not Found
o istenilen doküman bu servis sağlayıcıda bulunamadı
505 HTTP Version Not Supported
Sunucu-> kullanıcı cevap mesajının ilk satırında.
Bazı örnek kodlar:
ftp: dosya transfer protokolu
o Ana sisteme veya ana sistemden dosya aktarımı
o Kullanıcı/sunucu modeli
o kullanıcı: transferi başlatan taraf (uzak dosya
sistemine ya da sisteminden)
o sunucu: uzaktaki ana sistem (remote host)
o ftp: RFC 959
o ftp sunucu: port 21
dosya aktarımı FTP
sunucu
FTP
kullanıcı
arayüz
FTP
kullanıcı
yerel
dosya
sistemi
dosya
sistemi
Ana
sistemdeki
kullanıcı
ftp: ayrık kontrol, veri bağlantıları
o ftp kullanıcısı ftp sunucusnu port 21
üzerinden aktarım protokolu olarak
TCP’yi belirleyerek temasa geçer
o İki paralel TCP bağlantısı açılır:
o kontrol: kullanıcı ve sunucu
arasında komutlar, cevaplar
değiştirilir.
“band kontrolu dışında”
o veri: sunucudan veya sunucuya
dosya verileri
o ftp sunucusu “durumu” korur:
kılavuz kütük (directory), önceden
doğrulama (authentication)
FTP
kullanıcı
FTP
sunucu
TCP kontrol bağlantısı
port 21
TCP veri bağlantısı
port 20
ftp komutları, cevapları
Örnek komutlar:
o ASCII metin olarak kontrol
kanalı üzerinden gönderilir
o USER kullanıcı ismi
o PASS şifre
o LIST bulunulan directory
içerisinde dosyaların
listesini verir
o RETR dosya ismi
dosyayı (gets) alır
o STOR dosya ismi
dosyayı ana sisteme (host)
saklar (puts)
Örnek dönüş kodları
o durum kodu ve cümlesi
(http’de olduğu gibi)
o 331 Username OK,
password required
o 125 data connection
already open;
transfer starting
o 425 Can’t open data
connection
o 452 Error writing
file
E-posta
• E-posta, yazma ortamı sunan bir yardımcı
program aracılığıyla yazılır; daha sonra
uygulama katmanında SMTP protokolüne
gönderilir.
• Burada alıcı ve gönderici adresleri yazıldıktan
sonra, hazırlanan mektup bir alt katmana, yani
ulaşım katmanına gönderilir.
Elektronik Posta
Üç temel bileşen:
o kullanıcılar
o posta sunucuları
o Basit posta akatarım (simple
mail transfer) protokolu”
o User Agent (Kullanıcı
arayüzü)
o “posta okuyucusu”
o Posta mesajlarını
düzenleyen, yazan, okuyan
o örneğin, Eudora, Outlook,
elm, Netscape Messenger
o giden, gelen mesajları
sunucuda saklama
kullanıcı posta kutusu
dışarı giden
mesaj kuyruğu
posta
sunucusu
user
agent
user
agent
user
agent
posta
sunucusu
user
agent
user
agent
posta
sunucusu
user
agent
SMTP
SMTP
SMTP
Elektronik Posta: posta sunucuları
Posta Sunucuları
o posta kutusu kullanıcı için
(okunmak üzere) gelen
mesajları bulundurur
o mesaj posta mesajları
(gönderilmek üzere) kuyruğu
o smtp protokolu e-posta
mesajları göndermek için
posta servis sağlayıcıları
arasında
o “kullanıcı”: gönderici
posta sunucusu
o “sunucu”: posta alan
sunucu
posta
sunucusu
user
agent
user
agent
user
agent
posta
sunucusu
user
agent
user
agent
posta
sunucusu
user
agent
SMTP
SMTP
SMTP
Elektronik Posta: smtp [RFC 821]
o Kullanıcıdan sunucuya eposta mesajlarını güvenilir
bir şekilde aktarmak üzere tcp kullanılır, port 25
o doğrudan aktarım: gönderici sunucudan alıcı
sunucuya
o Aktarımın üç aşaması
o el sıkışması (handshaking, (greeting))
o mesajların aktarılması
o bitiş
o komut/cevap etkileşimi
o komutlar: ASCII text
o cevap: durum kodu ve cümle
Örnek smtp etkileşimi
S: 220 hamburger.edu
C: HELO crepes.fr
S: 250 Hello crepes.fr, pleased to meet you
C: MAIL FROM: <alice@crepes.fr>
S: 250 alice@crepes.fr... Sender ok
C: RCPT TO: <bob@hamburger.edu>
S: 250 bob@hamburger.edu ... Recipient ok
C: DATA
S: 354 Enter mail, end with "." on a line by itself
C: Do you like ketchup?
C: How about pickles?
C: .
S: 250 Message accepted for delivery
C: QUIT
S: 221 hamburger.edu closing connection
smtp: özet
http ile karşılaştırma:
o http: pull
o email: push
o Her ikisi de ASCII
komut/cevap etkileşim,
durum kodlarına sahiptir
o http: dosya içerisinde birçok
nesne farklı bağlantılar ile
gönderilir
o smtp: birçok nesnebir tek
bağlantı ile gönderilir
Posta mesaj formatı
smtp: e-posta mesajlarini
degistirmek uzere protokol
RFC 822: metin mesaj formati
icin standart:
o Baslik satirlari, ornegin,
o To:
o From:
o Subject:
o smtp komutlarindan farkli!
o metin kismi
o “mesaj”, ASCII karakterleri
kullanarak
başlık
metin
boş
satır
Mesaj formatı: multimedya uzantıları
o MIME: multimedia mail extension, RFC 2045, 2056
o Mesaj başlığındaki ilave satırlar MIME içerik bilgisini
verir
From: alice@crepes.fr
To: bob@hamburger.edu
Subject: Picture of yummy crepe.
MIME-Version: 1.0
Content-Transfer-Encoding: base64
Content-Type: image/jpeg
base64 encoded data .....
.........................
......base64 encoded data
multimedya veri tipi
parametre belirtilmesi
veriyi cözmek
için kullanılan metod
MIME sürümü
cözülmüş veri
Posta erişim protokolleri
o SMTP: alıcının sunucusuna teslimat/saklama
o Posta erişim protokolu: sunucudan yeniden alınması
o POP: Post Office Protocol [RFC 1939]
o yetkilendirme (agent <-->server) ve aliş (download)
o IMAP: Internet Mail Access Protocol [RFC 1730]
o daha fazla özellikler (daha fazla karışık)
o sunucuda saklanan mesajlarin düzenlenmesi
user
agent
gondericinin
posta sunucusu
user
agent
SMTP SMTP POP3 veya
IMAP
alicinin posta
sunucusu
POP3 protokolu
dogrulama sureci
o kullanıcı komutları:
o user: kullanıcı
ismini belirtme
o pass: şifre
o sunucu cevaplari
o +OK
o -ERR
o aktarım süreci,
kullanıcı:
o list: mesaj sayılarının
listesi
o retr: meşajları sayısı ile
alınması
o dele: silme
C: list
S: 1 498
S: 2 912
S: .
C: retr 1
S: <message 1 contents>
S: .
C: dele 1
C: retr 2
S: <message 1 contents>
S: .
C: dele 2
C: quit
S: +OK POP3 server signing off
S: +OK POP3 server ready
C: user alice
S: +OK
C: pass hungry
S: +OK user successfully logged on
DNS: Domain Name System
Kişiler: birçok tanımlayıcı:
o Sosyal Güvenlik Numarası,
isim, pasaport #
o İnternet anasistemleri,
yönlendiriciler(router):
o IP adresi (32 bit) – veri akışını
adreslendirmek için
kullanılırlar
o “isim”, örneğin,
gaia.cs.umass.edu – kişiler
tarafından kullanılırlar
Soru: IP adresleri ile isimler
arasında dönüşüm ?
Domain Name System(Alan
İsimlendirme Sistemi):
o Dağıtılmış veri yapısı
birçok isim sunucusunun hierarşik
(sıra) düzeninde uygulanırlar
o Uygulama katmanı protoklou
ana sistem, yönlendiriciler, isim
servis saglayıcıları isimleri çözmek
üzere haberleşirler (adres/isim
dönüşümü)
o not: çekirdek İnternet
fonksiyonu, uygulama katmanı
protokolu olarak uygulanır
o ağ “uç”’larında kompleks yapı
DNS isim servis sağlayıcıları
o servis sağlayıcılarının hepsi isim-IP
adresleri dönüşümüne sahip
değildirler
o yerel isim servis sağlayıcılar:
o her ISP, şirket yerel (default)
isim servis sağlayıcıya sahiptir
o ana sistem DNS isteği ilk olarak
yerel isim servis sağlayıcıya
gider
o otoriter (authoritative) isim servis
sağlayıcıları:
o ana sistem için: bu ana sistemin
IP adreslerini, isim bilgilerini
saklar
o bu ana sistem için isim/adres
dönüşümünü gerçekler
Neden DNS tek merkezli
olamaz?
o tek noktada hata oluşması
o trafik hacimi
o uzak merkezi veri tabanı
o bakım
ölçeklendirme yapılamaz!
DNS: Root isim servis sağlayıcıları
o isim/IP adres dönüşümünü çözemeyen yerel isim servis sağlayıcıları
tarafından aranırlar
o root isim servis sağlayıcıları:
o isim dönüşümü bilinmiyor ise (authoritative) isim servis sağlayıcılarına
başvururlar
o dönüşümü sağlar
o yerel isim servis sağlayıcılarına dönüşümü gönderir
b USC-ISI Marina del Rey, CA
l ICANN Marina del Rey, CA
e NASA Mt View, CA
f Internet Software C. Palo Alto,
CA
i NORDUnet Stockholm
k RIPE London
m WIDE Tokyo
a NSI Herndon, VA
c PSInet Herndon, VA
d U Maryland College Park, MD
g DISA Vienna, VA
h ARL Aberdeen, MD
j NSI (TBD) Herndon, VA
dünya genelinde
13 adet root isim
servis sağlayıcı
Bilgisayar Sistemleri Güvenliği
SİSTEM GÜVENLİĞİ
• Günümüzde , değişik boyutlardaki bilgisayar sistemleri
birçok saldırıya uğramaktadır. Maruz kalınan saldırıların
kaynağı ve şekli incelendiğinde, saldırıların basitleştiği,
başarılı saldırılar için kullanılan bilginin yaygınlığının arttığı
gözlemlenmektedir.
• Birçok saldırı için ağ mimarisinde alınacak tedbirlerle
başarılı saldırı sayısı azaltılabilmektedir. Bu sebeple
birçok noktada ağın yapılandırmasında güvenlik,
performansın da önüne geçebilmektedir.
• Özellikle dış dünyaya verilen hizmetlerde, güvenli ağ
tasarımının büyük önemi vardır. Çünkü bu tür bilgi
paylaşımında bulunan bir ağın saldırganlar tarafından ele
geçirilmesi, devre dışı bırakılması, ağdan bilgi çalınması
veya ağın kaynaklarının kötüye kullanılması kurum ve/veya
kuruluşlara para, itibar, iş ve zaman kaybı olarak
yansıyacaktır.
Çok Sayıda Güvenlik Cihazı İçeren Bir Mimari Model
Bir bilgisayar ağ sisteminin güvenliğinden maksat, ağdaki aktif cihazların ve ağın
bütnünün saldırılardan korunması anlamındadır.Bu güvenliğin sağlanabilmesi için
Güvenlik Duvarı(Firewall):Ag güvenlik duvarı , kurumun agı ile dıs aglar
arasında bir geçit olarak görev yapan ve internet baglantısında kurumun
karsılasabilecegi sorunları çözmek üzere tasarlanan çözümlerdir.
• Özel Sanal Aglar (Virtual Private Network-VPN): Ortak kullanıma açık
veri agları üzerinden kurum agına baglantıların daha güvenilir olması için
VPN kullanılmaktadır. İletilen bilgilerin sifrelenerek gönderilmesi, Genel
/Özel (Public/Private) anahtar kullanımı ile saglanır. VPN kullanan birimler
arttıkça daha sıkı politika tanımları gerekli hale gelmektedir.
• (Saldırı) Nüfuz Tespit Sistemleri (Intrusion Detection Systems-IDS):
Süpheli olayları, nüfuz ve saldırıları tespit etmeyi hedefleyen bir sistemdir.
IDS, süpheli durumlarda e-posta veya çagrı cihazı gibi yöntemlerle sistem
yöneticisini uyarabilmektedir.
• Proxy: Proxy bir baglantı uygulamasında araya giren ve baglantıyı
istemci (client) için kendisi gerçeklestiren bir hizmettir. Proxy’nin
kullanımı, uygulama temelli (application-level) güvenlik duvarı olarak
da adlandırılabilir. Bu tür bir uygulama aynı zamanda kimlerin bu
hizmetleri kullanacagını belirlemek ve performans amaçlı olarak
bant genisliginin daha etkin kullanılmasını saglamak için de
kullanılır.
• • Anti-Virus Çözümleri: HTTP, FTP ve SMTP trafigini üzerinden
geçirerek virüs taramasını yapmayı ve kullanıcıya gelmeden önce
virüslerden temizlemeyi hedefleyen sistemlerdir.
• • İçerik Süzme (content filtering): Çesitli yazılımlarla ulasılmak
istenen web sayfalarını, gelen e-posta’ları süzmeye yarayan
sistemlerdir.
• VLAN : Yerel ağların kendi içerisindeki performansı ve güvenliği
arttırmak için, aynı switche bağlı bilgisayarların farklı şekilde
guruplanmasıyla elde edilen sistemler.
• Bu servislerin hepsinin konfigürasyonu ve kullanacakları kuralların
belirlenmesi, izlenecek güvenlik politikasına göre yapılmalıdır.
Güvenlik Duvarları
• Firewall’ler bir tür erişim denetleyicidirler. Kendi özel ağınız ile publik ağ arasında
çalışarak iki yönlü bir şekilde trafiği denetlerler.Networke giriş bu nokta üzerinde yapılır.
• Temel olarak bir firewall, network üzerinde kendisine gelen paketleri, tanımlanan kurallar
dogrultusunda geçirip geçirmeyecegine karar verir.
• Hardware veya software olarak gerçekleştirilebilir. Örnek olarak Firewall konfigirasyonuna
izin verern Routerlar veya Pix veya ASA serisi kutu çözümleri donanımsal Firewallere
örnek verilebilir.
• ipfw, ipchains, pf gibi yazılımsal çözümler ise Unix, Windows XP and Mac OS gibi işletim
sistemleri üzerine kurulabilir.
• Güvenlik duvarı belirli bir makineyi denetlemek için o makine üzerine (host-based)
kurulabileceği gibi, bir bilgisayar ağını denetlemek için de kurulabilir.
Yarı Güvenli Bölge Yapısı (DMZ): Eğer iç ağ farklı
güvenlik seviyesine sahip bölgelere ayrılmışsa
ve bu bölgeler arasında akan trafiğin güvenlik
duvarı tarafından denetlenmesi isteniyorsa bu
yapı kullanılmalıdır . DMZ’de genellikle işletmenin
web, e-mail,ftp v.b dışa açık server’ları bulunur.
Güvenli bölge: Firewll’ın koruduğu ağ bölgesidir.
Belirli politikalar dahilinde koruma sağlanan ağ
bölgesidir. Örnek;İntranet
Korumasız bölge: Firewall’ın önündeki ağdır.
Örnek İnternet
Bir güvenlik duvarı çeşitli işlevleri yerine getirebilir
• Ağ trafiğini Filtre ve kontrol eder.
• Olayların kaydını tutar (trafik).
• içerik taramayı gerçekleştirebilir. (virüs tarama motorları,
içerik engelleme, url filtreleme , Protokol uygunluk test)
• Adres değişimi (Network Address Translation NAT
fonksiyonu gerçekleştirmek) uygulayarak iç yapının
dışarıdan gizlenmesini sağlar.
• Atakları belirlediğinde diğer güvenlik cihazlarına uyarılar
gönderir.
• Bir sanal özel ağ (VPN) sunucusu olarak kullanılabilir.
• Yöneticilerin kimlik doğrulamasını yapar.
Firewall’ler değişik OSI katmanlarında trafiği kontrol edebilirler
Ana güvenlik duvarı teknolojileri şunlardır:
-Paket filtreleme: Paketleri sadece başlık bilgilerine göre değerlendirir.
• Statik Paket Filtreleme
• Durum denetimli Paket Filtreleme (Stateful Inspection)
- İçerik Filtreleme (Deep packet İnspection): Paketlerin uygulama içeriğinede
bakıldığı teknolojidir.
- Uygulama Seviyesi (Proxy özelliği): Bağlantıların sonlandırıldığı ve paketlerin
içeriğinin denetlendiği teknolojidir.
9
Paket Filtreleme (Ağ Katmanı Firewalları)
• IP paketlerinin başlık alanı içindeki bilgilere
bakılarak istenmeyen paketler karşı tarafa
geçirilmez. Bu amaçla bir kurallar tablosu
oluşturulur. Bu tabloda belirtilen kurallara
uymayan paketler karşı tarafa geçirilmeyip
süzülür. Bu tür firewall oluşturmanın en kolay
yolu konfigüre edilebilir bir yönlendirici (router)
kullanmaktır.
• IP başlığındaki kaynak adres, hedef adres ve
port numarası bilgilerine bakılarak gelen veri
analiz edilir ve ona göre geçirilir veya atılır; veya
göndericiye bir mesaj gönderilir.
Filtre kurallarına bir örnek – Default Politika
• Hiçbir paketi reddetme
iptables –P INPUT ACCEPT
iptables –P FORWARD ACCEPT
iptables –P OUTPUT ACCEPT
• İzin verilmeyen herşeyi reddet.
iptables –P INPUT DROP
iptables –P FORWARD DROP
iptables –P OUTPUT DROP
Iptables, Linux işletim sisteminin varsayılan güvenlik duvarıdır. Bu güvenlik
duvarı servislerin çalıştığı portlardan geçen trafiği engelleyebilir, başka bir
porta yönlendirme yapabilir.
11
statik paket filtreleme teknolojisi
• Bu mimari halen Linux IPChains gibi bazı Firewall sistemlerinde kullanılan eski bir
mimaridir. Gelen ve giden paketleri sadece geldiği yer ,erişmek istediği port
numarası, protokolü gibi değerleri ile inceler ve bu değerlerden paketin
erişimine izin olup olmadığının saptamasını yapar.
• Örneğin bir http isteği geldiğinde, erişmek isteği portun 80, protokolün TCP ve
geldiği yerin 1.2.3.4 IP'si olduğunu görür ve içerideki sunucuya ulaşmasına izin
verilmişse, bu paketin içerideki sunucuya gitmesine izin verir. Basit bir mimaridir.
• En büyük zayıflığı paketleri ilk gönderen sistemi, yani oturumu ilk başlatan
sistemi saptayamıyor olmasıdır. Bu durum ciddi riskler oluşturmaktadır, kaynak
portu taramaları ve bağlantıları bu risklere örnektir.
• Bir örnek olarak; Ağdaki bir çalışanın FTP portundan sunucuya bir iletişim
kurabilmesi için izin verilmiştir. Oturumun işleyişi ise önce çalışanın 21/TCP
portunu hedef port olarak belirleyerek bir sisteme dosya isteği göndermesi ile
başlar. Hedef sistem, kaynak portu 20/TCP olan paketler ile çalışana dosya
transferi yapar. Böyle bir durumda saldırgan ağa kaynak portu 20/TCP olan
bir paket gönderdiğinde (sanki FTP server göndermiş gibi) Firewall sistemi bu
paketi görecek ve “içeriden bu pakete istek gelmeseydi bu paket
gönderilmezdi” mantığına dayanacak ve paketin içeriye girmesine izin
verecektir.
13
Şekilde statik paket filtrelemenin nasıl olduğu görülmektedir.
• PC, 1.2.3.4 IP'li dosya sunucusunun 21/TCP portuna bağlanırken Firewall izin
veriyor. Ancak 25/TCP portuna bağlanmak istediğinde Firewall izin vermiyor.
• Dosya sunucusu ise isterse kaynak portunu 20/TCP yaparak PC'ye istediği
porttan ulaşabilir. Çünkü Firewall PC'nin bir isteğinin karşılığında bu paketlerin
gönderildiğini düşünür.
• Bu son durum, saldırgana; kaynak portunu 20/TCP yaparak, içerideki
herhangibir bilgisayarın herhangibir portuna erişme imkanı verir. Çünkü Firewall
20/TCP’nin ağdan gelmiş bir isteğe FTP sunucusunun cevabı olduğunu
zannetmektedir.
• Zaaf: statik paket filtreleme tekniğinin, oturumu ilk başlatan sistemi
saptayamıyor olmasıdır.
• Firewall'un paketin hedef portuna bakmaması sebebiyle saldırgan kaynak portu
20/TCP olan paketlerle içerideki herhangi bir sistemin örneğin 139/TCP portuna
ulaşabilecektir. Böylece Firewall üzerindeki erişim kontrol listeleri etkisiz
kalacaktır.
İç Dış
14
Dinamik paket filtreleme teknolojisi
(Stateful İnspection)
• Dinamik paket filtrelemeli Firewall'ların,klasik paket filtrelemenin yanısıra
oturumu takip etme özelliği de vardır.
• Checkpoint firmasının ürettiği bu teknoloji yine bu firmanın tescilli markası
olan Stateful Inspection ismiyle anılmaktadır. Günümüz Firewall sistemleri
genelde bu sistem ile çalışmaktadırlar.
• Temel olarak TCP oturumları bir başı , ortası ve sonu olan oturumlardır.
Hiçbir oturum başından veya ortasından kurulamaz. Bu durumda Firewall'lar
kuralları sadece SYN flag'ıyla gönderilen paketlere (nereden gönderildiği
önemli değil) uygular ve geriye kalan paketler oturumun tutulduğu tabloya
bakılarak takip edilir. Böylece örneğin FIN veya SYN/ACK flag'lı paketlerin
bir oturumun devamı olmadığından geçişi engellenebilir. Oturumun SYN
flag'lı paketler ile başlayacağını düşünerek tasarlanan bu sistemin kuralları
bu paketlere uygulaması oldukça mantıklı ve güvenlidir. Ayrıca TCP için
olan bu oturum izleme işlemi ICMP ve UDP paketlerine de uygulanabilir.
• Ancak bu teknolojinin zayıflıkları da vardır, paketlerin içeriğini kontrol
etmemeleri bu zayıflıklarının başlıca sebebidir, ayrıca FTP protokolünün
proxy özelliğini desteklemesi ve bunun kötüye kullanım oranın oldukça fazla
olması Stateful Firewall sistemlerinin en büyük dezavantajlarındandır.
15
• Şekilde, dinamik paket filtreleme sisteminin nasıl
işlediği görülmektedir. PC'nin isteklerinde sonuç
değişmezken dosya sunucusunun kaynak portu
20/TCP olan paketi ise engellenebilmektedir.
• Niye? Çünkü eğer server syn paketi ile oturum
kurma isteğinde bulunmamışsa 20/TCP Firewall
tarafından engellenebilir.
İç
Dış
• İzin verilmeyen herşeyi iptal et.
iptables –P INPUT DROP
iptables –P FORWARD DROP
iptables –P OUTPUT DROP
• Dişarıdan firewall’e ssh ile login olunmasına izin ver.
iptables –A INPUT –i eth0 –p tcp -–dport ssh –j ACCEPT
iptables –A OUTPUT –o eth0 –p tcp -–sport ssh –j ACCEPT
• Bütün interface’lerden ping’e izin ver.
iptables –A INPUT –p icmp –-icmp-type echo-request –j ACCEPT
iptables –A OUTPUT –p icmp –-icmp-type echo-reply –j ACCEPT
• Drop any traffic coming from host 80.63.5.7’
iptables –I INPUT 1 –i eth0 –s 80.63.5.7 –j DROP
17
Uygulama Katmanı Firewalları
• Uygulama katmanı firewalları en sıkı koruma yapan firewall tekniğidir. Bu
yöntemde ağın güvenliği için arada vekil (proxy) sistem kullanılır ( Bu işlem,
güçlü bir iş istasyonu üzerine yüklenen yazılımla gerçekleştirilebilir.)
• Proxy mimarisini destekleyen Firewall'larda oturum başlatan ve hedef
arasında gerçekleşmez. Oturum açmak isteyen taraf isteği Firewall'a
gönderir ve Firewall bu paketi hedefe ulaştırır, hedeften cevap yine
Firewall'a gelir ve Firewall tarafından oturumu açmak isteyen tarafa iletilir.
• Oturum açıldıktan sonrada aynı şekilde devam eder. Böylece 2 sistem arası
tamamen yalıtılır ve Firewall paketlerin gerek içeriklerine, gerek hedef ve
kaynak portlarına gerekse de gönderenin IP adresine müdahale edebilir.
• Paketlerin içeriğini kontrol edebilme Proxy Firewall'ların en büyük
artılarındandır.
• Proxy, bir bağlantı uygulamasında araya giren ve bağlantıyı istemci (client)
için kendisi gerçekleştiren bir servistir. Böylece aynı istekler bir defaya
indirgenerek bağlantı sayısı azaltılmış ve band genişliğinin daha etkin
kullanılması sağlanmış olur.
• Yetersiz olduğu noktalara gelince araya girmesi ve paketleri kendisinin
iletmesinin doğal sonucu olan yavaşlık ortaya çıkmaktadır. Ciddi bir
yavaşlık olmamasına rağmen artan bağlantı sayısı ve yoğun ağlardaki
veri trafiği hızı olumsuz yönde etkilemektedir.
18
19
20
21
Ağ Katmanı ve Uygulama Katmanı
Firewallarının Karşılaştırılması
• Ağ katmanı firewallarında kuralları aşmak
uygulama katmanı firewallarına göre kuralları
aşmaktan kolaydır.
• Uygulama katmanı firewallarında; ağ katmanı
firewallarına göre daha iyi kayıtlama (log) ve
etkinlik raporları tutmak mümkündür.
• Uygulama katmanı firewallarında sunucu makine
işlemlerle ilgilendiği için saldırılara açık haldedir.
• Ağ katmanı firewalları daha kolay konfigüre
edilir. Uygulama katmanı firewallarında ise ağ
yöneticisine büyük bir sorumluluk düşer; gerekli
olan konfigürasyonu kendisi yapmalıdır.
22
Şekilde, proxy mimarisinin işleyişi görülmektedir.
PC'nin istekleri Firewall'a gelmekte ve Firewall
üzerinden dosya sunucusuna ulaşmaktadır,
cevaplar ise yine Firewall üzerinden PC'ye
ulaşmaktadır.
Kaynak portu 20/TCP olan paketler için yine
engelleme söz konusudur.
23
24
FİREWALL TOPOLOJİLERİ
• Bir firewall değişik yollar ile
kurulabilmektedir. İhtiyaçlara bağlı olarak
küçük bir network yada kişisel bir
bilgisayar için yeterli korumayı sağlayan
basit bir firewall de kullanılabilir;
• yada daha fazla koruma ve güvenlik
sağlayan daha komplike bir firewall
seçilebilir.
25
Basit Dual-Homed Firewall
• Dual-homed firewall bir firewall kullanmanın en basit ve
en genel yoludur. Internet, direk dial-up modem yada
ISDN gibi diğer bağlantı tipleri üzerinden firewall’e girer.
Bu konfigürasyon tipinde DMZ (De-Militarized Zone)
bulunamaz. Firewall, üzerinde bulundurduğu filtreleme
kurallarıyla yerel ağ ile internet arasındaki paket geçişini
kontrol eder.
26
• Burada firewall’in bir yüzü ile yerel ağın
dışına, bir yüzü ile de yerel ağın içine
bağlanıldığı için dual-homed olarak
isimlendirilmiştir.
• Bu yöntemin kolaylık avantajı
bulunmaktadır. Eğer internet bağlantısı bir
modem üzerinden ise ve sadece bir IP
adresi varsa bu yöntem kullanılabilir.
27
Bütünüyle Serbest Olan DMZ İçeren İki-bacaklı
Network
• Daha avantajlı olan bu konfigürasyonda, dışarıya çıkmayı sağlayan
router dışarıda bir hub veya switch’e bağlıdır. Firewall ile
filtrelenmeden dış dünyaya direk ulaşmak isteyen makineler bu
hub’a bağlanır. Ayrıca firewall’in dışa açılan yüzü bu hub’a bağlıdır.
Firewall’in diğer yüzü ise iç ağda bulunan hub’a bağlıdır.Firewall
tarafından korunma ihtiyacı duyan makineler iç ağdaki hub’a
bağlanırlar. İç ağdaki hub yerine switch kullanmak ek güvenlik ve hız
avantajı getirir.
28
Eğer PPP üzerinden bağlanılıyorsa bu faydalıdır.
Burada bir makine dış router/firewall (Firewall No.1) dır. Bu makine PPP bağlantısını
oluşturmak ve DMZ bölgesine olan ulaşımları kontrol etmekten sorumludur.
Diğer firewall (Firewall No.2) standart dual-homed firewall’dir ve görevi iç ağı korumaktır.
Bir önceki şekildeki gibi; DMZ bölgesi korumasız olarak internete açık durumdadır. Bu durum
firewall’in konfigürasyonunu kolaylaştırmaktadır.
Eğer DMZ bölgesi için de sınırlı bir koruma sağlamak gerekirse iç ağı koruyan firewall’den
tamamen ayrılmış olarak bir filtreleme gerçekleştirilebilir. DMZ bölgesi için sınırlı bir koruma, harici
bir router ve çoklu IP adresleri kavramlarına bağlı olarak gerçekleştirilir.
DMZ bölgesi için sınırlı koruma sağlamak üzere iki çözüm mevcuttur. Birinci çözüm; ikinci
bir router/firewall kurmak.
29
ÜÇ BACAKLI FİREWALL
DMZ bölgesi için sınırlı koruma sağlamak üzere ikinci çözüm üç-bacaklı bir
firewall oluşturmaktır. Bu, firewall kutusunda DMZ için ek bir ağ bağdaştırıcısına
gerek duyulması anlamına gelir. Firewall, dış dünya ile DMZ arasındaki paket
yönlendirmeyi;dış dünya ile iç ağ arasındakinden farklı yapacak şekilde konfigüre
edilir.
Üç-bacaklı firewall’un dezavantajı ek
olarak gelen karmaşıklıktır. DMZ
bölgesine olan giriş/çıkış ve iç ağa
olan giriş/çıkış tek bir geniş kurallar
kümesi tarafından kontrol edilir.
Dikkatli olunmazsa bu kurallar yanlış
oluşturulabilir.
30
DMZ BÖLGESİ
• DMZ, firewall tarafından daha az korunan,
daha fazla erişime izin verilen bir bölgedir.
Firewall’a üçüncü bir ağ çıkışı eklenmesi
ve Internet'e servis verecek olan
makinelerin(DNS, mail relaying, FTP gibi
WEB servisleri) buraya konulması ile
oluşturulur. Örneğin DMZ'deki makinelere
NAT uygulanmayabilir, tahsisli IP
numaralarına sahip olabilirler.
31
NAT(Network Adress Translation)
• NAT, RFC 1613 ile tanımlanıp, hemen hemen bütün
işletim sistemleri, firewall cihazları ve uygulamalarca
desteklenen güncel ağlarda çok popüler bir uygulamadır.
• NAT hızla tükenen gerçek IP adreslerine bir çözüm olarak
doğmuştur. Başka bir deyişle gerçek IP adresiyle sadece
internete çıkmak için geliştirilmiştir.
• NAT internete bağlı bir cihaz üzerinde çalışır ve, iç ağdaki
IP adreslerini dış ağdan gizleyerek , ağınızı herkese açık
olan ağdan (internetten) gizler.
• NAT ağınızı şeffaflaştırır; yani dahili ağınızdaki
cihazların tümünü internet bağlantısı için konfigüre
etmeniz gerekmez. Gateway konumundaki NAT cihazının
bunları tanıması ve izin vermesi yeterlidir.
4 bilgisayar ve bir routerdan oluşan bu ağ internete
bağlanmıştır. Ağdaki bütün hostlar C sınıfı özel bir IP
adresine sahiptir.
Router da ‘özel ağ’ arayüzünde 192.168.0.1, internete
bağlandığı ‘açık ağ’ arayüzünde ise 203.31.220.134
gerçek IP adresine sahiptir.
NAT NASIL ÇALIŞIR
NAT’ın çalışması için 3 farklı yol vardır, ancak temel
prensip her üçünde de aynıdır.
Bunu bir örnek üzerinde anlatalım; router (firewall veya
normal bir PC) NAT desteğiyle direk internete bağlı
olsun. Bütün hostlar internete router yoluyla bilgi
göndereceklerdir.
Router NAT aracılığıyla bu paketleri işleyip hedef
adreslerine gönderir.
Her paket routerın ‘özel ağ’ arabiriminden alındığında
router ağ katmanında o paketin kaynak IP adresini
(192.168.0.10) çıkarır ve yerine gerçek IP adresini
(203.31.220.134) yerleştirir ve o paketi yeni haliyle
internete gönderir.
• Router içerisindeki NAT operasyonuna bakarsak; orjinal paketlerin
kaynak adresleri değiştiriliyor ve bu bilgi router içerisindeki (NAT
tablosu olarak bilinen) hafızanın belirli adreslerine yazılıyor. Bu tablo
sayesinde bir cevap paketi alınırsa, router ağ içerisinde hangi
hostun bu paketi beklediğini anlar ve ona gönderir.
NAT TABLOSU
• NAT Tabloları, routerlar tarafından (veya başka NAT
destekli cihazların) paketlerin alınıp, kendi arabirimlerine
iletim işlevinde en önemli birimlerdir.
• Dahili ağdan harici ağa olan her türlü iletişim (veya ters
yönü) izlenir ve tüm arabirimlerdeki paketlerin ne
yapılacağı konusunda yardımcı olacak özel bir tablo
oluşturulur.
• NAT tablosunun çok büyük olması (daha fazla hafıza
gerektirdiği anlamına da gelir) çok daha fazla çift yönlü
iletişimin izlenebilmesini sağlar.
• Büyük NAT tablosuna sahip NAT destekli cihazdan kasıt;
dahili ağdaki daha fazla sayıda istemciye hizmet
edebilmesi demektir.
• Burada, özel ağdaki 192.168.0.5 ve 192.168.0.21’in istekleri NAT
destekli routerın ‘özel ağ’ arabiriminden alınır. Bu paketler;
üzerlerinde küçük bir değişiklik yapılana kadar router üzerinde özel
bir alanda geçici olarak tutulurlar. Bu örnekte yapılan değişiklik,
kaynak IP adresleri yerine gerçek IP adresinin (203.31.220.134)
yazılmasıdır.
• Router paketleri salmadan önce, NAT tablosunda her
paket girişi için bir kayıt tutar. Bu kayıtlar, internetten
cevap geldiği zaman routerın ne yapacağı konusunda
uygun hareketin seçilmesini sağlar.
• Cevap alındığı zaman router NAT tablosuna bakar,
uygun kaydı bulur ve yapması gereken diğer
değişiklikleri yapar. Yani internetten gelen paketlerin
hedef adreslerini 203.31.220.134’ten 192.168.0.5 ve
192.168.0.21 olarak değiştirir ve paketleri bu hostlara
gönderip, NAT tabosundaki ilgili kaydı siler.
• Bir çok NAT cihazında NAT oturum limiti, mevcut hafıza
boyutu ile sınırlıdır. Her bir dönüşüm cihaz hafızasında
160 byte’lık yer harcar. Sonuçta 10000 dönüşüm için 1.6
MB hafıza alanı gereklidir. Bunun için yönlendirme
platformları daha fazla sayıda dönüşüme cevap
verebilmek için yüksek hafızaya sahip olmalıdır. Ancak
pratikte durum farklıdır.
• Küçük Cisco routerlar (700,800,1600 serisi gibi) NAT
destekli IOS’lere sahiptirler. NAT oturum sayıları 2000
civarındadır. Fakat 3000-4000 oturum açılmak istendiği
zaman çok büyük hafıza gereksinimi yanında CPU
yönetimi problemi de ortaya çıkar. Bu durumda mesela
ping cevapları çok uzun süre bekleyebilir ve ergeç paket
ölümlerinde de exponansiyel bir artış olur.
• Gateway ve firewall özelliği ile beraber çok büyük router
modelleri eş zamanlı olarak (8000-25000) oturum
açabilir ve çok büyük şirketlerde ihtiyaçları gidermede
kullanılır.
STATİK NAT
• Bir özel ağdaki tüm bilgisayarların internete kendi gerçek
IP’si ile çıkmak istemesi durumudur. Çok küçük ağlarda
bu durum görülebilir.
Bu diyagramda bizim özel ağımızın statik NAT modundaki router ile
internet bağlantısı görülüyor
• Bu modd’a her bir host kendisiyle eşleşecek bir IP
adresine sahiptir. Mesela 192.168.0.1 IP adresine sahip
host 203.31.218.208 gerçek IP adresiyle eşleşir. Artık bu
hosttan gelecek her bir paket direk kendine özgü gerçek
IP adresiyle değiştirilecektir.
• Herkesin ağ ihtiyaçları farklı olup, bu tip bir bağlantıyı
kullanmak; internetten özel ağının görünmesini ve
erişimin kolay olmasını isteyen bazı şirketler için ihtiyaç
olabilir.
1. örnek
• Bu örnekte 192.168.0.20 adresine sahip bir geliştirme
serverı bulunmaktadır. Bu serverın çok fazla güvenlik
ihtiyacı olmakla beraber bazı emin müşteriler tarafından
değişik servislerine erişmek için kullanılmaktadır. Aynı
zamanda ana file serverımızda (192.168.0.10)
müşterilerimizin erişebileceği özel bir veritabanı
bulunmaktadır.
• Bu seçenekte statik NAT’ın ancak kompleks filtreler ile
tek bir IP adresi üzerinden güvenliği sağlanmıştır.
• Eğer sadece bir servis (sadece http gibi) kullandırmak
amacıyla benzer bir kurulum arıyorsanız, bundan daha
güvenli ve daha kısıtlayıcı olması yönünden mutlaka
farklı NAT modlarını kullanmalısınız.
2. örnek
• Statik NAT için diğer bir örnek DMZ alanlarının kullanılmasıdır. DMZ
alanları; bazı gerekli makinelar (webserver, e-mail server gibi) internete
direk erişebilip, aynı zamanda bütün datanın saklanması ve özel ağın
internet bağlantısına da engel olmaması gereken alanlardır.
• Bu diyagramda 1.firewall’a 3 ağ bağlıdır;
a- internet (203.31.218.X),
b- DMZ alanı (192.168.100.X)
c- iki firewall arasındaki küçük özel ağ (192.168.200.X).
1.Firewall 3 farklı host için statik NAT olarak konfigure edilebilir, bunlardan
ikisi DMZ’deki serverlar, diğeri ise 2. firewall.
• Firewall’deki her bir arabirim, aralarında yönlendirme yapılabilmesi için
farklı ağların bir parçası olmalıdır. Bu sebeple diyagram IP adresleri
yönünden karışık görünmekte fakat bunlar gerekli olmaktadır.
NAT adres dönüşümü nasıl meydana gelir?
• Statik NAT dönüşümü işlemi bunu destekleyen tüm cihazlarda aynıdır, değişmez. Yani bir
router veya firewall kullanırsak her ikiside statik NAT’ın kullanılmasında aynı özelliklere
sahip olacaktır.
• Burada hosttan gelen paketin routerda nasıl değiştiği görülüyor. Sadece 192.168.0.3 olan
kaynak IP adresi 203.31.220.135 gerçek IP adresi ile değiştiriliyor. Hedef IP adresi, kaynak
portu veya hedef portu değiştirilmiyor.
• Paketin, gönderildiği hedef tarafından alındığını ve cevap gönderildiğini farzedelim; alınan
cevap veya bu hotsa gelen diğer paketler bu modifikasyonda aynı sıraya girerek alınmalı
ve ilgili host’a teslim edilmelidir.
• Bu diyagram gelen paketlerin router içerisinde
uğradığı değişikliği gösteriyor.

DİNAMİK NAT
• Dinamik NAT ile özel IP adreslerimizi gerçek IP
adreslerine –statik olmayan bir yolla dönüştürürüz. Yani
dahili hostların internet ile iletişim kurduğu her bir oturum
için, onların gerçek IP adresleri aynı kalsa da
(muhtemelen değişebilir) Bu IP adresleri ISS tarafından
bizim özel ağımıza tahsis edilmiş olan IP havuzundan
çekilirler.
• Dinamik NAT’ta, router IP dönüşümü için gerekli trafik
bilgisini almadan NAT tablosu üzerinde dönüşüm
gerçekleşmez.
• Dinamik dönüşümler NAT tablosundan silindikten sonra
ağdaki diğer hostlar tarafından kullanılmak için bir
timeout periyodu tutarlar.
• Bu örnekte, bizim router ile dahili hostları ayarlayabilmemiz için
ISS’den 4 gerçek IP adresi isteğimiz vardır(203.31.218.210’dan
203.31.218.213’ kadar).
• 192.168.0.1 özel IP adresine sahip host, internete bir istek
gönderirken kurulan küçük oturumda, bu host’a 203.31.218.210
gerçek IP adresi tahsis ediliyor ve bu tahsis oturum sonlandırılana
kadar devam ediyor.
Varsayınız Firewall’un public ağa bağlanmak için 157.54.35.38 ve
157.54.35.39 gibi iki tane resmi IP adresi vardır.
Linux Netfilter ile NAT örnekleri
• Maskeleme (dynamic IP addresses)
iptables -t nat -A POSTROUTING -o eth0 -s 10.1.0.0/16 \
-j MASQUERADE
• Source NAT (static IP addresses)
iptables -t nat -A POSTROUTING -o eth0 -s 10.1.0.0/16 \
-j SNAT --to 1.2.3.4-1.2.3.6
• Destination NAT (with static IP addresses)
iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 \
-j DNAT --to 10.1.0.7:8080
• Statik ağ adres çevrimine alternatiftir. Port AdresYönlendirme
Dış dünyadan iç ağdaki web, ftp, e-posta
gibi sunuculara erişim sağlanması
amacıyla kullanılır.
• Port yönlendirmede erişim sağlanmak
istenen sunucuya ilişkin gerçek IP adresi,
güvenlik duvarının dış dünyaya açılan IP
adresi olarak belirlenir.
•Dış dünyadaki herhangi bir kullanıcı söz
konusu sunucuya ulaşmak için aslında
güvenlik duvarının gerçek IP adresine
erişim sağlar.
•Daha sonra güvenlik duvarı gelen
bağlantı isteğini inceleyip kendisi için olup
olmadığına bakar. Sonuç olarak bağlantı
isteği eğer güvenlik duvarı için değilse
ilgili sunucuya yönlendirilir.
Böylelikle iç ağdaki sunucuya dış ağdan erişim sağlanmış olur. Bu tür erişimler için
statik ağ adres çevrimi yerine port yönlendirmenin kullanılması daha güvenli
olmaktadır
Port yönlendirme
NAT Overload or PAT:
İç ağdan dış ağa tek bir
reel IP ile çıkmak için
PAT işlemi ayrıca, iç ağdaki çok sayıda özel IP’yi tek bir reel IP ile harici ağa
(Internet’e) çıkarmak içinde kullanılır. Veya birden fazla reel IP için kullanılabilir.
SALDIRI ÖNLEME MEKANİZMASI
• son zamanlarda saldırı önleme özelliği güvenlik
duvarlarında da bir özellik haline gelmeye başlamıştır.
• Normalde saldırı tespit ve engelleme sistemlerine ait olan
bu güvenlik özelliği, güvenlik duvarlarına da kısıtlı olarak
entegre edilmeye başlanmıştır.
•Bu özellik genellikle uygulama tabanlı güvenlik
duvarlarında bulunmaktadır. Bu tip güvenlik duvarları gelen
paketlerin içeriğini kontrol edebilmektedir. Böylelikle zararlı
içerik taşıyan paketler tespit edilip engellenebilmektedir.
• Ayrıca tespit edilip engellenen saldırılara ilişkin kayıtlar
tutulabilmektedir. Daha sonradan bu kayıtlar incelenip
saldırıların niteliği hakkında fikir edinilebilir.
Örneğin saldırıyı yapan bilgisayarın IP adresi tespit edilip bu IP
adresinden bundan sonra gelen bütün paketlerin bloklanması
sağlanabilir. TCP – SYN seli gibi birçok servis dışı bırakma saldırısı
engellenebilir.
Ancak güvelik duvarlarındaki bu özellik sınırlıdır ve sadece
saldırı imzaları dâhilindeki saldırılar tespit edilip durdurulabilmektedir. Bu
nedenle iç ağa gelen saldırıların tespit edilmesi ve engellenmesi için
sadece bu amaç için özelleşmiş olan saldırı tespit ve engelleme
sistemleri kullanılmalıdır.
Güvenlik duvarının saldırı önleme mekanizmasına ilişkin
aşağıdaki adımlar gerçekleştirilmelidir:
•En son çıkan güvenlik tehditlerine karşı koruma sağlanabilmesi
açısından saldırı imzaları periyodik olarak güncellenmelidir.
• Hem güvenlik duvarının yükünü hafifletmek hem de yanlış alarmların
(false positive) sayısını azaltmak amacıyla gerek duyulmayan
imzalar pasif hale getirilmelidir.
• Denetlenebilirliğin arttırılması amacıyla kritik saldırılara ilişkin kayıtların
tutulması sağlanmalıdır.

VIRTUAL PRIVATE
NETWORKS (VPN)
Geleneksel Bağlantı
VPN nedir?
•VPN(Virtual Private Network/Sanal Özel Ag) internet üzerinden
sifreli ve güvenli veri iletisimi saglamak için düsünülmüs bir
teknolojidir.
• Kamusal bir iletişim ağı üzerinde, Kiralık hatlar(Lease-line) gibi
daha güvenli, saglam çözümlerin yerine VPN kullanilmasinin temel
nedeni, maliyet ve kolay yapılandırmadır.
•Tüm VPN çözümlerinde İnternet erişimi üzerinden kurulan güvenli
tüneller söz konusudur. Güvenli tüneller, kriptolama teknikleri ile
sağlanır.
• Gartner Group; VPN'i, herkese açık bir iletişim altyapısı
üzerinden, iki veya daha fazla doğrulanmış/onaylanmış taraflar
arasında güvenli veri iletişimi sağlamak üzere oluşturulmuş sanal
ağlar olarak tanımlar.
Virtual Private Networks
Temelde iki tip VPN teknolojisi vardır. Amacımıza gore bu iki VPNteknolojisinden
birini seçebiliriz. Bu teknolojiler
1- Remote Access VPN (Uzak erişim VPN -)
2-Site-to-site VPN
VPN 4 kritik Fonksiyonu yerine
getirir
Authentication – Veriyi gönderen, alanın
doğru kişi olduğunu bilir.
Access control – Yetkisiz kişiler VPN’i
kullanamaz.
Confidentiality – Veri gizliği garanti edilir.
Data Integrity – Veri bütünlüğü garanti edilir.
Tunelleme
• Bir genel ağ üzerinde sanal bir point-to point bağlantı
oluşturmaktır. Tünel tekniğini 2 fazda anlatabiliriz:
• Faz1: İstemci VPN isteğini gönderir ve HA (Home Agent)
sistemi bu istemcinin kimlik sorgulamasını yapar.
• Faz2: Tünel içinden veri transferi başlatılır.
Şifrelenmiş datagram
Datagram Header Gönderilecek datagram alanı
Original Datagram
Data kapsülleme
Paketlerin VPN kapsüllenmesi
Tünelleme protokolleri üç kategoride sınıflandırılabilir:
1. Taşıyıcı protokoller: Tünellenmiş paketlerin Internet
üzerinden iletimini sağlamak için bu paketleri yönlendirir.
Tünellenmiş paketler bu protokolün paketleri içine enkapsüle
edilir.
2. Enkapsüle protokolleri: Pay-load paketin enkapsüle
edilmesini sağlar. Bu protokol ile tünel kurulur ve
sonlandırılır. Günümüzde en yaygın olan enkapsüle
protokolleri PPTP, L2TP, ve IPSEC’dir.
3. İletim protokolleri: Tünel içinden iletilmesi amacıyla
enkapsüle edilmesi gereken orijinal veriler için bu protokol
devreye girer. En yaygın olan iletim protokolleri PPP ve SLIP
(serial line internet protocol) protokolleridir.
Virtual Private Networks (VPN)
Basic Architecture
VPN gerçekleştirme tipleri
• 3 tip
– Hardware
– Firewall
– Software
Device Types: Hardware
• Genellikle VPN desteği olan Routerlardır.
Device Types: Firewall
Hem Firewall, hem VPN? Oldukça pahalı bir
çözüm.
Device Tipi: Software
• Aynı organizasyonun iki son noktası
arasında kullanımı için uygundur.
En çok kullanılan yazılımlar
PPTP Çözümü : Poptop
Ipsec Çözümü : Linux OpenSWAN, OpenBSD Ipsec
SSL VPN Çözümü : SSLExplore, OpenVPN
L2TP Çözümü : OpenL2tp
Gerçek bir VPN Çözümü Olarak OpenVPN
(SANAL ÖZEL AĞ --SÖA)
VIRTUAL PRIVATE NETWORKS
(VPN)

PPP protokolu
• Point TO Point Protokolu çevirmeli veya adanmış noktadan noktaya Seri bağlantılar
üzerinden veri göndermek için tasarlanmıştır. IP kullanımında, PPP, IP paketlerini PPP
çerçeveleri içinde kapsüller ve ardından kapsüllenen PPP paketlerini noktadan noktaya bir
bağlantı üzerinden aktarır (PPP’nin esas amacı, Layer-3 paketleri, bir Layer-2 ortamda
noktadan-noktaya seri link boyunca taşımaktır ve marka bağımlı değildir).
• PPP orijinal olarak çevirmeli (Dial up) veya xdsl istemcisi ve ağ erişimi sunucusu arasında
kullanılacak protokol olarak tanımlanmıştır.
•PPP’nin temel amacı seri bir iletim ortamı üzerinden paketlerin aktarılmasıdır. Böylece
PPP sayesinde, iki tane seri iletişime uygun cihazın (router v.b) özel olarak yapılandırılmış
veri paketleri (datagram) sayesinde bilgi değişimi yapması sağlanmış olur
PPP’nin çalışma mekanizması Kapsüllenme (Encapsulation), Bağlantı Kontrol
Protokolü (LCP) ve Ağ Kontrol Protokolü (NCP) olmak üzere üç ana bölümden
meydana gelmektedir.
Kapsülleme (Encapsulation) : Bütün WAN bağlantılarında, verinin iletilmeden evvel
"enkapsüle edilerek" frame (çerçeve) haline getirilmiş olması gerekir. PPP’ nin içerdiği
kapsülleme özelliği sayesinde; IP, IPX gibi farklı ağ katmanı protokollerinin aynı bağlantı
üzerinde eş zamanlı olarak çalışabilmesi sağlanır ve veri paketlerinin (Datagram) PPP ile
gönderilmek üzere nasıl paketleneceğini belirlenir. HDLC, (High-Level Data Link
Control-Yüksek Seviyede Veri Bağlantı Kontrolü) noktadan noktaya bağlantıda
kullanılan temel kapsülleme metodudur.
Link Kontrol Protokolü (LCP): PPP’nin en çok çalışan kısmıdır. Oturumu kurma ,
sürdürme , sınama ve sonlandırma görevlerini yapar. Bunlara ek olarak sıkıştırma, hata
kontrolü, çoklu link, geri arama ve aşağıda anlatacağımız kimlik doğrulamadır.
Ağ Kontrol Protokolü (NCP) : NCP ise, bağlantı sağlandıktan sonra, iki uç arasında ağ
adresi seçenekleri veya sıkıştırma özellikleri gibi ayarların yapılmasını sağlar. NCP, çoklu
Network katman protokollerinin eşzamanlı kullanımına izin vermek için tasarlanmıştır. Hiç
unutmayalım PPP OSI 1. Ve 2. Katman protokol kümesinden oluşur. İçerisinde geçen IP
ve IPx vb. protokoller bizleri yanıltmasın.
• PPP’nin geliştirilmesiyle, iki bilgisayarın haberleşebilmesi için ISP (İnternet Servis
Sağlayıcısı) tarafından atanan IP’yi sisteme tanıtmak için bir ilave işleme gerek
kalmamıştır. Sistem bu tanıtımı otomatik olarak yapmaktadır.
• PPP’de kimlik doğrulama işlemi (istemci ve sunucu arasındaki kimlik doğrulaması)
opsiyoneldir. PAP (Password Authentication Protocol-Şifre Doğrulama Protokolü)
veya CHAP (Challenge Handshake Authentication Protocol-Sorun Çözme Kimlik
Doğrulaması Protokolü)
• PAP oturum başında yanlızca bir defa kimlik doğrulaması yapar. PAP kimlik
doğrulama yaparken şifreler, clear text gönderilir.
• CHAP (Challenge Handshake Authentication Protocol), bir linkin ilk başlamasında
ve router’ın, aynı host’la hala haberleştiğinden emin olmak için linkte periyodik
kontroller yapar. PAP' ın aksine kimlik denetlemesini düzenli aralıklarla tekrarlar ve
MD5 ile yönlü hash şifrelemesi yapar. 3 adımda tanışılır.
1- R1 PAP kullanıcı adı ve şifresini R3’e gönderir.
2- R3, R1’den gelen kullanıcı adı ve şifreyi kendi yerel veritabanında arar. R1’in
gönderdiği kullanıcı adı ve şifre R3’de daha önceden tanımlanmıştır.
3-R3 herhangi bir eşleşme bulursa accept (kabul), aksi durumda reject (ret) mesajı
yollar.
PAP, kimlik doğrulama işlemini gerçekleştirmesine karşın çok güçlü bir
denetim yapmaz. PAP protokolünde “playback” (tekrarlama) isimli atak ile
bilgilerin alınıp, geri paket gönderme yapılarak oturuma dahil olunması şeklinde
kimlik denetimi aşılabilir. Bunun yanı sıra bir kere kimlik denetiminden geçtikten
sonra bir daha kimlik denetimi olmadığı için “session hijacking” (oturumun
çalınması) mümkündür.
CHAP, 3-Way Handshake (Üç Yönlü El Sıkışma) yapar. Kimlik denetimi açık olarak yapılmaz, md5
algoritmasına tabi tutularak “hash” (geri dönüşü olmayan fonksiyon) haline getirilir. Ayrıca CHAP’ta kimlik
doğrulama belirli aralıklarla yapılır. Aşağıdaki şekilde de görülebileceği gibi CHAP kimlik denetimi
sırasında şu işlemler gerçekleşir .
1- R3, üçlü el sıkışmayı başlatır ve R1’e “challenge” isimli , o anda belirlenmiş bir değer gönderir.
R1, kullanıcı adını, şifresini ve gelen “challenge” değerini md5 matematik fonksiyonuna tabi tutar ve R3’e
gönderir.
2- R3, kendi yerel veritabanında bulunan kullanıcı adı ve şifre ile “challenge” değerini md5’e tabi tutarak
elde ettiği değeri R1’in yolladığı değer ile karşılaştırır.
3- CHAP’ta “challenge” değeri için bağlantı her kuruldulduğunda rastlantısal olarak başka bir değer
seçileceği için şifreyi oluşturan “hash”li ifade bir daha aynı olmaz. Bu da “playback” ataklarını engeller.
Ayrıca iki tarafın da aynı sonucu alabilmesi için her iki cihaz için de verilen şifreler aynı olmalıdır.
PPP Kimlik Doğrulama Yapılandırması
PPP kimlik doğrulaması yapılırken hangi doğrulama protokolünün kullanılacağı aşağıdaki
komutlarla belirlenir. Bu komutlar “global configuration mode”dan ilgili seri “interface”e girildikten
sonra yazılır.
Router(config-if)#ppp authentication pap // ilgili interface’te pap’ı etkinleştirir.
Router(config-if)#ppp authentication chap // ilgili interface’te chap’ı etkinleştirir.
Router(config-if)#ppp authentication pap chap // hem chap hem pap etkinleştirilir, pap daha önce işleme alınır.
Router(config-if)#ppp authentication chap pap // hem chap hem pap etkinleştirilir, chap daha önce işleme alınır.
PAP Yapılandırması
R1'de Girilmesi Gereken Komutlar
R1(config) # username R3 password sifre1
R1(config-if) # ppp authentication pap
R1(config-if) # ppp pap sent-username R1 password sifre2
R3'te Girilmesi Gereken Komutlar
R3(config) # username R1 password sifre2
R3(config-if) # ppp authentication pap
R3(config-if) # ppp pap sent-username R3 password sifre1
PAP yapılandırmasında istenirse şifreler farklı da yapılabilir. Yukarıda da görülebilceği gibi “username” komutu
ile kendisine bağlanacak diğer yönlendiricinin kullanıcı adı ve şifre bilgisi, “ppp pap sent-username” komutu
ile ise kendi kullanıcı adı ve şifre bilgisi tanımlanır.
Geleneksel Bağlantı
VPN nedir?
•VPN(Virtual Private Network/Sanal Özel Ag) internet
üzerinden sifreli ve güvenli veri iletisimi saglamak için
düşünülmüş bir teknolojidir.
• Kamusal bir iletişim ağı üzerinde, Kiralık hatlar(Lease-line)
gibi güvenli, saglam çözümlerin yerine VPN kullanilmasinin
temel nedeni, maliyet ve kolay yapılandırmadır.
•Tüm VPN çözümlerinde İnternet erişimi üzerinden kurulan
güvenli tüneller söz konusudur. Güvenli tüneller, kriptolama
teknikleri ile sağlanır.
• Gartner Group; VPN'i, herkese açık bir iletişim altyapısı
üzerinden, iki veya daha fazla doğrulanmış/onaylanmış
taraflar arasında güvenli veri iletişimi sağlamak üzere
oluşturulmuş sanal ağlar olarak tanımlar.

VPN sanaldır:
Her bir VPN bağlantıda networkün fiziksel yapısı transparent
özelliktedir. Yani VPN kullanıcısı bağlı olduğu esnada bağlantı yaptığı
networkü sahiplenmez, bu network aynı anda birçok VPN kullanıcısı
tarafından paylaşılır.
VPN özeldir:
Özel olması VPN üzerinden akan trafiğin özel olması anlamındadır.
VPN trafiği Internet (public network) üzerinden geçer. VPN trafiğinin
Internet üzerinden güvenli geçişini sağlamak için özel network
önlemlerine ihtiyaç vardır, Örneğin data kriptolama, data doğrulaması
(data authantication), yetkilendirme (authorization) ve adres
spoofing’in önlenmesi gibi.
VPN bir Networktür:
Fiziksel bir varlığı olmayıp sanal olsada VPN bir network
özelliğindedir. VPN, iki uç arasında güvenilir tünel bağlantısı sağlayan
bir networktür.
Virtual Private Networks
Temelde iki tip VPN teknolojisi vardır. Amaca gore bu iki VPN teknolojisinden biri
seçilebilir. Bu teknolojiler
1- Remote Access VPN (Uzaktan erişim VPN )
2-Site-to-site VPN Uzaktan erişim VPN bağlantıları, evinde
çalışan ya da seyahat esnasında ofisinde
olamayan kullanıcıların İnternet
üzerinden özel ağ üzerindeki sunucuya
erişme imkânı sağlar. Remote Access
VPN’nin en önemli özelliği kimlik
sorgulaması ile uzak ve gezgin
kullanıcıların kimliklerini doğrulamasıdır.
Kullanıcılar uygun erişim ve teknolojiye
sahipse ISP ile bağlanabilir.
(Siteden siteye VPN:): Bu VPN
bağlantısı WAN (Wide Area Network)
bağlantısı gibi çalışır. Ağlar, İnternet
üzerinden verileri bir yönlendirici ile
başka bir yönlendiriciye iletir.
Yönlendicilere göre VPN bağlantısı,
veri bağlantısı olarak işlev görmektedir.
1. Remote Acces (Uzak Erişim) VPN (istemcisi tarafından başlatılan
(voluntary tunnel = isteğe bağlı -gönüllü tünel)
• VPN istemcisi, istemci makinede yer almaktadır. NAS sadece PPP aracılığıyla
müşteriye ortak IP adresi (istemci ve NAS arasındaki “public PPP oturumu") sunar.
•istemci üst özel IP almak için bir VPN bağlantısı (örn L2TP) oluşturur ve bu
şekilde doğrudan (istemci ve sunucu arasında "özel PPP oturumu") özel ağa bağlı
gibi özel ağa bağlanır. Bu VPN modu (VPN tüneli’nin kurulması ve yönetimi
istemcidedir) voluntary tunnel -gönüllü tünel " olarak adlandırılır.
Siteden Siteye VPN ( Access VPN NAS initiated)
•NAS, istemci adına kurumsal VPN sunucusuna VPN tüneli açar.
•Uzak erişim VPN istemcisinin aksine erişim kısmı (hiçbir şifreleme, hiçbir
özel IP) özel değildir.
• VPN istemcisi kendisi kontrolü altında olmadığından , Bu VPN modu (-
VPN tüneli istemci kontrolundan bağımsız olduğu için) “ compulsory
tunnel –zorunlu tunel " denir.
VPN ağları kullanım alanlarına göre;
Access VPN,
İntranet Tabanlı VPN,
Extranet (İnternet) Tabanlı VPN.
Access VPN gerçek kişiler tarafından bireysel kullanım
amacıyla tercih edilir. İntranet ve Extranet Tabanlı VPN
ağlar tüzel kişiler ( şirketler, üniversiteler gibi kurum ve
kuruluşlar) tarafından tercih edilir.
ACCES VPN
INTRANET VPN
Siteden Siteye VPN bağlantısı özel bir ağın iki bölümünü
birbirne bağlar. VPN sunucusu, bağlı olduğu ağa bağlantı
sunarken, yanıtlayan diğer sunucu yada yönlendirici (VPN
sunucusu) yanıtlayan yönlendiricinin (VPN istemcisi) kimlik
bilgilerini doğrular. Karşılıklı doğrulama sağlanır. Ayrıca siteden
siteye VPN bağlantısı üzerindeki iki sunucuda gönderdikleri veri
transferlerinin başlangıç noktaları tipik olarak yönlendiriciler veya
sunucular değildir.
EXTRANET VPN
Tipik bir VPN dağıtımında, istemci, Internet üzerinden
uzaktan erişim sunucusuyla sanal noktadan noktaya
bağlantı başlatır. Uzaktan erişim sunucusu aramaya yanıt
verir, arayanın kimliğini doğrular, verileri VPN istemcisi ile
kuruluşun özel ağı arasında aktarır.
Veriler, noktadan noktaya bağlantıyı taklit etmek amacıyla
üstbilgi kullanılarak kapsüllenir veya sarılır. Üstbilgi
(başlıktaki ek bilgi), verilerin bitiş noktalarına erişmeleri için,
paylaşılan veya ortak ağ üzerinden çapraz geçebilmelerine
olanak veren yönlendirme bilgileri sağlar.
Özel ağ bağlantısını taklit etmek için, gönderilen veriler
gizlilik amacıyla şifrelenir. Paylaşılan veya ortak ağda ele
geçirilen paketlerin şifreleri, şifreleme anahtarları olmadan
çözülemez. Özel ağ verilerinin kapsüllendiği ve şifrelendiği
bağlantı VPN bağlantısı olarak bilinir.
VPN 4 kritik Fonksiyonu yerine getirir
Authentication – Veriyi gönderen, alanın doğru
kişi olduğunu bilir.
Access control – Yetkisiz kişiler VPN’i kullanamaz.
Confidentiality – Veri gizliği garanti edilir.
Data Integrity – Veri bütünlüğü garanti edilir.
VPN güvenlik açısından sağladığı faydalar;
1- VPN aboneli dışındaki kimseler ilgili VPN’e erişemez.
2- VPN abonesi olmayanlar giri için VPN tarafından bloklanır
3-Internet üzerinden iletilen verilerin gizliliği ve bütünlüğü
sağlanmalıdır
VPN’de, Kimlik doğrulama ve erişim:
Verinin kriptolanması
LoginID ve Şifre sorgulaması
PKI yapısıyla kimlik doğrulama
ve mesaj bütünlüğünün
kontrolu

VPN ile üç farklı güvenlik tekniği sağlanır.
• Kapsülleme (VPN Tünelleme işlemi) ile Public ağlar üzerinden, Kiralık
hatlar (Lease-line), Frame Relay, ISDN gibi iki nokta arasında daha sağlam,
kesintisiz bir bağlantı hizmeti verir. Başka bir deyişle Tünel oluşturma, iletim
yapılırken bütünlüğün ve gizliliğin korunması için paketleri diğer paketlerin
içine kapsülleme işlemidir. Ancak, Kiralık hat, Frame Relay, ISDN, gibi bağlantı
şekilleri kullanılarak şirket ofisleri birbirine bağlandığında aradaki hat özel bir
hat olduğu için verilerin çalınması veya değiştirilmesi mümkün olmamaktadır.
Fakat internet üzerinden verilerin taşınması söz konusu olduğunda verilerin
güvenlik amacıyla şifrelenmeside gerekmektedir. VPN teknolojileri bunu
sağlar.
• Kimlik sorgulaması (Authentication) ile sadece yetkili kullanıcıların VPN
hizmetini alabilmesi sağlanır.
• Kriptolama (encryption) ile yapılacak haberleşmenin şifrelenerek başka
kullanıcıların haberleşmeyi dinlemesi, veri bütünlüğü (data integrity) ile de
kötü niyetli kullanıcıların yolladığınız paketlerin içeriğini değiştirebilmeleri
engellenir.
Paketlerin VPN kapsüllenmesi
PPTP, L2TP/Ipsec ve SSTP kullanan VPN bağlantılarının özellikleri kapsülleme, kimlik doğrulama
ve son olarak ise veri şifrelemedir.
Kapsülleme: VPN ağında veriler bir üstbilgi ile kapsüllenirler. Bu üstbilgi, verileri geçiş ağı sırasında
çapraz geçmelerine izin verecek bilgileri içerir. Kapsülleme işlemini anlamak için VPN tünel
protokolleri anlaşılmalıdır.
Kimlik doğrulama: Ağa erişmeye çalışan kişinin buna yetkili olup olmadığı, dışarıdan müdahele
edilemeyecek şekilde, yani şifreli olarak HTTPS protokolü ile yapılır ve izini olanlar ağa alınır.
Veri şifreleme: Veriler de dışarıdan ağdan geçen bilgileri dinleyenlerin çözümleyemeyeceği biçimde
şifrelenerek dışarıdakiler için anlaşılmaz hâle getirilir.
Tünelleme (kapsülasyon)
• Tünelleme (Enkapsülasyon) işlemi bir VPN uygulamasının en önemli
kısmıdır. Bu teknik organizasyonlara Internet üzerinden kendi sanal
networklerini oluşturma imkanı sağlar. Intranet dışından hiç bir
yetkisiz kullanıcı intranete erişim yetkisine sahip değildir.
• Tünellemede paket hedef networke iletilmeden önce bu pakete
tünelleme protokolünün başlık bilgisi eklenir. Payload olarak da
isimlendirilen orjinal paket internetin desteklemediği bir protokolü
kullanıyor olabilir, bu durumda tünelleme protokolü tünel içindeki
pakete başlık bilgisini ekler. Bu başlık yönlendirme bilgilerini içerir ve
paket artık Internet üzerinden iletilebilecek hale gelir. Tünelleme
protokolleri, tünelin en ucundaki kullanıcı için, oturum yönetimi
olarak bilinen işlemleri gerçekleştirmek üzere, tünelleri kurar ve
yönetir.
Tunelleme
• Tünelleme protokolleri IP kadar diğer protokollerin kapsülleşmesi
işini de yapar ve tünel aygıtları için yetkilendirme yöntemlerini
gerçekleştirir. Bu Protokoller genel olarak verileri şifreler ve tünel
içine gönderir.
• Bir genel ağ üzerinde sanal bir point-to point bağlantı
oluşturmaktır. Tünel tekniğini 2 fazda anlatabiliriz:
• Faz1: İstemci VPN isteğini gönderir ve HA (Home Agent) sistemi
bu istemcinin kimlik sorgulamasını yapar.
• Faz2: Tünel içinden veri transferi başlatılır.
TÜNELLEME PROTOKOLLERİ
Tünelleme protokolleri üç kategoride sınıflandırılabilir:
1. Taşıyıcı protokoller: Tünellenmiş paketlerin Internet
üzerinden iletimini sağlamak için bu paketleri yönlendirir.
Tünellenmiş paketler bu protokolün paketleri içine
enkapsüle edilir.
2. Enkapsüle protokolleri: Pay-load paketin enkapsüle
edilmesini sağlar. Bu protokol ile tünel kurulur ve
sonlandırılır. Günümüzde en yaygın olan enkapsüle
protokolleri PPTP, L2TP, ve IPSEC’dir.
3. İletim protokolleri: Tünel içinden iletilmesi amacıyla
enkapsüle edilmesi gereken orijinal veriler için bu protokol
devreye girer. En yaygın olan iletim protokolleri PPP ve
SLIP (serial line internet protocol) protokolleridir.
PPTP veri tünelleme işlemi
Bir PPTP veri paketi aşağıdaki enkapsülasyon işlemlerinden geçirilir:
-Verinin Enkapsülasyonu: Payload şifrelenir ve bir PPP frame içine
enkapsüle edilip bu frame’e bir PPP başlık eklenir.
-PPP frame’lerin enkapsülasyonu: Başlık bilgisi eklenmiş olan PPP
frame, GRE içine enkapsüle edilir.
-GRE paketi enkapsülasyonu: GRE paketin içine enkapsüle edilmiş
olan PPP frame’e bir IP başlık eklenir ve bu başlıkta PPTP istemci ve
hedef networkdeki sunucunun IP adresleri taşınır.
-Data Link Layer Enkapsülasyonu: PPTP bir Layer 2 tünelleme
protokolüdür. Bundan dolayı data link layer başlığı tünellemede
büyük öneme sahiptir. Bu layer datagramlara kendi başlık
bilgisini ekler.
Eğer bu datagram lokal PPTP tünelinden geçecekse, bir LAN
teknolojisi başlığı ile enkapsüle edilir. Eğer bir WAN tünelini
kullanacaksa bu datagramda değişiklik yapılmaz.
PPTP KİMLİK DOĞRULAMASI
PPTP aşağıda anlatılan kimlik doğrulama mekanizmalarını kullanır:
-MS-CHAP (Microsoft Challenge Handshake Authentication Protocol): PPP
tabanlı kimlik doğrulamalar için kullanılır. CHAP tekniğine benzemektedir. Tek
farkı, MS-CHAP tekniği RSA RC4 algoritmasını, CHAP tekniği ise RSA MD5
algoritmasını kullanır.
-PAP (Password Authentication Protocol): En yaygın dial-in kimlik doğrulama
protokolüdür.
PPTP protokolünün temel avantajları aşağıdaki gibidir:
-PPTP yaygın olarak kullanılan bir built-in Microsoft çözümüdür.
-IP tabanlı olmayan protokolleride destekler.
-Unix, Linux, Apple’s Macintosh desteği vardır.
PPTP Protokolünün dezavantajları ise aşağıdaki gibidir:
-L2TP ve IPSEC protokolüne göre güvenliği daha azdır.
-PPTP platform bağımlı bir protokoldür.
-PPTP protokolünün en büyük dezavantajı güvenlik mekanizmasının çok
sağlam olmamasıdır. Çünkü anahtarın kullanıcı şifresinden elde edildiği
simetrik şifreleme tekniğini kullanır.
L2TP (LAYER-2 TUNNELING PROTOCOL)
L2TP birden çok protokol trafiğinin şifrelenmesini ve ardından IP veya zaman uyumsuz
aktarım modu (ATM) gibi noktadan noktaya datagram teslimini destekleyen herhangi bir
medya üzerinden gönderilmesini sağlar. Internet üzerinden, enkapsüle edilmiş PPP
framelerin tünellenmiş veri olarak iletilebilmesi için UDP protokolünü kullanır.
L2TP paketlerin şifrelenmesi için IPSEC/ESP (Encapsulating
Security Payload) kullanılır. L2TP paketlerinin ESP ile şifrelenmiş formatı
aşağıda görülmektedir:


L2TP VE PPTP PROTOKOLLERİNİN KARŞILAŞTIRILMASI
• L2TP ve PPTP, OSI modeline gore 2. katmada çalışan protokollerdir.
Kullanıcı yetkilendirmesi esasına dayanarak çalışırlar. Örneğin bir PPTP
istemcisi, PPTP sunucusuna kullanıcı adı ve şifresini göndererek bağlantı
talebinde bulunur.
•Şayet istemcinin gönderdiği kullanıcı adı ve şifre doğruysa oturum açılır.
Artık istemci ile sunucu arasındaki bilgi kriptolu olarak taşınır. Kriptolama
için kullanılan anahtar, kullanıcı şifresinden türetilir.
•Hem L2TP hem de PPTP verinin aktarımını datagram (UDP) paketleri ile
yapar. Ancak PPTP, L2TP‘den farklı olarak tünelin kurulumu ve yönetimi
ile ilgili kontrol işlemlerini, sunucu ile istemci arasında TCP bağlantısı
kurarak yapar. Bu PPTP protokolünün, paket geçirme süresinin yüksek
olduğu ağlarda L2TP protokolüne göre performansın düşmesine sebep
olur.
•Diğer yandan L2TP’nin bir özelliğide aynı anda iki nokta arasında birden
fazla tünel açabilmesidir.
IPSEC-VPN
• Ağ katmanı seviyesinde güvenlik sağlamak içindir.
• Gelen bilginin doğru kişiden geldiğini garanti eder.
• Gelen paket için güvenlik ve bütünlük sağlar.





L2TP Over IPSEC
IPSEC’in Transport modu kullanılır. Tünelleme L2TP protokoluyla yapılır.
Paket şifreleme için IPSEC kullanılır
VPN’in Windows gerçeklemesi olarak bilinir.

VPN gerçekleştirme tipleri
• 3 tip
– Hardware
– Firewall
– Software
Device Types: Hardware
• Genellikle VPN desteği olan Routerlardır.
Device Types: Firewall
Hem Firewall, hem VPN? Oldukça pahalı bir
çözüm.
Device Tipi: Software
• Aynı organizasyonun iki son noktası arasında
kullanımı için uygundur.
En çok kullanılan yazılımlar
PPTP Çözümü : Poptop
Ipsec Çözümü : Linux OpenSWAN, OpenBSD Ipsec
SSL VPN Çözümü : SSLExplore, OpenVPN
L2TP Çözümü : OpenL2tp
Gerçek bir VPN Çözümü Olarak OpenVPN
Ağ Güvenliği Dersi
SON
Bot - Bilgisayar Organizasyonu Tasarım Dersi
Giriş
HAFIZA Hiyerarşisi
Bilgisayar organizasyonu dersinde, işlemcilerin (MikroişlemiMıcroprocessor) çalışma prensiplerini Fonksiyonel blok yapısı
yaklaşımıyla anlatmaya çalıştık.
Bilgisayarların önemli ünitelerinden biriside Hafızalar (Memory)dır.
4
Hafıza hiyerarşisi
Hiyerarşinin en altında mekanik parçaları olan kalıcı (ikincil
– Yardımcı) HD, Manyetik teyp v.b hafızalar bulunur.
Bunlar file birimi olarak kayıt tutarlar.
Registers
1KB
1 cycle
L1 data or
instruction
Cache
32KB
2 cycles
L2 cache
2MB
15 cycles
Memory
1GB
300 cycles Disk
80 GB
Hierarchy Listesi 10M cycles
•Registers
•L1 Cache
•L2 Cache
•Main memory
•Disk cache
•Disk
•Optical
•Tape
Yarıiletken Hafıza çeşitleri
(Ana hafıza ve Cache hafızalar yarı iletken hafızalardır)
Memory Arrays
Random Access Memory Serial Access Memory Content Addressable Memory
(CAM)
Read/Write Memory
(RAM)
(Volatile)
Read Only Memory
(ROM)
(Nonvolatile)
Static RAM
(SRAM)
Dynamic RAM
(DRAM)
Shift Registers Queues
First In
First Out
(FIFO)
Last In
First Out
(LIFO)
Serial In
Parallel Out
(SIPO)
Parallel In
Serial Out
(PISO)
Mask ROM Programmable
ROM
(PROM)
Erasable
Programmable
ROM
(EPROM)
Electrically
Erasable
Programmable
ROM
(EEPROM)
Flash ROM
Bellek (Hafıza – Memory) Terimleri

Yarı İletken Bellek Özellikleri
Register blok yapısı
RAM-SRAM-DRAM
Tran. Access
per bit time Persist? Sensitive? Cost Applications
SRAM 6 1X Yes No 100x cache memories
DRAM 1 10X No Yes 1X Main memories,
frame buffers
Bizim ilgileneceğimiz hafızalar, Cache ve Ana hafıza birimleridir. Bunlar
yarıiletken bellek yapılarıdır. SRAM genellikle Cache bellek, DRAM ana hafıza
birimlerinde kullanılır. Bir bitlik memory Cell’lerin birleştirilmesiyle oluşurlar.
Cache (Ön-bellek)
Cache (Ön) Bellek : Sistem belleğinden (Ana hafızadan) gelen veriler
çoğunlukla İşlemcinin (CPU) hızına yetişemezler .Bu problemi çözmek için
CPU içinde yüksek hızlı hafızalar bulunur.
• Ön-bellek çalışmakta olan programa ait komutların ve verilerin geçici
olarak saklandığı yüksek hızlı hafızalardır.
•İşlemci, ön-bellekte bulunan komut ve verilere, Ana Bellekte bulunan
komut ve verilere göre çok daha hızlı bir şekilde ulaşabilir.
•Cache bellekler, program ve verilerin en yoğun kullanılan kısımlarını tutar.
• Cache bellekler, birincil ön-bellek (Level 1, L1) ve ikincil ön-bellek (Level
2, L2) ve son olarak üçüncül ön-bellek (Level3, L3) olarak ayrılırlar.
•İşlemcinin Cache belleğe ve ana belleğe doğrudan erişim yolu vardır.
•İşlemci tarafından o anda kullanılmayan büyük verilerin tutulduğu ikincil
(yardımcı) belleklere işlemcinin doğrudan bağlantısı yoktur.
• Harici ön-bellekler işlemcinin dışındadır.
• Dahili ön-bellekler işlemcinin içindedir. Dahili ön bellek, CPU’nun en
son işlediği verilerin bir kopyasını saklar.
• Aranan veri dahili ön bellekte bulunamazsa harici ön belleğe bakılır.
•Harici ön bellekte de bulunamayan veriler ana bellekten
alınır.Bu,önbelleğe göre daha yavaş bir süreçtir.
•İşlemci cache ile word bazında, Ana hafıza Cache ile blok data
olarak alış veriş yapar.
L1 Cache bellekler işlemcinin içinde olup, 486DX
işlemcilerden bu yana kullanılıyor.
Şu an için AMD işlemciler çekirdek başına standart
olarak 64 KB L1 önbelleklerle gelirken Intel işlemciler
32 KB veri ve komut L1 Cache’lere sahipler.
İkinci seviye önbellekler (L2) Pentium III işlemcilerden sonra genel
olarak kullanılmaya başladılar (Daha önce Pentium Pro da bu önbellek
vardı ancak çekirdeğin içinde değildi.Dolayısıyla çekirdek hızı ile
çalışmıyordu).
180 Nm üretim sürecinin geliştirilmesiyle L2 önbellekler en sonunda
çekirdeğin içine girdiler ve aynı hızda çalışmaya başladılar.
Günümüzde işlemciler
çekirdeğe tümleşik 6 MB
L2 önbelleğe sahip
olarak geliyorlar.
Intel’in Core 2 Duo işlemcilerinde bu
önbellek çekirdekler tarafından
paylaşımlı olarak kullanılıyor. Genellikle
L2 önbellek çekirdek başına 512 KB
veya 1 MB büyüklüğe sahip oluyor. L2
önbelleği düşük olan işlemciler daha çok
giriş seviyesi modeller oluyorlar.
İlk başlarda sadece ek bir seviye olarak
kullanılırken günümüzde L3 önbellekler
çekirdekler arasında iletişimi de sağlayan
geniş ve paylaşımlı yapılar halini aldılar.
L3 önbelleği ilk kez masaüstüne getiren
Phenom ailesiyle AMD oldu. 65 NM
Phenom X4, 2 MB paylaşımlı L3
önbelleğe sahipti. Şu andaysa 45 NM
Phenom II X4 işlemciler 6 MB paylaşımlı
L3 önbelleğe sahip olarak geliyorlar.
Intel’in Core i5 ve i7 işlemcileri ise 8 MB
L3 önbelleğe sahipler.
ANA BELLEK
• Bilgisayar sistemin merkezi depolama birimidir. Büyük ve hızlıdır.
• Komut ve dataların depolandığı birimdir
• Statik ve dinamik olmak üzere iki türlüdür.
• Statik hafıza birimlerinde bilgi yaz bozlardan oluşur. Akım verildiği süre boyunca
bilgi depolanır.
• Dinamik RAM bilgileri (DRAM) elektrik akımı şeklinde tutar. Tutan devre
kondansatörlerdir.
• Üzerlerindeki yük zamanla azalır. Bundan dolayı belli sürelerle yenilenmelidir.
• Yenileme birkaç milisaniyede bir tüm kelimelere uygulanır.
• Okuma ve yazma süreleri kısadır.


1K X 4 SRAM (Part Number 2114N) Blok yapısı
CS1 CS2 RD WR Bellek fonk. Veri Yolu Durumu
0 0 X X Tutma Yüksek direnç
0 1 X X Tutma Yüksek direnç
1 0 0 0 Tutma Yüksek direnç
1 0 0 1 Yaz Ram’a giriş bilgisi
1 0 1 X Oku RAM’den çıkış bilgisi
1 1 X X Tutma Yüksek direnç
Bellek Adres Haritası
• Bilgisayar tasarımcısı sisteme gerekli bellek miktarının hesaplamalı ve RAM ve ROM
olarak tahsis etmelidir.
• Bellek adreslemesi çizelge hazırlanarak yapılır. Bu çizelgeye bellek adres haritası
denir.
• Sistemimiz 512 byte RAM ve 512 byte ROM gerektirsin. RAM yongaları 128 byte
olsun buna göre bellek adres haritası aşağıdaki gibi olacaktır.
•
Bileşen Adres yolu
10 9 8 7 6 5 4 3 2 1
RAM1 0000-07f 0 0 0 x x x x x x x
RAM2 0080-0ff 0 0 1 x x x x x x x
RAM3 0100-17f 0 1 0 x x x x x x x
RAM4 0180-1ff 0 1 1 x x x x x x x
ROM 0200-3ff 1 x x x x x x x x x
Sistemimiz 512 byte RAM ve 512 byte ROM gerektirsin. RAM yongaları 128 byte
olsun buna göre bellek adres haritası aşağıdaki gibi olacaktır.
Bellek ile MIB Bağlantısı
• 128x8 bayt hafıza organizasyonu
Örnek
• 10 adres hattı için 4 adet 128 bayt toplam 512 bayt hafıza için adres hafızasını
tasarlayınız.
İçerik Adreslemeli Bellek
Content Adressable Memory (CAM)
• Bir çok veri işleme uygulamalarında bellekte bulunan bir çizelgeden veri aranır.
• Bellekte bulunan bir değerin aranıp bulunması adres yerine verinin içeriği ile olursa
arama süresi kısaltılabilir. Buna içerik adreslemeli bellek CAM denir. Bu belleğe aynı
anda paralel olarak erişilebilir.
• Adres veya yer belirtmeye gerek yoktur.
• Bellek kullanılmayan boş bir alanı bularak kelimeyi buraya yerleştirir.
• Eğer kelime okunacaksa kelimenin içeriği veya onun bir kısmı belirtilir.
• Bellek bu verilene uygun ve onunla çakışan bütün kelimeleri belirler ve bunları
okumak için işaret koyar.
• Tasarımından dolayı bu bellek paralel aramalar için uygundur.
• Bu bellek RAM belleklerden çok daha pahalıdır. Çünkü her hücre saklama yeteneği
dışında içeriği karşılaştıracak devreler içerir.
Donanım Tasarımı
• İçinde bir bellek dizisi ve mantık devreleri vardır.
• Bellek kelime başına n bit olarak m kelimeden oluşur.
• Değişken yazacı A ve anahtar yazacı K n bit içerir.
• Çakıştırma yazacında m bit vardır.
• Herbir bellek kelimesi değişken yazacının içeriği ile paralel olarak karşılaştırılabilir.
• Değişken yazacının bitleriyle çakışan kelimeler çakıştırma yazacında karşılık gelen biti 1
yapar.
• Çakıştırma işleminden sonra çakıştırma yazacı içinde 1 yapılan bitler karşılık gelen
kelimelerin çakıştığını belirtir.
• Okuma işlemi çakıştırma yazacında karşılık gelen bitleri 1 olan kelimelerde sıralı olarak
yapılır.
• Anahtar yazacı değişken kelimesindeki belli bir alanı seçmek için bir maskeleme
oluşturur. Anahtar yazacı 1’lerden oluşuyorsa değişken yazacının tamamı her bir bellek
kelimesi ile karşılaştırılır.
• Maskeleme bellekte aranacak yazacı bir maskeleme oluşturur. Bu maskeleme bellekte
aranacak bilgi parçasını gösterir.
CAM bellek yapısı
CAM BELLEK yapısı
CAM BELLEK ŞEMASI
CACHE (Ön bellek-CEP Bellek)Bellek
Organizasyonu
• Programın çalışan kısımları ve verilerin o anda kullanılan
kısımları küçük ve hızlı belleğe konursa ortalama bellek
erişim süresi kısaltılabilir.
• Böylece programın icra süreside kısaltılabilir.
• Böyle bir belleğe ön bellek denir.
• Bu bellek küçük ve hızlıdır.
• Erişim süresi ana belleğin 5 te biri ile 10 da biri arasındadır.
• MIB ile ana bellek arasında olur. Bellek hiyerarşisinde en
hızlı bellektir. Hızı MİB bileşinlerine yakındır.
• Ön bellek tasarımını temel fikri en sık kullanılan buyruk ve
verileri bu bellekte tutmaktır.
• Böylece ortalama bellek erişim süresi ön bellek erişim
süresine yaklaşır.
Cache (Cep-Önbellek) bellek çalışma prensibi
• MIB belleğe erişmek istendiğinde ön belleği inceler. İstenen ön bellekte ise buradan
okunur.
• Eğer bu adres ön bellekte bulunmazsa o zaman ana belleğe gidilerek okunur. Sonra bu
okunan bilgini bulunduğu blok ön belleğe aktarılır. Blok büyüklüğü erişilen kelimeye
komşu yaklaşık 16 kelimeden oluşur. Böylece erişilen yakın verilere yeniden erişmek
kolay hale gelir.
• Ön belleğin verimi, bulma oranı denilen bir sayı ile ölçülür.
• MIB belleğe erişmek ister ve aradığını ön bellekte bulursa bu bir bulmadır. Eğer
aranan kelime ön bellekte değilse ve bellekte bulunursa buna bir bulamama denir.
• Oran=bulma sayısı / Toplam erişim sayısı
• Oran=Önbellek erişim sayısı/(ön bellek erişim sayısı+ana bellek erişim
sayısı)
Ana bellekten ön belleğe verilerin aktarılmasına haritalama
işlemi denir.
• İçerik adreslemeli haritalama
• Doğrudan haritalama
• Kümelenmiş içerik adreslemeli haritalama
• Ana bellek 12 bitlik 32 K kelimeden oluşsun. Ön bellek ise bunların 512 tanesini
taşıyor olsun. Ön bellekte bulunan her kelimenin ana bellekte bir kopyası bulunur.
MIB her iki belleğede erişebilir.
• Ön belleğe 15 bit adres yollar. Eğer aranan kelime ön bellekte varsa buradan 12 bit
veriyi okur. Aranan kelime ön bellekte bulunmazsa MIB kelimeyi ana bellekten okur
ve kelimeyi ön belleğe aktarır.
İçerik Adreslemeli Haritalama
• En hızlı ve çok yönlü kullanılabilen ön bellek tasarımı içerik adreslemeli bellek
alanıdır. Buradaki CAM bellek hem adresi hemde veriyi tutar.
• Böylece belleğin herhangi bir alanındaki veriler veya buyruklar ön belleğin
herhangi bir yerine yazılabilir.
• Şekilde bellekte duran 3 adres, beş basamak sekizlik düzende (15 bit) sayılarla ve
bunlara karşılık gelen 12 bit lik vriler ise 4 sekizli düzende sayılarla verilmiştir. 15
bit MIB adresi değişken yazacına yazılır ve çakıştırma yapılır.
• Adres varsa veri okunur sonra bulunduğu adres ve veri ön belleğe aktarılır.
Doğrudan Haritalama
• CAM bellekler RAM’a göre pahalıdır. Çünkü hücrelere bir çok devre
eklenmiştir.
• 15 bit CPU adresi 2 alana bölünür. 9 bit indis alanı 6 bit başlık alanıdır.
Aslında Önbellek için 9 bit yeterlidir.
• Cache içindeki herbir kelime (12 bitlik) veri ve (6 bitlik) başlık (Tag)
bilgisini tutar.
• n bitlik bellek adres alanı k ve n-k olarak ikiye
ayrılır. k indis olup ön belleği adresler.
• MIB bir bellek isteminde bulunduğunda ön
belleğe erişmek için indis alanı kullanır. MIB
adresinin başlık alanı ön bellekten okunan
kelimenin başlık alanı ile karşılaştırılır. İki başlık
çakışırsa istenen kelime ön bellektedir. Çakışma
yoksa istenen kelime ana bellekten okunur. Bu
kelime daha sonra başlığıyla beraber ön belleğe
yazılır eski kelime atılır.
• Doğrudan haritalamada bit sayısı değişebilir.
• Çünkü iki veya daha fazla kelimenin indis alanları
aynı ise ve başlık alanları farklı ise ve bunlara
tekrar tekrar erişiliyorsa bu durum ortaya çıkar.
Şekilde görüldüğü gibi ana hafızadaki 00000 adresindeki 1220 verisi Cache
bellek içindedir. Ve indisi 000 ve Tag (başlığı) 00’dır.
Örneğin; CPU’nun 02000 adresindeki veriyi istediği varsayılsın. Bunun
indisi 000’dır. Tag’i 02’dir. Fakat TAG’ler çakışmadığından bu veri
önbellekte your. Veri (5670) Ana bellekten alınıp ön belleğe atılır.
• Bir önceki örnekte 1 kelimelik blok için doğrudan
erişim yapılmaktadır.
• Aynı işlem 8 kelimelik bloklar içinde yapılabilir.
Bunun için indis alanı 2 parçaya bölünür.
• Blok alanı
• kelime alanı .
•512 kelimelik bir ön bellekte her biri 8 kelimelik 64 blok vardır (64x8).
Dolayısıyla Blok numarası 6 bitlik bir alanla verilir. Kelime alanı ise blok içinde 3
bit yer kaplar. Ön bellek içindeki başlık(tag) alanı blok içindeki 8 kelime için
aynıdır.
• Bir bulamama olduğunda 8 kelimenin tamamı bellekten ön belleğe aktarılır.
Buda zaman alır.
•Daha büyük blok büyüklüğü tanımalamakla bulma oranı arttırılabilir.
Kümelenmiş İçerik adreslemeli
haritalama
• Doğrudan erişimli ön bellek tasarımında , adreslerinde
aynı indisli fakat farklı başlık değeri bulunan iki kelime
aynı anda ön bellekte bulunamazlar.
• Bu direkt adreslemenin dezavantajıdır.
• Kümelenmiş içerik adreslemeli haritalama direkt
haritalamanın gelişmiş şeklidir.
• Aynı ön bellek kelimesi içinde birden fazla aynı indis
adresli bellek kelimesi bulunabilir.
• Her bir veri kelimesi başlığı ile beraber depolanır ve
bunlar bir küme oluşturur.
• Küme sayısı birden fazladır.

Sanal bellek
• Sanal bellek büyük bilgisayar sistemlerinde kullanılan bir kavramdır.
• Bununla kullanıcılar yardımcı belleğin kapasitesine eşit belleği olan sanal ve
bireysel makinede çalışıyormuş gibi olurlar.
• MB tarafından verilen her adres bir haritaya gider ve sanal adres fiziksel adrese
dönüştürülür.
• Sanal bellek adres sistemi ile programdaki adresler gerçek ana bellek adreslerine
dönüştürülür.
• Bu iş MIB de çalışırken dinamik olarak yapılır.
• Dönüşüm veya haritalama donanım tarafından bir haritalama çizelgesi yardımıyla
otomatik olarak yapılır.
• Kullanıcı tarafından kullanılan adrese sanal adres denir.
• Bu adreslerin kümesine adres uzayı denir.
• Ana bellekteki bir adrese fiziksel adres veya yer adı verilir. Bunların kümesine bellek
uzayı denir.
• Dolayısı ile adres uzayı programlar tarafından oluşturulan buyrukların ve verilerin
adresleridir.
• Bellek uzayı ise gerçek bellek adresleri olup işlemler için doğrudan verilmelidir.
• Bir bilgisayar düşünün belleği 32K olsun. Bu bilgisayarın 1024 K kelimelik
bir yardımcı belleği olduğunu varsayalım.
• 2^20 =1024 olduğundan yardımcı belleğin kapasitesi 32 ana bellek eder.
Adres uzayı N ve bellek uzayı M ile gösterilirse N=1024 ve M=32 K dır.
• Çok programlı bir bilgisayar sisteminde programlar ve veri yardımcı bellek
ile ana bellek arasındadır.
• Farzedelim ki program 1 MIB tarafından icra edilmekte olsun.
• Program ve onun datasının bir kısmı yardımcı bellekten ana belleğe
aktarılır.
• Program ve veri bölümleri bellekte birbirine komşu ve birbirini takip eden
adreste bulunmazlar.
• Çünkü bilgiler gidip gelmektedir. Boş yerler ise dağınık yerlerdedir.
• Örnekte yardımcı bellekten tek tek veri veya buyruk okumak zaman alır.
Dolayısıyla bunların ana bellekten okunması daha avantajlıdır.

• 20 bit adres 15 bite dönüştürülmelidir. sanal adresin fiziksel adrese dönüşümü
şekildeki gibi olacaktır.
Sayfa kullanarak adres haritalama
• Adres haritalama işlemi adres ve bellek uzaylarının her biri sabit uzunlukta gruplara
bölünürse çok basit hale gelebilir.
• Fiziksel bellek blok adı verilen eşit büyüklükte gruplara bölünmüştür.
• Bu büyüklük 64 ile 4096 arasında olabilir. Sayfa deyimi adres uzayında eşit
büyüklükteki grupların adıdır.
• Adres uzayı 8 K
• Bellek uzayı 4 K
• Eğer herbiri 1 K gruplara
Bölünürse 8 sayfa 4 blok eder.
• Bellek sayfa çizelgesinde 8 kelime vardır her sayfa için bir kelime sayfa
çizelgesindeki adres sayfa numarasını gösterir.
• Çizelgede 1,2,5 ve 6 numaralı sayfaların ana bellekte 3,0,1,2 numaralı bloklarda
olduğunu gösterir.
• Çizelgedeki 1 bit varlık biti olarak tanımlanır. Ve sayfanın yardımcı bellekten ana
belleğe aktarılmış olup olmadığını gösterir. 0 aktarılmadığını gösterir.
• MIB bellekten bir kelimeyi 13 bitlik sanal adres ile arar.
• Sanal adresin önemli 3 biti sayfa numarasını ve doğal olarak bellek sayfa
çizelgesinde bir adres gösterir.
• Bellek sayfa çizelgesindeki bir kelimenin içeriği sayfanın ana bellekteki blok
numarasını verir.
• Bu içrik ana bellek adres yazacındaki önemli bitleri oluşturur. Satır sayısı ise sanal
adresten doğrudan doğruya ana bellek adres yazacına aktarılarak ana bellek adresi
hazırlanır.
• Ana belleğe gönderilen oku sinyali ile ana bellekteki kelimenin içeriği MBR de CP
nin kullanımına hazır olur. Varlık biti 0 ise sanal adresin gösterdiği kelime bellekte
değildir.
• İşletim sistemi çağrılarak istenen sayfanın ana belleğe aktarılması ve bu işin
hesaplamadan önce yapılması sağlanır.

İçerik adreslemeli bellek sayfa çizelgesi
• RAM sayfa çizelgesi kullanışsızdır. Önceki örnekte 8 kelimesine gerek vardı. Her
sayfa 1 tane. Bunlardan 4 tanesi daima boş kalır.
• Çünkü bellek 4 blok olmaktadır.
• Genel olarak n sayfa m bloktan oluşan bir sistemde n kelime gerekir.
• Bunlardan sadece m tanesi doludur. Diğerleri boştur.
• 1024 K kelimelik adres uzayı ve 32 kelimelik bellek düşünelim. Hersayfa ve blok 1
kelime ise sayfa sayısı 1024 ve blok sayısı 32 olur. O halde bellek sayfa çizelgesi
1024 kelime olacak ve sadece 32 tanesinde varlık biti 1 olabilecektir. Herhangi bir
anda 992 yer boş olacaktır.
• Çizelgeyi oluşturmak için daha etkin bir yol kelime sayısının bellekteki blok sayısına
eşit alınmasıdır.
• Böylece çizelge büyüklüğü küçülür ve tamamen kullanılır.
• Bu çizelge CAM bellekte tutulabilir.
• Bu çizelgedeki her kelimede sayfa numarası ve buna karşılık gelen blok numarası
bulunur. Kelimedeki sayfa alanı ile sanal adresteki sayfa alanı karşılaştırılır.
• Eğer çakışma olursa kelime bellekten okunur. Ve karşılık gelen blok numarası elde
edilir.

Bellek Yönetim Donanımı
• Çoklu işletim sisteminde bir çok program bellekte bulunur.
• Ayrıca programların ve verilerin sürekli gidip gelmesi
gerekir. Bir programın kaplayacağı alan değişebilir. Bu
programların idare edilmesi gerekir.
• Bellek yönetim biriminin parçaları şunlardır.
• Mantıksal bellek adreslerini fiziksel adreslere dönüştüren
dinamik bir dönüşüm parçası
• Bellekte bulunan programların farklı kullanıcılara
kullanılmasını sağlayan bir parça
• Bilginin yetkisiz kullanıcılardan korunması ve kullanıcıların
işletim sisteminin değişen fonksiyonlarda korunması
• Mantıksal adres 3 bölümden oluşur.
• Kesim alanı kesim numarasını belirler. Sayfa alanı kesim içindeki
sayfayı kelime alanı sayfa içindeki kelimeyi belirtir.
• Mantıksal adresin fiziksel adrese dönüşümü iki çizelge ile yapılır.
Mantıksal adresin kesim numarası kesim çizelgesi için olan adresi
belirler kesim çizelgesindeki giriş sayfa çizelgesi için göstergedir.
Toplam sayfa çizelgesi içinde bir giriş bir gösterge adresidir.
• Sayfa çizelgesinde bulunan değer fiziksel bellekte bir blok
numarasıdır. Blok alanı ile kelime alanının arka arkaya yazılarak
birleştirilmesi son fiziksel adresi verir.
• Bu sistem için CAM bellek kullanımı hızı arttırır. Son bellek
erişimlerinin adresleri burada tutulur.
• Bu tip belleğe dönüştürülmüş içerik adresli bellek TLB denir.



BMÜ-202
Bilgisayar Organizasyonu
2010-2011 Bahar Dönemi
Ders 1: Giriş
2
Sayısal sistemlerin temel yapı taşları Bağlaçlar ve FF’ların
çalışması ve elektronik yapıları, bunlarla sayısal devre tasarımı,
Ardışıl devreler. (Toplayıcı, Mux’lar, Sayıcılar , S.register v.b)
fonksiyonel devrelerin yapıları. Sayısal bigisayarların bu
birimlerden oluşumunun mantığının kavranması.
Bir bilgisayarı oluşturan temel
birimler ve bunların birlikte
kullanılabilmesi için kullanıcımakine etkileşimi (üst seviye
programlama dili - makine dili )
seviyesinde tasarım adımları .
Bunun için organizasyon
aşamalarının öğrenilmesi.
“ Bilgisayarlar nasıl çalışır?”
sorusuna cevap arar.
Bilgisayarı kendi diliyle
programlayarak, donanımsal
olarak istenilen kontrol
işaretlerinin gerçek zamanda
oluşturulması v.b gerekli ve
faydalı uygulamaları yapabilmek.
Yazılımsal ve donanımsal olarak optimize
bir şekilde çalışabilecek bir bilgisayarın
tasarlanması için gereken aşamaların
(yüksek seviye dil-assembler dili- makine
dili (komutun binary kelime karşılığı )
ve komutları işleyen ünitelerin kontrolu)
öğrenilmesi ve tasarımının yapılması.
“Bilgisayar nasıl tasarlanır?”
sorusunu cevaplar.
Bilgisayar mı tasarlayacağız ki?
Belki !!!!! AMA…..
1- Eğer gömülü sistemler üzerinde
çalışacaksanız.
2-İşletim sistemleri , Derleyici, aygıt
sürücüleri v.b. Sistem yazılımlarını
performanslı bir şekilde gerçekleştirecekseniz
3- Yazılımlarınızdan iyi performans
istiyorsanız.
Bu durumların hepsinde,
donanımı anlamanız gerekir!
Bilgisayar
Organizasyonu
Dersin
Önemi
Neler anlatılacak?
Hafta İçeriği
1 Giriş, bilgisayar kuramsalları ve teknolojisi (Bölüm-1)
2 Komutlar: Makine dili (Bölüm-2 ve Ek A)
3 Komutlar: Makine dili (Bölüm-2 ve Ek A)
4 Bilgisayar aritmetiği (Bölüm-3 ve Ek B)
5 Bilgisayar aritmetiği (Bölüm-3 ve Ek B)
6 Bilgisayar performansını anlamak ve değerlendirmek (Bölüm 4)
7 1. Arasınav
8 İşlemci: Veriyolu ve kontrol (Bölüm 5 and Ek C)
9 İşlemci: Veriyolu ve Kontrol (Bölüm 5 and Ek C)
10 Boru hattı ile performans iyileştirilmesi (Bölüm 6)
11 Hafıza hiyerarşisi (Bölüm-7)
12 Hafıza hiyerarşisi (Bölüm-7)
13 Veri depolama, ağlar ve diğer çevrebirimler (Bölüm-8)
15 uygulamalar
3
Kaynak :Computer Organization and Design (David A.Patterson)
Yardımcı kaynak : Bilgisayar Sistemleri Mimarisi (M. Morris Mano)
Kazancınız ne olacak?
Bahsedilen konuları başarılı bir şekilde anlatabilirsek ve sizlerde
öğrenmek için gerekli çabayı gösterirseniz; elde edeceğiniz bilgi kazanımları
aşağıda sıralanmıştır.
–Komut kümesi mimarisi tasarımı ve uygulaması
–Bilgisayar aritmetiğinin öğrenilmesi (fix point ve floating point sayı
sistemleri)
–İşlemci uygulamalarında veri yolu ve kontrol mekanizmaları
–İşlemci uygulama alternatifleri (tek çevrim, çok çevrim ve boru hattı
uygulamaları)
–Bellek hiyerarşisi tasarımı
–Bilgisayar performansının bellek-hız değerlendirilmesinin yapılması
–Çok işlemcili aritmetik algoritmalar ve gerçek zamanlı planlama
–Önbellek tasarımı
–Sanal bellek
–Bellek arabirim ve çevrebirimleri
4
Bilgisayar nedir? Nerelerde kullanılır?
“ Yüksek hızda aritmetik ve mantıksal işlemleri
ard arda yapabilen ve karar verebilme yetisine
sahip hafızalı bir elektronik cihazdır ”
5
Bilgisayar nedir? Nerelerde
kullanılır?
6
Kişisel Bilgisayarlar
• Düşük maliyetli, tek bir kullanıcı için iyi bir performans sunan kişisel bilgisayarlar
• Masaüstü bilgisayarlar sadece son 30 yıllık bir geçmişe rağmen, günümüzde
,bilgisayar pazarlarındaki en büyük paya sahiptir.
• Kişisel bilgisayarlarda;
– Microprocessor
– Memory - Synchronous DRAM
– Hard disk(s), CDROM/DVD, etc.
– I/O - mouse, klavye, video kart, monitor, network kartı, v.b)
7
Sunucular
• Büyük iş yüklerini taşıyan sunucularda
• Tek karmaşık uygulamalar (bilimsel hesaplama veya mühendislik uygulaması gibi) ya
da çok küçük işler (web sunucusu gibi).
• Sunucularda;
8
- Microprocessor(s)
- Hard disks
- Network Interface(s)
Gömülü sistemler
• Kullanıcının hiç ummadığı cihaz ve birimlerde, bunları yönetmek için.
• Aşağı yukarı her cihaz ve aletin içine girmiştir.
• Gömülü sistemlerde
9
-Microcontroller / Microprocessor
-Hafıza: RAM, ROM; Disk
-Özel amaçlı I/O (including analog stuff) vardır.
10
• Mevcut bilgisayar yapısını anlamak için kronolojik
gelişim evrelerini bilmek yerinde olur.
• Bilgi işlem makinelerinin evrimi birkaç yüzyıldır
devam etmektedir.
• Günümüz referans alındığında, bilgisayarların evrimi,
radikal teknoloji değişimine göre dört kuşağa ayrılır.
Bilgisayarın Tarihsel gelişimi
Aşağıda verilen tarihlerin yaklaşık tarihler olduğunu unutmayınız.
0.kuşak öncesi
ABAKÜS: Aritmetik işlemleri gerçekleştirmek
için kullanılan sayma tablosudur. Sayıları
temsil etmek için pozisyonel gösterimi kullanır.
M.Ö 1200’lü yıllarda Çin’de ortaya çıkmıştır
ALGORİTMA: Bir görevi gerçekleştirmek için resmi
prosedürler olarak tarif edilen algoritmayı,
Muhammed b. Musa el- Khwarizmi 800’lü yıllarda
geliştirildi.
11
12
Sürgülü Hesap Cetveli
• 1621’de, Willliam Oughtred
isimli bir İngiliz matematikçi,
Napier’in logaritmalarını
kullanarak ilk Sürgülü Hesap
Cetveli’ni oluşturmuştur.
• Bu hesap cetveli, 1960lı
yılların sonlarına kadar
okullarda yaygın olarak
kullanım alanı bulmuştur.
0.kuşak: Mekanik hesaplama makinaları
(1642 – 1945)
13
– Hesapsal saat (computing clock) - Wilhelm Schickard
(1592 - 1635).
– Pascaline - Blaise Pascal (1623 - 1662).
– (Fark makinası) Difference Engine - Charles Babbage
(1791 - 1871), also designed but never built the
Analytical Engine.
– Delikli kart tabulating machines - Herman Hollerith
(1860 - 1929).
Hollerith kartları (Delikli kart) yaygın olarak1970'lerde ,
bilgisayar girişi için kullanılmıştır.
14
İlk Mekanik Hesaplayıcılar
• Wilhelm Schickard’ın
1623 yılında birbiri ile
bağlı dişlilerden oluşan
bir cihazı geliştirmesi ile
ilk mekanik hesaplayıcı
ortaya çıkmıştır.
15
Pascaline
• 1642 yılında Blaise Pascal adlı bir Fransız
tarafından geliştirilen ve “Pascaline” olarak
adlandırılan cihaz ile mekanik olarak
toplama, çıkarma, çarpma ve bölme
işlemleri gerçekleştirilebilmekteydi.
• Dişli mekanizmaları marifetiyle, işlenecek
sayılar aranıp , uygun şekilde dizilip hesap
yapılırdı.
16
Leibniz Hesaplayıcısı
• 1673 yılında, bir Alman
Baronu, Gottfried
Wilhelm von Leibniz
tarafından , Pascalinin
birazdaha gelişkini
“Leibniz Hesaplayıcısı”
olarak adlandırılan bir
diğer mekanik
hesaplayıcı üretilmiştir.
17
Jacquard’ın Dokuma Makinesi
• Bir Fransız dokumacı Joseph
Jacquard, delikli kartlarla
(dokuma deseninin hafızaya
alınmış şekli) dokuma işlemini
gerçekleştiren bir dokuma
makinesi üretmiştir.
Difference Engine - Charles Babbage (1791 – 1871) Fark Makinası
• 1822 yılında bir İngiliz
matematikçi olan Charles
Babbage , Daha karmaşık
hesaplamalar için fark
makinası tasarlamıştır.
• 4,000’den fazla dişli ve diğer
parçalardan oluşan bu
makine, yeterli hassasiyette
dişliler üretilemediğinden,
çalışır duruma
getirilememiştir.
18
19
Babbage-Analitik Makina
• 1834 yılında Babbage,
“Analitik Makine (Analytical
Engine)” adı verilen yeni bir
genel amaçlı hesaplayıcı
tasarlamıştır.
• Bu makinenin tasarımı,
modern bilgisayarların
tasarımlarının arkasında yatan
hafıza, programlanabilen bir
işlemci, bir çıktı aygıtı ve
kullanıcı-tanımlı programlar
ve veri gibi birçok kavramı
tanımlamaya yaramıştır.
20
Babbage-Delikli Kartlar
• Babbage, programları ve veriyi, daha önce Jacquard’ın
dokuma makinesi için geliştirdiğine benzer şekilde delikli
kartlarda saklamayı önermiştir.
• Delikli kartlar, ilk elektronik bilgisayar dönemlerinde de
(1970’lerde )yaygın olarak kullanılmıştır.
Tabulating Machine
• 1890 yılında,Amerikalı Herman Hollerith nüfus sayımı
sonuçlarını hızlı çabucak belirleyebilmek için delikli kartlarla
çalışan makineyi yaptı.
• Hollerith ‘in gelistirdigi bu makine J.M.Jaquard’in 1806 yilinda
kullandigi kart sistemini kullaniyordu. Mark-1, kartlari verilen
kodlara göre delerek bilgiyi kaydediyor, delikli karttaki bilgiyi
tekrar okuyabiliyor ve bu bilgiyi kullanabiliyordu. Mark- I insan
müdahalesi ile islem gördügü için yari otomatik çalisiyordu.
• Mark –I ile sayimin degerlendirme süresi dörtte bire düstü.
• Makine üretimini arttrmak isteyen H. Hollerithin
kurduğu Tabulating MachineCompany şirketi 1924
yılında IBM (International Business Machine
Corporation) adını aldı.
•
21
Elektromekanik Bilgisayarlar
• Elektriksel röleler (hareketli
kontağı olan kontrollu
elektrik anahtarı) kullanılarak
Conrad Zuse tarafından
geliştirildi.
• İlk defa binary aritmetik
kullanılan makinadır.
• Z3 (1941) fonksiyonelprogramlama kullanılan ilk
bilgisayardır.
– 2,000 relays
– 5-10 Hz
22
Alman Elektrik mühendisi ZUSE’nin
bu eserinin tasarımı İkinci Dünya
Savaşı nedeniyle gizli tutulmuştur.
Bu tasarımla ilgili bilgiler savaştan
sonra ortaya çıkmıştır.
23
1. kuşak Bilgisayarlar - Vacuum Tube Bilgisayarlar
(1945 - 1953)
• Vakum Tüp Lambalı elektronik anahtar elemanlarının kullanıldığı
bilgisayarlardır.
• İlki; Atanasoff- Berry Bilgisayar (ABC) (1937 - 1938) ‘dır. Lineer
denklem takımlarını çözmek için kullanıldı.
• John Atanasoff ve Clifford Berry , Iowa State Universitesi
elemanlarındandır.
• ABC, mekanik anahtarlar yerine vakum tüplerinin kullanıldığı ilk
bilgisayardır.
• İlk sayısal bilgisayardır
• Hesaplama işlemlerinin temeli ikili sayı sistemine dayanmaktadır
24
Birinci kuşak bilgiayar :ENİAC:
– John Mauchly and J. Presper Eckert tarafından…
– University of Pennsylvania, 1946
– Electronic Numerical Integrator and Computer
(ENIAC)
– ENIAC, Birleşik Devletler ordusunun savaş
sırasındaki işlemleri için geliştirilmeye çalışılıyordu.
– Savaşın bitiminden üç ay sonra, Kasım 1945’de
tamamlanabildi.
• The ENIAC ilk genel amaçlı elektronik bilgisayardır.
ENIAC (1945)
• 18000 vacuum tubes & 1500 röle kullanılmıştır. 10.000 direnç, 7.000
kondansatör ….
• 30 ton ağırlığında, 140 kW güç harcıyor (kışın soba ihtiyacını da görüyor,)
• 6000 anahtar ve kablo üzerinden Programlanıyor.
• Bir saniyede 5000 toplama, 3500 çarpma işlemi gerçekleştiriyor. Çalışma hızı
100 hz.(Şimdilerde GHZ’ler mertebesindeyiz)
26
• Birinci kuşak bilgisayarların seri üretimi;
– The IBM 650 ilk seri üretim bilgisayar. (1955)
° Ömrü kısa sürdü. Aşamalı olarak 1969 yılında devre dışı.
– Bu periyottaki diğer önemli bilgisayar üreticileri ise
UNIVAC, Engineering Research Associates (ERA), ve
Computer Research Corporation (CRC).
° UNIVAC ve ERA, Unisys CorporatioIn kurucusu Remington
tarafından satın alınır..
° CRC , Underwood (typewriter) Corporation tarafından
satın alınır…
° Dikkat bu yıllarda Billy Gates henüz doğmamış!!!!!!!!!
27
UNIVAC
• Ticari olarak kullanılabilen ilk sayısal bilgisayar UNIVAC (Universal
Automatic Computer)’dır.
• Eckert-Mauchly Computer tarafından tasarlanmıştır.
• Remington Rand firması tarafından satın alınmıştır.
• Amerika Başkanlık seçimlerini tahmin edebilmek amacıyla kullanılmıştır.
• 1951-1958 yılları arasında 48 adet UNIVAC bilgisayar Remington-Rand
firmasının müşterilerine teslim edilmiştir
28
UNIVAC’ın Özellikleri
• UNIVAC, 14.5 feet (4.5 m) uzunluk, 7.5 feet (2.3m)
yükseklik ve 9 feet (2.7 m) genişliğe sahipti.
• ENIAC’dan daha küçük, ancak daha güçlü idi.
• Saniyede 7,200 karakter okuyabiliyor ve 2.25 milyon
deyimi işleyebiliyordu
• 12,000 karakter (12k) belleğe (RAM) sahipti.
• Verilerin depolanabilmesi ve sonradan okunabilmesi
için manyetik bantları kullanıyordu.
• En düşük resmi satış fiyatı yaklaşık 930,000$ idi.
29
Birinci Kuşaktaki Programlama Yöntemleri
• İlk kuşak bilgisayarların her biri yalnızca belirli
işlemleri yapmak üzere programlanabilirlerdi.
• Programların değiştirilmesi, uzun süren kablo ve
anahtar bağlantıları yapılarak mümkün olabilirdi.
• Birinci kuşak bilgisayarların döneminin sonlarına
doğru Assembly adı verilen bir programlama dili
geliştirildi
• Programcılar bu dilde programlarını daha kolay,
ancak yalnızca o bilgisayarda kullanabilmek üzere
yazabilme imkanına kavuştular.
1947’li yıllar;
• O yıllarda dünyaca çok önemli bir akademik
dergi olan Popular Mechanis şöyle bir yorum
yapıyor.
“Öyle umuyoruz ki; Elektronikçilerin icadı
ENİAC çok hızlı bir gelişmeyle 10 yıl içerisinde
10 ton ağırlığa düşer. 10Kw güç harcar, İşlem
hızı iki katına çıkar”
Tabiidir ki bu yorum makinacı gözüyledir.
Oysa 1948’li yılların ortasına doğru Transistör
denenen statik elektronik eleman icat edilir.
30
31
2. Kuşak: Transistörlü Bilgisayarlar (1954 -1965)
–Transistörün icadıyla vakum tüp devri kapanıyor.
–Transistör; Vakum tüpten çok daha küçük (1/13),
daha az enerji harcıyor, daha hızlı anahtarlıyor.
–IBM’in 7094 (bilimsel amaçlı) ve 1401 (iş amaçlı)
–Digital Equipment Corporation (DEC) PDP-1
–Univac 1100
–Control Data Corporation 1604.
–. . . Ve diğer üreticiler transistörlü bilgisayar seri
üretimini gerçekleştiriyorlar..
Bu sistemler birkaç mimari benzerlikler vardı,
Transistor- temelli Makinalar
• IBM 704 (1955)’de transistörler kullanarak bir mainframe bilgisayar
geliştiriyor.
• The 704’e değişik terminallerin bağlanabilmesi, merkezi bilgisayar
fikrinin ve dağıtılmış giriş/çıkışlı uygulamaların ilkidir.
• FLOATİNG –Point sayı sisteminin uygulandığı ilk makinadır.
32
3.Kuşak: Entegre Devreli Bilgisayarlar
• Texas Instruments’da çalışan Jack Kilby ve Fairchild
Semiconductor’da çalışan Robert Noyce’un birbirlerinden
bağımsız olarak çalışmaları sonucunda “entegre devre”
(Integrated Circuits –I C) ortaya çıktı.
1/30/07 CIS 273: Lecture 1 33
34
Entegre Devre Teknolojisi
• Entegre devre teknolojisi, transistör, diyod v.b statik
elektronik devre elemanının yüzlercesinin bir silisyum
veya germanyum yüzeye kimyasal yollarla
yerleştirilmesi şeklindedir.
• Böylece bilgisayar gibi cihazların fiziksel boyut, ağırlık
ve güç ihtiyaçlarını büyük ölçüde azaltmıştır.
• “Entegre Devreler” üçüncü kuşak bilgisayarların
gerçekleştirilmelerini sağlamıştır.
35
– IBM 360
– DEC PDP-8 and PDP-11
– Cray-1 supercomputer
– . . . and many others.
• Bu süreçte IBM diğer markalara ezici bir
üstünlük sağlamıştır..
– Bu dönemin Bilgisayar üreticileri IBM ve
diğerleri (Burroughs, Unisys, NCR, Control Data,
ve Honeywell) olarak karakterize edilmiştir.
3.Kuşak-Integre devre’li Bilgisayarlar (1965-1980)
36
RCA Spectra 70
• Entegre devre teknolojisi kullanılarak üretilen
bilgisayarlardan ilk ikisi RCA Spectra 70 ve uzun
yıllar kullanımda kalan bir bilgisayar olan IBM
360’dır.
37
IBM 360
Minicomputers
• Çok daha büyük ve hızlı
makinelere odaklanmadan,
Digital Equipment Inc(DEC),
1965 yılında, ticari ilk
minibilgisayar olan
DEC PDP-8’i üretmiştir
• PDP-8, birçok üretim yerinde,
küçük işletmelerde ve bilimsel
laboratuarlarda yaygın olarak
kullanılmıştır.
38
39
İlk Üçüncü Kuşak Programlama Dilleri
• Programcıların istedikleri işlemleri kolay
yapabilmelerine imkan sağlayacak programlama dil
arayışları da sürmekte idi.
• İlk olarak FORTRAN (Formula Translator) programlama
dili mühendislik hesapları için ortaya çıktı
• Ticari uygulamalarda kullanılmak üzere COBOL
(Common Business Oriented Language) programlama
dili ortaya çıktı.
• Diğer programlama dilleri bu dilleri takip etti.
40
İşletim Sistemi’nin Doğuşu
• İlk kuşak bilgisayarlarda her bilgisayar için özel yazılımlar
geliştirilmekteydi.
• Bir programda kullanılan bir altprogram, geliştirilen başka bir
programda da yeniden yazılmaktaydı.
• Her programda standart olan altprogramları bir kütüphane
yapısı içinde toplamak ve ihtiyaç duyulduğunda o
altprogramları oradan çağırıp işlemleri gerçekleştirebilmenin
yollarını aramaya başladılar.
• “İşletim Sistemi” yazılımları ortaya çıktı.
• Her bilgisayar üreticisi kendi işletim sistemini geliştirerek
kullanıcılara daha rahat program yazabilecekleri ortamlar
sağlamaya başladılar.
41
4. Kuşak
VLSI entegre devreli Bilgisayarlar
(1980 - ????)
(Microprocessors- Mikroişlemciler)
42
– Çok büyük çaplı İntegre devrelerin içinde en az
10.000 adet bağlaca eşdeğer eleman vardır.
– Mikroişlemci gelişimi bu dönemde çok hız
kazanmıştır.
– İlk 4 bit işlemci olan INTELT 4004 gerçekleşmiştir.
– 8080, 8086 gibi daha sonraki sürümleri, ve 8088
"kişisel bilgisayar“ fikrinin uygulaması.
4. Kuşak – VLSI entegre devreli Bilgisayarlar (1980 - ????)
(Microprocessors- Mikroişlemciler)
• Intel’den Ted Hoff ilk mikroişlemci olan 4004’ü, Bir Japon hesap makinası
üretim firması (BUSİCOM) için geliştirdi (1971).
• 4004, transistörlerin tek tek bağlandığı devreler yerine IC şeklinde
gerçekleştirilmiş ilk Mikroişlemci örneğidir.
• Tek bir yonga üzerinde 2,800 transistör bulunmakta, saniyede 60,000
deyimi işleyebilmekteydi.
• Intel, 4004 modelinden sonra ilk 8-bit mikroişlemci olan 8008 modelini
piyasaya sürmüştür.
43
Xerox Alto (1975)
• Kullanıcı için grafiksel
arayüzlü ilk bilgisayardır.
• Ayrıca bizim bildiğimiz,
fare, klavye, özellikli ve
"masaüstü" monitorlü
ilk yapıdır.
44
Personal computers (Kişisel Bilgisayarlar)
• MITS Altair 8800 (1975) ilk
kişisel bilgisayardır.
• 256 bytes hafızalı, monitor,
keyboard, harici hafızası
yok.
• Microsoftun sahiplerinden
Paul Allen ve Bill Gates
Altair için ilk programı
(BASIC derleyici) yazdı.
45
Supercomputers
• Cray XMP (1986) 4
işlemcili özel bir
bilgisayar.
• Fazla ısındığından su
soğutmalı olraka
çalışıyor.
• Maksimum
performansı 840
megaflops …
46
47
• Moore Yasası (1965)
– Gordon Moore, Intel’in kurucusu
• “Entegre devredeki transistör yoğunluğu her yıl iki
katına çıkacak.“
• Günümüz versiyonu:
“silikon çip yoğunluğu her 18 ayda iki katına çıkar.“
• Nisan 2005'te Intel firması 19 Nisan 1965 tarihli Electronics
Magazine dergisi sayısını satın almak için 10.000 ABD Doları teklif
etmiştir.
Fakat bu yasa sonsuza kadar geçeli olamaz.
1.5 Historical Development
MOORE yasasına değişik bir bakış
48
İNTEL İŞLEMCİLERİN GELİŞİMİ
49
1/30/07 CIS 273: Lecture 1 50
Core i7 (Quad) 731,000,000
Six-Core Core
i7 (Gulftown)
1,170,000,000
10-
Core Xeon Westmere
-EX
2,600,000,000
Yıllara göre entegre devre teknolojisi
51
İntel işlemcilerin gelişimi(1971-74)
52
İntel işlemcilerin gelişimi(1978-79)
53
İntel işlemcilerin gelişimi(1982-89)
54
İntel işlemcilerin gelişimi(1993-95)
55
İntel işlemcilerin gelişimi(1997-2000)
56
İntel işlemcilerin gelişimi(2002-2005)
57
İntel işlemcilerin gelişimi(2006-2006)
58
İntel işlemcilerin gelişimi(2006-2007)
59
1/30/07 CIS 273: Lecture 1 60
Bu teknoloji nereye kadar?
Hammadesi kum olduktan sonra, sonunu
hayal edemiyoruz….
61
BÖLÜM-1
• Biz şu ana kadar, bilgisayarların ana ünitesi
olan Mikroişlemcilerin ( İşlemci –
Microprocessors – Central Processing
Unit(CPU) – Merkezi İşlem Birimi (MİB) )
yapısal gelişmelerinin kronolojisini özetledik.
• Artık Bilgisayar yapısını tanımaya başlayabiliriz.
62
63
• ENİAC’ta programlama digital logic devre seviyesinde
yapılırdı..
• Bilgisayarın programlanması, fişlerin ve tellerin farklı
bir şekilde bağlanmasıyla gerçekleşirdi.
• Her bir farklı problemi çözmek için farklı donanım
konfigürasyonları gerekiyordu.
1.7 The von Neumann Model
Farklı bir basit problemi çözmek için, ENIAC vasıflı
teknisyenler tarafından günlerce emek verilerek
donanımsal konfigüre edilirdi.
Bilgisayarların Bileşenleri
64
• Aslında ENİAC’ın mucitleri, John Mauchley ve J.
Presper Eckert, hafızasında komutların saklandığı
bir bilgisayar tasavvur etmişlerdi.
• Bu fikrin asıl yaratıcısı o çağlarda yaşayan
Matematikçi John von Neumann’dır.
• Kayıtlı-programlı bilgisayarların von Neumann
Mimarisi sistemleri olarak da bilinmesi bu
yüzdendir.
• Bu mimari günümüzdeki bilgisayarların temel
taşıdır.
Von Neumann Bilgisayar Modeli
• von Neumann mimarisi veri ve komutları tek bir veri depolama
biriminde barındıran bilgisayar tasarı örneğidir. Belleğin,
işlemciden ayrılması Von Neumann mimarisi olarak ifade edilir.
• İlk hesap makineleri değişmez yazılımlara (veya programlara)
sahiptiler. Bir makine hangi işlemi gerçekleştirmesi için
tasarlandıysa sadece onu yerine getirebiliyordu. Bu tür
bilgisayarların yeni bir görevi yerine getirebilmesi için
donanımlarının tekrar tasarlanması zorunludur.
• Bu zorlukların aşılması "saklı yazılım bilgisayarı" ilkesi ile
gerçekleşmiştir. Makinenin yürütebileceği bir dizi komutun
tanımlanması ile bilgisayarlar çok daha esnek bir yapıya kavuştular.
• Komut ve verinin aynı biçimde saklanması ise, bu ilke sayesinde
yazılımın kolayca değiştirilebilmesine olanak tanımıştır.
• Saklı yazılım tasarımı, ayrıca yazılımların çalıştırılmaları esnasında
kendilerini değiştirebilmelerini mümkün kılar. 1/30/07 CIS 273: Lecture 1 65
November142023Von Neumann Bilgisayar Modeli
• Bilgisayarı oluşturan Bileşenler
• von Neumann mimarisi veri ve komutları tek bir veri depolama biriminde barındıran bilgisayar tasarı örneğidir.
– Central Processing Unit (CPU - MİB): Kontrol Birimi (komut kodlarının çözülmesİ, İşlemlerin sıraya
konması v.b), Datapath (Registers’lar, Aritmetik ve lojik işlem birimi , Veri yolları) alt birimleri vardır.
– Memory: Komutların ve verilerin saklandığı ortam.
– Input/Output (I/O) sub-system: I/O BUS’ları, Arayüzler, Elemanlar.
– The stored program concept: Bir zaman diliminde Komut setinin hafızalandığı bir ortak bellekten
çağrılan komutlar icra edilir.
-
Memory
(komutlar,
veriler)
Kontrol
Datapath
Registers,
ALU, veriyolları
Computer System CPU
Giriş
Çıkış
I/O Devices
Major CPU Performance Limitation: The Von Neumann computing model implies sequential execution one instruction at
67
68
• Bilgisayarların
çalışmasını anlamak için
sanal katmanlı bir yapı
modeli uygundur.
• Her bir katman belirli
görevleri gerçekleştirmek
içindir ve kendi komutları
vardır. Katmanlar
gerektiğinde alt
seviyelerdeki komutları
çağırabilirler.
• Esas işi enalt tabakadaki
sayısal devreler
yapacaktır.
Bilgisayarın hiyerarşik yapısı
69
• Seviye 6: Kullanıcı seviyesi
– Kullanıcı ile bilgisayarın etkileştiği arayüz. Bu seviye birçok bilgisayar familyası için aynıdır.
• Seviye 5: Yüksek-seviyeli dil seviyesi
• C, Pascal, Java v.b programlas dilleri ile yazdığımız programlarla bilgisayarla etkileştiğimiz seviyedir.
• Seviye 4: Assemler dili seviyesi
– 5.seviyedeki yüksek-seviye dilinde yazılmış program assemler diline çevrilir. as well as instructions
programmed directly at this level.
• Level 3: Sistem yazılımı seviyesi
– Sistemde işlenen prosesleri kontrol eder. Sistem kaynaklarını korur.
– Assemler dili komutları fazla değişikliğe uğramadan bu seviyeye geçer.
• Seviye 2: Makine dili seviyesi
– Instruction Set Architecture (ISA – Komut Seti Mimarisi) seviyesi olarak bilinir.
– Makine mimarisine özel komutların oluşturulduğu seviyedir. Makine dilinde yazılmış programlar hiçbir
şekilde derleyiciye, yorumlayıcıya veyea assemler’a ihtiyaç duymazlar.
• Seviye 1: Kontrol Seviyesi
– Bir kontrol ünitesi komutları decode eder ve işler. Verilerisistem üzerinde hareket ettirir.
– Kontrol üniteleri mikroprogramlanabilir olabilir veya sadece devrelendirilmiş(Hardwired) yapıdadır.
– Bir mikroprogram donanım tarafından uygulanabilen, bir düşük seviyeli bir dilde yazılmış bir programdır.
– Devrelendirilmiş(Hardwired) üniteler, doğrudan makine komutlarını çalıştırır donanımlardır.
• Seviye 0: Digital Logic Seviyesi
– Bu seviyede biribirine uygun bir şekilde bağlanmış sayısal lojik devreler bulunur (IC’nin içinde)
– Bu komponentler, diğer üst sevilerdeki matematiksel ve Lojik işlemleri gerçekleştirir.
Hiyerarşik yapının şeması
70
1-Uygulama Yazılımları (Applıcatıon SW): kullanıcı ve sistem yazılımı arasındaki
etkileşimi sağlar. Yüksek seviyeli dildir. C++, Web Browser v.b
2,3,4 Sistem yazılımları: (2) İşletim Sistemi: Bilgisayarın kaynaklarını yönetir, birden fazla
programın beraber çalışmasını düzenler. (3) Compiler :Yüksek seviyeli dilde yazılmış
deyimleri assemler diline dönüştürür. (4) Assemler: Sembolik deyimleri makinenin anlayacağı
komutlara, makine diline çevirir.
5- komut Seti Mimarisi (ISA): Yazılımdan donanıma geçiş arayüzüdür. Bu derste uğraşacağımız en
önemli konudur. Kapsadığı birimlere dikkat!!!!!!!!!!!!!!
Yüksek seviyeli dilden- Sayısal gerçeklemeye
71
Özet
a = b+c ----add a,b,c-------01101110
73
74
75
Bir reklam düşünün:
Bunların hepsi ne demek?
76
Kapasite ve hız ölçü birimlerini hatırlayalım.
• Kilo- (K) = 1 thousand = 103 and 2
10
• Mega- (M) = 1 million = 106 and 2
20
• Giga- (G) = 1 billion = 109 and 2
30
• Tera- (T) = 1 trillion = 1012 and 2
40
• Peta- (P) = 1 quadrillion = 1015 and 2
50
• Exa- (E) = 1 quintillion = 1018 and 2
60
• Zetta- (Z) = 1 sextillion = 1021 and 2
70
• Yotta- (Y) = 1 septillion = 1024 and 2
80
1.3 An Example System
77
• Hertz = Bir saniyedeki clock sayısı (frequency)
– 1MHz = 1,000,000Hz
– İşlemci hızı MHz veya GHz. Birimi ile ölçülür.
• Byte = Hafıza kapasite birimidir.
– 1KB = 2
10 = 1024 Bytes
– 1MB = 2
20 = 1,048,576 Bytes
– Ana hafıza (RAM) genellikle MB birimi ile ifade edilir.
– Hard disklerin hafıza birimi genellikle GB veya TB ‘dır.
1.3 An Example System
78
1.3 An Example System
Zaman ve yer ölçme birimleri:
• Milli- (m) = 1 thousandth = 10 -3
• Micro- () = 1 millionth = 10 -6
• Nano- (n) = 1 billionth = 10 -9
• Pico- (p) = 1 trillionth = 10 -12
• Femto- (f) = 1 quadrillionth = 10 -15
• Atto- (a) = 1 quintillionth = 10 -18
• Zepto- (z) = 1 sextillionth = 10 -21
• Yocto- (y) = 1 septillionth = 10 -24
79
• Milisaniye = 1/100.000 saniye
– Bir Hard disk sürücünün erişim zamanı 5 - 20 ms’dir.
• Nanosaniye = 1/1.000.000.000 saniye
– Bir RAM’ın erişim zamanı 30 ile 70 nanosaniyedir.
• Micron (micrometre) = 1 millionth of a meter
– Bir işlemci teknolojisini belirtmek için iki komponent
arasındaki mesafeyi verir. Örnek 1mikron teknolojisi.
1.3 An Example System
80
• Bir clock işaretinin, Frekansıyla periyodu(cycle)
arasındaki f=1/T ilişkisini unutmayalım.
• 133MHz’lik bir veriyolu hızının bir periyotluk
zamanı :
1.3 An Example System
Bu tanımlardan sonra tekrar
reklama dönelim…..
133,000,000 cycles/second = 7.52 ns/cycle
81
Ana kart: İşlemci; Hafıza birimleri, çevre birimleri ile etkileşimi sağlayan
veriyolları ve arayüzlerin üzerinde bulunduğu elektronik karttır. Üzerindeki
cipset entegre bu trafiği yönetmek içindir.
2000’li yıllardaki ana kart örneği
1/30/07 CIS 273: Lecture 1 82
Chipset(Ana kart trafiğini yöneten birim)
• Bilgisayar donanımlarını birbirlerine
bağlamak ve koordineli halde çalışmalarını
sağlamak için kullanılan bir donanımdır.
Parçaların aralarında iletişim kurmasını ve
gerekli işlemlerin gerçekleşmesini
sağlamak için anakartlar üzerinde harici
işlemci yanında kart işlemcileri de
bulunmaktadır. Chipset olarak ta
adlandırılan bu işlemcilerin bilgisayar
performansı üzerinde çok etkili oldukları
bilinmektedir. Chipset’lerdeki gelişmeler
işlemcilerdeki gelişmelere paralel olarak
ilerlemektedir. Yeni bir RAM ya da bus
geliştirildiği zaman bunu işlemciye
aktaracak olan Chipsetler de geliştirilir
• Kuzey Köprüsü (North Bridge)
• Anakart üzerinde bulunan, bellek ve AGP
ve Güney Köprüsünü işlemciye bağlayan
yongadır.
• Güney Köprüsü (South Bridge)
• North Bridgearacılığı ile işlemciye
bağlanarak paralel ,seri,usb,ps2 gibi düşük
hızlı çıkış ve arabirimlerin işlemciye
bağlanmasını sağlayan çipin ismidir. 83
İşlemci ve chip set
1/30/07 CIS 273: Lecture 1 84
85
86
ANA kart ile ilgili
87
Bus (Veri yolu)
Bilgisayardaki veriyoluna verilen isimdir. Paralel iletken yollardan oluşur. Bayt’ı
oluşturan bitleri; paralel olarak 0 veya 1 sevyiesinde elektrisel işaretler şeklinde taşır.
Anakart üzerinde bir çok çeşit bus yapısı vardır. Bu farklılık her bileşenin farklı
ihtiyacından kaynaklanmaktadır. Örneğin hafıza veriyolu (memory bus), kuzey köprü (hafıza
kontrolcusu) ile hafıza arasındaki veriyoludur.
Yeni nesil bilgisayarlarda(günümüzdeki) hafıza ile CPU arasındaki veriyoluna FSB
(front side bus), CPU ile level2 bellek arasındaki veriyoluna BSB(back side bus) ismi
verilmektedir. Günümüzde PCI, AGP, PCI Express, USB,SCSI, SATA, firewire ve PCMCIA
gibi veri yolları vardır. Verileri bazıları seri bazıları ise paralel olarak iletir. Her bir veriyolu
yapısı kendisine has bir slot veya soket yapısına sahiptir. Veriyolları aygıt sürücüleri
yardımıyla kontrol edilir.
SCSI(Small Computer System Interface): Birçok farklı donanım birimini(yazıcı,
cd-rom, sabit disk, tarayıcı... ) destekleyen, aynı veriyoluna birçok donanım biriminin
bağlanmasına imkan veren bir veriyolu yapısıdır. SCSI veriyoluna bağlanan her bir
donanımın tekil bir numarası (ID) olması gerekmektedir. SCSI-3 versiyonunda Maksimum
veri yolu genişliği 16 bit, veriyolu hızı 80Mhz ve desteklenen donanım sayısı 16 dır.
IEEE1394 Firewire: Daha çok video, ses, görüntü işleme ve DVD dünyasında
kullanılan yüksek hızlarda seri veri aktaran bir yapıdır. İ-Link(Sony) ve DV(Panasonic)
olarak ta isimlendirilir. SCSI'nın daha da gelişmiş şeklidir. Günümüz bilgisayarlarında paralel
SCSI'nin yerini almıştır. Firewire bant genişliği 400, 800 ve 3200 Mbit değerlerinde
olabilmektedir. Firewire HotPlugging yapıya sahiptir.
Ana kart ile ilgili -II
88
PCI(Peripheral Component Interconnect): Ses, ekran, tv ve ağ kartları
bağlanabilir. Paralel iletişimi kullanılır. Anakart üzerine onboard olarak veya slotlar yardımıyla
bağlanan donanım yapılarını destekler. 33/66Mhz frekans değerini ve 32/64 bit band
genişliğini kullanan modelleri vardır.
AGP(Accelerated Graphics Port): Hızlandırılmış grafik port'u anlamına gelen AGP,
ekran kartları ve video kartları için kullanılan yeni bir veri yoludur. Paralel iletişimi kullanır. 32
bit genişliğe sahiptir. 1x, 2x, 4x ve 8x gibi sürümleri vardır. AGP yapısı bir veriyolu olmasına
rağmen noktadan noktaya iletimi sağlar. Sabit 32 bit genişliğin her bir çarpana 66Mhz eklenip
çarpılmasıyla band genişliği hesaplanır.
PCI veri yolu ile aralarındaki temel fark: AGP'ler 128 KB'a varan büyük grafik dokularını
(texture) ekran kartı belleğinin dışında, sistem belleğinden de yararlanarak işler. Bu sayede
performansta artış sağlanır. AGP veri yolunun performansta bu şekilde bir artış sağlamasına
"Doğrudan Bellek Kullanımı" DIME (Direct Memory Execute) denir.
PCMCIA veya PC Card (Personal Computer Memory Card International
Association): Dizüstü bilgisayarlarda kullanılan genişleme yuvalarının bağlandığı veriyoludur.
31-1067 Mbit bant genişliğine sahiptir.
USB(Universal Serial Bus): Evrensel seri veriyolu anlamındadır. PnP özelliğe
sahiptir. Tek bir bilgisayara 127 adet donanım bağlamaya izin veren bir yapıdır. Günümüzde
monitör, klavye, fare, TV kartı, Ses kartı, sabit disk gibi birçok donanım birimi bu veriyolunu
kullanmaktadır. HotPlugging yapıya sahiptirler.USB3.0 Çok yüksek hızlı olup 4.8Gbit bant
genişliğine sahiptir.
Anakart ile ilgili -III
89
PCI Express: En yeni bus yapısıdır. PCI Express PCI veri yolunda kullanılan
paralel veri iletimi mimarisinin yerine seri çalışan ve noktadan noktaya iletişim
mimarisini kullanan bir teknoloji getiriyor Çarpanları sahip olduğu hat sayısını
gösterir. Veriler paketler halinde iletilir. Bus yapısından ziyade ağ mantığı ile
çalışır. Veri seri olarak birkaç hattan gönderilip alınabilir. Bu hatların her
birine kanal denmektedir ve çarpanla gösterilir. Veriler anahtarlama
yöntemiyle istenen noktalara kanalize edilerek band genişliğinden bağımsız
iletim oluşturulur. Yani her bir kanal için adanmış bir yol anahtarlanarak
sağlanır. Her bir hat sayısı 250MB/s band genişliğine sahiptir. Haberleşme
şekli seridir. Kartlara sağladığı elektriksel güç AGP den yaklaşık iki kat
fazladır. Slot uzunluğu, çarpan sayısı ile doğru
PCI-Express veriyolunun çalışma mimarisi aynı donanım birimlerini ortak
çalıştırmak için elverişlidir.
Serial ATA(SATA), masaüstü bilgisayarlardaki, bazı sunuculardaki ve ağa
bağlı depolama cihazlarındaki(HD) paralel ATA fiziksel depolama
arabiriminin yenilenmiş versiyonudur.
Anakartla ilgil -IV
• Portlar
Bilgisayarın dış dünya(modem, kalvye, yazıcı, kamera...) ile iletişimini sağlayan giriş
çıkış kapılarına port denir. Aslında bunlarda birer veriyoludur. Seri, paralel, USB,
PS/2... gibi çeşitleri vardır.
• BIOS (Basic Input Outpu System ) Temel giriş çıkış sistemi anlamına gelir. Bilgisayar
ilk açıldığında bu sistemin sahip olduğu program kodları ile başlatılır. Bu kodlar
eeprom veya flash hafıza denilen yapılarda saklanır. Biosun ilk işi sistem
elemanlarını(ekran kartı, sabit disk, Ram...) tanımlamak ve onları kontrol etmektir.
Donanım birimleri denetlendikten ve başlangıç parametreleri yüklendikten sonra
BIOS disk üzerindeki MBR (Master Boot Record) alanında işletim sistemi açılış
dosyalarını arar. İşletim sistemini çağırarak kontrolü ona bırakır.
Chipset
Anakart üzerinde faklı donanımların birbiri ile iletişimini sağlayan chiplerdir.
Norhbridge(kuzey köprü) ve Soutbridge(güney köprü) adında iki bileşenden(chip)
oluşur. Norhbridge hızlı bileşenleri(CPU, RAM, PCI Express ve AGP) birbirine bağlar.
SouthBridge ise yavaş bileşenleri birbirine bağlar(IDE, USB, PCI...).
90
Veriyolu karşılaştırmaları
91
Adı Band genişliği
AGP 1x 266MB/s
AGP 2x 533MB/s
AGP 4x 1067MB/s
AGP 8x 2133MB/s
PCI(32Bit, 33Mhz) 132MB/s
PCI(64Bit, 33Mhz) 266MB/s
PCI(64Bit, 66Mhz) 533MB/s
PCI Express 1x 250MB/s
PCI Express 2x 500MB/s
PCI Express 4x 1000MB/s
PCI Express 8x 2000MB/s
PCI Express 16x 4000MB/s
PCI Express 32x 8000MB/s
EISA 32MB/s
ANAKART BİLGİLERİ- Örnek
92
1.3 An Example System
93
400 MHz, BUS(veriyolu) hızını gösterir. Bir sistem veriyolu bilgisayar
içinde veri taşır. Daha hızlı veri yolu daha iyi veriyoludur.
Mikroişlemci sisteminin "beyni"dir. Bu, programları
yorumlar ve yürütür. Bu bir Pentium (Intel) 4.20GHz
'de çalışan işlemcidir.r
İŞLEMCİLER
1. ALU(Aritmetik ve Mantıksal İşlem
Birimi): Toplama çıkarma, çarpma, bölme,
mantıksal ve, veya, değil komutları ve
kaydırma komutları. 2. Komut Çözücü(Instruction Decoder):
İşlemcinin yapması gereken kodların icrası
için gerekli işlemleri başlatır ve komutun
çalıştırılması için gerekli işlemleri belirler. 3. Kaydediciler(Registery): İşlemci
içerisinde sayıları depolamak için kullanılan
hafıza çeşididir. İşlemci veri uzunluğu kadar
genişliğe(32, 64 bit) sahiptirler. Literatürde
test, EBX, EAX, BX, ES, IP gibi isimler alan
kaydedici hafıza gözleri vardır. 4. Bayraklar(Flags): İşlemlerin sonucuna
göre 1 ya da 0 değerlerini alan 1 bit
genişliğe sahip hafıza gözleridir. Sıfır, işaret,
elde, eşlik, taşma gibi çeşitleri vardır.
Örneğin bir çıkarma işleminde sonuç sıfır
çıkarsa sıfır bayrağı 1 değerini alır. 5. Veriyolları(Buses): İşlemcinin diğer
donanım birimleri ile bağlantısını sağlayan
iletken elektriksel yollardır. Üç adet veriyolu
bulunur. Bunlar veri(data), adres(address)
ve kontrol(control) veriyollarıdır.
94
• Bilgisayarda genelde üç tip bilgi iletişimi yapılır.
• Bunlar; veri (data) iletişimi, işlemin kontrol (control) edilmesi ve durumun
bir bilgi ile (Status data) belirlenmesidir.
• Kontrol işaretleri bilgisayarın farklı üniteleri arasında bir işlem yapıldığı
sırada kullanılır. Status (durum) işaretleri ile merkezi işlemcinin durumu ve
ne iş yaptığı açıklanır. yani veri giriş mi yaptığı yoksa veri çıkışı mı oluyor ya
da kontrol mu yapılıyor gibi.
• Bir merkezi işlemci işleyeceği bilgileri bellekten alarak işler, daha sonra
işlenen bilgileri belleğe ya da portlara bilgi olarak geri gönderir. Veri
işlemlerinin dışında ayrıca mantıksal ve matematiksel operasyonları
gerçekleştirir.
• CPU bir işlemi gerçekleştirirken kontrol, adres ve veri yolarını kullanır ve
CPU’nun o anki durumu; işlem durum kaydedicisinde yani Status
Register’da görülür.
• Bir mikroişlemcinin iki tane çalışma frekansı vardır. Bunlardan biri; iç
frekans (internal), diğeri ise;dış frekans (external). İç frekans, işlemcinin
saniyede yaptığı işlem miktarını tanımlar. Dış frekans ise; işlemcinin bellek
ve çipset gibi diğer bileşenlerle haberleştiği frekanstır. Buna veri yolu hızı
ya da FSB de denilmektedir. İç frekans her zaman dış frekanstan çok daha
hızlıdır. 1/30/07 CIS 273: Lecture 1 95
İşlemciler
• 1- Klasik İşlemciler: Komutlar zaman üzerinde sırayla işlenir. Bir komutun
işlenmesi biter. Sonraki komut işlenmeye başlar.
• 2- Pipe-Line İşlemciler: Bir komutun işlenmesi süreci devam ederken sonraki
komutun işlenmesi için hazırlık yapılır.
• Bir komutun icra süreci:Fetch, Decode, Execute, write back
96
• Örneğin 5 ve 6 sayılarının toplanması ve ekrana yansıtılması işleminin
işlemci birimleri tarafından şu şekilde gerçekleşir:
1. Komut alınır : örneğin 5 rakamı belleğin 12345 adresinden alınır.
2. Komut çözülür.
3. Komut çalıştırılır : ALU sayıyı bulur.
4. Komut saklanır : 5 rakamı belleğe geçici olarak saklanır.
5. 1, 2, 3, 4 adımları aynen 6 rakamı için de uygulanır.
6. Komut alınır : toplama işlemi çalıştırılır.
7. Komut çözülür.
8. Komut çalıştırılır : ALU 5 ve 6 sayılarını toplar
9. Komut saklanır : hesaplanan sonuç geçici olarak belleğe saklanır.
10. Komut çalıştırılır : ekranda görüntüleme emri iletilir.
11. Komut çözülür.
12. Komut çalıştırılır : sonuçta hesaplanan sonuç ekranda gösterilir.
1/30/07 CIS 273: Lecture 1 97
İŞLEMCİLER
3-HT (Hyper threading ) İşlemciler: Hyper-Threading (Çoklu iş parçacıkları) teknolojisi,
tek bir fiziksel işlemcinin çok sayıda komut zincirini (farklı programları iş parçacıkları
şeklinde bölerek) eş zamanlı olarak işlemesi ile performans artışı sağlamasıdır.
Hyper-Threading teknolojisine sahip olan bir işlemci, mantıksal olarak iki adet
işlemciden oluşmaktadır. Çip üzerinde tek bir işlemci bulunmasına rağmen
programları zaman paylaşımlı olarak çalıştırabilir.
Not: HT özelliğine izin veren işletim sistemleri ile HT özelliği olmayan işlemcilerle de
farklı programlar eşzamanlı olarak çalıştırılabilir. Fakat performans çok iyi değildir.
98
İşlemciler
4- Çok çekirdekli İşlemciler ( Örn:Dual Core İşlemciler): İşlemci paketi
içerisinde birbirinden bağımsız olarak komutları çalıştırabilen her yapıya
çekirdek ismi verilmektedir. Gerçek zamanlı olarak kendisine verilen iş akışı
görevlerini aynı anda yerine getirerek performansı artırır. Her çekirdek
birbirinden bağımsız FSB ye sahiptir. Tüm çekirdekler L2 yi ortak kullanırlar.
Günümüzde 2 ve 4 çekirdekli işlemciler bulunmaktadır. Intel Pentium Dual
Core, Intel Pentium Core 2 Duo, Intel Quad Core ve AMD Athlon X2 serisi
çok çekirdekli yapıya sahiptir.
99
100
İşlemci ile ilgili Parametreler
• 1. Hız: Birimi frekans olarak GHz katsayısı(10003) ile değerlendirilir. İşlemcinin hızlı olması
işlemlerini daha kısa sürede tamamlaması anlamına gelmektedir. Günümüzde 1.8, 2.0, 2.2,
2.4, 2.6, 3.0, 3.2, 3.6, 3.8 GHz hızlarında olanları vardır.
2. Bit Genişliği: İşlem yapabilme boyutunu gösterir. Günümüzde 64 ve 32 bit işlemciler vardır.
İşlemcinin sahip olduğu kaydediciler, veri hattı ve adres hattının genişliğini gösterir.
3. FSB Hızı: İşlemcinin, kuzey köprüsü ile iletişim hızını gösterir. Günümüzde 1333, 1066, 800,
533 Mhz değerlerine sahip işlemciler vardır.
4. Level2(L2) Cache: İşlemciye yakınlığından dolayı bu isim verilir. En yakın olana L1, diğerine
L2, L3 gibi isimlendirmeler kullanılır. Yapısı SRAM hafıza tipindedir. SRAM hafızalar daha hızlı
fakat maliyetleri yüksek hafıza çeşitleridir. Yavaş olan RAM erişimlerini azaltmak için işlemci
içerisinde yer alan daha hızlı fakat küçük boyutlardaki hafızaya verilen isimdir. İşlemcinin
hafıza kontrol devresinden(MCH) istekte bulunduğu her kod bu belleğe yazılır. İşlemci aynı
kodu RAM yerine daha hızlı olan bu bellekten alır.
2x1MB, 2MB, Core2 Dualarda 4MB, Core2 Quad larda 8MB ve Celeron larda 1MB veya 512 KB
L2 bellek miktarı vardır. RAM'den tipik olarak 4 kat daha hızlı çalışmaktadır.
5-Silikon teknolojisi: Bir nanometre metrenin milyarda biridir. Piyasada şu anda bulunan
işlemcileri oluşturan komponentler arasındaki mesafe bir metrenin 45 milyarda biri
genişliğindedir (45nm teknolojisi). Transistörlerden 2000 tanesini yan yana koyduğunuzda bir
insan saç telinin çapı (0.09 mm) kadar bir genişliğe ulaşılır. Silikon dioksit (1960’lardan bu yana
kullanılmaktadır) yerine hafniyum oksit kullanımıyla yeni transistörlerde daha az enerji kaybı,
daha az ısınma ve daha hızlı geçişler sağlanır.
•
101
İşlemci temel özellikleri -örnek
102
103
• Büyük ana bellek kapasitesi olan bilgisayarlar, 1.3 An Example System
daha büyük programları, daha küçük ana bellekli
bilgisayarlara göre daha hızlı çalıştırırılar.
• RAM rastgele erişimli bellek için kullanılan bir
kısaltmadır. Rasgele erişim, hafıza uzayındaki
herhangi bir yerdeki bilgiye aynı sürede erişilebilir
anlamındadır.
• Önbellek (Cache), RAM’den daha hızlı erişilebilir
geçici bir bellek türüdür.
104
Bilgisayar iki seviyeli ön belleğe sahiptir. Level 1 (L1) cache(önbellek) daha küçük
kapasitelidir ve işlemcinin içerisinde inşa edilmiştir. Level2 (L2) cache ise kapasite
olarak daha büyüktür,işlemci ile ana hafıza (RAM) arasındadır.
Sistem 256 MB’lık DDR (Double Data Rate)
SDRAM – (Synchronous Dynamic RAM)’e sahiptir.
CIS 273: Lecture 1 105
RAM (Random Access Memory- Rasgele Erişimli Bellek)
• Bilgisayarda verilerin geçici olarak depolandığı hafıza birimidir. CPU'nun
ihtiyaç duyduğu kodları sakladığı için hızlı ve kapasitesinin çok olması
performansa doğrudan etki edecektir. Rasgele erişimli olması sayesinde
belleğin sıra gözetmeksizin istenen adresindeki veriler okunup yazılabilir.
• Disk, CDROM ve I/O portlarından gelen ve giden veriler geçici olarak RAM
üzerinde işlenmek üzere tutulur. RAMler üzerindeki bilgiyi tutabilmeleri
için elektrik enerjisine ihtiyaç duyarlar. Elektrik enerjisi kesildiğinde
üzerlerindeki verilerde kaybolur.
• RAM, her bir hücresi bir transistor ve kapasitordan oluşan 2 boyutlu(satır
ve sütunlardan oluşan) matris yapıya sahiptir. Hücreler şarj edilirken hücre
hücre değil, satır satır edilir. Verileri tazeleme oranı(refresh rate) satır
bazında değerlendirilir. Örneğin 2K tazeleme oranına sahip bir bellekte
2048 adet satır tazeleniyor demektir.
• Günümüzde DDR SDRAM(double-data-rate synchronous dynamic
random access memory), DDR2 SDRAM, DDR3 SDRAM ve SDRAM yapıda
hafıza ürünleri kullanılmaktadır.
• Daha ucuz ve küçük boyutta olduğundan bilgisayar ana belleğinde DRAM
kullanımı tercih edilirken SRAM hızından dolayı öncelikle cache bellek için
kullanılır. 106
• SDRAM(Synchronous Dynamic RAM): 64 bit veri genişliğine sahiptir.
Günümüz bellek yapılarından en az band genişliğine sahiptir. DDR çeşit
RAM' lerin temelini oluşturur ve onlardan en az iki kat yavaş çalışır.
Dinamik bellek yapısındadır. 168 pine sahiptir.
DDR SDRAM: 64 bit veri genişliğine sahiptir. Veri transferi için, saat(clock)
işaretinin alçalan ve yükselen kenarlarını kullanan yapıya sahip, SDRAM
çeşididir. Dolayısıyla SDRAM' e göre iki kat hızlıdır. 184pin yapıdadır.
• DDR2 SDRAM: 64 bit veri genişliğine sahiptir. DDR SDRAM ile aynı yapıda olup aynı
saat hızında çalışırlar. Aralarındaki fark latency(istenen adrese ulaşmak için
harcanan zaman) değerinin DDR da daha büyük olması ve daha fazla güç
gereksinimidir. Ayrıca burada belleğin, I/O bus frekansı DDR'a göre iki katı hızda
çalışmaktadır. 240 pin yapıya sahiptir.
• DDR3 SDRAM: 64 bit veri genişliğine sahiptir. DDR yapıya sahiptir. Fakat en az güç
gereksinimine sahiptir. DDR2 ye göre dahili geçici hafıza miktarı büyüktür. DDR3'
ün, I/O bus frekansı DDR2'ye göre iki katı hızda çalışmaktadır. 240 pin yapıya
sahiptir.
107
RAM Parametreleri
• Kapasite: Bir RAM’ın kapasitesi diye, xbaytlık kaç tane farklı adresşeme olduğudur.
Hız: Bir işlemci RAM üzerindeki veriye ihtiyaç duyduğunda hafıza kontrol
devresine(MCH=Memory Control Hub) istekte bulunur. MCH bu isteği RAM'e aktarır ve
MCH veri okunmaya hazır olduğunda bunu CPU'ya rapor eder. RAM'in aldığı bi talebe
karşılık vermesi için geçen süreye Access Time (Erişim zamanı) denir. Hafıza modülleri 80-
50ns arasında değişen Access Time sürelerine sahiptir. Sürenin kısa olması modülün hızını
gösterir.
108
6. ÖNBELLEK (Cach)
• Bilgisayar hızını belirleyen en önemli faktörlerden biri dir.
• SRAMlerden oluşmuş bellek topluluğudur.
• Çalışma şekli; işlenecek olan bilgi alınmak istendiğinde ilk defa buraya
uğranır.
• Kullanım amacı; işlenecek olan bilgi işlemeden önce buraya getirilerek
bilgilerin işlenmeye hazır hale getirilmesidir.
• Genellikte işlemcilerde kullanılır ve işlemcinin hızını belirleyen en önemli
faktörlerden birisidir.
• Normalde işlenecek bilgilerin hepsi bilgisayarın ANA BELLEĞİN (RAM) ’de
bulunur.
• İşlemci verileri işlemek için yol sistemleri ile ANA BELLEĞE gider, oradan
işleyeceği bilgiyi alır ve işler. ANA BELLEĞİN ve yolların hızı işlemcinin
hızına yetişemez. İşlemcinin her veri işleme ihtiyacında ANA BELLEĞE
gitmesi zaman kaybına yol açar ve işlemci yeteri kadar verimli kullanılmaz.
İşte bu yavaşlığı önlemek için önbellekler kullanılır.
110
1.3 An Example System
Bu 80GB’lık veriyi saklayabilir.. 7200 RPM, diskin
dönüş hızıdır. Genelde,disk dönüş hızı, daha hızlı
işlemdir. Bu her zaman doğru değildir..
Sabit disk kapasitesi,
saklayabileceğiniz veri ve
programlarınızın boyutunu
belirler.
Sabit diskler (Harddiskler)
• Sabit diskler, üzerlerine kalıcı olarak bilgi depolanabilen ve depo edilmiş
verilerin okunabildiği manyetik ortamlardır. Sabit disklerin bilgi depolama
kapasitesi disketlerden çok yüksektir, Günümüzde 80 -120 , 256 512 GB, 1-
2 TB.lık sabit diskler yaygın olarak kullanılmaktadır.
• Sabit disklerde bilgi kaydedilen bölüm (disk plakaları-bunların üsüste
gelmesiyle silindir oluşur), mıknatıslanmayan metal bir yüzey (alüminyum)
üzerine kaplanmış demir grubu (demir, nikel, kobalt vb.) oksitlerden oluşan
bir tabakadır.
• Her bir disk için iki adet okuma/yazma kafası(head) vardır (Her iki yüz için)
111
• Sabit disk üretildikten sonra biçimlenmeden (formatlanmadan)
kullanılamaz. Biçimleme işlemi yapılınca disk yüzeyinde iç içe daireler
şeklinde izler (track) oluşturulur. Bunlar gerçekte disk üzerine çizilmiş izler
olmayıp bilgilerin adresleme biçimidir. Disk üzerin oluşturulan izler
bilgilerin kolayca bulunmasını sağlamak için sektör (dilim) lere bölünür.
• Kümeler(Cluster) ise İşletim sisteminin disk yönetimi ile alakalıdır. Dosya
ve dizinlerin yerleştirildiği en küçük disk alanına denir. Boyutu dosya
sistemine göre değişir.
112
Disk Parametreleri
• Disk Dönüş Hızı(RPM=Rotate Per Minute): Diskin dakikadaki dönüş hızını
gösteren bir parametredir. Günümüzde 15.000, 10.000, 7200, 5400rpm
değerlere sahip diskler bulunmaktadır.
Tampon Bellek(Cache veya Buffer): Disk erişimi bellek erişiminden daha
yavaş olduğu için disk performansını artırmak için HDD üzerine bellek
hafıza birimleri yerleştirilmiştir. Amaç erişilmesi öngörülen verileri bellekte
hazır bekletmektir. Eğer istenen veri bellekte varsa disk erişimi olmadan
veriler doğrudan bellek üzerinden gönderilir.
Konumlanma Süresi(Seek Time): Disk üzerinde okuma yazma kafasının,
istenen adrese yazma veya okuma amaçlı ulaşmak için harcadığı süredir.
Kafanın disk üzerindeki konumuna göre bu süre kısalıp uzayabilir. Bunun
için ortalama konumlanma süresinden(average seek time) bahsedilir. Kısa
olması diskin okuma ve yazma performansının daha iyi olduğunu gösterir.
HDDLerde erişim süresi ms’ler mertebesindedir.
Kapasite: Depolayacağı veri miktarını gösterir. Günümüzde 750 GB, 1TB ve
hatta 4TB kapasiteli diskler bulunmaktadır.
113
1/30/07 CIS 273: Lecture 1 114
• Spin Up: işletme hızına diski hızlandırma zamanı.
• Seek Time: İstenen Track’ı bulma zamanı
• Rotational Time: istenen sektörü bulma zamanı
• Transfer Time: Veri okuma veya yazma zamanı.
• Bir sabit diskin kapasitesi şu şekilde hesaplanır.
• Silindir sayısı*Sektör Sayısı*kafa sayısı*512’dir. 1024 silindir, 256 kafa ve 63
sektör parametrelerine sahip bir sabit diskin kapasitesi:
1024*256*63*512=845571864 Byte’dır. Bu da yaklaşık 8.4 Gigabyte’dır.
115
1.3 An Example System IDE(integrated Drive Electronics), işlemciyle Hard
disk arasında veri akışının kontrolunu sağlayan
eski bir standarttır. SATA (Serial Advanced
Technology Attachment) ise IDE’nin yerini alan bir
hafıza arayüz standartıdır.
A CD yaklaşık 650MB datayı hafızalar. Bu
sürücü yazılabilir CDs, CD-RW’leri
destekleyebilir. 48x sürücünün hızını açıklar. X
her bir saniyede153,000 byte’lık data demektir.
116
1.3 An Example System
Bu sistem 10 tane
porta sahiptir.
Port’lar bir sistem ve onun
çevresel birimleri arasında
verinin alınıp verilmesini
sağlar.
117
• Serial port 1.3 An Example System lar ile, veriyi oluşturan bitleri 1,0 sinyal
katarı ardarda (herbir clok süresince tek bit)
olarak iki nokta arasında tek bir iletişim ortamı ile
gönderebilirsiniz.
• Parallel portlar ile bir baytlık(veya daha fazla)
bilgiyi tekbir zaman diliminde karşı tarafa
gönderebilirsiniz. Bit sayısı kadar iletişim yolu
olmalıdır.
• USB (Universal Serial Bus) : Kendisini konfigüre
edebilen akıllı bir seri arayüzdür. Tak-Çalıştır’ı
destekler.
118
1.3 An Example System
Sistem BUS’ları, I/O BUS’ları
olarak düzenlenebilir. PCI,
(Peripheral Component İnterface),
bunlardan biridir.
Bu sistem 3 adet PCI BUS’a sahiptir.
Devices: Bir video kart, Bir ses kartı, ve
bir adet data/fax modem.
119
Bir monitorde, bir görüntünün saniyede kaç kez 1.3 An Example System
tekrar oluşturulma sayısı onun yenileme oranını
(refresh rate) ifade eder. Bir monitorun piksel
(nokta) aralığı, görüntünün netliği ile orantılıdır.
Bu monitörün piksel(dot) aralığı .24mm’dir. Görüntü
yenileme oranı 75Hz’dir.
Video Kartı 128Mb hafıza bulundurur.
Monitör
• Katot Işınlı Tüp (CRT, Cathode Ray Tube)
denilen bu tüp, havası boşaltılmış
mühürlenmiş bir cam konidir.
• Koninin geniş tarafı düz ve dikdörtgen
biçimindedir. Bu, monitörün ekranını
oluşturan taraftır. Koninin öbür tarafı dardır
ve katot levhaları ile küçük tel ızgaraları
içerir. Bu katot levhaları ısıtıldığında tüpün
içinde serbestçe dolaşan elektron bulutları
oluştururlar.
• Katot negatif olarak yüklenirken,dış kısmına
pozitif bir yüksek gerilim (26000V)
uygulanarak katot ışınlı tüpün anodu veya
pozitif kutbu oluşturulur. Anot ve katot
arasındaki büyük gerilim farkı, bu serbest
elektronların ekrana doğru fırlatılmalarına
neden olur.
1
/30
/07 CIS 273: Lecture
1 120
• Çözünürlük (Resolation): Çözünürlük, ekran kartının gönderdiği görüntüyü dikey ve
yatay olarak ifade ederken kullandığı piksel sayısıdır.
• Boyut: Ekranın fiziksel uzunluğunu ekranın boyutları belirler. 14 inc`lik bir
monitörün genişliği yaklaşık olarak 11 inc`tir (28 cm).
• Tazeleme Oranı (Refresh Rate):Elektron tabancası, CRT`nin noktacıklarını üst
sıradan başlayarak en alt sıraya kadar tarar. Bundan sonra elektron tabancası, grafik
kartından kendisine gelen diğer ekran görüntüsünü CRT üzerinde oluşturmak üzere
tarama işlemine devam eder. Bir tam ekran tarandıktan sonra yeni bir görüntü
oluşturmak üzere tarama işleminin başlamasına ekranın tazelenmesi denir. Bu
tazeleme olayının saniyede kaç kez tekrarlandığı ise tazeleme hızıyla ölçülür.
Saniyede 60 Hz`lik tazeleme hızına sahip olan bir monitör, o sırada saniyede 60
ekran taramaktadır.
• Bir monitörün satır sayısı ile düşey tarama frekansının çarpımı yatay
tarama frekansını verir. Bu, elektron demetinin, ekranın solundan sağına
saniyede kaç defa gidileceğini gösterir. Buna göre 480 satır
çözünürlüğünde ve 70 Hz düşey tarama frekansına sahip monitörün;
480*70 veya 33600 Hz (33.6 KHz)`dir. Bu durumda elektron demeti
saniyede 33600 satırı tarayacaktır.
1/30/07 CIS 273: Lecture 1 121
• Bir monitörün satır sayısı ile düşey tarama frekansının çarpımı yatay tarama
frekansını verir. Bu, elektron demetinin, ekranın solundan sağına saniyede kaç defa
gidileceğini gösterir. Buna göre 480 satır çözünürlüğünde ve 70 Hz düşey tarama
frekansına sahip monitörün; 480*70 veya 33600 Hz (33.6 KHz)`dir. Bu durumda
elektron demeti saniyede 33600 satırı tarayacaktır.
• Nokta Aralığı (Dot Pitch):Aynı renkteki iki nokta (dot)`nın, merkezleri arasındaki
uzaklık nokta aralığı (dot pitch) olarak adlandırılır. Nokta aralığının bugünkü
değerleri 0.25 mm ve 0.28 mm arasında değişir. “Nokta aralığı ne kadar küçük
olursa, daha net görüntü anlamına gelir.”
1/30/07 CIS 273: Lecture 1 122
LCD Liquid Crystal Display
• LCD monitörlerde görüntü sıvı kristal diyotlar yardımıyla sağlanmaktadır. Bu
diyotlara gerilim uygulandığında, içlerindeki moleküllerin polarizasyonu
değişmekte ve beraberinde de diyodun geçirgenliği değişmektedir.
• Normalde şeffaf olan bu diyotlara gerilim uygulandığında geçirgenliklerini
kaybederler ve siyaha dönerler. Renkli LCD monitörlerde ise çok ufak ve birden
fazla diyot kamanı kullanılarak görüntü alınmaktadır.
• LCD monitörler DSTN ve TFT olmak üzere ikiye ayrılmaktadır. Ucuz olan ve “passive
matrix” teknolojisini kullanan DSTN (Dual-Scan Twisted Nematic)’ler çözünürlükleri
ve görüş açıları TFT’lerden düşük olan monitörlerdir. Bu monitörler genelde dizüstü
bilgisayarlarda kullanılmaktadır.
• TFT (Thin Film Transistor)’ler ise “active matrix” adı verilen ve görüntüyü daha
parlak ve keskin gösteren bir teknoloji kullanırlar. TFT’lerde her piksel bir ya da dört
transistör tarafından kontrol edilir ve bu sayede flat panel ekranlar arasında en iyi
çözünürlüğü sunarlar.
1/30/07 CIS 273: Lecture 1 123
Peki bu bileşenleri üreticiler kendi
standartlarına göre üretebilirler mi?
124
-Bilgisayar bileşenlerinin, beklediğimiz gibi çalışacağının bir güvencesi varmı?
-Bilgisayar bileşenlerinin birlikte çalışacağının ne güvencesi var?
Bu belirsizliği ortadan kaldırmak ve Bilgisayar bileşenlerinin birlikte
çalışabilirliğini sağlamak için - bilgisayar donanım standartlarını belirleyen
birkaç önemli organizasyon vardır.
-The Institute of Electrical and Electronic Engineers (IEEE)
-The International Telecommunications Union (ITU)
-The American National Standards Institute (ANSI)
-The British Standards Institution (BSI)
-The International Organization for Standardization (ISO)
125
Bu bileşenlerin nasıl çalıştığını ve bunların biribirleriyle nasıl
etkileştiği ve etkileşim yazılımı ile komple bilgisayar sistemlerinin nasıl
kontrol edilebileceği, organize edilebileceği bundan sonraki
konularımızda zaman zaman açıklanacaktır.
2.Bölüm
Komutlar: Bilgisayar dili
Instructions: Language of Computers
“Ben, Tanrıyla İspanyolca, kadınlarla İtalyanca, erkeklerle
Fransızca, karımla Almanca konuşurum.”
V.Charles – Fransa Kralı 1337-1380
“Geç bunları kralım; ben tek dil konuşurum anlayan geçer. Anlamayan seneye gelir”
D.A.B.D.Başkanı Hayrettin CAN – 2011
2
Bilgisayar Sistemi
• Bir bilgisayarın işlemcisi büyük bir lojik devredir.
Processor
Control
Datapath
Output
Input
Memory
1001010010110000
0010100101010001
1111011101100110
1001010010110000
1001010010110000
1001010010110000
3
İşlemci işlemi nasıl yapar?
• The “fetch/execute- (Alma(getirme) / yürütme)” süreci
– İşlemci komutu, hafızadan getirir (fetches).
– İşlemci komutu “makine dilinde “ yürütür (executes).
Processor
Control
Datapath
1001010010110000
0010100101010001
1111011101100110
1001010010110000
1001010010110000
1001010010110000
Memory
1001010010110000
Yeni
komut Komutun yüklenmesi ve çözülmesi
Operand’ın işlenmesi
Sonuçların kaydedilmesi
Address
Instruction
İşlenenin (Operand) getirilmesi
İşlemin yapılması -II
0000 1001 1100 0110 1010 1111 0101 1000
1010 1111 0101 1000 0000 1001 1100 0110
1100 0110 1010 1111 0101 1000 0000 1001
0101 1000 0000 1001 1100 0110 1010 1111
...
Memory
program & data
I / O
Datapath
Control
Fetch – Decode – Execute Cycle
Tamamda,
Makinanın anlayacağı dildeki komutlarla
ben nasıl program yazabilirim ki hocam?
Bilgisayar sistemlerinde Soyutlama (biribirinden ayırma)
Abstractions in Computer Systems
• Yüksek seviyeli bir dilde kodlanmış komutları
makinanın işlemesi ve tekrar geri döndürmesi
süreci oldukça karmaşık bir süreçtir.
• Tasarımcılar; karmaşıklığı yönetmek için
soyutlama (ayrıştırma) tekniğini kullanırlar.
– Sadece ilgili bilgilere odaklanılır.
– Gereksiz ayrıntılara hiç bakılmaz.
6
Makine dili : Bilgisayar sistemiyle haberleşebilmek için , komutların binary formda oluşturulmuş şeklidir.
00000000001000100100000000100000
Yüksek Seviyeli dil (C) c = a + b;
Assembler dili : Bir sembolik
komut kodunu binary forma çeviren bir
programdır. ( Binary koddaki komutların
sembolik gösterimini yapan dil)
add R8,R1,R2
Assembler
Compiler
Yazılımsal Ayrıştırma - Diller
Compiler: Yüksek seviyeli dilde
yazılmış programı assemler sembolik dil
komutlarına çevirir. Yüksek seviyeli
dildeki birkaç satırlık program assemler
dilinde çok daha fazla sayıda komut içerir.
7
Yazılımsal ayrıştırma - Sistem Yazılımı
• İşletim Sistemi
– Alt-seviye detayları programcıdan izole eder.
• Sistem kaynaklarını yönetir.
• Dosya sistemlerini yönetir.
– Birden fazla programın işletilmesini koordine eder.
– Kullanıcı programlarının sisteme zarar vermesini önler.
• Kütüphaneler
– Üst düzey primitiv programlara , programcının erişimini sağlar.
– İyi tanımlanmış arayüzler ile programlara erişim sağlanır( API).
• Uygulamalar: kullanıcı için özel fonksiyonları başarmak içindir.
– Web Browser
– Tablo
– Word Processor
8
Komut Seti Mimarisi - Instruction Set Architecture (ISA)
(Donanım-Yazılım Arayüzü - The Hardware-Software Interface)
• Bilgisayarın en önemli ayrışımıdır
Logic - gates, state machines, etc.
Circuit - transistors, etc.
Layout - mask patterns, etc.
Hardware
Processor I/O System
Software
Compiler
Application Programs
Operating System
Application
Komut Seti Mimarisi (ISA)
SW & HW arasında bir arayüzdür.
2.1. Giriş
• Bir bilgisayarı, donanımsal (hardware) olarak yorumlamak için
onun dilini bilmelisiniz. Bir bilgisayar dilinin kelimelerine komut
(instruction) denir. Ve genellikle bu kelimelerin bütününe komut
seti diyeceğiz. Bu komutlar;
- Kullanıcı tarafında: assembler dili
- Bilgisayar tarafında : Makine dili
• Bir komut setinin öğrenilmesi demek;
-Yüksek seviyeli programlama dilleri (C dili) ile ilişkisi nedir?
-Yüksek seviyeli dille yazılmış komutu makine nasıl anlar?
-Donanımsal olarak komutun gereği nasıl yapılır?
• Örneklerimizde yüksek seviyeli dil olarak C programlama dilini
kullanacağız.
Komut seti mimarisi (ISA) SW/HW arayüzü
olarak tanımlanabilir.
• 1980’lerden beri popular olarak kullanılan MIPS
(Mıllıon Instructıon of per Second) komut seti
mimarisini (Instruction Set Architecture – ISA)
kullanacağız.
• MIPS komutlarını zamana yayarak adım adım
öğreneceğiz.
• Komutların ve farklı tipten verilerin, hafıza
biriminde sayı değerleri olarak saklandığını
varsayan “Stored program consept” konseptini
kullanacağız.
Stored program consept(Hafızalanmış Program Konsepti )
Günümüz bilgisayarları 2 önemli özelliği gözeterek inşa edilirler.
1-Komutlar, sayı sembolleri ile gösterilir.
2- Programlar ana hafızada kaydedilir. Ordan sayı
sembolleri olarak okunur veya yazılır. Bu prensipler “storedprogram” konseptidir.
Özel olarak; Hafıza, makine kodu oluşturan bir editör
programının kaynak kodlarını ihtiva eder. Bu editör programı ,
ilgili yüksek seviye dilde yazılmış kodların makine kodu karşılığını
text olarak oluşturur. Hatta bu editörde derlenmiş makine kodları
doğrudan kullanılabilir.
ISA’nın temel prensipleri
• Komut seti mimarisinde (ISA) önemli dizayn prensipleri her
zaman ön plandadır. Bunlara uyulunca donanımsal mimari
optimize bir şekilde oluşur.
1-Basitlik düzenlilikten yanadır. (simplicity favors regularity):
Komutların belirli bir düzene göre işlenmesi Çözümü
basitleştirir. Donanımın basitleşmesi için komutların tipini ve biçimini
basitleştirtmek için kullanırız.
2- En küçük en hızlıdır (smaller is faster): İşlemciler sadece basit
ilkellerin (primitive) uygulanmasını gözetmeli. Yani basit
birimlerden oluşmalı. Register sayısı, ALU işlemlerinin sayısı, v.b donanım
birimlerini doğru boyutta seçerken önemlidir.
3- Make the common case fast : Çok kullanılanları hızlı yapın.
4: Good design demands good compromises : İyi tasarım , iyi
tavizler (uzlaşmalar) verilerek oluşur.
2.2 Bilgisayar donanımının İşlemesi
MIPS Komut Seti
• Herbir bilgisayar muhakkak olarak aritmetik işlemleri gerçekleştirebilmelidir.
C kodu: a = b + c ;
• Assembler kodu: ( İnsanın anlayacağı makine komutları formu)
• add a, b, c # b ve c’yi toplayıp a operand’ına koyar.
• Makine kodu: (Donanımın anlayacağı makine komut formu)
• 00000010001100100100000000100000
• MIPS’te her komut 3 operand’a (işlenen değer) sahiptir. Ve bir birim
zamanda sadece 1 işlem başarılır.
• Operandların sırası sabittir . (İlk operand hedef operand’dır.)
• a, b, c aslında birer register (Kayıtçı)’dır. Registerlerin bit olarak kayıt
kapasitesi, işlenenlere yazılacak değerler için çok önemlidir.
• Aşağıdaki C kodunu assembler koduna çevirelim.
a = b + c + d + e
• Bu işlem 2’den fazla sayının toplanması işlemidir. MIPS’te
aritmetik komutlar 3 operand’la işlendiğinden (En basit işleme
şekli budur. ) bu toplama işlemi ard arda toplamalar ile
gerçekleşir.
• MIPS kodu : add a, b, c # a=b+c
add a, a, d # a=b+c+d
add a, a, e # a=b+c+d+e
• #-- yorum sembolüdür. Satır sonuna kadar etkilidir.
• Bir aritmetik işlem için, operand sayısı üçtür. Olması gereken
budur ve daha az, daha fazla olmaması, “donanımın basitliği”
felsefesine uyar.
Örnek:
Aşağıdaki 2 program parçası için C Compiler’ın
çıkışı ne olur. (t geçici operand’ı ifade eder)
• C deyimi > C Compiler > MIPS instructions
a = b + c;
d = a –e;
f = (g + h) – (i + j);
2.3 Donanımın İşlenenleri( Operands)
• Yüksek seviyeli programlama dillerinden farklı olarak MIPS’de
herbir satır sadece bir komutun icra edilmesi içindir. Yani n+1 adet
toplama için n tane komut icra edilmelidir (Simplicity favors regularitiy).
• Aritmetik komutlarda, İşlenenler (Operand) kaydedilmelidir.
Bunun için MIPS’e yalnızca 32 register’in sağlanması yeterlidir.
(Buna karşılık intel İşlemcilerde komutların hafızadaki verilerle
direkt çalışılmasına izin verilir.)
• Register’lar ALU’ya en yakın küçük kapasiteli hafızalardır.
İşlemcinin içindedirler.
• MIPS’te herbir register 32 bitliktir. Ve 32 register vardır.
Bu MIPS-32’dir. ( smaller is faster- 32 register’lı yapı 33 registerLI
yapıdan daha hızlıdır.)
• MIPS-64 ise 32 adet 64-bit register anlamındadır.
17
REGİSTER’ler Neye Var?
• C programlamada, her bir operand (değişken) ana hafızada
tutulur.
• Donanımsal olarak, her seferinde ana hafızaya erişim zaman
açısından pahalıdır.
•Eğer bir a operandına tekrar tekrar erişilecekse, bunu işlemci
içerisindeki bir registere bir sefer getirip üzerinde işlem yapmak
daha hızlı olur.
• Komutların icrasının kolaylaşması için, her bir komutu (add,
sub v.b) yalnızca bir register’da işletmemiz gerekir.
• Not: C’de işlenenlerin sayısı çok fazla olabilir. Ancak
assemler’da registerlerin sayısı sabittir. Fakat çok fazla
değişken, geçici registerler ile işlenebilir.
MIPS’te Register isimleri için kural
• 32 adet registerleri numaralarını kodlayarak
komutlarda belirginleştirebiliriz.
• $s0, $s1, $s2, …Yüksek seviyeli programlama
dillerindeki operand registerlerine karşılık gelir.
• $t0, $t1, $t2, … Yüksek-seviye dil kodlarını
MIPS’te kodlarken kullanılan geçici
değişkenler (temporary variables ) için
kullanılan registerlere karşılık gelir.
Register Standart İsimleri (MIPS-32)
Name Register Number Usage Preserved on call
(Çağrılarda içeriğinkorunması)
$zero 0 the constant value 0 n.a.
$at 1 reserved for the assembler n.a.
$v0-$v1 2-3 value for results and expressions no
$a0-$a3 4-7 arguments (procedures/functions) yes
$t0-$t7 8-15 temporaries no
$s0-$s7 16-23 saved yes
$t8-$t9 24-25 more temporaries no
$k0-$k1 26-27 reserved for the operating system n.a.
$gp 28 global pointer yes
$sp 29 stack pointer yes
$fp 30 frame pointer yes
$ra 31 return address yes
Örnek:
f = (g + h) – (i + j)
Örneğindeki f, g, h, i, j değişkenleri $s0, $s1,$s2,$s3,$s4
registerlerine atanmış olsun. Bu işlemin MIPS kodu
karşılığı nedir?
Cevap:
Hafıza İşlenenleri(Operands)
• Şimdiye kadarki örneklerde birkaç değişken üzerinde işlem yapıyorduk. Bu durumda da
registerlerde problem çıkmıyordu.
• Fakat öyle işlemler vardır ki çok sayıda verinin kullanılması
gerekir. Yani karmaşık ve kapasiteli bir veri bloğuyla
çalışılması sözkonudur. Bu durumda işlenen sayısı register
sayısından çok çok fazla olabilir.
• Bu durumda milyonlarca tane veriden oluşan veri
yapılarını ana hafızalar üzerlerinde bulundururlar.
• Ana hafıza; yüksek seviye-programlama dili
komutlarının,verilerin ve sonuçların saklandığı yerdir.
• Registerler ise, MIPS komutlarının çalıştırdığı aritmetiksel
işlemlerin yapıldığı dataları bulundurur.
• Ana hafızadaki veriler, registerlare MIPS’ın
içerdiği transfer komutlarıyla çağrılır. Bu
komutlara “veri transfer komutları (lw, sw)
denir.
• Hafızadaki bir veri kelimesine ulaşabilmek
için; komut, ulaşılacak verinin hafıza adresini
beslemelidir. Çünkü hafıza tek boyutlu çok
büyük bir dizi şeklinde, adreslenmiş bir yapıdır.
• Bir hafıza adresi, dizi içerisinde bir indextir
(0,1,2…).
• “Adreslenmiş byte" anlamında, index
hafızadaki 1 baytlık yeri işaret eder.
Ana hafızadaki bir operand’ın atanmasının derlenmesi- Örnek
(Compiling an assignment when an operand is in memory)
• Ana hafıza dizi şeklindeki operandlar’ı (İşlenenler - veri) registerler
ile ilişkilendirmek için , derleyici bellekte bir yer ayırır. Ve data
transfer komutu için bir başlangıç adresini de belirler.
• A , 100 baytlık bir dizi olsun. g için $s1 registeri, h için $s2 registeri ,
adres bloğunun başlangıç adresi için için $s3 (başlangıç registeri)
kullanılsın (Veriler 1 bayt’lık olsun).
g = h + A[8]; işlemi için
lw $t0, 8($s3) # temporary register $to’a A[8]’in get,rilmesi.
add $s1, $s2, $t0
Başlangıç registeri (Base register): Dizinin başlangıç adresi
offset: Data transferi için sabit(8).
**** Çoğu veri ögeleri 1 baytlık olabildiği gibi, 4 baytlık(32 bitlik)
64 baytLık veri ögesi uzunlukları da söz konusudur. 32bitlik veri
elemanlarının transfer edilmesi ise aşağıdaki gibidir.
•Bir önceki problemi 32bitlik kelime uzunluğu için kodlayalım.
• Çoğu veri ögeleri 1 bayttan dah uzun kelimeler kullanır.
• MIPS’te registerler 32bit (4 bayt ) veri tutarlar.
0.kelimenin byte adresi 0’dan başlar
1.kelimenin byte adresi 4
2.kelimenin byte adrei 8…
lw $t0, 32($s3) #8x4=32
add $s1, $s2, $t0
load ve Store (lw ve sw) kullanımının derlenmesi
(Compiling Using Load and store)- örnek
C kodu: A[12] = h + A[8];
Bu işlem C kodunda tek bir işlem olmasına rağmen ana hafızada 2 tane işlenen ( değişken)
vardır. Dolayısıyla 1’den fazla MIPS komutuna ihtiyaç vardır.
MIPS kodu :
lw $t0, 32($s3) #32 = 8x4
add $t0, $s2, $t0
sw $t0, 48($s3) # toplama sonucu nu ana hafızaya kaydet (store word) .
• Derleyicinin atamaları:
–$s3’ü başlangıç adresi için (A dizisinin başlangıç adresi)
–$s2’ yi h değişkeni için.
• Hatırla!.Aritmetik işlemler registerlardaki verilerle yapılır. Hafızadakilerle değil.
Bu komut çalışmaz : add 48($s3), $s2, 32($s3) niye?
Sabit veya doğrudan işlenenler (değişkenler)
(Constant or Immediate Operands)
• Çoğu zaman programlar, İşlemlerin bir çoğunda sabit değerler kullanır.
Dolayısıyla MIPS aritmetik komutlarının yarıdan fazlası sabitlerle yapılan
işlemlerdir.
• Açıklama Notu: Bu konuyla ilgili Donanım-Yazılım etkileşimi
 Birçok programlarda çok sayıdaki değişken sayısı, bilgisayarın sahip olduğu
sınırlı sayıdaki registerlardan fazladır. Dolayısıyla derleyici; en sık kullanılan
değişkenleri registerlar’da tutmaya çalışır. Register’ler ve hafıza arasında yer
değiştiren (Load ve store komutları ile) değişkenleri ise hafızanın belirli bir
kısmına yerleştirir. Daha az kullanılan değişkenlerin konulduğu hafızanın belirli
bölgesine “ Sıçrama registerleri- spilling registers “ denir.
 Donanım prensibinden dolayı, hız ve kapasite ters orantılıdır. Dolayısıyla ana
hafızanın hızı registerlere göre yavaştır.
 Registerdaki veri daha kullanışlı, faydalı bir veridir. MIPS aritmetik komutları iki
registeri okuyabilir, onlarla işlem yapabilir, onlara yazabilir. MIPS’in data transfer
komutları ise sadece bir işleneni (operand) okuyabilir veya yazabilir . Onlarla
işlem yapamaz.
 Performanslı bir derleyici, registerleri etkili olark kullanan derleyicidir.
• Biz şu ana kadar sadece komutları kullanmayı gördük. Bu
komutları kullanmak için, ana hafızadan bir sabit yüklenmelidir.
( Sabitler, program yüklenirken ana hafızaya yüklenirler).
• Örneğin ; C dilinde , AddrConstant4 ( programın başlangıcında $s1 ile ilişkili
hafıza yerinde olduğunu varsayalım) adresindeki 4 sabitini , $s3 registerine
ekleyelim:
lw $t0, AddrConstant4($s1) # $t0 = constant 4
add $s3, $s3, $t0 # $s3 = $s3+ $t0
Veya;
addi $s3, $s3, 4 # $s3 = $s3+ 4
addi “immediate instruction - Doğrudan işlenen komut” olarak adlandırılır. Bu
komut sabitlerle çalışmaya müsaade eder. Bu komutlar donanımsal 3.dizayn
prensibini gösterir.
•Dizayn prensibi 3: “Make the common case fast”
Özet
MIPS
— Adreslenmiş baytları loading/storing yapar.
— Sadece registerlerda aritmetik işlemler yapar.
Komutlar Anlamı
add $s1, $s2, $s3 $s1 = $s2 + $s3
addi $s1, $s2, 100 $s1 = $s2 + 100
sub $s1, $s2, $s3 $s1 = $s2 –$s3
lw $s1, 100($s2) $s1 = Memory[$s2+100]
sw $s1, 100($s2) Memory[$s2+100] = $s1
29
HAFIZA Adresleri (3.hafta ders başlangıcı)
• Compiler datayı(veriyi) hafızada organize eder. …
• O her operand’ın lokasyonunu (nereye kaydedildiğini) bilir.
• Compiler, load/store komutlarının gereği için hafızanın
adresi belli bölgelerini ayırıp kullanır (spilling registers ).
Memory
…
Base address (Başlangıç adresi =1000)
int a, b, c, d[10]
30
Immediate Operands - Örnek
• Bir komut sabit bir giriş değerine ihtiyaç duyar.
• Bir immediate komut,girişlerden birini sabit bir değer olarak kullanır (Bir register
operand’ı yerine).
addi $s0, $zero, 1000 # programın başlangıç adresinin 1000 olduğu, bunun $s0
# ‘a kayıt edilmesini, $zero ise devamlı 0’a eşit olan bir
# register olduğunun belirtilmesi.
addi $s1, $s0, 0 # Bu a operand’ının adresidir.
addi $s2, $s0, 4 # Bu b operand’ının adresidir.
addi $s3, $s0, 8 # Bu c operand’ının adresidir.
addi $s4, $s0, 12 # Bu dizi operandı d[0] ın adresidir.
31
Memory Instruction Format
(Hafızadan transfer komutunun formatı)
• Hafızadan reg’e transfer komutunun formatı;
destination register (Hedef registeri)
source address (kaynak adresi)
lw $t0, 8($t3)
any register
a constant that is added to the register in brackets
(Parantez içindeki registerin içeriğine eklenen sabit değer)
32
Örnek
Aşağıdaki C kodunu Assemler koduna dönüştür. Bir önceki hafıza
yapısını ve register transferlerini kullan.
C kodu: d[3] = d[2] + a;
Çözüm.
addi $s0, $zero,1000
addi $s1, $s0, 0 # Bu a değişkeninin adresidir.
addi $s2, $s0, 4 # Bu b değişkeninin adresidir.
addi $s3, $s0, 8 # Bu c değişkeninin adresidir.
addi $s4, $s0, 12 # Bu d[0] değişkeninin adresidir.
lw $t0, 8($s4) # d[2] , nin içeriği $t0 registerine getirilir.
lw $t1, 0($s1) # a’nın içeriği $t1 registerine getirilir.
add $t0, $t0, $t1 # Toplam $t0’nin içindedir.
sw $t0, 12($s4) # $t0’In içeriği d[3] nolu hafızadaki adrese yazılır.
Özet tablo
Örnek:
a) Aşağıdaki işlemin sonucunu elde ediniz. Data hafızasının başlangıç
adresi 0’dır. A dizisinin başlangıç adresi 8’dir.
b) Bu işlemlerin yüksek seviyeli dil kodu nedir.
addi $s0, $zero,0
addi $s1, $s0,8
lw $s2, 0($s0)
lw $s3, 20($s1)
add $s4, $s2, $s3
sw $s4, 28($s1)
2.4 Komutların Bilgisayarda temsil edilmesi
(representing instructions the Computers)
• Bilgisayar sistemler binary sayı sisteminde çalışırlar. Bu sayı sisteminde 0
ve 1 olmak üzere 2 rakam vardır.
• Bu rakamların donanımsal olarak tanınması ve işlenmesi, sadece 2
durumda (düşük seviye = Lojik 0, ve yüksek seviye = lojik 1) bulunabilen
elektriksel gerilim seviyeleri ile olur.
• Sözcükler 1 ve 0’ların yanyana dizilmesiyle oluşur. Sözcüğü oluşturan her
rakama (0 veya 1) (binary digit) BİT denir.
• Komutlar ve sabitler ve değişkenler binary sözcükler şeklinde ifade edilir.
• MIPS assembler dilinde, $s0 dan $s7 ye kadar olan sembolleri 16 dan 23 ‘e
kadarki registerleri, $t0 dan $t7 arasındaki semboller 8 den 15’ e kadarki
registerleri haritalar ( MIPS-32 32 adet register’la işlem yapar). Burada $s0
16. registerdir. $t0 ise 8.registerdir.
• 32 tane registerin geri kalanları ise sonra açıklanacaktır.
Nostalji
MIPS assembler komutunun Makine komutuna dönüşümü
•Register gösterimi için niye 5 bitlik yer ayırıyoruz? Niçin
•Başarılabilecek fonksiyonların sayısı kaçtır? Neden
MIPS alanları
• Bir komut daha büyük bir alan ihtiyaç duyabilir. Örneğin lw komutu için , 2
tane registere ve bir tane sabite ihtiyaç vardır. Eğer sabiti ifade etmek için
5 bitlik adres alanı kullanılacaksa siz sabit bir değer olarak en fazla 32’yi
ifade edebilirsiniz. Ancak, bir diziden veya veri yapısından eleman seçmek
için kullanılan bu sabit değer çoğu zaman 32’den çok büyüktür. Bu
nedenle, tüm komutları aynı uzunlukta tutmak ve tek bir komut formatı
kullanmak oldukça zordur.. Bu durum bizi 4. donanım tasarım prensibine
götürür.
• Design principle 4: Good design demands good compromises.
(iyi tasarım , iyi tavizler (uzalaşmalar) verilerek oluşur)
MIPS tasarımcıları, komut uzunluklarının benzer olması için, farklı
gurublardaki komutlar için farklı komut formalraı oluşturmak yoluna
gitmişlerdir.
Örnek;
R-Format’lı komutlar (registerler için)
I-Format’lı komutlar ( sabitler veya veri transferi için)
J-Formatlı komutlar (Şartsız Dallanmalar için)
R-tipi, I-Tipi komut formatları
I- tipi komut formatında, 16 bitlik alanın anlamı, başlangıç adres registerine
2**15 = 32.768 tane bayt adresi veya sabit değerin yüklenebileceğidir.
I- tipi komut formatında; rt alanı hedef register olarak değerlendirilir. Yani
yüklemenin sonucunun yazıldığı registerdir.
UNUTMA !!!!!!!!
** I-tipi format immediate(doğrudan ) ve data transfer komutları içindir
** R-tipi formak Register komutları içindir.
** J-tipi format şartsız dallanma komutları içindir.
MIPS komutlarının kodlanması
•Dikkat !! subi komutu yoktur. Sadece addi komutu vardır. Sabit bir
negatif değer olabilir.
•Formatın opcode kısmı komut kümesini belirtir ( 0: toplama veya
çıkarma v.b aritmetik işlem komutlar, 35: lw komutu)
•Func kısmı ise komut gurubundaki özel işlem komutunu belirtir
(toplama:32 v.b)
MIPS assemblerden, makine dili koduna çevrimine örnek (S.65):
ÖĞRETİLENLERİN ÖZETİ
LOJİK İşlemler, operatörler, (2.5. Logical Operations)
• İlk bilgisayarlardaki komutlar veri sözcüklerini bir bütün olarak ele alırdı.
Ancak; kelime içindeki bit alanları ve hatta bireysel bitlerin üzerinde
çalışmasınında yararlı olduğu ortaya çıktı. Her biri 8 bit olarak saklanır bir
kelim içinde karakter incelenmesi böyle bir operasyona örnektir.
• Bu tip komutlar; paketler veya kelimeler şeklindeki verilerin içeriğini, bit
açma, değerlendirme için kullanılır.
• Bu komutlar mantıksal(Lojik) işlemleri olarak bilinir.
• Shift operations ( kaydırma İşlemi):
sll $t2, $s0, 4 # $t2 = $s0 << 4
• $s0 registerinin içeriğini 4 bit sola kaydır. (Sağdan 0
doldurarak), ve sonucu $t2 registerine yaz.
• $s0’ın içeriği; 00000000 00000000 00000000 00001001 = 9
Komut işlendikten sonraki değer.
• $t2’nin içeriği; 00000000 00000000 0000000 10010000 = 144
• 4 , “shift amount - shamt” olarak isimlendirilir ve R-tipi komut
formatınta, kaydırma alanını oluşturur.
• Hatırlayınızki bir bitlik sola kaydırma, sözcüğün 2 ile çarpılmasına
eşdeğerdir.
• Bu komut R-tipi bir komut’tur. Op ve func alanı 0’dır. Rs alanı
kullanılmaz. 0 yazılır.
$t2 0000 0000 0000 0000 0000 1101 0000 0000 ise
$t1 0000 0000 0000 0000 0011 1100 0000 0000 ise
and $t0, $t1, $t2 # $t0 = $t1 & $t2
$t0 0000 0000 0000 0000 0000 1100 0000 0000 olur.
or $t0, $t1, $t2 # $t0 = $t1 I $t2
$t0 0000 0000 0000 0000 00011 110010000 0000 olur.
Önemli: MIPS’te NOT işlemi, nor komutu ile başarılır. Çünkü;
A Nor 0 = NOT (A OR 0) = NOT (A)
nor $t0, $t1, $t3 # $t0 = ~( $t1 | $t3)
$t3 0000 0000 0000 0000 0000 0000 0000 0000 ise
$t0 1111 1111 1111 1111 11000011 1111 1111 olur.

• Tablodan da görüldüğü gibi MIPS’in lojik komutları sabit değerler
(immediate) ile de işlem yapabilirler. Bu lojik komutlar andi ve
ori dir.
andi $s1, $s2, 100 # $s1 = $s2 & 100
ori $s1, $s2, 100 # $s1 = $s2 | 100
2.6. instructions for making decisions (Karar Komutları)
• Bir bilgisayarı basit hesap makinesinden ayıran en önemli özellik
karar verebilme yeteneğidir. Giriş verileri ve değişkenler arasına
istenen işlemlerin yapılması sürecinde birçok farklı komutlar çalışır.
• Pororamlama dillerinde karar verme deyimi if dir. Bu deyim bazen
de go deyimi ve bir etiket ile kombine edilir.
• MIPS assembler dili iki tane karar verme komutu içerir. Bunlar
if……go deyimlerine benzerdir (Şartlı dallanma komutları).
1-Branch if equal (beq - Eşitse dallan):
beq register1, register2, L1 # register1’in içeriği register2’nin
# içeriğine eşit ise L1’e dallan.
2- Branch if not equal (bne - Eşit değilse dallan):
bne register1, register2, L1 # register1’in içeriği register2’nin
# içeriğine eşit değilse L1’e dallan.
Örnek: Aşağıdaki C kodunun MIPS kodu karşılığını bulunuz.
if(i==j) f= g + h; else f = g - h;
• Buradaki f, g, h, i, j değişkenleri; MIPS’ te sırasıyla f→$s0 , g → $s1,
h → $s2, i → $s3, j → $s4 registerleri ile ilişkilendirilmişlerdir.
MIPS kodu aşağıdadır.
bne $s3, $s4, Else # eğer i ≠ j ise Else etiketli yere git
add $s0, $s1, $s2 # h = g + j , eğer i ≠ j ise atlanır (işlenmez)
j exit # Exit etiketli yere atla. (Şartsız dallan).
Else: sub $s0, $s1, $s2 # h=g-j , eğer i=j ise atlanır(işlenmez)
Exit:
Not: 1-) Hafızadaki değişkenlerin registerlere transfer edilmesi
gösterilmemiştir.
2- ) Atlama yerlerinin adresleri compiler ve assemler dili
programlayıcısı tarafından belirlenir.
MIPS şartsız dallanma komutu
j etiket
• Aynı örneği başka şekilde gerçekleştirelim
if (i!=j); beq $s4, $s5, Else
h=i+j; add $s3, $s4, $s5
else j Exit;
h=i-j; Else: sub $s3, $s4, $s5
Exit:..
Döngüler (LOOPS)
• Kararlar hem, iki alternatif arasında seçim yapmak için (if deyimi ile karar),
hemde bir hesaplamadaki iterasyon için (döngü şeklinde bulunur).
• Her iki durum için benzer assemler komutları kullanılır.
Örnek: C’de kodlanmış aşağıdaki while döngüsünün MIPS assemler kodu nedir?
while ( save[i] == k )
İ += 1;
varsayılım ki; i ve k sırasıyla $s3 ve $s5 registerlerindedir ve dizinin başlangıç
değeri ise $s6 registerine kayıt edilmiştir.
İlk adım, save[i] operandını bir geçici (temporary) registere yüklemektir.
- save[i] operandını geçici registere yükleyebilmek için önce onun adresini
bilmeye ihtiyaç vardır.
- i değişkenini , save dizisinin başlangıç adresine eklemeden önce , i değişkenini 4
ile çarpmalıyız (her bir kelime 32 bit olduğu için). Bu işlemi i sözcüğünü 2 defa sola
kaydıran komut (sll) ile yapabiliriz.
-Biz programa bir LOOP isimli döngü etiketi eklemeliyiz. Böylece döngünün
sonunda, dallandığımız yere geri dönebiliriz.
Loop: sll $t1, $s3,2 # $t1 = 4*i yükle
Save[i] dizi indexsinin adresini elde edelim.(dizinin başlangıç adresine $t1’in içeriğini yükleyerek)
add $t1, $t1 ,$s6 # $t1 = save[i] adresi
Elde edilen bu adres değeri ile, save[i] içeriğinin $t0 register’ine e transferi.
lw $t0, 0 ($t1) # $t0 = save[i]
Save[i] ≠k ‘ya göre LOOP testi
bne $t0, $s5, Exit # eğer Save[i] ≠k ise, Exit’e git
i’ye 1 eklenme işlemi
addi $s3, $s3,1 # i = i + 1
Loop dönüsünün başına şartsız dallanma işlemi
j Loop # Loop döngüsüne git.
Exit:
• Karşılaştırılanların eşit olması veya olmaması testi değişik
şekillerde başarılabilir. Görme testi (to see) de bunlardan
birisidir.
• MIPS’te , bu işlem karşılaştırma komutu ile yapılır. Bu komut
“set on less than” veya slt komutudur. Bu komut iki registerin
içeriğini karşılaştırır; eğer 1. registerin içeriği 2.registerin
içeriğinden küçük ise 3. bir registeri 1’ set eder. Tersi ise 0’a set
eder.
slt $t0, $s3, $s4 # $s3 < $s4 ise $t0 = 0
• Sabit operand’ların karşılaştırmasına çok sıkça rastlanır. $zero
registerinde devamlı 0 yüklü olduğundan 0 ile karşılaştırmalar
bununla yapılır. Diğer sabit değerleri karşılaştırmak için; slti
komutu kullanılır. Örneğin, $s2 registerinin içeriğinin 10
sayısıyla karşılaştırmak için;
slti $t0, $s2,10 # eğer $s2 < 10 ise, $t0 = 1


57
Registerleri tekrar hatırlayalım !!!!!!!
Bunlar bi-li-ne-cek
• The 32 MIPS registerleri guruplara göre:
 Register 0 : $zero devamlı olarak 0 değeri ile yüklüdür.
 Regs 2-3 : $v0, $v1 bir prosedürün döndürdüğü değer yüklüdür.
 Regs 4-7 : $a0-$a3 prosedüre giriş argümanları yüklüdür.
 Regs 8-15 : $t0-$t7 geçici değerler
 Regs 16-23: $s0-$s7 Değişkenler için
 Regs 24-25: $t8-$t9 daha fazla geçici değerler
 Reg 28 : $gp global pointer
 Reg 29 : $sp stack pointer
 Reg 30 : $fp frame pointer
 Reg 31 : $ra Dönüş adresi yüklüdür.
2.7.Bilgisayar donanımında prosedürlerin (Fonksiyonların)
desteklenmesi
• Prosedür; özel bir görevi başarmak içi kullanılan altprogramlar
(subroutine v.B) gibi düşünülebilir. Bunlar kendilerine
tanımlanan parametrelerle ilgili işlemi başarıp sonucu verirler.
• C, Java v.b üste seviye programlarda , tool olarak ta adlandırılır .
• Prosedürler, programcıya karmaşık bir problemi çözerken,
kompleks programı parçalara ayırıp, her parçanın ayrı
parametreler kullanılarak sonuçlarının diğer bölümlerde
kullanılması kolaylığını sağlar.
• Prosedürler sadece kendisi için tanımlanmış işi yapabilir,
programda , programcı onu sık sık çağırarak başvurabilir. Yani
programın farklı noktalarında yapılması gereken aynı işlemler
için de prosedürlere başvurulur.
Bir prosedürün yürütülmesi için yazılan bir program
aşağıdaki altı adımı yerine getirmelidir.
1- Kullanılacak parametrelerin, prosedürün ulaşabileceği bir yere
yerleştirilmesi.
2- Prosedüre transferin kontrolu.
3- Prosedür için gereken hafıza kaynaklarının oluşturulması.
4- İstenen görevin yapılması.
5- Sonuçların, çağıran programın erişebileceği yerde hafızalanması.
6-Bir programda, bir prosedür değişik değişik noktaklardan
çağrılabilir. Dolayısıyla bu merkez noktaların kontrol edilebilir
olması gerekir. Çünkü prosedür tamamalandıktan program
tekrar o noktadan devam edebilsin diye.
• Daha önce de belirtildiği gibi, registerler en hızlı veri yerleştirme
ve tutma yerleridir. Biz onları mümkün olduğunca verimli
kullanmak isteriz.
• MIPS-32’nin procedurlar için kullandığı registerlerin standart
isimleri aşağıdadır.
$a0 - $a3 :Kullanılacak parametreler için 4 tane argüman registeri
$v0 - $v1: döndürülen değerler için 2 tane değer registeri.
$ra : Dönülecek orijinal noktayı bilmek için bir tane dönüş adresi
registeri (return address tarifi).
• Bu registerlara ek olarak; MIPS assemler dili; prosedürler için bir
atlama komutu da bulundurur. Bu komut istenen adrese (prosedür
adresine) atlar ve aynı zamanda, takip eden komutun adresini de
$ra ’ ya kaydeder. Bu komuta jump-and-link (jal) komutu denir.
jal Prosedür adresi
• Jal komutunun prosedür adresi kısmı, çağrılacak prosedürün
adresidir. Bu adres o anda PC’deki aktüel adrestir. Bu fonksiyon
aynı zamanda , tamamlandıktan sonra ana programda
dönülecek yerin adresini; (dönüş adresini), $ra registerine
depolar. Bu adres “program Counter -PC” registerindeki adres +
4 ’dür.
• Şu anda yürütülmekte olan komutun adresinin saklandığı özel
bir register (register dosyasının parçası olmayan) vardır. Bu
program sayacı (PC)’dır.
• Jal komutu; $ra registerına geri dönüş komut adresi olarak
PC(Program Counter) + 4 adresini set eder.
• Prosedürün sonuna eklenen;
Jr $ra
(jump register- jr) komutu, $ra registerindeki belirtilen adrese
şartsız dallanmayı sağlamanın garantisidir.
• Böylece çağıran program (calling program - caller -
ana program v.b olabilir), ilgili parametre
değerlerini $a0-$a3 registerlerine koyar ve, jal X
‘ ile X prosedürüne bu parametre değerleri ile
dallanır. (Prosedür, değişik komutların işlendiği bir
program parçasıdır. Bazen callee diye
isimlendirilir.)
• Calle, yani çağrılan program yani, prosedür;
kendisinden istenen hesaplamaları başarır ve
sonuçlarını $v0 - $v1 registerlerine koyup, çağıran
programda kaldığı yere jr $ra komutu ile geri
döner.
ÖZET
Caller (= Ana program veya diğer Prosedür)
• –stores parameters in $a0 -$a3
• –performs a jal ProcedureAddress to call the procedure
• Callee(= Prosedür)
• –performs calculations
• –saves the results in $v0 -$v1
• –performs a jr $rato return to the Caller
1
5.Hafta:
2.7. Bilgisayar donanımında prosedürlerin (Fonksiyonların)
desteklenmesi (4.hafta başlangıcı)
•Prosedür; özel bir görevi başarmak için kullanılan
altprogram (function-subroutine – tool) gibi düşünülebilir.
• Bunlar kendileri için tanımlanmış parametrelerle ilgili
işlemi başarıp sonucu verirler.
• Prosedürler, programcıya karmaşık bir problemi çözerken,
programı parçalara ayırıp, her parçanın ayrı parametreler
kullanılarak sonuçlarının diğer bölümlerde kullanılması
kolaylığını sağlar.
• Prosedürler sadece kendisi için tanımlanmış işi yapabilir,
programda , programcı onu sık sık çağırarak başvurabilir.
Yani programın farklı noktalarında yapılması gereken aynı
işlemler için de prosedürlere başvurulur.
Bir prosedürün yürütülmesi için yazılan bir program
aşağıdaki altı adımı yerine getirmelidir.
1- Kullanılacak parametrelerin, prosedürün ulaşabileceği bir
yere yerleştirilmesi.
2- Prosedüre transferin kontrolu.
3- Prosedür için gereken hafıza kaynaklarının oluşturulması.
4- İstenen görevin yapılması.
5- Sonuç değerlerinin, çağıran programın erişebileceği yerde
hafızalanması için bir yer.
6-Bir programda, bir prosedür değişik değişik noktalardan
çağrılabilir. Dolayısıyla bu orijin noktaların kontrol edilebilir
olması gerekir. Çünkü prosedür tamamlandıktan program
tekrar o noktadan devam edebilsin diye.
• Daha önce de belirtildiği gibi, registerler en hızlı veri yerleştirme
ve tutma yerleridir. Biz onları verimli kullanmak isteriz.
• MIPS-32’nin procedurlar için kullandığı registerlerin standart
isimleri aşağıdadır.
$a0 - $a3 :Kullanılacak parametreler için 4 tane argüman registeri;
Ana programdan (Çağıran -Caller) veya başka bir prosedürden,
çağrılan prosedüre ( callee) gönderilen giriş argümanları içindir.
$v0 - $v1: Prosedürden döndürülen değerler için 2 tane register.
$ra : Dönülecek orijinal noktayı bilmek için bir tane dönüş adresi
registeri (return address tarifi).
• Bu registerlar’a ek olarak; MIPS assemler dili; prosedürler için bir
atlama komutu da bulundurur. Bu komut istenen adrese (prosedür
adresine) atlar ve aynı zamanda, takip eden komutun adresini de
$ra ’ ya kaydeder. Bu komuta jump-and-link (jal) komutu denir.
jal Prosedür adresi
• Yürütülmekte olan komutun adresinin saklandığı özel bir register
(register dosyasının parçası olmayan) vardır. Buna program
sayacı (PC – Program counter) diyoruz.
• Jal komutunun prosedür adresi kısmı, çağrılacak prosedürün
adresidir. Bu adres o anda PC’deki aktüel adrestir. Bu fonksiyon
aynı zamanda , tamamlandıktan sonra ana programda dönülecek
yerin adresini; (dönüş adresini), $ra registerine depolar.
• Jal komutu; $ra registerına geri dönüş komut adresi olarak
PC (Program Counter) + 4 adresini set eder.
• Prosedürün sonuna eklenen;
Jr $ra
(jump register - jr) komutu, $ra registerindeki belirtilen adrese
şartsız dallanmayı sağlamanın garantisidir.
Dikkat!!! Jr $ra → PC= R[rs] ( rs reg’inin içeriğini PC’ye
koyar.)
• Böylece çağıran program (calling program - caller - ana
program v.b olabilir), ilgili parametre değerlerini $a0-
$a3 registerlerine koyar ve, jal X ‘ ile X
prosedürüne bu parametre değerleri ile dallanır.
(Prosedür, değişik komutların işlendiği bir
program parçasıdır. Bazen callee diye
isimlendirilir.)
• Calle, yani çağrılan program yani, prosedür;
kendisinden istenen hesaplamaları başarır ve
sonuçlarını $v0 - $v1 registerlerine koyup, çağıran
programda kaldığı yere jr $ra komutu ile geri
döner.
Prosedürün ihtiyaç duyduğu register sayısı fazla ise ne yapılmalı?
• Prosedürün attığı ilk adım, ana program
tarafından kullanılan registerlerin içeriklerini
kaydetmek olur. Çünkü bu registerları kendisi de
kullanacağından bir önceki içerikler kaybolmamalıdır.
Ana programa geri dönmeden önce de registerlerin ilk
içeriklerini ilgili registerlere tekrar kaydetmelidir.
• Registerların kaydedildiği hafıza kısmı spilling
memory olarak isimlendirilir.
• stack = LIFO yapısında, registerlerin saklanma
biçimini tarif eden veri yapısıdır.
• Stack Pointer ($sp) : Stack’teki en son işlenenin
adresini işaret eder.
• Stack’e yazma için push (itme) okuma için pop
(çekme) işlemleri kullanılır.
Aşağıdaki C prosedürünü inceleyelim
int leaf_example (int g, int h, int i, int j)
{
int f;
f = (g + h) –(i + j);
return f;
}
İlgili operandlar aşağıdaki registerlardadır. Bu
reg’lerin bir özelliği varmıdır?
g →$a0, h → $a1, I → $a2, j → $a3, f → $s0
Bu prosedür derlendiğinde MIPS kodu nedir?
Bu prosedürün yapacağı 1.İşlem : Ana programda
kullanılabilen reg’leri stack’e depolamaktır. Bu prosedürün, $to,
$t1, $s0 reg’lerini kullandığını farz edelim. Stack’e atma işlemi
aşağıdaki gibidir.
Leaf_example: # prosedür bu etiketle başlar
addi $sp, $sp, -12 # Stakc’te 3 birimlik yer açmak
sw $t1, 8($sp) # t1’in içeriğini stack’in içine kaydetmek (push)
sw $t0, 4($sp) # to’ın içeriğini stack’in içine kaydetmek
sw $s0, 0($sp) # s0’ın içeriğini stack’ın içine ittirmek.
Şekil: stack ve stack pointer’in
değerleri;
a) Prosedür çağrılmadan önce
b) Prosedürün çalışma süresince
c) Prosedür sonlandıktan sonra
Prosedürün MIPS kodu
ÖZET
Caller (= Ana program veya diğer Prosedür)
• – Parametreli, $a0 -$a3 registerlarına kayıt eder.
• – jal ProcedureAddress prosedürün çağrılmasını sağlar.
• Callee(= Prosedür)
• – kendinden beklenen hesaplamaları başarır.
• – Elde mettiğ sonuçları $v0 -$v1 geri dönüş reg’lerine kayıt eder.
• – jr $ra komutu ile çağıran programa geri döner.
• Eğer bir prosedür, s ile başlayan reg’leri kullanacaksa,
bunların içerikleri muhakkak korunmalı (stack’e atılabilir).
• Eğer bir prosedür, t ile başlayan reg’leri kullanacaksa,
bunların içerikleri korunmayabilir.
12
özet
• Jal komutu prosedüre dallanmak için kullanılır ve PC içeriğine
4 ekleyerek geri dönüş adres registerine (ra) yazar.
• Argümanlar $a0-$a3 registerlerine, Geri dönüş değerleri,
$v0-$v1 registerlerine atanır.
• Callee,callerin registerlerinin üzerine yazabildiği için, İlişkili
değerler hafızaya(Stack) kopyalanmalıdır.
•Her bir procedur, yerel değişkenler için bir hafıza yerine
İhtiyaç duyar (Stackt’e yer ayrılması ).
•Stack; procedürler için ihtiyaç duyulan organize edilmiş
hafıza bölgesidir.
İç İçe prosedürler (Nested Procedures)
• Başka bir prosedür tarafından çağrılmayan prosedürlere
yaprak prosedür (leaf prosedür) denir.
• Kullanılan prosedürler yaprak prosedür olsaydı işler çok
kolay olurdu.
• Oysa; bir prosedür tanımlanmış bir işi kolay bir şekilde
yapmak için, içerisinde başka bir prosedürün (veya
prosedürlerin) çağrılmasına gerek duyabilir.
• Hatta; kendi kendilerini çağıran recursive (Yinelemeli)
prosedürler bile mevcuttur.
• Bu şekilde çalışmalarda , kullanılan registerlardaki
bilgilerin kaydedilmesi ve geri çağrılması durumları çok
önemlidir.
Çalışılan prosedür yaprak prosedür değilse çok dikkat
edilmelidir.!!!!!!! Örneğin;
• ProsedürA, 5 parametresi ile ( $a0 = 5, $ra ’da set edilerek)
ana program tarafından çağrılmış olsun.
• –ProsedürB ise 10 parametresi ile ($a0 = 10, $ra dönüş
adresi tekrar set edilerek) ProsedürA tarafından çağrılmış
olsun.
• – A prosedürü doğru data ile devam edebilecek midir?
• – A prosedür’ü ana programa doğru bir şekilde dönebilecek
midir?
• En son çağrılan prosedür, registerlerin üzerine veri yazabileceği
için; ilgili reg’lerdeki değerlerin belleğe (stack) kaydedilmesi
gerekir !!!!!TAMAM’MI?
• Önemli not: İç-içe çağrılan prosedürlerde veya rekürsif
programlarda her çağırıdan önce bir önceki dallanma yeri ve
parametreler stac’te kaydedilmelidir.
15
Stack (Yığıt)
Procedür’ün kullandığı her bir register değerleri stack’ta
yedeklenmelidir. Aşağıda iç içe prosedürler için stack’taki
değerlerin yerleşimi gösterilmiştir.
Proc A’s values
Proc B’s values
Proc C’s values
…
Yüksek adres
Düşük adres
Stack bu şekilde
genişletilir.
Proc A
call Proc B
…
call Proc C
…
return
return
return
Örnek: Aşağıdaki rekürsif fonksiyonunun
MIPS komu seti kodunu tazınız.
int fact (int n)
{
if (n < 1) return (1);
else return (n * fact(n-1));
}
Ana programda; çağrılan fact(n)
fonksiyonundan sonraki komutun adresi 500
olsun. n=5 olsun.
STACK’te yeni veriler için yer ayrılması
•Bir prosedür tarafından stack’ta tahsis edilen yer, “prosedür frame” veya
“aktivasyon kayıtı” olarak adlandırılır. (Bu ayrılan yer,Prosedür için yerel verileri ve
kaydedilen değerleri içerir).
•Frame Pointer; Verilen bir prosedür için yerel değişkenleri ve kaydedilen
registerlerin yerini gösteren bir değerdir
• $fp registeri , stac’teki kayıtın başını, $sp sonunu gösterir.
•$fp prosedürün yürütülmesi boyunca değişmez.. $sp Prosedürün yürütmesi
boyunca değişebilir.
17
•$fp Frame’in 1.kelimesini gösterir.
•$sp ; stac’in en üstünü gösterir.
•$sp programın çalışması boyunca değişebilir.
•$fp sabit kalır, böylece $fp kullanılarak referans veri adresi tespit edilir.
•$fp kullanıldığında, $sp başlangıç noktasına bu sayede getirilir.
Prosedürün çağrılması ile
Stack yerleşim, (a) önce, (b)
süreç boyunca, (c) sonra
• Global pointer: Hafıza alanına kaydedilen global
değişkenlerin (ana program ve prosedürler
tarafından kullanılabilen) kaydedildiği alanı
gösterir. Bu değer $gp registerinde tutulur.
• Dinamik olarak tahsis edilen hafıza ( C’de
malloc() fonksiyonu ile ayrılır ) heap alanıdır.
18
19
0
$sp
$gp
0040 0000 hex
1000 0000 hex
Text
Static data
Dynamic data
Stack
7fff ffff hex
1000 8000 hex
pc
Reserved
Yürütülebilir programlarda gerçek zamanda hafıza-Organizasyonu
Program instructions
Variables allocated once
per program (global, C
static)
Explicitly allocated space,
(C malloc()library proc)
$sp
stack
pointer
global
pointer
$gp
0
Fonksiyon için lokal veriler,
stack frames

20
21
22
23
Karakterlerle çalışma için temel komutlar
•Çoğu bilgisayarlar, text prosesleri için karakter gösteriminde
8-bitlik kelime kullanır (ASCII kodlamada olduğu gibi) .
•Bazı komutlar, 32 bitlik bir kelimeden 8 bitlik bir kelime elde
edebilir. Bunlardan lb ve sb transfer komutları 32 bitlik
kelimeler yerine 8 bitlik kelimeleri transfer edebilir.
•MIPS bunu desteklemelidir. Çünkü bazı programlar 8 bit
çalışmak içindir.
• lb (load byte) Komutu, ana hafızadaki 8 bitlik veriyi
registerin en sağdaki 8 bitine yükler.
•Sb(Store byte) komutu ise bunun tersini yapar.
• lb $t0, 0($sp)
• sb $t0, 0($sp)
24
Örnek
Aşağıdaki kodu assemlere dönüştürün.
void strcpy (char x[], char y[])
{
int i;
i=0;
while ((x[i] = y[i]) != `\0’)
i + = 1;
}
strcpy:
addi $sp, $sp, -4
sw $s0, 0($sp)
add $s0, $zero, $zero
L1: add $t1, $s0, $a1
lb $t2, 0($t1)
add $t3, $s0, $a0
sb $t2, 0($t3)
beq $t2, $zero, L2
addi $s0, $s0, 1
j L1
L2: lw $s0, 0($sp)
addi $sp, $sp, 4
jr $ra
String (dizi-karakter topluluğu) karakterlerden oluşur. Örneğin C’de tanımlı
“Cal” stringi 4 byte ile gösterilir ( 67 (C), 97 (a),108 (l),0(null) olur.
Varsayım: x ve y dizilerinin başlangıç
adresleri $a0 ve $a1’de olsun. i için $so
reg’i kullanılsın. $so reg’i muhakkak
stakc’te yedeklenmelidir.
•MIPS komut seti half-word (16 bitlik) yükleme
ve depolama (transfer ) işlemlerini de destekler.
• lh (load half) : hafızadan bir half word’ü
registerin en ağırlıksız 16 bitine yükleme işini
yapar.
• Sh(Store half) : Bu komut ise tersi işlemi
yapar.
25
26
32 bit immediate operandlar
• Immediate komutlar ile sadece 16-bit sabitler belirtilebilir.
• lui (load upper immediate) komutu: 16 bitlik sabiti, registerin
upper register (en ağırlıkılı 16 bit) alanına kaydetmek için
kullanılır. 32 bitlik sabit tanımlamak için iki immediate komut
kullanılır.
Örnek: 32 bitlik sabit sayı oluşturma
27
MIPS’te , assemler $at registerinde saklanmış
değeri uzun sabit değerlerini veya adres
değerlerini oluşturmaktan sorumludur.
Dallanma ve atlamada adreslemenin önemi
• Şartlı dallanmada, dallanılacak adres 16 bitlik sabit bir değerdir. Dallanılacak
adres 16 bitden daha büyük ise ne olacaktır?
• Aynı şekilde şartsız dallanmada (atlama) da dallanılacak adres 26 bit’tir. Daha
büyük bir değerde ne olacaktır?
1- Dallanma adresi, 32bitlik bir reg’in içeriği ile toplanıp PC’ye
yazılır . Buna relative adresleme denir. Ama hangi registeri
kullanalım?
PC = register + dallanma komutundaki adres
Şartlı dallanmalarda genellikle yakın komutlara dallanıldığından (İstatistiksel
elde edilmiştir) , mevcut komutun adresinin tutulduğu PC reg’in kullanıma çok
uygundur. Buna PC-Relativ adresleme denir. 28
2- PC’nin içeriği ile dallanma komutundaki adres
toplanıp PC’ye yazılır. Buna PC-Relative adresleme
denir. Genellikle bu kullanılır .
PC = PC + dallanma komutundaki adres
Böylece biz mevcut komuttan ± 2
15 word adresi kadar uzağa
dallanabiliriz.
• Şartlı dallanmada, belirtilen 16 bitlik sabit değer, hafızadaki
word (32 bit – 4 byte) adresleridir. Oysa ana hafızada 1
baytlık adresleme söz konusuydu. Bu durumda dallanılacak
doğru adresi bulmak için 16 bitlik sabit değeri 4 ile çarpıp
PC + 4’e eklemek gerekir.
PC = (PC+4) + (dallanma komutundaki adres*4)
29
Örnek:
30
bne $t0, $s5, Exit komutu için PC-relative adresleme;
• PC = (PC+4 ) + (dallanma adresi*4)
• → PC = (80012+4) + (2*4) = 80024 (Exit etiketinin adresi)
• Not: 80012, bne komutunun adresidir. Sonraki komutun adresi 80012 + 4
dür. bne komutundaki dallanılacak exit etiketinin adresi 2 olarak komutta
verilmiştir. Bu değer word olarak adres değeridir.
• Oysa biz 32bit çalıştığımızdan bu değer 4 ile çarpılıp word’e dönüştürülerek
dallanılacak gerçek adres elde edilir. (80024 adresi)
31
j Loop (Atlama komutu) için Pseudodirect
adresleme
Şartsız dallanma komutundaki 26 bitlik alan
word (32 bitlik) olarak atlama adresini belirtir.
Bunu byte olarak ifade etmek için 4 ile
çarpmak gerekir.
Dolayısıyla bu alan PC’de 28 bit olarak ortaya
çıkar. Niye?
PC = (PC’nin en ağ.4 biti) +(jump addresi*4)
→PC = (0000)2+ (20000*4)10= 8000010(Loop’un adresi)
32
Uzaklara Dallanma (Branching Away)
beq $s0, $s1, L1
L1 etiketinin çok uzak bir adres olduğunu
varsayın. Budurumda iki komut kullanılarak
çok uzak adreslere dallanma yapılabilir.
bne $s0, $s1, L2
j L1 # uzaklara dallanabilir. Niye?
L2:
33
MIPS’de Adresleme modları
1- Register adresleme : Burada operand register’dır.
2- Base veya yerdeğiştirme adresleme: Burada operand ana
hafızadaki lokasyondur.Ki onun adresi; komutaki sabit ile
registerin toplamından elde edilir.
3- İmmediate adresleme: Buradaki operand komutun
kendisindeki sabittir.
4-PC-Relative adresleme: Burada adres, komuttaki sabit ile
PC’deki değerin toplanmasıyla elde edilir.
5- Pseudodirect adresleme: Buradaki atlama adresi PC
ağırlıklı bitleri ile birleştirilmiş komutunun 26 bit’idir.
Bunları şematik olarak gösterebiliriz.
34
Adresleme modları şeması
35
Makine dilinin dekodlanması
•Makine dilinden ,tersine giderek orijinal assemler komutlarnı yaratmaktır.
• Örnek:
00af8020 hex
Makine dilindeki komutun assemler dili karşılığı nedir?
Çözüm:
36
37
Bir Programın Başlatılması
C Program
Assembly dili program
Object: makine dilindeki prog.parç. Object: makine dilindeki kütüphane rutinleri
Çalıştırılabilir: machine dilinde program
Memory
Compiler
Assembler
Linker
Loader
x.c
x.s
x.o x.a, x.so
a.out
38
Assembler’in Rolü
• Pseudo(sözde) kodları gerçek donanım komutlarına
dönüştürmek.
– Pseudo-kodlar assembly programa kolayca dönüştürür
örnekler: “move”, “blt”, 32-bit immediate operandlar gibi.
• Assembly kodlar machine kodlarına dönüştürülür.
Ayrı object file (x.o) her bir C dosyası için oluşturulur
(x.c) komut etiketleri için gerçek değerleri hesaplar.
Dış referanslar ve hata ayıklama bilgileri hakkında bilgi
sağlamak için
39
Linker’in Rolü
 patch iç ve dış kaynaklar
 veri ve komut etiketlerinin adreslerini hesapla
 hafızada veri ve kod modüllerini organize et.
• Bazı kütüphaneler(DLLs) dinamik olarak bağlanır(linked)
Dummy rutinleri yürütülebilir nokatalara– Bu dummy
rutinleri dinamik linker ve yükleme cağırır. Bu yüzden onlar
doğru rutinlere atlama için yürütülebilir güncellenebilir.
40
3. Bölüm
BİLGİSAYAR ARİTMETİĞİ
1
İşaretli ve işaretsiz sayılar
Sayılar herhangi bir taban kullanılarak temsil edilebilir.
Günlük hayatımızda kullandığımız sayı sistemi 10’luk
(Desimal) sayı sistemiyken bilgisayar 2’lik (Binary)sayı
sistemini kullanmaktadır. Herhangi bir tabanda bir sayının
oluşumu aşağıdaki gibidir. Ai basamak rakamı, T taban, i
basamak değerini ifade eder. Ai basamak rakamı, 0, 1..T-1’e
kadarki ardışıl rakamlardan herhangibiri olabilir.
2
Soru: Bilgisayarlarda niye 2 tabanlı sayı sistemi kullanılır?
Cevap: Bu tabanda kullanılan rakamlar 0 ve 1’dir. Bu rakamların elektriksel
işaretler olarak tanınması çok kolaydır.(Transistörün anahtarlama modunda
çalıştırılması ile)
1011two sayısının desimal sayı sistemindeki karşılığını
hesaplayalım;
Bu sayıyı ikilik tabanda 32 bit ile ifade edecek olursak
yeni sayı;
3
32 bitlik işaretsiz sayılarda yazılabilecek en küçük sayı;
En büyük sayı;
Bu sayıların desimal karşılıklarının hesaplanması;
4
İşaretli sayılarda ikilik tabanda diğer sayı
tabanlarında olduğu gibi ± işaretleri, sayının
pozitif ya da negatif olduğunu belirlemez ikilik
tabanda işaretli bir sayının işaretini en anlamlı biti
(MSB) vermektedir. En anlamlı bit işareti, diğer
bitler ise sayıyı ifade etmektedir.
En anlamlı bit ‘0’ ise sayı pozitiftir ve desimal
karşılığı işaretsiz sayılarda olduğu gibi hesaplanır.
En anlamlı bit ‘1’ ise sayı negatiftir ve desimal
karşılığını hesaplayabilmek için 2’ye tümleyeninin
alınması gerekmektedir.
5
Yukarıda 32 bitlik bazı işaretli sayılar ve desimal karşılıkları verilmektedir.
32 bitlik işaretli sayılar ile ifade edilebilecek;
En büyük sayı (231
-1) 2,147,483,647
En küçük sayı (-2
31) -2,147,483,648 dir.
6
• İkilik tabanda verilen işaretli bir sayının desimal
karşılığı aşağıdaki şekilde hesaplanmaktadır.
Buradaki -2
31 işaret bitinitemsil etmektedir.
7
Örnek: 5 bitlik işaretli sayı için
( + 13)10 = 0 1101 = 0x24 +1x23 +1x22+0x21+1x20 = 8 + 4 + 1 = + 13
( - 13)10 = 1 0011 = -(1x24
) + ( 0x23 +0x22 +1x21 +1x20
) = -16 + 3 = -13
İkilik tabandan onluk tabana dönüşüm işlemi
Verilen 32 bitlik işaretli sayının desimal karşılığını
bulalım.
Sayının tüm bitlerini formülde yerine koyarsak;
8
MIPS
• lb, lbu
– ( lb - load byte) 32 bitlik işaretli sayının en anlamlı 24 bitini işarete göre doldurur.
– ( lbu- load byte unsigned) işaretsiz sayılarda anlamlı bitlere 0 atar.
• lh, lhu
– ( lh - Load half) işaretli sayılarda en anlamlı 16 biti işarete göre doldurur.
– ( lhu - Load half word unsigned) işaretsiz sayılarda
• slt & slti
– ( slt - set on less than) işaretli sayılarda karşılaştırma
– ( slti - set on less than immediate) işaretli tamsayılarda karşılaştırma
• sltu & sltiu
– ( sltu - set on less than unsigned) işaretsiz sayılarda karşılaştırma
– ( sltiu -set on less than immediate unsigned) işaretsiz tamsayılarda karşılaştırma
9
İşaretli ve işaretsiz sayıların karşılaştırılması
$s0 register’ında aşağıdaki sayı olsun.
$s1 register’ında aşağıdaki sayı olsun.
Aşağıdaki tanımlamaya göre $t0 ve $t1 register’larının
değerleri ne olur?
10
Cevap;
$s1 değeri 1’dir. $s0 işaretli bit tamsayı ise değeri
-1, işaretsiz bir tamsayı ise değeri 4294967295 tir.
slt $t0, $s0, $s1 $t0=1 (-1<1)
sltu $t1, $s0, $s1 $t1=0 (4294967295>1)
11
İşaret değiştirme
• 2 sayısını 32 bitlik -2’ye çeviriniz.
12
Bir sayının negatifi alınacağı zaman öncelikle tüm
bitlerinin tersi alınır, ardından 1 ile toplanarak karşılığı
bulunur.
Aynı işlem negatif bir sayının pozitif karşılığını bulmak için
de kullanılır.
13
İkilik tabanda işaretli 16 bitlik 2’yi 32 bit ile ifade edelim.
İkilik tabanda işaretli 16 bitlik -2’yi 32 bit ile ifade edelim.
16 bitlik -2’yi 32 bitlik sayıya çevireceğimiz zaman anlamlı
bitlerine ‘0’ değil ‘1’ eklememiz gerekmektedir.
14
15
Toplama
6 ile 7 sayılarının ikilik sayı tabanında toplanması;
16
Basamaklar sağdan sola elde biti de göz önüne
alınarak eklenerek soldaki basamağa geçer.
Çıkarma
Aynı örnek üzerinde çıkarma işlemini yapalım;
Çıkarma işleminde yukarıdaki gibi doğrudan çıkarma
yapılabileceği gibi çıkarılan sayının 2’ye tümleyeni
alınarak toplamada yapılabilir.
17
MIPS
• Add, addu
– İşaretli sayılarda toplama
– İşaretsiz sayılarda toplama
• Addi, addiu
– İşaretli sayılarda bir tamsayı ile toplama
– İşaretsiz sayılarda
• Sub, subu
– İşaretli sayılarda çıkarma
– İşaretsiz sayılarda çıkarma
– MIPS istisna nedeninin talimat adresini içeren
EPC(exception program counter) olarak adlandırılan bir
register içerir. sistem kontrolünden ayrılma
komutu(MFC0-move from system control) EPCyi genel
amaçlı bir register içine kopyalamak için kullanılır.
18
Toplama ve çıkarma için overflow durumları;
19
• Bir işlem sonucunda elde edilen sayısal değer, sözcük uzunluğu ile
tanımlanmış değerlerden büyükse, taşma (overflow) vardır denir.
• 32 bitlik 2 sayı toplandığında/çıkarıldığında sonuç 33 bit ise;
• İki pozitif sayı toplandığında sonuç negatif ise (sonucun İşaret biti 1 ise);
• İki negatif sayı toplandığında sonuç pozitif ise (sonucun işaret biti 0 ise);
• Bir pozitiften bir negatif değer çıkartıldığında sonuç negatif ise (sonucun
işaret biti 1 ise)
• Bir negatiften bir pozitif değer çıkartıldığında sonuç pozitif ise ( sonucun
işaret biti 0 ise)
overflow (taşma) veya underflow (borç alma) oluştuğu anlaşılır.
• Bir negatif sayı bir pozitif sayıya eklendiğinde hiçbir zaman taşma olmaz.
• Çıkarılan sayılar aynı işaretli ise taşma olmaz.
Taşma oluşumunun tanınması
20
– add, addi veya sub komutlarının sebep olduğu bir taşma interrupt ‘ı
( kesme – exception-istisna) oluşur.
•Kontrol, önceden tanımlanmış adresteki interrupt rutinine atlar.
•Interrupted addresi, mümkün yeniden başlatamalar için kaydedilir.
• MIPS $epc (exception program counter) registeri içerir. Bu register
interrupt’ a sebep olan komutun adresini tutar.
• Move from system control (Sistem kontrolundan ayrılma) komutu ile;
mfco $t0, $epc # copy $epcto register
$epc reg’in içeriği $t0 reg’e aktarılır.
• İşaretsiz sayılarda oluşan ( addu, addiu, subu komutları ile) overflow’lardaki
interrup’lar sürekli olarak sezilmek istenmez. Bu durumdaki taşma yok sayılır.
Çünkü işaretsiz sayılarla işlemler genellikle ana hafıza adreslemeleri içindir.
Tavsiye:
QtSPIM’de : EPC ve ilgili reg’leri incele.
MIPS overflowu yakalayabilir, ancak birçok bilgisayarda
overflow testi için dallanma şartı bulunmamaktadır.
Overflow’u yakalayabilmek için MIPS kodu aşağıdaki
gibi yazılır;
21
22
İşaretsiz sayılarda toplama için ($t0= $t1+$t2)
overflow’u yakalayabilmek için yazılan MIPS kodu;
23
Çarpma
24
Multiplicand 1000
Multiplier 1001
1000
0000
0000
1000
Product 01001000
m bit x n bit = m+n bit çarpım (product)
Binary 2 sayıyı çarpma işlemi;
– çarpan(multiplier) bit 1 => çarpılanı (multiplicand) kopyala (1 x multiplicand)
– çarpan bit 0 => yerine 0 koy (0 x multiplicand)
x
ÇARPMA İŞLEMİNİN DONANIMININ
İLK VERSİYONU VE AKIŞ ŞEMASI
25
Multiplicand(çarpılan) register, product(çarpım)
register ve ALU 64-bit genişliğindeyken;
multiplier(çarpan) ise 32-bit uzunlukludur. Kontrol
bloğu çarpılan ile çarpanın ne zaman kaydırılacağını
ve sonucun ne zaman yenileneceğini belirtir.
32-bit multiplicand(çarpılan) register’ın en
anlamsız bitlerindedir ve her adımda sola kayar
Çarpımın başlangıç değeri 0’dır
26
27
28
29
30
31
Fix-point çarpma işlemi
32
Multiplicand 0010
Multiplier 0011
0010
0010
0000
0000
Product 00000110
x
Bu çarpma devresi işaretli sayıların Çarpılması için
kullanılabilir mi?
33
İşaretli sayıların çarpılması işlemi; işaretsiz sayıların çarpılması
şeklindedir. Yani negatif sayı pzitifsayıya dönüştürülüp iki işaretsiz
ssayının çarpılması şeklinde gerçekjleştirilir. Sonucun işareti ise
işaretli sayılarınişaret bitlerine göre belirlenir.
ÇARPMA İŞLEMİNİN İŞLENMİŞ VERSİYONU
34
Multiplicand register, multiplier register ve ALU 32-bit uzunluğunda;
product register ise 64-bit uzunluğundadır. Çarpım sonucu sağa
kaydırılarak işlem devam eder.Çarpan bulunmadığı için
multiplicand (çarpılan) çarpım register’ının en anlamlı 32 biti ile
toplanır.
Çarpım register’ının başlangıç değeri 0
35
İşlenmiş versiyona göre çarpma işlemi
36
İterasyon Step Multiplier Multiplicand Product
0 init 0011 0010 0000 0000
values
1 1a 0011 0010 0010 0000
2 0011 0010 0001 0000
3 0001 0010 0001 0000
2 1a 0001 0010 0011 0000
2 0001 0010 0001 1000
3 0000 0010 0001 1000
3 1a 0000 0010 0001 1000
2 0000 0010 0000 1100
3 0000 0010 0000 1100
4 1a 0000 0010 0000 1100
2 0000 0010 0000 0110
3 0000 0010 0000 0110
Multiplicand 0010
Multiplier 0011
0010
0010
0000
0000
Product 00000110
x
MIPS
• 64 bitlik çarpımı ifade edebilmek için Hi ve Lo adı
verilen 2 adet 32-bitlik register kullanılır.
• mult, multu
İşaretli ve işaretsiz sayılarda çarpma işlemi
• mflo, mfhi
bu komutlar sanal (pseudoinstruction)komutlar olup
yukarıda verilen mult ve multu komutları
çalıştırıldığında bu komutlar 64 bitlik sonucu 32
bitlik Hi ve Lo olmak üzere 2 register’a taşır.
37
Hızlı çarpma donanımı
32 bitlik bir toplayıcı ile döngü
kurarak 32 adet toplama
yapmak yerine çarpma işlemi
döngü açılarak 32 toplayıcı ile
yandaki şekilde yapılabilir.
Buradaki her toplayıcı dışarıya
32 bitlik toplam ile elde bitini
göndermektedir.
38
Bölme
39
1001 Quotient(Bölüm)
Divisor(Bölen) 1000 1001010 Dividend (Bölünen)
–1000
10
101
1010
–1000
10 Remainder(Kalan)
Dividend = (Quotient * Divisor) + Remainder
Bölme donanımının ilk versiyonu
40
Divisor(bölen) register, remainder(kalan) register ve ALU 64-bit
uzunluğunda; quotient(bölüm) registerı 32-bit uzunluğundadır.
Kontrol bölen ve bölümün ne zaman kaydırılacağı ve kalan
registerına yeni değerin ne zaman yazılacağını belirler.
32 bitlik bölen (Divisor), bölen register’ının sol yarısından başlar ve
her adımda sağa kaydırılır.
Kalan register’ı bölünen registerının değeriyle başlar.
Bölüm(Quotient) registerı 0
ilk değeriyle başlamaktadır.
Bölme Algoritması
41
Neden 33?
000001112 (7)/ 00102
(2)
42
Bölme donanımının gelişmiş versiyonu
43
Bölen, ALU ve bölüm 32 bitlik, kalan ise
64 bitliktir. Bu donanımda bölüm registeri
bulunmamakta, bölüm kalan registerının
en anlamlı bitlerinde bulunmaktadır.
Kalan registerının anlamlı bitlerinde
bölüm registerının değeri bulunur.
MIPS
• div, divu
iki tane 32 bitlik operand registerı ile işlenen içerik
bölünür, kalan Hi registerına bölüm ise Lo
registerına aktarılır taşma her iki durumda da göz
ardı edilir.
Sözde talimatlar kullanılarak div (signed with
overflow), divu (unsigned without overflow) 3 tane
32 bitlik register ile iki registerın bölümü 3 .
registera aktarılır.
44
45
FLOATING POINT SAYILAR
46
Floating Point Sayılar
• IEEE 754 floaing point formatı günümüzde gerçek
sayıları temsil etmek üzere kullanılan en yaygın
gösterim şeklidir.
• Bilgisayarda gerçek sayıları temsil etmenin birkaç
farklı yolu vardır.Örneğin fixed point sayı gösterimi ile
her sayı 2 integer sayının oranı şeklinde gösterilebilir.
• IEEE 754 floating point formatında ise gerçek sayılar
bilimsel bir notasyonla gösterilir.
47
Floating Point
Aşağıda verilen sayıları tanımlayabilmek için floating
point sayılar kullanılır;
– Kesirli sayılar, örneğin 3.1416
– Çok küçük sayılar, örneğin .00000000023
– Ve çok büyük sayılar, örneğin –3.15576 * 1046
48
Floating point sayı gösterimi
Floating point sayıların gösterimi 3 bölümden oluşur. Bu bölümler:
sign(işaret), exponent(üs) ve significand(fraction,mantissa-kesir) olarak
ifade edilir.
Sign Biti: Sign biti pozitif sayılar için 0, negatif sayılar için 1 değerini alır.
Exponent: Exponent alanı hem negatif hem de pozitif üsleri temsil
edebilmektedir.Bunu gerçekleştirmek için bir bias değeri gerçek üs
değeriyle toplanıp exponent kısmı oluşturulur.
IEEE 32 bitlik gösterimi için bias değeri 127, 64 bitlik gösterim için de 1023
tür.Buna göre gerçek üssün 0 olması exponent alanında saklanan değerin
127 olacağı anlamına gelir.
Mantissa: Mantissa sayıyı ifade eden bitleri gösterir. Bu,sayının tam ve
kesir(fraction) kısımlarını gösteren bitlerden oluşur.
49
Floating point sayılar aşağıdaki gibi gösterilir:
(–1)sign * significand * 2exponent
Örneğin; -101.001101 * 2111001
– significand bölümü ne kadar bit ile ifade edilirse sayı
gerçeğe o kadar yakın olur.
– exponent bölümü ne kadar bitle ifade edilirse, değer
aralığı o kadar artar.
50
Floating point sayılar 1  significand  10two(=2ten)
aralığında ifade edilir. Bu aralıkta olmayan sayıların normalize
edilmeleri gerekmektedir.Örneğin; –101.001101 * 2111001
sayısının floating point olarak gösterilişi (normalize edilmiş hali),
–1.01001101 * 2111011 şeklindedir.
Floating point standartında gösterilecek olan sayıların
normalize edilmesi zorunludur. Sayıların normalize
edilmesindeki amaç aynı sayıyı daha az bit ile ifade
etmektir. Bu nedenle binary formda ifade edilecek
her sayı aşağıdaki formatta olmak zorundadır.
1.xxxxxxx2
x 2yyyyy
Örneğin binary bir sayı olan
11110000 11001100 10101010 00000000;
+ 1.1110000 11001100 10101010 x 231
şeklinde gösterilir.
51
IEEE 754 Floating-point Standard
IEEE 754 floating point standartında 32 bitlik ve 64 bitlik olmak üzere 2 tür
gösterim mevcuttur.Her 2 gösterim için sign, exponent ve mantissanın
durumları aşağıda verilmiştir.
– Single precision (tek duyarlıklı): tek kelime (32 bit)
– Double precision (çift duyarlıklı): iki kelime (64 bit)
52
31
sign
bits 30 to 23
8-bit exponent
bits 22 to 0
23-bit fraction
31
sign
bits 30 to 20
11-bit exponent
bits 19 to 0
upper 20 bits of 52-bit fraction
bits 31 to 0
lower 32 bits of 52-bit fraction
53
54
IEEE 754 Floating-point Standard
• Sayı normalize kabul edilir ve sayıda noktanın sol tarafında yer
alan 1 biti fraction kısmında gösterilmez.
– Yani significand kısmı 1.1001… olan sayı 1001… şeklinde
ifade edilir.
– Sayıların temsili:
sayı değeri = (–1)sign * (1 + fraction) * 2exponent value
• Sayının değerini daha kolay bir şekilde bulabilmek için
exponent biaslanır.
– Exponent tamamen 0lardan oluşmuşsa en küçük, 1’lerden
oluşmuşsa en büyüktür.
– single precision için bias değeri 127, double precision ise
1023’tür.
– Sayı temsili;
sayı değeri = (–1)sign * (1 + fraction) * 2(exponent – bias)
55
Örnek 1;
–0.75ten sayısını IEEE 754 standartına göre single
precision ve double precision formatında ifade edelim.
Desimal değer: –0.75 = –3/4 = –3/22
Binary karşılığı: –11/100 = –.11 = –1.1 x 2-1
IEEE single precision floating point exponent
= bias + exponent değeri
= 127 + (-1) = 126ten
= 01111110two
56
IEEE 754 single precision formunda 0.75:
(–1)1*(1 +.1000 0000 0000 0000 0000 0000) * 2(126-127)
IEEE 754 double precision formunda 0.75:
(–1)1 *(1 +.1000 0000 0000 0000 0000…0000)*2(1022-1023)
57
Örnek 2; -2345.12510 desimal sayısını IEEE 754 standartında
32 bitlik formatta ifade edelim:
-2345.12510 = -100100101001.0012
(binary karşılığı)
= -1.001001010010012
x 211 (normalize binary)
-Mantissa negatif olduğu için işaret biti 1 olacaktır. (S=1)
-32 bit için bias değeri 127 idi, binary sayının exponenti=11
E=127+11=13810 = 100010102
(8 bit)
-Kesir kısmı (fraction)= .00100101001001000000000 (23 bit)
58
Sign Exponent Fraction
1 10001010 00100101001001000000000
1bit 8bit 23bit
yazılmaz
Örnek 3; Aşağıda verilen ikilik tabandaki floating
point sayıyı desimal sayıya çevirelim.
İşaret biti:1, exponent alanının değeri:129,
fraction alanı: 1x2-2 = ¼=0.25
59
IEEE 754 formatında sayı gösterimi
60
0 özel durumu:
– Exponent ve fraction tamamen 0’lardan oluşmuşsa, işaret
biti ne olursa olsun sayının değeri 0’dır.
– Exponent 0 ve fraction 0’dan farklı ise sayının değeri;
(–1)sign * (1 + fraction) * 2-127 ’dir.
Matlab ortamında floating-point sayılar
>> q= quantizer('single','nearest','saturate');
>> num2hex(single(-0.75))
ans = bf400000
>> hex2num(q,'C5129200')
ans = -2.3451e+003
61
Floating-point sayının özelliklerinin belirlendiği fonksiyon
1 01111110 10000000000000000000000
1 10001010 00100101001001000000000
Desimal sayının floating point karşılığını veren komut
floating point sayının desimal karşılığını veren komut
Floating Point Toplama
Örnek; 1,234,823.33310 + .001110 =?
Floating point sayıların toplanabilmesi için
öncelikle kesir kısımlarının toplanması gerekir
ancak toplamaya başlanılmadan önce sayıların
exponentlerinin aynı olması sağlanmalıdır. Bu
nedenle toplama işlemine geçilmeden önce
üslerin eşitlenmesi gerekir.
1,234,823.333 = 1.234823333 x 106
.0011 = 1.1 x 10-3 = 0.0000000011 x 106
62
Toplanacak sayıların üsleri eşitlendikten sonra önce
kesir kısmı ardından tam kısımları toplanır.
1.2348233330 x 106
0.0000000011 x 106
1.2348233341 x 106
63
+
Toplama işleminin Algoritması
64
Verilen algoritmaya göre toplama işleminin
adımları;
• 1. adım: toplanacak olan sayıların exponentleri
eşitlenir. küçük olan sağa kaydırılarak büyük olan
exponente eşitlenir.
• 2.adım: sayıların fraction(mantisa) kısımları toplanır.
• 3. adım: elde edilen toplam normalize edilir.
• 4. adım: elde edilen toplam değeri olması istenen
uzunluğa(4 bit) getirilir.
65
Örnek 2; 0.5 + (-0.4375) =?
Toplam 4 dijitle ifade edilsin.
Öncelikle sayıların binary karşılıklarını hesaplayalım:
66
1. adım: exponentlerin eşitlenmesi
2. adım: fraction kısımlarının toplanması
3. adım: toplamın normalize edilmesi
67
4. adım: overflow,underflow oluşmuş mu?
Üs değeri 127≥-4≥-126 arasında olduğu sürece
overflow veya underflow oluşmaz.
Sonuç olarak elde edilen değerin desimal
karşılığı;
68
Floating point toplama için donanımın blok şeması
69
Örnek; 2345.12510 sayısı ile .7510 sayısını IEEE
754 standartında 32 bitlik formatta toplayınız.
X= 2345.12510
Y= 0.7510
1.adım: Exponentlerin büyük olana eşitlenmesi
Ex > Ey
E= 10001010=13810
Ex
-Ey= 10001010 – 01111110 = 00000110 = 1210
Fy 12 bit sağa kaydırılacak.
Fy
x 2-12=0.00000000000110000000000
70
Sign Exponent Fraction
0 10001010 00100101001001000000000
Sign Exponent Fraction
0 01111110 10000000000000000000000
2.adım: kesirlerin toplanması
Fx+ (Fy x 2-12)= 1. 00100101001001000000000
+ 0. 00000000000110000000000
=1.00100101001111000000000
3. adım: toplam normalize mi? Evet
4.adım: overflow veya underflow oluşmuş
mu?hayır
5.adım: sonuç 0 mı? Hayır
Sonuç:
71
Sign Exponent Fraction
0 10001010 00100101001111000000000
1bit 8bit 23bit
Floating point sayılarda Çarpma
Örnek 1; 1.11010x1010 x 9.20010x10-5 dört dijitlik
sayıları çarpalım (IEEE 754 single precision).
1.adım: toplamadan farklı olarak üsler toplanır.
Öncelikle biaslanmış exponentleri hesaplamalıyız.
10+127=137 ve (-5)+127= 122
Yeni exponent= 137+122= 259
259 sayısını 8 bitle nasıl ifade edeceğiz?
72
Biaslanmış sayıları toplarken bias değerini çıkarmayı
unutmamamız gerekir, dolayısıyla;
yeni exponent= 137+122-127 = 132
ya da yeni exponent= 10 + (-5)+ 127 = 132 olur.
2.adım: significand kısımları çarpılır.
1.110
9.200
0000
0000
2220
9990
1021200010
Çarpım sonucu= 10.21200010=10.21210x105
73
x
+
3. adım: sonucun normalize edilmesi
10.21210x105=1.021210x106
4.adım: significant kısmı 4 dijit olduğu için sayının
yuvarlanması gerekir.
1.021210x106=1.02110x106
5.adım: işaret bitinin değerinin bulunması. Çarpılan
sayıların işaretleri aynı ise sonuç pozitif(S=0),
farklı ise sonuç negatif (S=1) olur.
Sonuç= +1.02110x106
74
Çarpma Algoritması
Genel olarak 3 ve 4. adımlar
birer kez gerçekleştirilir, ancak
normalizasyon yapılmamışsa
3. adım tekrarlanmalıdır.
75
Örnek 2; Verilen algoritmanın adımlarını takip ederek
0.510 ile -0.437510 sayılarını çarpalım.
Sayıların binary karşılıkları; 1.0002
x2-1 ve -1.1102
x2-2
1. Adım: exponentlerin toplanması
Bias olmadan -1 +(-2)= -3
Bias ile; (-1+127)+(-2+127)-127=124
2. Adım: significand kısımlarının çarpımı
1.0002
1.1102
0000
1000
1000
1000
11100002 76
x
+
çarpım= 1.110000x2-3
3. Adım: çarpım sonucu normalize mi? Evet
İşlem sonucunda overflow oluşmuş mu?
127≥-3≥-126 aralığında olduğundan hayır
Bias edilen için 254≥124≥1 aralığında olduğundan hayır
Underflow oluşmuş mu? Hayır
4. Adım: çarpım değerini 4 bit ile ifade etmemiz
gerekiyor. Dolayısı ile çarpım= 1.110000x2-3=1.110x2-3
5. Adım: çarpılan sayıların işaretleri farklı olduğu için
sonuç negatif olacaktır.
Sonuç = -1.110x2-3
Sonucu onluk tabana çevirerek değerini kontrol edelim;
Sonuç = -1.110x2-3=-0.0011102=-0.001112
=-7/25
10=-7/3210=-0.2187510
77
Örnek 3; -1810 ve 9.510 sayılarını IEEE 754 single
precision formatında çarpalım.
X= -18 = 100102
Y=9.5 = 1001,12
(1) Exponentleri topla
Ex + Ey
- 12710= 1000 0011 + 1000 0010 – 01111111
= 1000 0110
(2) Fraction kısımlarının çarpımı
1.0010 0000… 0000 x 1.0011 0000 … 0000
= 01. 0101 0110 0000 … 0000 0000
78
1 10000011 00100000000000000000000
0 10000010 00110000000000000000000
46 bit uzunluğunda
Sonuç single precision olacağı için fraction kısmı
24 bit uzunluğuna indirilmelidir.
Fraction = 1.0101 0110 0000 0000 0000 000
(3) Fraction kısmının normalize edilmesi
gerekmiyor.
(4) overflow? Yok underflow? Yok
(5) İşaret biti
Sx XOR Sy = 1 xor 0 = 1
Sonuç;
79
S E F
1 1000 0110 0101 0110 0000 0000 0000 000
MIPS
MIPS’te otuziki tane 32bitlik register($f0 - $f31) içeren floating point
coprocessor(yardımcı işlemci) bulundurmaktadır. IEEE 754 single
precision ve double precision formatlarında işlem yapmak için
aşağıdaki kodlar registerları ile birlikte kullanılmalıdır.
• Toplama, single (add. s), double (add . d)
• Çıkarma, single (sub. s), double (sub .d)
• Çarpma, single (mul. s), double (mul .d)
• Bölme, single (div. s), double (div .d)
• Karşılaştırma, single (c .x. s), double (c. x .d)
x değişkeni equal(eq), not equal(neq), less than(lt), less than or
equal(le), greater than(gt) veya greater than or equal(ge) olabilir.
• branch, true (bclt), false (bcIf)
80
Floating-point comparison(karşılaştırma) ve Branch
şarta bağlı olarak bir biti true veya false yapar.
lwcl ve swcl komutları ile floating point single ve
double precision registerlarına ($fO, $f1, $f2, ...)ayrılarak
yazılmasını sağlayan komutlardır. Verilen MIPS kodu, 2
single precision sayıyı hafızadan alıp(load), topladıktan
sonra hafızaya yollamaktadır(store).
lwcl $f4,x($sp) # Load 32-bit F.P. number into F4
lwcl $f6,y($sp) # Load 32-bit F.P. number into F6
add.s $f2.$f4.$f6 # F2 = F4 + F6 single precision
swcl $f2.z($sp) # Store 32-bit F.P. number from F2
81
82
83
84
Floating-Point C Programının MIPS Assembly
kodunda derlenmesi
Örnek; Fahrenheit (Fo
)’ı Celsius(Co
)’a çevirelim:
float f2c (float fahr)
{return((5.0/9.0) * (fahr- 3 2.0));}
Sıcaklığın(Fahr) $f12’de, 5.0, 9.0 ve 32.0 sayılarının floating
point değerlerin hafızada tutulan sabitler (sabitlere erişim
pointer $gp) olduğunu varsayalım. Elde edilen sonucun(Co
)
$ f0 registerına yazılması isteniliyorsa, MIPS assembly kodu:
85
f2c:
Hafızadan sabitlerin alınması
Iwcl Sfl6.const5(tgp) # $f 16 - 5.0 (5.0 In memory)
lwcl Sfl8.const9($gp> # $f19 - 9.0 (9.0 in memory)
Fraction kısmını oluşturan 5.0/9.0
div.s $f16. $f16. If18 # $fl6 = 5.0 / 9.0
32.0 sabitinin hafızadan alınıp, sıcaklıktan (fahr =$f12) çıkarılması:
lwcl If18. const32(Sgp) 9 Sfl8 - 32.0
sub.s $fl8. $f 12. If 18 y/ If 18 = fahr - 32.0
Elde edilen 2 sonucun çarpılarak $f0 register’ına gönderilmesi
mul.s$fO, $f16, $f18 # $f0 = (5/9>*<fahr - 32.0)
jr $ra # return
86
87
88
Performans Değerlendirmesi
ve Anlaşılması
Giriş
• Amaç; Bir bilgisayar için aşağıda belirtilen sorulara
cevap bulmaktır?
• Performans nasıl ölçülür?, raporlama ve özetleme ?
• Performansı hesaplamak için ana parametrelerin
belirlenmesi..
• Niçin bazı donanımlar farklı programlar için diğerlerinden
daha iyidir?
• Sistem performansının hangi parametreleri donanımla
alakalıdır.?
• Komut seti, performansı nasıl etkiler?
Performans
Bir bilgisayarın diğerinden daha iyi performansa sahip olması ne
demektir? Bu soruya yolcu uçaklarına benzetme yaparak cevap verelim.
Tabloda tipik yolcu uçakları, seyir hızları, seyir mesafeleri ve
kapasiteleri verilmiştir. Eğer bu tablodaki uçaklardan hangisinin en iyi
performansa sahip olduğunu bulmak istersek ilk önce performans
kelimesi ile ne kastettiğimizi bilmeliyiz. Örneğin en yüksek seyir hızına
sahip olan uçak Concorde’dur, en uzun yolu DC-8 giderken en yüksek
kapasiteye 747 sahiptir.
Bireysel bir bilgisayar kullanıcısı olarak response (cevap süresinin)
kısalmasını isteriz.
Datacenter yöneticileri ise genelde birim zamanda üretilen veri
miktarının veya bant genişliğinin artmasını isterler.
Dolayısıyla çoğu zaman farklı performans metriklerine sahip oluruz.
• Response time (Cevap Zamanı), Latency (Gecikme) veya
Execution (Elapsed) time (Yürütme zamanı):
Bir işi tamamlamak için harcanması gerekli toplam
zaman (Hafıza erişim zamanı, CPU time, I/O, v.b. gibi
donanımlarla alakalıdır). Yani bir programın sonu ve başı
arasındaki harcanan zamandır.
İşimi çalıştırmak ne kadar sürer?
Bir işi yürütmek ne kadar sürer?
Veri tabanını sorgulamak için ne kadar beklemeliyim?
Gibi sorular bu terimlerle ilgilidir.
• Response zamanını minimize etmek, performansı
maximize etmektir.
• Throughput (Veri - çıktı): Verilen bir sabit
zamanda yapılan toplam iş miktarıdır.
Bir seferde kaç tane işi makinada çalıştırılabilir?
Ortalama yürütme oranı nedir?
Ne kadar iş yapıldı?
Gibi sorular bu terimle ilgilidir.
• Eğer yeni bir işlemci ile makinayı upgrade yaparsak neyi
arttırmış oluruz?
• Eğer laboratuvara yeni bir makina eklersek neyi arttırmış
oluruz.
• CPU time: Giriş çıkış sayısı veya başka programların
harcadığı zaman değildir.
•CPU’nu bir program için hesaplamaya harcadığı zamandır.
Bu terim bekleme sürelerini veya giriş/çıkış işlemleri için
harcanan zamanı içermez.
•Kullanıcı CPU zamanı: Bir program için CPU’nun harcadığı
zamandır.
•Sistem CPU zamanı: işletim sisteminde görevleri yerine
getirmek için CPU ‘nun harcadığı
•Biz kullanıcı(user) CPU time’ a odaklanacağız.
Program Performansını Anlamak
• Bir programın performansını geliştirmek için öncelikle
performans ölçütlerini açıkça belirlemek ve bundan
sonra performansı kısıtlayan darboğazlara bakmak
gereklidir.
• Bir bilgisayar kullanıcısı açısından yalnızca süre ile ilgili
endişeler olsa da, daha detaylı bakıldığında diğer
performans ölçütleri de göz önünde bulundurulmalıdır.
Özellikle bilgisayar tasarımcıları, donanımın basit
fonksiyonları ne kadar hızlı gerçekleştirdiklerini belirleyen
bir ölçüt isteyebilirler.
• Neredeyse bütün bilgisayarlar, olayların donanım
tarafından ne zaman gerçekleştirileceğini belirleyen bir
saat kullanmak üzere tasarlanmışlardır. Bu ayrık zaman
gecikmeleri saat döngüsü (darbe, saat darbesi, saat
periyodu, saatler, çevrimler (cycles)) olarak isimlendirilir.
Verim ve execution (yürütme) time ile ilgili
• X ve Y makinalarında çalışan programlar için verim,
PerformanceX = 1 / Execution timeX
Performancex > Performancey
1 / Execution timex > 1 / Execution timey
Execution timey > Execution timex
• X, Y den n kez daha hızlıdır.
PerformanceX / PerformanceY = n
Execution timey
/ Execution timex= n
Problem: A makinası bir programı 20 sn’de çalıştırıyor.
Aynı programı B 25 saniyede çalıştırıyor. A, B’den ne kadar
hızlıdır.
Çözüm:
PerformanceA
/ PerformanceB= Execution timeB
/ Execution timeA= n
Buna göre performans oranı = 25 / 20 = 1.25 = n
PerformanceA = PerformanceB x 1.25
Yürütme zamanı yerine sık sık biz cycle terimini kullanırız.
(h/w tasarımcının görüşü)
CPU execution time = CPU clock cycles x clock cycle time
• “Ticks” aktiviteler başladığı zamanki clock’ u gösterir.
• cycle time (period) = time between ticks = seconds per cycle
• clock rate (frequency) = cycles per second = 1/ cycle time
• (1 Hz. = 1 cycle/sec), 4 Ghz’ ‘lik clock’un cycle periyodu
• Performansı geliştirmek için yukarıdaki bağıntıya göre
neler yapılabilir.?
1- Bir program için gerekli Cycle’ların sayısının azaltılması
2- Clock cycle time (Periyot) azlatmak
3- Diğer ifadeyle clock rate (Frekans) arttırmak.
Örnek
• Programımızı A bilgisayarı 10 sn’de çalıştırıyor. A bilgisayarı 4 Ghz
lik Clock’a sahiptir. B bilgisayarı programı 6 sn de çalıştırıyor. B
bilgisayarı A’nın clock cycles’ları sayısının 1.2 katına ihtiyaç
duymaktadır. B ne kadarlık bir clock zamanına ( veya frekansına)
sahiptir?
• Çözüm:
Komutların sayısını clock’ların sayısına eşit farz edebilirmiyiz?
• Çarpma toplamadan daha çok zaman alır.
• Floating point sayılarla işlem tamsayılarla işlemlerden daha uzundur.
• Hafızaya erişim registerlere erişimden daha uzun zaman alır.
Bu düşünce yanlıştır.Çünkü farklı
komutlar farklı makinalarda farklı
zaman alırlar.
Niçin? Makine kodlarını hatırlayın!
Ortalama Clock Cycle’ı
•Bir programda execution time (yürütme zamanı) doğrudan doğruya
komutların sayısına bağımlıdır.
•Buna göre, bir programın yürütme zamanı hesabı için başka bir yolda;
yürütülen komutların sayısı ile, her komut için harcanan ortalama zamanın
çarpılmasıdır.
CPU execution time = CPU clock cycles x clock cycle time
(CPU yürütme zamanı = CPU clock sayısı x clock periyodu)
Veya;
CPU execution time = Programdaki komut sayısı x CPI x clock periyodu
Clock cycles per instruction (CPI); Bir program için bir komut
başına clock cycle’ının ortalama sayısıdır. Buna göre bir programın
harcayacağı clock sayısı:
CPU Clock cycles = Programdaki komutların sayısı x CPI
• Verilen bir program için
Bazı komutların sayısı (makine komutları)
Bazı cycle’lar sayıları
Bazı seconds sayıları gereklidir.
• Bu nicelikler ile ilgili kelimeler;
cycle zamanı (cycle başına saniye)
clock rate (saniye başına cycle)
CPI (komut başına ortalama cycle’lar)
• Yoğun floating point uygulamaları daha yüksek CPI
gerektirir.
• Performans, yürütme (execution) zamanı tarafından
belirlenir.
Diğer değişkenlerin hangisi performansa eşittir.
• Yürütülen program için Cycle’lerin sayısı?
• Programda komutların sayısı?
• Saniye başına cycle’ların sayısı (Frekans)?
• Komut başına cycle’ların ortalama sayısı?(CPI)
• Saniye başına komutların ortalama sayısı?(MIPS)
Yaygın hata: değişkenlerin birini düşünmek performansı
gösterir ancak gerçekçi değildir.
CPI aynı ISA (komut seti)’ nin farklı gerçekleştirmelerini
karşılaştırmak için iyi bir ölçümdür.
• Farzedin ki aynı komut seti mimarisi ile gerçekleştirilmiş iki
farklı makinaya sahibiz.
• A makinasının Clock cycle süresi 250 ps ve aynı program
için 2.0 CPI ya sahiptir.
• B makinasının Clock cycle süresi 500 ps ve 1.2 CPI ya
sahiptir.
• Bu program için hangi makine daha hızlıdır. Ne kadar
hızlıdır?
• Eğer iki makine aynı ISA’ya sahipse (clock rate, CPI,
yürütme zamanı, komutların sayısı, MIPS) daima benzer
olacaklarmıdır?
Çözüm:
• Verilere göre her iki bilgisayarda, aynı program için benzer sayıda komut
işler. Bu sayıya I diyelim.
• İlk olarak her bir bilgisayar için clock cycle sayısını bulalım.
– CPU clock cyclesA = I x 2.0
– CPU clock cyclesB = I x 1.2
Buradan her bir bilgisayar için CPU time’i hesaplayabiliriz.
CPU timeA = CPU clock cyclesA x Clock cycles timeA
= I x 2.0 x 250 ps = I x 500 ps
CPU timeB = CPU clock cyclesB x Clock cycles timeB
= I x 1.2 x 500 ps = I x 600 ps
Anlaşılacağı gibi A bilgisayarı daha hızlıdır.
PerformanceA
/ PerformanceB= Execution timeB
/ Execution timeA= n
= Ix600ps / Ix500ps = 1.2
CPU time = komut sayısı x CPI x Clock cycle time
Kod Segmentlerinin karşılaştırılması
• Bir derleyici tasarımcısı iki kod dizileri arasında karar vermeyi
deniyor. Donanım aşağıdaki mimarileri desteklemektedir.
• 3 farklı komut sınıfı vardır. A, 1 cycle, B, 2 cycle, C 3 cycle ihtiyaç
duyuyor.
• İlk kod dizisi 5 komuta,(A=2, B=1,ve C=2)
• İkinci kod dizisi 6 komuta sahiptir. (A=4, B=1 ve C=1.)
• Hangi size göre daha hızlıdır. Ne kadar?
• Herbir dizi için CPI?
Çözüm:
• 1.kod dizisi (2 + 1 + 2 = 5 komut)
• 2.kod dizisi ( 4 + 1 + 1 = 6 komut ) kullanır.
• n komut sınıflarının sayısı, Ci
i. Sınıfın komutlarının sayısı ise yukarıdaki
formüle göre, her iki komut dizisine göre CPU clok cycles’ı (Clock periyodu
sayısını) bulabiliriz.
Buna göre 2.kod dizisi daha hızlı olsa bile fazladan 1 komut işleyecektir.
Dolayısıyla daha düşük bir CPI’ye sahip olmalıdır.
Örneğe devam:
• Bu örnek gösterir ki; performans değerlendirme için yalnızca bir
kıstas (Burada komut sayısı kullanılsaydı) kullanmak yanıltıcı
olabilir.
• İki bilgisayarı performans açısından karşılaştırmak için, (yürütme
zamanı- execution time) her üç bileşeni ( Komut sayısı, CPI, Clock
Cycle time (periyot)) dikkate almak gerekir.
• Eğer bileşenlerden bir kısmı özdeş ise, performans karşılaştırması
özdeş olmayan bileşenlere göre yapılır. Örneğin her iki bilgisayarın
frkansları ayni ise karşılaştırma; komut sayısı ve CPI’ya göre
yapılabilir.
• Performas’a ve CPI’ye etki eden en büyük faktör isePİPELİNE
mimarisidir ki bu konu daha ileride detaylandırılacaktır.
Performans değerlendirilmesi
• İki veya daha fazla bilgisayar arasındaki performans değerlendirmesini
nasıl yaparız.?
• İki bilgisayarın performansını değerlendirmek için; bu iki bilgisayarda
bir workload ’(tanımlıbir işlemler kümesi programı)’un yürütme
(execution) zamanları karşılaştırılır.
• Benchmark “ Bir ölçme veya değerlendirme standartı "dır. Bir
bilgisayar benchmarkı; tipik bir şekilde tanımlı workload’u
gerçekleştiren bilgisayar programıdır.
• Bilgisayar benchmark için ölçülen metrikler;
Hız: Bir workload’ın nekadar hızlı tamamlandığı.
Throughput:: Bir birim zamanda tamamlanan workload birimi’dir.
• Birden fazla bilgisayarda aynı bilgisayar benchmarkı çalıştırılarak bir
karşılaştırma yapılmasını sağlar.
• Performans en iyi gerçek bir uygulamanın çalıştırılmasıyla belirlenir.
• Küçük kriterler
Mimarlar ve tasarımcılar için güzel
Standardize etmek kolay
Kötüye kullanılabilir.
• SPEC (System Performance Evaluation Cooperative) şirketler
gerçek program ve giriş kümeleri hakkında anlaşmaya varmışlardır.
CPU- yoğunluklu kriterleri kullanarak sunucular ve iş
istasyonları üzerinde duruluyor.
• Şimdilerde CPU performansı, grafik, yüksek performanslı
hesaplama, nesneye yönelik hesaplama,Java uygulamaları, client
server modelleri, mail sistemleri , Dosya sistemleri ve web serverler.
İçeren performans testleri önem kazanmıştır.
Performans Raporu
• Hazırlıktan sonra performans ölçümleri seçilen uygun
kriterler kümesinden elde edilir.
• Tekrarlanabilirlik :rapordaki diğer herşey dahil, deneyler
rapor edilen sonuçları çoğaltmak gerekir. (O/S version,
derleyici, giriş, bilgisayar konfigürasyonu, gibi)
• Girişlerin seçimi çok önemlidir. Büyük girişler bellek
sistemini değerlendirmek için gereklidir. Ayrıca büyük iş
yükü gereklidir.
• Kriterlerin bir grubunun performansını özetlemek için
nasıl karar verildiği kritiktir.
• Özet hesaplama nasıl yapılmalıdır.
• Aşağıdaki örneği göz önüne alınız.
• Program 1 için A, B’den 10 kat daha hızlıdır.
• Program 2 için B, A’dan 10 kat daha hızlıdır.
• Toplam sonucu nedir?
• Sürekli özet ölçümü
• Böylece bağıl performansı özetlemek için 2 programın toplam
yürütme zamanını kullanabiliriz.
• Böylece B, A’dan 9.1 kat daha hızlıdır.
• Yürütme zamanının ortalaması toplam yürütme zamanına oranıdır.
Bu ise aritmetik ortalamadır.
• Weighted AM (Ağırlaştırılmış aritmetik ortalama): iş yükünde
programın frekansını yansıtmak için her bir programa ağırlık faktörü
atanır.
• Farzedinki 4 farklı desktop seçiyorsunuz. (apple
Macintosh, Pentium 4, AMD, Pentium 5)
• En hızlı bilgisayar en yüksek clock rate’ sahip olan
olacaktır.
• Bütün bilgisayarlar aynı komut setini kullandığı için(intel
ISA) komutların sayısı aynıdır. En hızlısı en yüksek clock
rate sahip olan olacaktır.
• AMD işlemci farklı CPI’lara sahip olabilir. Ancak biz clock
rate bakarak iki pentium işlemcinin daha hızlı olduğunu
söyleyebiliriz.
• Benzer işler için kriterlerin sonuçlarına bakarak tam bir
performans elde edebiliriz.
• Aşağıdakilerden hangisi doğrudur.
• Program 1 için A B’den daha hızlıdır.
• Program 2 için A B’dan daha hızlıdır.
• Program 1 ve 2’nin yürütmelerinin sayısı eşit işyükü için
A B’den daha hızlıdır.
• Program 2’nin program 1’den 2 kat daha işyükü için A
B’den daha hızlıdır.
• 12 integer 14 floating point program
• Herbir grup için farklı özetler.
• Clock rapor edilir ancak Çoğunlukla harcanan zaman
CPU’dadır. CPU performansı ölçülür.
• Performans skalası clock rate ile hemen hemen lineerdir.
• Diğer gözlemler?
• Bir clock rate tarafından bölünen CFP2000 ve
CINT2000’in ortalama değerlerine bakınız.
• CINT2000/Clock ratePentium III = 0.47Pentium 4 = 0.36
• CFP2000/Clock ratePentium III = 0.34Pentium 4 = 0.39
SPECweb99
• Verime odaklanır.Bir web server bağlantılarının
maksimum sayısının ölçümünü destekleyebilir.
• Çoklu işlemciler sık sık kullanılır.
• Web server s/w sistem ölçümlerinin bir bölümüdür.
• SPECweb99 performansı bir çok sistem karakteristiğine
bağlıdır. (disk sürücülerinin sayısı, CPU’ların sayısı,
ağların sayısı, clock rate)
• Örnek: Pentium III Xeon w/ 7 disk drives, 8 CPUs, 8
networks, at 0.7GHz, Pentium Xeon 4 w/ 5 disk drives, 2
CPUs, 4 networks, at 3.06GHz ‘dan çok daha hızlıdır.
• Güç işlemci performansı için anahtar sınırlama oluyor.
• Batarya güçleri yavaş gelişiyor
• İşlemciler etkili işletilebilmek için tasarımlanmalıdır. Farklı
clock rate’ler arasında anahtarlanabilmeli ve güç
korunabilmelidir.
• 3 işletim modu varsayılır.
Maximum güç: maximum clock rate→ en iyi performans
Laptop mode: adaptif clock rate
Minimum güç: minimum clock rate → en iyi güç verimliliği
• Enerji verimliliği:kriterler çalışıyorken performans ortalama
güç tüketimi tarafından bölünür
• Hangi makinedaha düşük clock rate ile
daha yüksek performansa sahiptir.
• Performans özel programlara özgüdür.
• Toplam yürütme zamanı performansın tutarlı bir özetidir.
• Mimari performansı arttırmak için
Clock rate’yi arttırmak
İşlemci organizasyonunu geliştirmek,düşük CPI
Compiler geliştirme,düşük CPI ve düşük komut sayısı
Komut sayısını etkileyecek algoritma/dil seçmek
• Birçok tuzak,
Makine performansının bir yönünü geliştirmeyi ummak
toplam performansı etkiler. (Amdahl kanunu )
Performans metriği olarak bir alt performans denklemi
kullanılarak (MIPS ölçümleri)
• Örnek; bir makinada, bir program 100 saniyede
çalıştığını farzedelim. Bu zamanın 80 sn’si çarpma
içindir. Biz programı 4 kat daha hızlı çalıştırmak istersek
çarpma hızını nekadar çok geliştirmeliyiz.
• Programı, 5 kat daha hızlı nasıl yapabiliriz.?
• MIPS = Million Instructions Per Second
• Anlamak kolaydır,belli varsayımlar altında performans
belirlemekte kullanılır.
• “whole picture” vermediği için Çoğu kez yanlış olabilir.
• Yürütme oranı tanımlar ancak komut yetenekleri
görünmez
• Farklı ISA’lar ile bilgisayar karşılaştırmada kullanılamaz.
Niçin?
• İki farklı compiler 4 Ghz lik bir makinada 3 farklı komut
sınıfı için test ediliyor. Class A, Class B, ve C Class,
sırasıyla 1, 2, ve 3 cycle gereklidir.
• Her iki compiler yazılımın büyük bir parçası için kod
üretmede kullanılır.
• İlk compilerin kodu 5 million Class A komut, 1 million
Class B komut, and 1 million Class C komut kullanıyor.
• İkinci compiler kodu 10 million Class A komut,1 million
Class B komut, ve 1 million Class C komut kullanıyor.
• Hangi dizi MIPS’e göre daha hızlıdır.
• Yürütme zamanına göre hangi dizi daha hızlıdır.
Bölüm: 5
İşlemci: Datapath ve Kontrol
Slide Kaynağı: Patterson & Hennessy COD
book website (copyright Morgan Kaufmann)
adapted and supplemented
Önemli bir problemin çözümünde, hiçbir
detay önemsiz değildir – French Proverb
Adam haklı – Hayrettin Can
 Biz şimdi bir MIPS komut setinin gerçekleştirilmesini incelemeye
hazırız.
 Komut yapılarını ana hatlarıyla hatırlayalım.
 Aritmetik-Lojik komutlar: add, sub, and, or, slt
 Hafıza-tabanlı komutlar: lw, sw
 Kontrol-Akış komutları: beq, j
MIPS’in gerçekleştirilmesi
op rs rt offset
6 bits 5 bits 5 bits 16 bits
op rs rt rd shamt funct
6 bits 5 bits 5 bits 5 bits 5 bits 6 bits
R-Format
I-Format
op address
6 bits 26 bits
J-Format
 Fetch/execute gerçekleştirme işlemine yüksek seviye ayrıştırmayla bakarsak:
 Komut adresini okumak için program Counter (PC) kullanılır.
 Komutun hafızadan alınması ve PC’nin arttırılması.
 Okunacak registerleri seçmek için için komut yapısındaki alanları kullan. Örneğin
transfer komutu (Load, store) sadece 1 registerin okunmasına gerek duyar fakat
diğer komutlar 2 reg’in okunmasına gerek duyar.
 Komut sınıfına bağlı yürütme (execute ) işlemi.
 Tekrar…….
MIPS’in gerçekleştirilmesi: Fetch/Execute Çevrimi
Dikkat ediniz ki çoğu komutlar doğrudan icra edilir ve bir sonraki komutun adresi PC+4 ile yazılır. Fakat
dallanma veya atlama komutlarında ise ALU dallanılacak yeni komut adresini hesap edebilir. Veya şartsız
dallanma komutlarında ise PC+4 ikinci bir toplama ile dallanılacak komutun adresi elde edilir.
Komut getirildikten sonra, formatına
göre operandlar ilgili reg’lere getirilip
işlenir. Veya ana hafıza ya load/store
edilebilir.
İşlemcilerde gerçekleştirme stilleri
 Tek Cycle
 Herbir komut 1 clock cycle’da icra edilir.
 Clock en yavaş komutlar için yeterince uzun olmalıdır.; Bu
yüzden,
 Dez avantaj: sistem en yavaş komut kadar hızlıdır.
 Çoklu-Cycle
 Çoklu-cycle adımlarında fetch (Alma)/execute(Yürütme) yapılır
 Her bir clock cycle’da 1 adım icra edilir.
 Avantajı: Her bir komut ihtiyacı kadar birkaç cycle kullanır.
 Pipeline
 Herbir komut çoklu adımlarda yürütülür.
 Her bir clock cycle’da 1 adım/komut icra edilir.
 Paralel olarak çoklu komutlar işlenir – assembly line
 Donanımda 2 tip fonksiyonel eleman vardır.
 Veri üzerinde işlem yapan elemanları : (Kombinasyonal elemanlar
olarak adlandırılır – Toplayıcılar v.b.)
 Veri içeren elemanlar: (state veya ardışıl elemanlar olarak
adlandırılır. Hafıza elemanları v.b)
Functional Elemanlar
Kombinasyonal Elemanlar
 giriş  çıkış fonksiyonları gibi çalışır . örneğin; ALU
 Kombinasyonal lojik, bir registerden okur veya bir registere veya
okuduğu registere yazar.
 read/write bir cycle’da meydana gelir. – kombinasyonal eleman
gelecekte kullanabilmek için veri depolayamaz
Clock cycle
State
element
1
Combinational logic
State
element
2
State
element
Combinational logic
Combinational logic donanım birimleri
State (Durum) Elemanlar
 State elemanlar dahili hafızaları içerir. Ör: registers ve hafıza.
 Bütün state elemanlar makinanın durumunu tanımlar
 Bunun anlamı nedir? Tekrar açmayı ve kapatmayı düşün.
 Flipflops ve latches are 1 bitlik state elemanlardır, Eşdeğeri 1
bitlik hafızalardır.
 Flip-flop veya Latch’in çıkış(ları) daima saklanan bit değerine
bağlıdır. Onların durumu 0/1 veya yüksek/düşük veya
doğru/yanlış olarak adlandırılır.
 Bir flip-flop veya latch’in girişi onun durumuna bağlı olarak
clock olup olmadığına göre değişebilir.
Set-Reset (SR-) latch (unclocked)
Q
Qbar
Sbar
(set)
Rbar
(reset)
n1
n2
Q
_
Q
R
S
NOR latch
 Clock işareti; bir state elemanını (FF’lar barındıran) senkronlamak veya
ona yaz/oku yapmayı denetlemek için kullanılır.
 Genellikle kenar tetiklemeli (Yükselen/Düşen) state elemanları kullanılır.
 Latch’ler seviye tetiklemelidir.
 Flip-flops are kenar teteiklemelidir.
Senkronize Lojik:
Clock girişli FF’lar veya LATCH’ler
Clock period Rising edge
Falling edge
 Durum (Q) sadece clk’nın 1 olduğu zamanda değişebilir.
 Tek bir data (D) girişi vardır. (SR-latch ile karşılaştırıldığında)
 Tanımlanmamaış davranışı yoktur.
Clock girişli D-latch
D
C
Q
D-LATCH’in zamanlama diyagramı
D
Q
Qbar
n1
n2
clk
r2
r1
a1
a2
clkbar
X
Y
Dbar
Clock girişli D-flipflop
 Negatif kenar tetiklemeli FF’dır.
 3 tane S-R Mandal’la yapılır.
sbar
s
r
q
qbar
rbar
clear
clk
cbar
d
clkbar
 Registerler D-flipflop’ların dizisi ile gerçekleştirilir.
Data path’de durum(State) elemanları:
Register File
Register file iki okuma portu ve 1 yazma portuna sahiptir.
 Port gerçekleştirme:
n-to-1
decoder
Register 0
Register 1
Register n – 1
C
C
D
D
Register n
C
C
D
D
Register number
Write
Register data
0
1
n – 1
n
M
u
x
Register 0
Register 1
Register n – 1
Register n
M
u
x
Read data 1
Read data 2
Read register
number 1
Read register
number 2
32 register için oku portları
5 bit mux’ların çifti ile
gerçekleştirilir.
Yazma portu bir decoder kullanılarak
gerçekleştirilir. 32 register için 5’e 32’lik
decoderdir. Yazma işlemi Clock ile ilişkilidir.
(Yükselen veya düşen kenar)
Clock
Clock
DATA PATH’de durum(state) elemanları:
Register File
Verilog - VHDL
 Donanım tanımlama dili, Bütün donanımlar Verilog veya VHDL
donanım tanımlama dili kullanılarak gerçekleştirilebilir.
 Detaylı bilgi ve örnekler için Verilog, VHDL slide’larına bakınız
MIPS’in tek Cycle’da gerçekleştirme
 MIPS komut seti mimarisinin ilk gerçekleştirilmesinde her bir
komut için yeterince uzun tek bir clock cycle kullanacağız.
 Herbir komut yükselen veya düşen clock kenarı ile başlar ve
yükselen veya düşen kenar ile sonlanır.
 Bu yaklaşım pratik değildir. Multicycle işlemeden daha
yavaştır.Burada farklı komut sınıfları farklı cycle zamanları
alabilir.
 Herbir komut bir tek cycle gerçekleştirmede en yavaş komut kadar
zaman alır.
 multicycle gerçekleştirmede bir kaç cycle kullanılarak bu problemden
kaçınılır.
 Tek cycle yaklaşımı pratik olmamasına rağmen konuyu anlamak
için yararlı ve önemlidir.
 Note : we shall implement jump at the very end
Datapath: komut Store/Fetch & PC arttırma
PC
Instruction
memory
Instruction
address
Instruction
a. Instruction memory b. Program counter
Add Sum
c. Adder
Fetch ve depolama ve PC’ yi arttırmak için
3 elaman kullanılır
DATAPATH
Datapath Animasyonu
Instruction <- MEM[PC]
PC <- PC + 4
R D
Memory
ADDR
PC
Instruction
4
ADD
Datapath: R-Tipi Komut
ALU control
RegWrite
Registers
Write
register
Read
data 1
Read
data 2
Read
register 1
Read
register 2
Write
data
ALU
result
ALU
Data
Data
Register
numbers
a. Registers b. ALU
Zero
5
5
5 3
Instruction
Registers
Write
register
Read
data 1
Read
data 2
Read
register 1
Read
register 2
Write
data
ALU
result
ALU
Zero
RegWrite
ALU operation
3
R-type komutları gerçekleştirmek
için 2 eleman kullanıldı Datapath
Datapath Animasyonu …
add rd, rs, rt
R[rd] <- R[rs] + R[rt];
5 5 5
RD1
RD2
RN1 RN2 WN
WD
RegWrite
Register File
op rs rt rd shamt funct
Operation
ALU Zero
Instruction
3
Datapath: Load/Store Komutu
16 32
Sign
extend
b. Sign-extension unit
MemRead
MemWrite
Data
memory
Write
data
Read
data
a. Data memory unit
Address
Instruction
16 32
Registers
Write
register
Read
data 1
Read
data 2
Read
register 1
Read
register 2
Data
memory
Write
data
Read
data
Write
data
Sign
extend
ALU
result
Zero
ALU
Address
MemRead
MemWrite
RegWrite
ALU operation
3
load/store komutunu gerçekleştirmek için
İki ek eleman kullanıldı
Datapath
Datapath Animasyonu…….
lw rt, offset(rs)
R[rt] <- MEM[R[rs] + s_extend(offset)];
Datapath Animasyonu……
sw rt, offset(rs)
MEM[R[rs] + sign_extend(offset)] <- R[rt]
Datapath: Branch Instruction (Dallanma komutları)
16 32
Sign
extend
ALU Zero
Sum
Shift
left 2
To branch
control logic
Branch target
PC + 4 from instruction datapath
Instruction
Add
Registers
Write
register
Read
data 1
Read
data 2
Read
register 1
Read
register 2
Write
data
RegWrite
ALU operation
3
Datapath
Kaydırma donanımı gerekli değildir:
Basit olarak girişler çıkışlar bağlıdır
Herbir kaydırma 2 bit soladır.
Animating the Datapath
beq rs, rt, offset
if (R[rs] == R[rt]) then
PC <- PC+4 + s_extend(offset<<2)
MIPS Veriyolu I: Single-Cycle
Giriş ya register (R-type) yada komutun alt yarısı
R-tip komutlar ve load/store için
veriyolu oluşturmak için 2 mux kullanılır
Veri ya ALU’dan (R-type)
Yada hafızadan (load)
R-tipi komutun çalışması
add rd,rs,rt
5 5 1 6
RD1
RD2
RN1 RN2 WN
WD
RegWrite
Register File
Operation
ALU
3
E
X
T
N
D
1 6 3 2
Zero
R D
WD
MemRead
Data
Memory
ADDR
MemWrite
5
Instruction
3 2
M
U
X
M
U ALUSrc X
MemtoReg
Load Komutunun Çalışması
lw rt,offset(rs)
5 5 1 6
RD1
RD2
RN1 RN2 WN
WD
RegWrite
Register File
Operation
ALU
3
E
X
T
N
D
1 6 3 2
Zero
R D
WD
MemRead
Data
Memory
ADDR
MemWrite
5
Instruction
3 2
M
U
X
M
U ALUSrc X
MemtoReg
Store komutunun Çalışması
sw rt,offset(rs)
5 5 1 6
RD1
RD2
RN1 RN2 WN
WD
RegWrite
Register File
Operation
ALU
3
E
X
T
N
D
1 6 3 2
Zero
R D
WD
MemRead
Data
Memory
ADDR
MemWrite
5
Instruction
3 2
M
U
X
M
U ALUSrc X
MemtoReg
MIPS Datapath II: Single-Cycle
PC
Instruction
memory
Read
address
Instruction
16 32
Registers
Write
register
Write
data
Read
data 1
Read
data 2
Read
register 1
Read
register 2
Sign
extend
ALU
result
Zero
Data
memory
Address
Write
data
Read
data
M
u
x
4
Add
M
u
x
ALU
RegWrite
ALU operation
3
MemRead
MemWrite
ALUSrc
MemtoReg
komut fetch’i ekleme
Komut ve veri okuma aynı
clock cycle da farklı komut
hafızada meydana gelir.
ALU işlemleri ve PC artımı aynı clock cycle’da farklı toplayıcılarda meydana gelir
MIPS DATA PATH III: Single-Cycle
PC
Instruction
memory
Read
address
Instruction
16 32
Add ALU
result
M
u
x
Registers
Write
register
Write
data
Read
data 1
Read
data 2
Read
register 1
Read
register 2
Shift
left 2
4
M
u
x
ALU operation 3
RegWrite
MemRead
MemWrite
PCSrc
ALUSrc
MemtoReg
ALU
result
Zero
ALU
Data
memory
Address
Write
data
Read
data M
u
x
Sign
extend
Add
dallanma yeteneğinin ve diğer mux’un eklenmesi
Instruction address is either
PC+4 or branch target address
Herbir cycleda her iki toplama
için exstra ikinci toplayıcıya
ihtiyaç vardır.
Yeni mux
Önemli not: single-cycle gerçekleştirmede veri komut boyunca
depolanamaz. Veri yalnızca kombinasyonal lojik yoluyla taşınır
Soru: Memread sinyaline gerçekten ihtiyaç varmıdır. RegWrite’ ı düşünün
DATAPATH: Executing add
add rd, rs, rt
5 5 1 6
RD1
RD2
RN1 RN2 WN
WD
RegWrite
Register File
Operation
ALU
3
E
X
T
N
D
1 6 3 2
Zero
R D
WD
MemRead
Data
Memory
ADDR
MemWrite
5
Instruction
3 2
M
U
X
ALUSrc
MemtoReg
ADD
<<2
R D
Instruction
Memory
ADDR
PC
4
ADD
ADD
M
U
X
M
U
X
PCSrc
DATAPATH Executing lw
lw rt,offset(rs)
5 5 1 6
RD1
RD2
RN1 RN2 WN
WD
RegWrite
Register File
Operation
ALU
3
E
X
T
N
D
1 6 3 2
Zero
R D
WD
MemRead
Data
Memory
ADDR
MemWrite
5
Instruction
3 2
M
U
X
ALUSrc
MemtoReg
ADD
<<2
R D
Instruction
Memory
ADDR
PC
4
ADD
ADD
M
U
X
M
U
X
PCSrc
DATAPATH Executing sw
sw rt,offset(rs)
5 5 1 6
RD1
RD2
RN1 RN2 WN
WD
RegWrite
Register File
Operation
ALU
3
E
X
T
N
D
1 6 3 2
Zero
R D
WD
MemRead
Data
Memory
ADDR
MemWrite
5
Instruction
3 2
M
U
X
ALUSrc
MemtoReg
ADD
<<2
R D
Instruction
Memory
ADDR
PC
4
ADD
ADD
M
U
X
M
U
X
PCSrc
DATAPATH Executing beq
beq r1,r2,offset
5 5 1 6
RD1
RD2
RN1 RN2 WN
WD
RegWrite
Register File
Operation
ALU
3
E
X
T
N
D
1 6 3 2
Zero
R D
WD
MemRead
Data
Memory
ADDR
MemWrite
5
Instruction
3 2
M
U
X
ALUSrc
MemtoReg
ADD
<<2
R D
Instruction
Memory
ADDR
PC
4
ADD
ADD
M
U
X
M
U
X
PCSrc
DATA PATH, Kontrol
 Ana Kontrol biriminin girişleri; Komut kodu formatındaki
opcode bitleri (6 bit)’dir.
 Ana Kontrol birimi aşağıdaki çıkışları üretir.
 ALU kontrol girişleri ( 2 bit input)
 Yazma enable (olası olarak, okuma enable ) her bir
depolama elemanları için sinyal.
 Herbir mux için seçme kontrolü
Kontrol Birimleri
ALU Kontrol Bloku Ana Kontrol Birimi devre şeması
ALU Kontrol
 ALU kontrol planı: Ana kontrol birimi; ALU kontrol birimi girişine iki bit
(ALUop kontrol) gönderir. ALU kontrol birimi girişine ayrıca komutun 6
bitlik funct bitleri de uygulanır. Çıkışta, ALU kontrolu için 3 bitli oluşur.
 ALU kontrol alanı Fonksiyon
000 and
001 or
010 add
110 sub
111 slt
 ALU icra etmelidir.
 load/stores için add (ALUOp 00)
 Dallanma için sub (ALUOp 01)
 and, or, add, sub, slt R-type komutlarının biri için, 6 bit funct alanınına
bağlıdır. (ALUOp 10)
Main
Control
ALU
Control
2
ALUOp
6
Instruction
funct field
3
ALU
control
input
To
ALU
Recall from Ch. 4
ALU kontrol bit ayarları
komut AluOp komut Funct Alanı İstenen ALU
opcode işlemi ALU etkisi girişi
LW 00 load word xxxxxx add 010
SW 00 store word xxxxxx add 010
Branch eq 01 branch eq xxxxxx subtract 110
R-type 10 add 100000 add 010
R-type 10 subtract 100010 subtract 110
R-type 10 AND 100100 and 000
R-type 10 OR 100101 or 001
R-type 10 set on less 101010 set on less 111
ALU kontrol bitleri için doğruluk tablosu
ALUOp Funct field Operation
ALUOp1 ALUOp0 F5 F4 F3 F2 F1 F0
0 0 X X X X X X 010
0 1 X X X X X X 110
1 X X X 0 0 0 0 010
1 X X X 0 0 1 0 110
1 X X X 0 1 0 0 000
1 X X X 0 1 0 1 001
1 X X X 1 0 1 0 111
*, eğer X olursa, *
ozaman satır 2 ile
3-7 arası çatışma
Vardır.
Ana kontrol Birimi tasarımı
 MIPS komut formatları hakkında gözlemler
 opcode daima 31-26 bitlerindedir.
 Okunabilen 2 register daima rs (bits 25-21) ve rt (bits 20-16) dir.
- load/stores için base register daima rs (bits 25-21) dir.
 Dallanma ve load/store için 16-bit offset daima 15-0 bitleridir.
 Load için hedef register 20-16 (rt) bitlerindedir. R-type komutlarda
15-11 (rd) bitleridir. (bunun için mux ile seçmek gereklidir)
31-26 25-21 20-16 15-11 10-6 5-0
31-26 25-21 20-16 15-0
opcode
opcode
rs
rs
rt
rt address
R rd shamt funct -type
Load/store
or branch
DATA PATH ve kontrol I
MemtoReg
MemRead
MemWrite
ALUOp
ALUSrc
RegDst
PC
Instruction
memory
Read
address
Instruction
[31– 0]
Instruction [20– 16]
Instruction [25– 21]
Add
Instruction [5– 0]
RegWrite
4
16 32 Instruction [15– 0]
0
Registers
Write
register
Write
data
Write
data
Read
data 1
Read
data 2
Read
register 1
Read
register 2
Sign
extend
ALU
result
Zero
Data
memory
Address
Read
data
M
u
x
1
0
M
u
x
1
0
M
u
x
1
0
M
u
x
1
Instruction [15– 11]
ALU
control
Shift
left 2
PCSrc
ALU
Add
ALU
result
MIPS DATAPATH III’e kontrol ekleme (ve özel hedef register için alan seçmek için yeni bir
mux): 9 kontrol sinyallerinin fonksiyonları nedir?
New multiplexor
Kontrol sinyalleri
Signal Name Effect when deasserted (Lojik 0) Effect when asserted (Lojik 1)
RegDst yazma registeri için hedef register sayısı yazma registeri için hedef register sayısı
rt alanı (bits 20-16) rd alanı (bits 15-11)
RegWrite None Write register girişindeki datayı, hedef reg’e
yazar.
ALUSrc ikinci ALU operandı İkinci ALU operandı is the sign-extended,
ikinci register file çıkışından gelir(Read data 2) komutun düşük 16 bitine sign-extended dir
PCSrc PC toplayıcının çıkışı tarafından yer değiştirilir. PC Toplatıcının çıkışı tarafından yer değiştirilir.
bu PC + 4 ile hesaplanır bu hedef dallanmayla hesaplanır.
MemRead None Data memory içeriği giriş adresine göre belirlenir
bu giriş ilk ilk Read data çıkışına konur
MemWrite None Data memory içeriği giriş adresine göre belirlenir
bu giriş Write data ğirişinin değeri tarafından değiştirilir.
MemtoReg ALU’dan gelen değeri Write Data memory’den gelen değeri Write
data giriş registerine yaz data giriş registerine yaz
Yedi kontrol sinyalinin etkileri
Datapath with Control II
PC
Instruction
memory
Read
address
Instruction
[31– 0]
Instruction [20 16]
Instruction [25 21]
Add
Instruction [5 0]
MemtoReg
ALUOp
MemWrite
RegWrite
MemRead
Branch
RegDst
ALUSrc
Instruction [31 26]
4
16 32
Instruction [15 0]
0
0 M
u
x
0
1
Control
Add
ALU
result
M
u
x
0
1
Registers
Write
register
Write
data
Read
data 1
Read
data 2
Read
register 1
Read
register 2
Sign
extend
M
u
x
1
ALU
result
Zero
PCSrc
Data
memory
Write
data
Read
data
M
u
x
1
Instruction [15 11]
ALU
control
Shift
left 2
ALU
Address
Kontrol birimi ile MIPS Veri yolu: Kontrol girişi 6-bit komut opcode alanıdır.
Çıkış 7, 1-bit signal ve 2-bit ALUOp sinyalidir.
Instruction RegDst ALUSrc
MemtoReg
Reg
Write
Mem
Read
Mem
Write Branch ALUOp1 ALUp0
R-format 1 0 0 1 0 0 0 1 0
lw 0 1 1 1 1 0 0 0 0
sw X 1 X 0 0 1 0 0 0
beq X 0 X 0 0 0 1 0 1
Komut opcode tabanlı MIPS veriyolu için kontrol sinyalleri hesaplama
PCSrc opcode’dan
doğrudan set edilemez:Sıfır test çıkışı
Gereklidir.
PC
Instruction
memory
Read
address
Instruction
[31– 0]
Instruction [20 16]
Instruction [25 21]
Add
Instruction [5 0]
MemtoReg
ALUOp
MemWrite
RegWrite
MemRead
Branch
RegDst
ALUSrc
Instruction [31 26]
4
16 32
Instruction [15 0]
0
0 M
u
x
0
1
Control
Add
ALU
result
M
u
x
0
1
Registers
Write
register
Write
data
Read
data 1
Read
data 2
Read
register 1
Read
register 2
Sign
extend
M
u
x
1
ALU
result
Zero
PCSrc
Data
memory
Write
data
Read
data
M
u
x
1
Instruction [15 11]
ALU
control
Shift
left 2
ALU
Address
Control Signals:
R-Type Instruction
Control signals
shown in blue
1
0
0
0
1
???
Value depends on
funct
0
0
5 5
1 6
RD1
RD2
RN1 RN2 WN
WD
RegWrite
Register File
Operation
ALU
3
E
X
T
N
D
1 6 3 2
Zero
R D
WD
MemRead
Data
Memory
ADDR
MemWrite
5
Instruction
I3 2
M
U
X
ALUSrc
MemtoReg
ADD
<<2
R D
Instruction
Memory
ADDR
PC
4
ADD
ADD
M
U
X
M
U
X
PCSrc
MUX RegDst
5
r d
I[15:11]
r t
I[20:16]
r s
I[25:21]
immediate/
offset
I[15:0]
0
1
0
1
1
0
0 1
5 5
1 6
RD1
RD2
RN1 RN2 WN
WD
RegWrite
Register File
Operation
ALU
3
E
X
T
N
D
1 6 3 2
Zero
R D
WD
MemRead
Data
Memory
ADDR
MemWrite
5
Instruction
I3 2
M
U
X
ALUSrc
MemtoReg
ADD
<<2
R D
Instruction
Memory
ADDR
PC
4
ADD
ADD
M
U
X
M
U
X
PCSrc
MUX RegDst
5
r d
I[15:11]
r t
I[20:16]
r s
I[25:21]
immediate/
offset
I[15:0]
0
1
0
1
1
0
0 1
Kontrol sinyalleri: lw komutu
0
Kontrol sinyalleri
mavi renktir.
0
010
1
1
1
0
1
5 5
1 6
RD1
RD2
RN1 RN2 WN
WD
RegWrite
Register File
Operation
ALU
3
E
X
T
N
D
1 6 3 2
Zero
R D
WD
MemRead
Data
Memory
ADDR
MemWrite
5
Instruction
I3 2
M
U
X
ALUSrc
MemtoReg
ADD
<<2
R D
Instruction
Memory
ADDR
PC
4
ADD
ADD
M
U
X
M
U
X
PCSrc
MUX RegDst
5
r d
I[15:11]
r t
I[20:16]
r s
I[25:21]
immediate/
offset
I[15:0]
0
1
0
1
1
0
0 1
Kontrol sinyalleri: sw komutu
0
Kontrol sinyalleri
Mavidir.
X
010
1
X
0
1
0
5 5
1 6
RD1
RD2
RN1 RN2 WN
WD
RegWrite
Register File
Operation
ALU
3
E
X
T
N
D
1 6 3 2
Zero
R D
WD
MemRead
Data
Memory
ADDR
MemWrite
5
Instruction
I3 2
M
U
X
ALUSrc
MemtoReg
ADD
<<2
R D
Instruction
Memory
ADDR
PC
4
ADD
ADD
M
U
X
M
U
X
PCSrc
MUX RegDst
5
r d
I[15:11]
r t
I[20:16]
r s
I[25:21]
immediate/
offset
I[15:0]
0
1
0
1
1
0
0 1
Kontrol Sinyalleri: beq komutu
Kontrol sinyalleri
mavidir.
X
110
0
X
0
0
0
1 if Zero=1
DATAPATH kontrol: III
Shift
left 2
PC
Instruction
memory
Read
address
Instruction
[31– 0]
Data
memory
Read
data
Write
data
Registers
Write
register
Write
data
Read
data 1
Read
data 2
Read
register 1
Read
register 2
Instruction [15– 11]
Instruction [20– 16]
Instruction [25– 21]
Add
ALU
result
Zero
Instruction [5– 0]
MemtoReg
ALUOp
MemWrite
RegWrite
MemRead
Branch
Jump
RegDst
ALUSrc
Instruction [31– 26]
4
M
u
x
Instruction [25– 0] Jump address [31– 0]
PC+4 [31– 28]
Sign
extend
16 32
Instruction [15– 0]
1
M
u
x
1
0
M
u
x
0
1
M
u
x
0
1
ALU
control
Control
Add
ALU
result
M
u
x
0
1 0
ALU
Shift
left 2
26 28
Address
31-26 25-0
Jump opcode address
Jump’lar için MIPS veri yolu genişletilir: kontrol birimi yeni jump kontrol biti üretir.
İlave jump kontrol biti
ile yeni mux
Hedef adrese
jump oluşturma
DATAPATH: Executing j
(j komutunun yürütülmesi)
R-type Komutlar: Step 1
add $t1, $t2, $t3 (active = bold)
PC
Instruction
memory
Read
address
Instruction
[31– 0]
Instruction [20– 16]
Instruction [25– 21]
Add
Instruction [5– 0]
MemtoReg
ALUOp
MemWrite
RegWrite
MemRead
Branch
RegDst
ALUSrc
Instruction [31– 26]
4
16 32
Instruction [15– 0]
0
0 M
u
x
0
1
Control
Add
ALU
result
M
u
x
0
1
Registers
Write
register
Write
data
Read
data 1
Read
data 2
Read
register 1
Read
register 2
Sign
extend
Shift
left 2
M
u
x
1
ALU
result
Zero
Data
memory
Write
data
Read
data
M
u
x
1
Instruction [15– 11]
ALU
control
ALU
Address
Fetch ( komutun getirilmesi ) PC’nin içeriğinin arttırılması
R-type Komut: Step 2
add $t1, $t2, $t3 (active = bold)
PC
Instruction
memory
Read
address
Instruction
[31– 0]
Instruction [20– 16]
Instruction [25– 21]
Add
Instruction [5– 0]
MemtoReg
ALUOp
MemWrite
RegWrite
MemRead
Branch
RegDst
ALUSrc
Instruction [31– 26]
4
16 32
Instruction [15– 0]
0
0 M
u
x
0
1
Control
Add
ALU
result
M
u
x
0
1
Registers
Write
register
Write
data
Read
data 1
Read
data 2
Read
register 1
Read
register 2
Sign
extend
Shift
left 2
M
u
x
1
ALU
result
Zero
Data
memory
Write
data
Read
data
M
u
x
1
Instruction [15– 11]
ALU
control
ALU
Address
Register file’dan 2 kaynak register oku
R-type komut: Step 3
add $t1, $t2, $t3 (active = bold)
PC
Instruction
memory
Read
address
Instruction
[31– 0]
Instruction [20 16]
Instruction [25 21]
Add
Instruction [5 0]
MemtoReg
ALUOp
MemWrite
RegWrite
MemRead
Branch
RegDst
ALUSrc
Instruction [31 26]
4
16 32
Instruction [15 0]
0
0 M
u
x
0
1
ALU
control
Control
Add
ALU
result
M
u
x
0
1
Registers
Write
register
Write
data
Read
data 1
Read
data 2
Read
register 1
Read
register 2
Sign
extend
M
u
x
1
ALU
result
Zero
Data
memory
Read
data
Address
Write
data
M
u
x
1
Instruction [15 11]
ALU
Shift
left 2
ALU 2 register operandı işler
R-type komut: Step 4
add $t1, $t2, $t3 (active = bold)
PC
Instruction
memory
Read
address
Instruction
[31– 0]
Instruction [20 16]
Instruction [25 21]
Add
Instruction [5 0]
MemtoReg
ALUOp
MemWrite
RegWrite
MemRead
Branch
RegDst
ALUSrc
Instruction [31 26]
4
16 32
Instruction [15 0]
0
0 M
u
x
0
1
ALU
control
Control
Shift
left 2
Add
ALU
result
M
u
x
0
1
Registers
Write
register
Write
data
Read
data 1
Read
data 2
Read
register 1
Read
register 2
Sign
extend
M
u
x
1
ALU
result
Zero
Data
memory
Write
data
Read
data
M
u
x
1
Instruction [15 11]
ALU
Address
Sonuç registere yazılır.
Single-cycle Gerçekleştirme Notları
 Adımlar gerçekten ayrı değildir. Tamamen bir clock
cycle’da herbir komut tamamlanır.
 Bir cycle boyunca Datapath’in işletimi kombinasyoneldir.
Hiçbir şey bir clock cycle boyunca depolanmaz.
 Bu yüzden, makine bir cycle başlangıcında stabildir. Ve
cycle sonunda makine yeni bir stabil duruma geçer.
 single-cycle işlemeyi anlamak için çok önemli:
bizim Verilogdaki SimpleSingleCycleComputer
örneklerine bak.
1. Komutu Fetch et ve PC’ yi arttır.
2. Register file’dan base registeri oku: base register
($t2) komutun 25-21 bitleri ile verilir.
3. ALU 16 bitlik lower sign-extended ve register
file’dan değerlerin toplamını hesaplar
4. ALU’dan toplam data memory için adres olarak
kullanılır.
5. Hafıza biriminden data register file’a yazılır. Hedef
register ($t1) komutun 20-16 bitleriyle verilir
Load komut adımları lw $t1,offset($t2)
Load komutu : lw $t1 offset($t2)
PC
Instruction
memory
Read
address
Instruction
[31– 0]
Instruction [15– 11]
Instruction [20– 16]
Instruction [25– 21]
Add
Instruction [5– 0]
MemtoReg
ALUOp
MemWrite
RegWrite
MemRead
Branch
RegDst
ALUSrc
Instruction [31– 26]
4
16 32
Instruction [15– 0]
0
0 M
u
x
0
1
ALU
control
Control
Shift
left 2
Add
ALU
result
M
u
x
0
1
Registers
Write
register
Write
data
Read
data 1
Read
data 2
Read
register 1
Read
register 2
Sign
extend
M
u
x
1
ALU
result
Zero
Data
memory
Write
data
Read
data
M
u
x
1
ALU
Address
1. Komutu Fetch et ve PC’yi arttır.
2. Register file’dan iki registeri ($t1 and $t2) oku
3. ALU register file’dan veri değerlerini çıkararak
icra eder; PC+4’ ün değeri Hedef dallanma
adresini vermek için 2 sola kaydırılan komutun
sign-extended lower 16 bit (offset)’ eklenir.
4. ALU’dan Zero sonuçları karar vermek için
kullanılır PC’de depolamak için sonuçlar
toplanır. ( 1 veya 3. adımdan)
Branch komut adımları: beq $t1, $t2, offset
Branch komutu : beq $t1, $t2, offset
PC
Instruction
memory
Read
address
Instruction
[31– 0]
Instruction [15– 11]
Instruction [20– 16]
Instruction [25– 21]
Add
Instruction [5– 0]
MemtoReg
ALUOp
MemWrite
RegWrite
MemRead
Branch
RegDst
ALUSrc
Instruction [31– 26]
4
16 32
Instruction [15– 0]
Shift
left 2
0
M
u
x
0
1
ALU
control
Control
Registers
Write
register
Write
data
Read
data 1
Read
register 1
Read
register 2
Sign
extend
1
ALU
result
Zero
Data
memory
Write
data
Read
M data
u
x
Read
data 2
Add
ALU
result
M
u
x
0
1
M
u
x
1
0
ALU
Address
Gerçekleştirme: ALU kontrol Bloğu
Operation2
Operation1
Operation0
Operation
ALUOp1
F3
F2
F1
F0
F (5– 0)
ALUOp0
ALUOp
ALU control block
ALU Kontrol logic
Truth table for ALU control bits
ALUOp Funct field Operation
ALUOp1 ALUOp0 F5 F4 F3 F2 F1 F0
0 0 X X X X X X 010
0 1 X X X X X X 110
1 X X X 0 0 0 0 010
1 X X X 0 0 1 0 110
1 X X X 0 1 0 0 000
1 X X X 0 1 0 1 001
1 X X X 1 0 1 0 111
*
•Eğer X olursa satır-2
ve satır3-7 arası
karışıklık olur.
Gerçekleştirme: Ana kontrol bloğu
R-format Iw sw beq
Op0
Op1
Op2
Op3
Op4
Op5
Inputs
Outputs
RegDst
ALUSrc
MemtoReg
RegWrite
MemRead
MemWrite
Branch
ALUOp1
ALUOpO
Signal R- Format lw sw beq
name
Op5 0 1 1 0
Op4 0 0 0 0
Op3 0 0 1 0
Op2 0 0 0 1
Op1 0 1 1 0
Op0 0 1 1 0
RegDst 1 0 x x
ALUSrc 0 1 1 0
MemtoReg 0 1 x x
RegWrite 1 1 0 0
MemRead 0 1 0 0
MemWrite 0 0 1 0
Branch 0 0 0 1
ALUOp1 1 0 0 0
ALUOP2 0 0 0 1
Girişler Çıkışlar
Ana kontrol sinyalleri için doğruluk
tablosu
Ana kontrol PLA (programmable
logic array): LA altında yatan prensip
Herhangi bir mantıksal gösterim
Ürünlerin toplamı olarak yazılabilir.
 Farzedin ki fixed-period clock çalışmada; her komut datapath’de
bir clock cycle kullanır.
 CPI = 1

“cycle time” en uzun komutun uzunluğu tarafından belirlenir.
 Ancak birkaç komut kısa clock cycle’da çalışabilir. Zaman israfı
 Düşünün Daha komplike komutlara floating point gibi sahip olursak!
 resources used more than once in the same cycle need to be
duplicated
 Donanım ve chip alan israfı
Single-Cycle Tasarım Problemleri
Örnek:Tek cycle gerçekleştirmede Fixed-period clock , variable-period clock kullanımı
 Kayan nokta ünitesi eklenmiş bir makine düşünün. Aşağıdaki gibi
işlevsel(fonksiyonel) gecikmelerin olduğunu varsayalım:
 Memory erişimi: 2 ns., ALU and adders: 2 ns., FPU add: 8 ns., FPU multiply:
16 ns., register file access (read or write): 1 ns.
 multiplexors, control unit, PC accesses, sign extension, wires: gecikme yok.
 Farzedin ki komutlar aşağıdaki gibi karıştırılmıştır.
 Yükleme komutu (Load) %31’lik benzer zaman almaktadır.
 Tüm store’lar 21%’lik benzer zamanda oluşur.
 R-format komutlar 27% de (Bir periyotluk zamanın %27 si) oluşmakta.
 Dallanmalar 5% ‘lik zamanda oluşmakta.
 Şartsız dallanmalar 2% Lik zaman almakta.
 FP toplama ve çıkarma benzer olarak toplam 7%’lik zamanda oluşmakta.
 FP çarpma ve bölme benzer olarak toplam 7%’lik bir zaman almakta.
 (a) Bir sabit periyotlu Clock işareti ile single-cycle gerçekleştirme işlemi
 (b) Her bir komutun yürütülmesi için yeteri kadar zaman uzunluğundaki değişken
Clock periyoduna göre çalışan single-cycle işlemi ( bu tip çalışma gerçekleştirilecek bir
uygulama değildir.)
için performans karşılaştırması yapınız.
Çözüm
 Clock period for fixed-period clock = longest instruction time = 20 ns.
 Average clock period for variable-period clock =
8  31% + 7  21% + 6  27% + 5  5% + 2  2% + 20  7% + 12  7% = 8.1
ns.
 Bu şekilde, performancevar-period /performancefixed-period = 20/7 = 2.46
Instruction Instr. Register ALU Data Register FPU FPU Total
class mem. read oper. mem. write add/ mul/ time
sub div ns.
Load word 2 1 2 2 1 8
Store word 2 1 2 2 7
R-format 2 1 2 0 1 6
Branch 2 1 2 5
Jump 2 2
FP mul/div 2 1 1 16 20
FP add/sub 2 1 1 8 12
Tek çevrim (Single-Cycle) tasarımın
sorunlarına çözüm
Çözüm Alternatifi: Herbir komut sınıfı için farklı çevrim süreli
değişken-periyodlu clock kullanmak.
 İmkansız bir çözüm.Değişken hızlı( periyotlu) bir clock uygulama
olarak teknik olarak zor
 Diğer Çözüm:
 Daha küçük bir clock cycle kullanmak.
 Farklı komutları, farklı sayıda clock cycleri ile gerçekleştirmek. Yani her
komutun değişik fazlarınının herbirini bir cyle’lık çevrimde çözebilmek.
 Bu mümkündür : Bunun ismi Multicyle uygulamadır.
 Komutlar adımlara bölünür.
 Herbir adım birtek clock cycle’ında yapılır.
 Komut çevriminde herbir adım/cycle’da yapılan iş miktarı eşitlenerek
dengelenir.
 restrict each cycle to use at most once each major functional unit so
that such units do not have to be replicated
 Bir komutun farklı adımlarında, fonksiyonel birimler paylaşılarak
kullanılabilir.
 Adım/Cycle arasındaki ilişki.
 Bir cycle(çevrim) sonunda store edilen data, aynı komutun daha
sonraki cycle’ında kullanılır.
 Bu amaçla ek dahili (programcı-görünmez) reg tanıtmak gerekir
 Programcının, store edilmiş programda; Daha sonraki komutlarda
kullanılabilmesi için saklanacak data için durum elemanları, reg’ler,
Memory kullanılır.
Multicycle Uygulama
 Multicycle ve singlecycle
özelliklerini gösteren
diyagramlar.
 Tek bir ALU kullanılır.
Fazladan toplayıcı
gerektirmez.
 Clock cycel’ları
arasındaki kullanılacak
datayı tutmak için
fazladan reg’ler gerekir.
Multicycle Uygulama
PC
Instruction
memory
Read
address
Instruction
16 32
Add ALU
result
M
u
x
Registers
Write
register
Write
data
Read
data 1
Read
data 2
Read
register 1
Read
register 2
Shift
left 2
4
M
u
x
ALU operation 3
RegWrite
MemRead
MemWrite
PCSrc
ALUSrc
MemtoReg
ALU
result
Zero
ALU
Data
memory
Address
Write
data
Read
data M
u
x
Sign
extend
Add
PC
Memory
Address
Instruction
or data
Data
Instruction
register
Registers
Register #
Data
Register #
Register #
ALU
Memory
data
register
A
B
ALUOut
Single-cycle datapath
Multicycle datapath (high-level view)
Multicycle Datapath
Shift
left 2
PC
Memory
MemData
Write
data
M
u
x
0
1
Registers
Write
register
Write
data
Read
data 1
Read
data 2
Read
register 1
Read
register 2
M
u
x
0
1
M
u
x
0
1
4
Instruction
[15– 0]
Sign
extend
16 32
Instruction
[25– 21]
Instruction
[20– 16]
Instruction
[15– 0]
Instruction
register
1 M
u
x
0
3
2
M
u
x
ALU
result
ALU
Zero
Memory
data
register
Instruction
[15– 11]
A
B
ALUOut
0
1
Address
Temel multicycle MIPS Datapath yapısı; R-tipi ve yük / store komutları için.
kırmızı elips yeni dahili reg, mavi elips yeni mux’lardır.
 Biz aşağıdaki avantajlar için komutları, adımlar halinde
parçalayacağız.
 Her bir adım bir clock cycle’da oluşur.
 Herbir adımda yapılan iş miktarı yaklaşık birirbirine eşittir.
 Her bir cycle, herbir önemli fonksiyonel birimi en fazla 1 kez
kullanır. Bu yüzden böyle birimler çoğaltılamaz.
 Fonksiyonel üniteler, aynı komutun farklı çevrimlerinde
kullanılabilir.
 Bir çevrimin sonunda elde edilen data bir sonraki çevrimde
kullanılabileceğinden saklanmalıdır.
Komutların adımlar halinde parçalanması
Komutların adımlara bölünmesi
 Biz genel olarak bir komutu aşağıdaki yürütme adımlarına parçalayacağız.
– Not1: Bütün komutların hepsi aşağıdaki adımların hepsine birden ihtiyaç
duymayabilir.–Not2: Her bir adımbir clock cyle’da gerçekleşir.
1. Komutların getirilmesi ve PC’nin arttırılması (IF)
(Instruction fetch and PC increment (IF))
2. Komutların çözülmesi ve register getirilmesi (ID)
(Instruction decode and register fetch (ID))
3. Yürütme, hafıza adres hesabı, veya dallanmayı tamamlama (EX)
(Execution, memory address computation, or branch completion (EX))
4. Hafızaya erişim veya R tipi komutun tamamlanması (MEM).
(Memory access or R-type instruction completion (MEM))
5. Hafızaya okumanın tamamlanması (WB)
(Memory read completion (WB))
 Herbir MIPS komutu 3-5 Cycle’da (adım) oluşur.
 Komutu alıp Instruction Reg (IR)’e getirmek için PC’yi kullan. Yeni
komut için PC+4 yap bunu PC’ye yaz.
 RTL kullanılarak kısaca tarif edilebilir.RTL (Register-Transfer
Language):
IR = Memory[PC];Komut Reg (IR)’e PC’de yazılı adresteki komutu getir.
PC = PC + 4; PC’ye 4 ekle
Adım 1: Instruction Fetch & PC Increment (IF)
(Komutun getirilmesi & PC’nin arttırılması)
 Onlara İhtiyaç duyulduğunda rs ve rt reg’lerini oku.
Komut bir dallanma komutu ise dallanma adresini hesap et.
 RTL:
A = Reg[IR[25-21]];
B = Reg[IR[20-16]];
ALUOut = PC + (sign-extend(IR[15-0]) << 2);
Adım 2: Instruction Decode and Register Fetch (ID)
(Komutun decode edilmesi ve Registerlerin getirilmesi)
 ALU komut tipine bağımlı olarak aşağıdaki 4 fonksiyondan birisini
başarır (yürütür).
 memory reference (Hafıza referansını hazırlar):
ALUOut = A + sign-extend(IR[15-0]);
 R-type:
ALUOut = A op B;
 branch (komutu tamamlıyor):
if (A==B) PC = ALUOut;
 jump (komutu tamamalıyor):
PC = PC[31-28] || (IR(25-0) << 2)
Adım 3: Execution, Address Computation or Branch Completion (EX)
(Yürütme, Adress hesabı veya dallanmanın tamamlanması)
 Komut tipine bağımlı olarak yeniden:
 Load ve store için hafızaya erişim sağlar.
 load
MDR = Memory[ALUOut];
 store (instruction completes)
Memory[ALUOut] = B;
 R-type (instructions completes)
Reg[IR[15-11]] = ALUOut;
Adım 4: Memory access or R-type Instruction Completion (MEM)
(Hafızaya erişim veya R-tipi komutun tamamalanması)
 Komut tipine bağımlı olarak yeniden;
 Yüklenen değeri geri yazar.(Komut tamamlama)
Reg[IR[20-16]]= MDR;
Önemli: There is no reason from a datapath (or control) point of
view that Step 5 cannot be eliminated by performing
Reg[IR[20-16]]= Memory[ALUOut];
for loads in Step 4. This would eliminate the MDR as well.
The reason this is not done is that, to keep steps balanced in
length, the design restriction is to allow each step to contain
at most one ALU operation, or one register access, or one
memory access.
Adım 5: Memory Read Completion (WB)
(Hafıza Okumanın tamamlanması)
Bir komutun icra edilme sürecinin özeti
Step name
Action for R-type
instructions
Action for memory-reference
instructions
Action for
branches
Action for
jumps
Instruction fetch IR = Memory[PC]
PC = PC + 4
Instruction A = Reg [IR[25-21]]
decode/register fetch B = Reg [IR[20-16]]
ALUOut = PC + (sign-extend (IR[15-0]) << 2)
Execution, address ALUOut = A op B ALUOut = A + sign-extend if (A ==B) then PC = PC [31-28] II
computation, branch/ (IR[15-0]) PC = ALUOut (IR[25-0]<<2)
jump completion
Memory access or R-type Reg [IR[15-11]] = Load: MDR = Memory[ALUOut]
completion ALUOut or
Store: Memory [ALUOut] = B
Memory read completion Load: Reg[IR[20-16]] = MDR
1: IF
2: ID
3: EX
4: MEM
5: WB
Step
Multicycle Yürütme Adım (1):
Instruction Fetch (Komutun getirilmesi)
IR = Memory[PC];
PC = PC + 4;
4
PC + 4
Multicycle Execution Step (2):
Instruction Decode & Register Fetch
A = Reg[IR[25-21]]; (A = Reg[rs])
B = Reg[IR[20-15]]; (B = Reg[rt])
ALUOut = (PC + sign-extend(IR[15-0]) << 2)
Branch
Target
Address
Reg[rs]
Reg[rt]
PC + 4
Multicycle Execution Step (3):
Memory Reference Instructions
ALUOut = A + sign-extend(IR[15-0]);
Mem.
Address
Reg[rs]
Reg[rt]
PC + 4
Multicycle Execution Step (3):
ALU Instruction (R-Type)
ALUOut = A op B
R-Type
Result
Reg[rs]
Reg[rt]
PC + 4
Multicycle Execution Step (3):
Branch Instructions
if (A == B) PC = ALUOut;
Branch
Target
Address
Reg[rs]
Reg[rt]
Branch
Target
Address
Multicycle Execution Step (3):
Jump Instruction
PC = PC[31-28] concat (IR[25-0] << 2)
Jump
Address
Reg[rs]
Reg[rt]
Branch
Target
Address
Multicycle Execution Step (4):
Memory Access - Read (lw)
MDR = Memory[ALUOut];
Mem.
Data
PC + 4
Reg[rs]
Reg[rt]
Mem.
Address
Multicycle Execution Step (4):
Memory Access - Write (sw)
Memory[ALUOut] = B;
PC + 4
Reg[rs]
Reg[rt]
Multicycle Execution Step (4):
ALU Instruction (R-Type)
Reg[IR[15:11]] = ALUOUT
R-Type
Result
Reg[rs]
Reg[rt]
PC + 4
Multicycle Execution Step (5):
Memory Read Completion (lw)
Reg[IR[20-16]] = MDR;
PC + 4
Reg[rs]
Mem. Reg[rt]
Data
Mem.
Address
Multicycle Datapath with Control I
Shift
left 2
MemtoReg
IorD MemRead MemWrite
PC
Memory
MemData
Write
data
M
u
x
0
1
Registers
Write
register
Write
data
Read
data 1
Read
data 2
Read
register 1
Read
register 2
Instruction
[15– 11]
M
u
x
0
1
M
u
x
0
1
4
ALUSrcB ALUOp
RegDst RegWrite
Instruction
[15– 0]
Instruction [5– 0]
Sign
extend
16 32
Instruction
[25– 21]
Instruction
[20– 16]
Instruction
[15– 0]
Instruction
register
1 M
u
x
0
3
2
ALU
control
M
u
x
0
1
ALU
result
ALU
ALUSrcA
Zero
A
B
ALUOut
IRWrite
Address
Memory
data
register
… with control lines and the ALU control block added – not all control lines are shown
Multicycle Datapath with Control II
Complete multicycle MIPS datapath (with branch and jump capability)
and showing the main control block and all control lines Shift
left 2
PC
M
u
x
0
1
Registers
Write
register
Write
data
Read
data 1
Read
data 2
Read
register 1
Read
register 2
Instruction
[15– 11]
M
u
x
0
1
M
u
x
0
1
4
Instruction
[15– 0]
Sign
extend
16 32
Instruction
[25– 21]
Instruction
[20– 16]
Instruction
[15– 0]
Instruction
register
ALU
control
ALU
result
ALU
Zero
Memory
data
register
A
B
IorD
MemRead
MemWrite
MemtoReg
PCWriteCond
PCWrite
IRWrite
ALUOp
ALUSrcB
ALUSrcA
RegDst
PCSource
RegWrite
Control
Outputs
Op
[5– 0]
Instruction
[31-26]
Instruction [5– 0]
M
u
x
0
2
Jump
Instruction [25– 0] address [31-0]
26 28
Shift
left 2
PC [31-28]
1
1 M
u
x
0
3
2
M
u
x
0
1
ALUOut
Memory
MemData
Write
data
Address
New gates For the jump address New multiplexor
Multicycle Control Step (1):
Fetch
IR = Memory[PC];
PC = PC + 4;
1
0
1
0
1
0
X
0
X
0
010
1
5 5
RD1
RD2
RN1 RN2 WN
WD
RegWrite
Registers
Operation
ALU
3
E
X
T
N
D
1 6 3 2
Zero
R D
WD
MemRead
Memory
ADDR
MemWrite
5
Instruction I
3 2
ALUSrcB
<<2
PC
4
RegDst
5
I
R
M
D
R
M
U
X
0
1
2
3
M
U
X
1
0
M
U
X
0
A 1
B
ALU
OUT
0
1
2
M
U
X
<<2 CONCAT
2 8 3 2
M
U
X
0
1
ALUSrcA
jmpaddr
I[25:0]
r d
MUX
0 1
r s r t
immediate
PCSource
MemtoReg
IorD
PCWr*
IRWrite
Multicycle Control Step (2):
Instruction Decode & Register Fetch
A = Reg[IR[25-21]]; (A = Reg[rs])
B = Reg[IR[20-15]]; (B = Reg[rt])
ALUOut = (PC + sign-extend(IR[15-0]) << 2);
0
0
X
0
0
X
3
0
X
X
010
0
5 5
RD1
RD2
RN1 RN2 WN
WD
RegWrite
Registers
Operation
ALU
3
E
X
T
N
D
1 6 3 2
Zero
R D
WD
MemRead
Memory
ADDR
MemWrite
5
Instruction I
3 2
ALUSrcB
<<2
PC
4
RegDst
5
I
R
M
D
R
M
U
X
0
1
2
3
M
U
X
1
0
M
U
X
0
A 1
B
ALU
OUT
0
1
2
M
U
X
<<2 CONCAT
2 8 3 2
M
U
X
0
1
ALUSrcA
jmpaddr
I[25:0]
r d
MUX
0 1
r s r t
immediate
PCSource
MemtoReg
IorD
PCWr*
IRWrite
0
X
Multicycle Control Step (3):
Memory Reference Instructions
ALUOut = A + sign-extend(IR[15-0]);
X
2
0
0
X
0
1
X
010
0
5 5
RD1
RD2
RN1 RN2 WN
WD
RegWrite
Registers
Operation
ALU
3
E
X
T
N
D
1 6 3 2
Zero
R D
WD
MemRead
Memory
ADDR
MemWrite
5
Instruction I
3 2
ALUSrcB
<<2
PC
4
RegDst
5
I
R
M
D
R
M
U
X
0
1
2
3
M
U
X
1
0
M
U
X
0
A 1
B
ALU
OUT
0
1
2
M
U
X
<<2 CONCAT
2 8 3 2
M
U
X
0
1
ALUSrcA
jmpaddr
I[25:0]
r d
MUX
0 1
r s r t
immediate
PCSource
MemtoReg
IorD
PCWr*
IRWrite
Multicycle Control Step (3):
ALU Instruction (R-Type)
ALUOut = A op B;
0
X
X
0
0
0
X
0
1
X
???
0
5 5
RD1
RD2
RN1 RN2 WN
WD
RegWrite
Registers
Operation
ALU
3
E
X
T
N
D
1 6 3 2
Zero
R D
WD
MemRead
Memory
ADDR
MemWrite
5
Instruction I
3 2
ALUSrcB
<<2
PC
4
RegDst
5
I
R
M
D
R
M
U
X
0
1
2
3
M
U
X
1
0
M
U
X
0
A 1
B
ALU
OUT
0
1
2
M
U
X
<<2 CONCAT
2 8 3 2
M
U
X
0
1
ALUSrcA
jmpaddr
I[25:0]
r d
MUX
0 1
r s r t
immediate
PCSource
MemtoReg
IorD
PCWr*
IRWrite
1 if
Zero=1
Multicycle Control Step (3):
Branch Instructions
if (A == B) PC = ALUOut;
0
X
X
0
0
X
0
1
1
011
0
5 5
RD1
RD2
RN1 RN2 WN
WD
RegWrite
Registers
Operation
ALU
3
E
X
T
N
D
1 6 3 2
Zero
R D
WD
MemRead
Memory
ADDR
MemWrite
5
Instruction I
3 2
ALUSrcB
<<2
PC
4
RegDst
5
I
R
M
D
R
M
U
X
0
1
2
3
M
U
X
1
0
M
U
X
0
A 1
B
ALU
OUT
0
1
2
M
U
X
<<2 CONCAT
2 8 3 2
M
U
X
0
1
ALUSrcA
jmpaddr
I[25:0]
r d
MUX
0 1
r s r t
immediate
PCSource
MemtoReg
IorD
PCWr*
IRWrite
Multicycle Execution Step (3):
Jump Instruction
PC = PC[21-28] concat (IR[25-0] << 2);
0
X
X
X
0
1
X
0 X
2
XXX
0
5 5
RD1
RD2
RN1 RN2 WN
WD
RegWrite
Registers
Operation
ALU
3
E
X
T
N
D
1 6 3 2
Zero
R D
WD
MemRead
Memory
ADDR
MemWrite
5
Instruction I
3 2
ALUSrcB
<<2
PC
4
RegDst
5
I
R
M
D
R
M
U
X
0
1
2
3
M
U
X
1
0
M
U
X
0
A 1
B
ALU
OUT
0
1
2
M
U
X
<<2 CONCAT
2 8 3 2
M
U
X
0
1
ALUSrcA
jmpaddr
I[25:0]
r d
MUX
0 1
r s r t
immediate
PCSource
MemtoReg
IorD
PCWr*
IRWrite
Multicycle Control Step (4):
Memory Access - Read (lw)
MDR = Memory[ALUOut];
0
X
X
X
1
0
1
0 X
X
XXX
0
5 5
RD1
RD2
RN1 RN2 WN
WD
RegWrite
Registers
Operation
ALU
3
E
X
T
N
D
1 6 3 2
Zero
R D
WD
MemRead
Memory
ADDR
MemWrite
5
Instruction I
3 2
ALUSrcB
<<2
PC
4
RegDst
5
I
R
M
D
R
M
U
X
0
1
2
3
M
U
X
1
0
M
U
X
0
A 1
B
ALU
OUT
0
1
2
M
U
X
<<2 CONCAT
2 8 3 2
M
U
X
0
1
ALUSrcA
jmpaddr
I[25:0]
r d
MUX
0 1
r s r t
immediate
PCSource
MemtoReg
IorD
PCWr*
IRWrite
Multicycle Execution Steps (4)
Memory Access - Write (sw)
Memory[ALUOut] = B;
0
X
X
X
0
0
1
1 X
X
XXX
0
5 5
RD1
RD2
RN1 RN2 WN
WD
RegWrite
Registers
Operation
ALU
3
E
X
T
N
D
1 6 3 2
Zero
R D
WD
MemRead
Memory
ADDR
MemWrite
5
Instruction I
3 2
ALUSrcB
<<2
PC
4
RegDst
5
I
R
M
D
R
M
U
X
0
1
2
3
M
U
X
1
0
M
U
X
0
A 1
B
ALU
OUT
0
1
2
M
U
X
<<2 CONCAT
2 8 3 2
M
U
X
0
1
ALUSrcA
jmpaddr
I[25:0]
r d
MUX
0 1
r s r t
immediate
PCSource
MemtoReg
IorD
PCWr*
IRWrite
1
0
0
X
0
X
0
XXX
X
X
1
1
5 5
RD1
RD2
RN1 RN2 WN
WD
RegWrite
Registers
Operation
ALU
3
E
X
T
N
D
16 32
Zero
RD
WD
MemRead
Memory
ADDR
MemWrite
5
Instruction I
32
ALUSrcB
<<2
PC
4
RegDst
5
I
R
M
D
R
M
U
X
0
1
2
3
M
U
X
0
1
M
U
X
0
A 1
B
ALU
OUT
0
1
2
M
U
X
<<2 CONCAT
28 32
M
U
X
0
1
ALUSrcA
jmpaddr
I[25:0]
rd
MUX
0 1
rs rt
immediate
PCSource
MemtoReg
IorD
PCWr*
IRWrite
Multicycle Control Step (4):
ALU Instruction (R-Type)
Reg[IR[15:11]] = ALUOut; (Reg[Rd] =
ALUOut)
Multicycle Execution Steps (5)
Memory Read Completion (lw)
Reg[IR[20-16]] = MDR;
1
0
0
X
0
0
X
0 X
X
XXX
0
5 5
RD1
RD2
RN1 RN2 WN
WD
RegWrite
Registers
Operation
ALU
3
E
X
T
N
D
16 32
Zero
RD
WD
MemRead
Memory
ADDR
MemWrite
5
Instruction I
32
ALUSrcB
<<2
PC
4
RegDst
5
I
R
M
D
R
M
U
X
0
1
2
3
M
U
X
0
1
M
U
X
0
A 1
B
ALU
OUT
0
1
2
M
U
X
<<2 CONCAT
28 32
M
U
X
0
1
ALUSrcA
jmpaddr
I[25:0]
rd
MUX
0 1
rs rt
immediate
PCSource
MemtoReg
IorD
PCWr*
IRWrite
 Bu kodların yürütülmesi kaç cycle da tamamalanır?
lw $t2, 0($t3)
lw $t3, 4($t3)
beq $t2, $t3, Label #assume not equal
add $t5, $t2, $t3
sw $t5, 8($t3)
Label: ...
 Yürütülen 8. cycle’da ne oluşur?
 In what cycle does the actual addition of $t2 and $t3 takes place?
Basit Sorular
Clock time-line
 Kontrol sinyallerinin değeri aşağıdakilere bağlıdır.
 Hangi komut yürütülüyor
 Hangi adım icra ediliyor
 Bir sonlu durum makinası kullanmak için bilgilerinizi kullanın
 finite state machine grafiksel olarak belirtin, veya
 Microprogramming kullanın
 Gerçekleştirme belirtimlerden(tanımlardan) elde edilir.
Kontrol Gerçekleştirme
 Finite state machines (FSMs):
 Durumlar kümesi ve
 Sonraki durum fonksiyonu, giriş ve şimdiki durum tarafından
hesaplama
 Çıkış fonksiyonu, olası giriş ve şimdiki durum tarafından hesaplama
 Moore machine’sını kullanacağız. Çıkış sadece şimdiki duruma
bağlıdır.
Finite State Machines
Next-state
function
Current state
Clock
Output
function
Next
state
Outputs
Inputs
Örnek: Moore Makinası
 Moore makinası aşağıdadır. # tarafından sonlandırılan giriş
binary stringi ile çıkış; eğer stringdeki 0’ların sayısı çift ise “odd
değilse “even olacaktır.
Even state Odd state
Output even state Output odd state
No
output
No
output
Output
“even”
Output
“odd”
0
0
1
1
# #
Start
FSM Kontrol: yüksek Seviye bakış
Memory access
instructions
(Figure 5.38)
R-type instructions
(Figure 5.39)
Branch instruction
(Figure 5.40)
Jump instruction
(Figure 5.41)
Instruction fetch/decode and register fetch
(Figure 5.37)
Start
ALUSrcA = 0
ALUSrcB = 11
ALUOp = 00
MemRead
ALUSrcA = 0
IorD = 0
IRWrite
ALUSrcB = 01
ALUOp = 00
PCWrite
PCSource = 00
Instruction fetch
Instruction decode/
Register fetch
(Op = 'LW') or (Op = 'SW')
(Op = R-type)
(Op = 'BEQ')
(Op = 'JMP')
0
1
Start
Memory reference FSM
(Figure 5.38)
R-type FSM
(Figure 5.39)
Branch FSM
(Figure 5.40)
Jump FSM
(Figure 5.41)
FSM kontrolün yüksek seviye bakışı
Her komutun komut yakalama ve decode işlemi benzerdir.
Sinyaller durum
dairesi içinde
gösterilmektedir.
FSM Kontrol: Hafıza referens
MemWrite
IorD = 1
MemRead
IorD = 1
ALUSrcA = 1
ALUSrcB = 10
ALUOp = 00
RegWrite
MemtoReg = 1
RegDst = 0
Memory address computation
(Op = 'LW') or (Op = 'SW')
Memory
access
Write-back step
(Op = 'SW')
(Op = 'LW')
4
2
3 5
From state 1
To state 0
(Figure 5.37)
Memory
access
Hafıza-referansı için FSM kontrol 4 duruma sahiptir.
FSM Control: R-Tip Komut
ALUSrcA = 1
ALUSrcB = 00
ALUOp = 10
RegDst = 1
RegWrite
MemtoReg = 0
Execution
R-type completion
6
7
(Op = R-type)
From state 1
To state 0
(Figure 5.37)
R tip komut gerçekleştirmek için FSM kontrol 2 duruma sahiptir.
FSM Control: Branch Instruction
Branch completion
8
(Op = 'BEQ')
From state 1
To state 0
(Figure 5.37)
ALUSrcA = 1
ALUSrcB = 00
ALUOp = 01
PCWriteCond
PCSource = 01
Dallanma komutları için FSM 1 duruma sahiptir.
FSM Kontrol: Jump Komutu
Jump completion
9
(Op = 'J')
From state 1
To state 0
(Figure 5.37)
PCWrite
PCSource = 10
Jump komutu için FSM kontrol 1 duruma sahiptir.
FSM Kontrola genel bakış
PCWrite
PCSource = 10
ALUSrcA = 1
ALUSrcB = 00
ALUOp = 01
PCWriteCond
PCSource = 01
ALUSrcA =1
ALUSrcB = 00
ALUOp= 10
RegDst = 1
RegWrite
MemtoReg = 0
MemWrite
IorD = 1
MemRead
IorD = 1
ALUSrcA = 1
ALUSrcB = 10
ALUOp = 00
RegDst=0
RegWrite
MemtoReg=1
ALUSrcA = 0
ALUSrcB = 11
ALUOp = 00
MemRead
ALUSrcA = 0
IorD = 0
IRWrite
ALUSrcB = 01
ALUOp = 00
PCWrite
PCSource = 00
Instruction fetch
Instruction decode/
register fetch
Jump
completion
Branch
Execution completion
Memory address
computation
Memory
access
Memory
access R-type completion
Write-back step
(Op = 'LW') or (Op = 'SW')
(Op = R-type)
(Op = 'BEQ')
(Op = 'J')
(Op = 'SW')
(Op = 'LW')
4
0
1
2 6 8 9
3 5 7
Start
Multicycle MIPS datapath için tüm FSM kontrolü:
Multicycle datapath Kontrol II’ye bakınız
Yay üzerindeki etiketler
hesaplanan sonraki durum
şartlarıdır.
IF ID
EX
MEM
WB
Örnek: multicycle CPU’da CPI
 Farzedelim
 Önceki stayt’ın kontrol tasarımı
 22% yükleme , 11% depolama, 49% R-tip işlemler, 16% dallanma,
and 2% jump komutları olsun
 Herbir adım 1 clock cycle gerektirirse CPI nedir.
 Çözüm:
 Her bir komut sınıfı için önceki slayttan clock cycle’ların sayısı:
 yükleme 5, depolama 4, R-tip komutlar 4, dallanma 3, jump 3
 CPI = CPU clock cycles / komut sayısı count
=  (komut sayısıclass i  CPIclass i) / komut sayısı
=  (komut sayısıclass I / komut sayısı)  CPIclass I
= 0.22  5 + 0.11  4 + 0.49  4 + 0.16  3 + 0.02  3
= 4.04
FSM Control:Implementation
FSM gerçekleştirmeye yüksek seviye bakış: Kombinasyonal lojik bloklara girişler
Şimdiki durum sayısı ve komut opcode bitleridir. Çıkışlar sonraki durum sayısı ve
şimdiki durum için iddia edilen kontrol sinyalleridir.
PCWrite
PCWriteCond
IorD
MemtoReg
PCSource
ALUOp
ALUSrcB
ALUSrcA
RegWrite
RegDst
NS3
NS2
NS1
NS0
Op5
Op4
Op3
Op2
Op1
Op0
S3
S2
S1
S0
State register
IRWrite
MemRead
MemWrite
Instruction register
opcode field
Outputs
Control logic
Inputs
Four state bits are required for 10 states
FSM Kontrol:PLA gerçekleştirme
Üst yarı AND düzlemidir ve bütün ürünleri hesaplar. Ürünler düşey hatlar tarafından
düşük OR düzlemiyle taşınır. Herbir çıkış için toplam terim ilgili yatay düzlem
tarafından verilir. Örnek IorD = S0.S1.S2.S3 + S0.S1.S2.S3
Op5
Op4
Op3
Op2
Op1
Op0
S3
S2
S1
S0
IorD
IRWrite
MemRead
MemWrite
PCWrite
PCWriteCond
MemtoReg
PCSource1
ALUOp1
ALUSrcB0
ALUSrcA
RegWrite
RegDst
NS3
NS2
NS1
NS0
ALUSrcB1
ALUOp0
PCSource0
 ROM (Read Only Memory)
 Hafıza yerlerinin değerleri zaman öncesinde sabittir.
 Bir rom doğruluk tablosu gerçekleştirmek için kullanılabilir.
 Eğer adres m bit ise biz 2
m alanını adresleyebiliriz.
 Çıkışlar giriş adresindeki bitlerdir.
FSM Kontrol:ROM Gerçekleştirme
m n
0 0 0 0 0 1 1
0 0 1 1 1 0 0
0 1 0 1 1 0 0
0 1 1 1 0 0 0
1 0 0 0 0 0 0
1 0 1 0 0 0 1
1 1 0 0 1 1 0
1 1 1 0 1 1 1
ROM m = 3
n = 4
m-giriş n-çıkış ise ROM 2m x n bittir. – böyle bir ROM n bitlik 2m dizisi
olarak düşünülebilir.
address output
 ROM geliştirmek:
 4 durum bitleri 16 çıkış sinyali verir.ROM’un 2
4 x 16 bitleri
 Bütün 10 bit 4 sonraki durum bitlerini verir.ROM’un 2
10 x 4 bitleri
 Toplam – ROM 4.3K bit olur
 PLA daha küçüktür.
 Ürün terimleri paylaşılabilir.
 Aktif bir çıkış üretmek için yanlızca girişlere ihtiyaç vardır
 PLA boyut = (#girişler  #ürünler terimi) + (#çıkışlar 
#ürünler terimi)
 FSM Kontrol PLA = (10x17)+(20x17) = 460 PLA hücresi
 PLA hücreleri bir ROM hücre boyutundadır. (biraz daha büyük)
FSM Kontrol: ROM vs. PLA
 Microprogramming iözel FSM kontrol methodudur. (Bir programlama dilini
andıran yada grafikten ziyade text)
 Eğer komut seti büyük veya her komutun cycle sayısı büyük ise FSM çok
büyük olduğundan bu uygundur.
 Böyle grafiksel gösterim durumlarında zor olabilir. Binlerce durum olduğu
ve onlarla bağlantılı yaylar olduğunda
 Bir microprogram özelliği: Gerçekleştirme ROM veya PLA ile
gerçekleştirmedir.
 Bir microprogram microkomutlar dizisidir.
 Herbir microinstruction8 alana sahiptir. (Etiket + 7 fonksiyon)
 Label: Microcode dizisini kontrol etmede kullanılır.
 ALU Kontrol:ALU tarafından yapılacak işlemleri belirtir.
 SRC1: İlk ALU operandı için kaynağı belirtir.
 SRC2: ikinci ALU operandı için kaynağı belirtir.
 Register Kontrol: Register file için read/write belirtir.
 Hafıza: Hafıza için read/write belirtir.
 PCWrite Kontrol :PC’nin yazmasını belirtir.
 Sequencing: sonraki komutu seçmeyi belirtir.
Microprogramming
Microprogramming
 The Sequencing alan değeri microprogramın yürütme
sırasını belirler.
 value Seq : Sonraki microkomuta geçme kontrolü
 value Fetch : sonraki başlanacak ilk microkomuta dallanma
ör: mikroprogramdaki ilk microkomut gibi
 value Dispatch i : gönderme tablo girişi (dispatching olarak
adlandırılır) ve kontrol girişi tabanlı microkomuta dallanma :
 Dispatching bir tablo oluşturma aracı tarafından
gerçekleştirilir, dispatch tablo olarak adlandırılır, onun girişleri
microkomut etiketleridir ve o kontrol girişi tarafından
indexlenir. Çoklu dispatch tabloları olabilir. –sıralama
alanındaki Dispatch i değeri göstermeye i ninci dispatch tablo
kullanılır.
Kontrol Microprogram
 The microprogram corresponding to the FSM control shown
graphically earlier:
Label
ALU
control SRC1 SRC2
Register
control Memory
PCWrite
control Sequencing
Fetch Add PC 4 Read PC ALU Seq
Add PC Extshft Read Dispatch 1
Mem1 Add A Extend Dispatch 2
LW2 Read ALU Seq
Write MDR Fetch
SW2 Write ALU Fetch
Rformat1 Func code A B Seq
Write ALU Fetch
BEQ1 Subt A B ALUOut-cond Fetch
JUMP1 Jump address Fetch
Dispatch ROM 1
Dispatch ROM 2 Op Opcode name Value
Op Opcode name Value 000000 R-format Rformat1
100011 lw LW2 000010 jmp JUMP1
101011 sw SW2 000100 beq BEQ1
100011 lw Mem1
101011 sw Mem1
Microprogram 10 mikrokomut içerir.
Gönderne Table 2
Gönderme Tablo 1
Microcode: Trade-offs
 Özellikleri Avantajları
 Tasarlamak ve yazmak kolaydır.
 Tipik olarak imalatcı mimari ve microkodu paralel tasarlar
 Gerçekleştirme Avantajları
 Hafızadaki değeri değiştirmek kolaydır (e.g., off-chip ROM)
 Diğer mimariler taklit edilebilir.
 Dahili registerlerden yararlanılabilir.
 Gerçekleştirme dezavantajları
 Kontrol şimdilerde aynı chip üzerinde gerçekleştirilir. Off Chip ROM’un
sahip olduğu avantaja sahip değildir.
 ROM on-board cache’den hızlı değildir.
 Microkodu değiştirmeye az ihtiyaç vardır. Genel amaçlı bilgisayarlar
özel uygulamalar için tasarlanmış bilgisayarlardan çok daha fazla
kullanılmaktadır.
Özet
 Bu bölümde datapath tasarımı ve bütün modern
bilgisayar mimarisi tanımlandı
 Multicycle datapath’ler single-cycle’a göre 2 büyük
avantaj sunar.
 Fonksiyonel birimler bir tek komutla yeniden kullanılabilir.
 Daha kısa execution path’ler ile komutlar birkaç cycle
tüketilmesiyle daha hızlı tamamlanabilir.
 Modern bilgisayarlar, gerçekte, take the multicycle
paradigm to a higher level to achieve greater
instruction throughput:
 pipelining (bir sonraki komut) birçok komutu(farklı cycle’a
sahip olsalar bile) eşzamanlı yürütme
 MIPS mimarisi pipeline olarak tasarlandı.
PİPELİNE (BORU HATTI) İşlemi ile
Performansın Geliştirilmesi
Paralel İşleme ve PİPELİNE
 Aynı zamanda, birden fazla veya çok sayıda işlemin yapılabilmesi bilgisayar
sisteminin hızını (Throuhput) arttırır.
 Paralel işlemede ise aynı anda birden fazla komut icra edilir. Örneğin, bir
zaman diliminde bir komut ALU’da yürütülürken (execute), aynı zaman
diliminde daha sonraki komut ise bellekten okunabilir. Bu işlem tek işlemcili
paralel çalışmaya örnektir.
 Paralel çalışmaya diğer örnek , birden fazla işlemcisi bulunan sistemlerdir.
 Paralel işleme aşağıdaki başlıklarda incelenebilir.
 1- PİPELİNE (Boru Hattı) İşlemleri
 2-VEKTÖR İŞLEMLERİ
 3-DİZİ İŞLEMCiLERİ
Pipeline bir yürütme tekniği olup, artmetik alt işlemlerde veya bir komutun
fazlarının (evrelerinin) işlenmesi sırasında üstüste gelmesidir. Vektör işlemleri
büyük boyutlu vektörel veya matris işlemlerinin yapılması içindir. Dizi
İşlemcileri ise büyük çaplı diziler üzerinde işlem yaparlar.

Pipelining
 Bir işe başladıktan sonra en kısa sürede bitir.!! Zaman kaybetme!
Time
6 PM 7 8 9 10 11 12 1 2 AM
A
B
C
D
Time
6 PM 7 8 9 10 11 12 1 2 AM
A
B
C
D
Task
order
Task
order
Farz etki her bir görev ( yıkama-kurutma- katlama- dolaba yerleştirme) 30 dakikadır. Ve ayrı
görevler için ayrı donanımlar kullanılıyorsa, farklı görevler aynı zamanda üstüste çakışabilir.
Pipelined
Not pipelined
PİPELİNE İŞLEMLERİNİN ANLAŞILMASI
 Pipeline işlemi birtakım işlemlerin topluluğudur ve boru hattını oluşturan
her bir kesimde (segmentte) herbir farklı işin farklı alt işlemleri aynı
zamanda gerçekleşir. Bir kesimde elde edilen sonuç aynı iş için sonraki
kesimde kullanılmak üzere saklanır.
Her bir kesimde icra edilecek alt işlemler şekilde
verilmiştir. 5 Registerden herbiri, her clock cyce’lında
yeni veriler ile yüklenir.
Reg’lerin içeriklerinin değişimi
Aynı biçimde alt işlemlere parçalanabilen ve aynı karışıkılğa sahip her işlem
PİPELİNE olarak işlenebilir.
Herbir alt işlem segment(kesimde ) yapılır. Bir önceki işlemde elde edilen
sonucun bir sonraki işlemde kullanılabilmesi için Reg’lere ihtiyaç vardır. Aşağıdaki
durum 4 kesimli bir PİPELiNE işlemidir.
PİPELİNE davranışı uzay-zaman diyagramı ile gösterilebilir. 4 kesimli
bir PİPELİNE işlemi ile 6 tane görevin icra edilmesi aşağıdaki
şemada verilmiştir.
PİPELİNE işlemenin hızı (Kazancımız ne?)
n: Görev Sayısı (Bir assemler programdaki işlenecek komut sayısı diyebiliriz.)
PİPELİNE çalışmayan bir makine için;
tn: Clock cycle (her bir görevi bitirmek için gerekli zaman)
t1: n tane görevi tamamlamak için gerekli harcanacak zaman.
→ t1 = n * tn
PİPELİNE bir makine için. (k kesimli (durumlu))
tp: Clock cycle (Herbir alt işlemin tamamlanması için gerekli zaman)
tk: n adet görevin başarılması için gerekli zaman
→ tk = (k + n - 1) * tp
 Hızlanma (Speedup)
 Sk: Speedup
→ Sk = t1 / tk = n*tn / (k + n - 1)*tp
n görev sayısı arttıkça (k + n -1) terimi yaklaşık n olur. Buna göre aşağıdaki bağıntı ortaya çıkar.
Sk= tn / tp
Eğer; pipeline ve pipeline olmayan bilgisayarlarda bir görevin tamamlanması için geçen zaman eşit ise,
Bu durumda; pipeline toplam hızlandırması k (kesim sayısı) kadar olabilir.
Örnek:
4-kesimli pipeline’da, bir alt işlemin her bir kesimde işlenebilmesi için gerekli
zaman;
tp = 20nS olsun.
İcra edilecek görev sayısı 100 olsun. Sk hızlanma değerini hesaplayınız.
Çözüm:
Pipeline olmayan bir sistemde, tekbir görev için harcanacak zaman 20*4 = 80nS
Tüm görevin icra edilmesi için harcanacak zaman: 100*20*4 =8000 ns.
 Pipeline makine için toplam süre ; (k + n - 1)*tp =(4+100 -1)*20=2060 ns
Buna göre;
Sk = 8000 / 2060 = 3.88
Elde edilir.
Önemli not: Bütün alt işlemlerin icra sürelerinin aynı olduğunu kabul ediyoruz.
 PİPELİNE İşlemenin 2 temel uygulaması
vardır.
 1- Aritmetik işlemlerde PİPELİNE
 2-Komut Yürütmede PİPELİNE
Aritmetik İşlemlerde PİPELİNE
PİPELİNE aritmetik birimleri, FP işlemler için ve çarpma işlemleri için önemli bir hızlandırıcı yapıdır.
Floating-point Toplama
[1] Exponentlerin karşılaştırılması
[2] Mantisanın hizalanması
[3] Mantisaların toplanması/Çıkarılması
[4] Sonuç Normalizasyonu
Örnek:
4 kesim için harcanan zamanlar: t1=60ns, t2=70ns,t3=100ns, t4=80ns , fiziksel gecikmeler 10ns olsun.
Buna göre;
pipeline’sız bir makinada 1 toplama işlemi için: 60+70+100+80+10 = 320ns
Aritmetik işlem için 4 kesimli pipeline ‘da ise herbir kesim de hrcanan süre farklı olduğundan en kötü
durum olarak pipeline clock cycel’ını 100ns alarak tp = 100+10 =110 ns elde ederiz. Buna göre;
Sk= tn / tp = 320 / 110 = 2.9
Komut Yürütme için Pipeline
Single-Cycle Komut Yürütme: Planlama
Instruction
fetch
Reg ALU
Data
access
Reg
8 ns
Instruction
fetch
Reg ALU
Data
access
Reg
8 ns
Instruction
fetch
8 ns
Time
lw $1, 100($0)
lw $2, 200($0)
lw $3, 300($0)
2 4 6 8 10 12 14 16 18
2 4 6 8 10 12 14
...
Program
execution
order
(in instructions)
Instruction
fetch
Reg ALU
Data
access
Reg
Time
lw $1, 100($0)
lw $2, 200($0)
lw $3, 300($0)
2 ns
Instruction
fetch
Reg ALU
Data
access
Reg
2 ns
Instruction
fetch
Reg ALU
Data
access
Reg
2 ns 2 ns 2 ns 2 ns 2 ns
Program
execution
order
(in instructions)
Single-cycle
Pipelined
Farzedin ki memorye erişim ve ALU işlemleri 2 ns ; register erişimi 1 ns.
Buna göre, single cycle clock 8 ns’dir. Pipelined clock cycle ise 2 ns.
Pipelining: Unutma
 Pipeline işlemi tek bir görev (veya komut işlemesi ) için harcanacak
zamanı (latency) azaltmaz fakat görevin bütünü (bir programın sıralı
komutları v.b) için harcanan zamanı azaltır (Verilen sabit bir
zamanda yapılan iş miktarını –throughput- arttırır).
 Pipeline hızı en uzun durum ile sınırlıdır.
 potential hızlandırıcı= Boru durumları sayısıdır (kesim sayısı).
 Dengesiz boru durumları hızı azaltır (her kesim için farklı süreler).
 Pipeline sürecinde herhangi bir fazda boş kalmak pipeline’ı
yavaşlatır.
 En verimli pipeline işlemi, komutların parçalanmasıyla oluşan alt
işlem sürelerinin (fetch, decode v.b) eşit sürelerde işlenmesi ile
olur.
Örnek Problem
 Problem: Çamaşır yıkama örneği için aşağıdaki tabloyu doldurmak isteyelim.
1. Her bir durumun uzunluğu(stage lengths) 30, 30, 30 30 dak. olsun.
2. Durumların uzunluğu (stage lengths) , 20, 20, 60, 20 dak. olsun.
 Pipeline’ı hızlandırmak için bir formül ortaya çıkaralım?
Person Unpipelined Pipeline 1 Ratio unpipelined Pipeline 2 Ratio unpiplelined
finish time finish time to pipeline 1 finish time to pipeline 2
1 120 d. 120 d. 120/120 = 1 120 d. 120/120 = 1
2 2x120=240d 120+30=150d 240/150 = 1.6 180 d 240/180 = 1.33
3
4
n n x 120/(120+((n-1)x30)
Dört kesimli (Segmentli) Komut İçin Pipeline
Dört aşamaya (faz – Kesim-segment) bölünmüş komutlar için kesimler ;
FI: Komutu getir
DA: Komutu çöz, etkin adresi hesapla
FO: Veriyi getir
EX: Komutu yürüt
Not: komut ve data hafızalarına ayrı ayrı erişildiğini düşününüz.
Dallanma komutu olmadığı sürece, hiçbir kesim boş geçilmez. Farklı
işlemler yapar. Ancak 3. komutun dallanma olduğu durumu inceleyelim.
Neler olur ve neden olur? Niye 5.ve 6. adımlarda işlem yapılmaz?
Dallanma komutunun işleyip dallanılacak adres ortaya çıkıncaya kadar bir sonraki
komut ile ilgili sadece Fetch işlemi yapılabilir. 5.6. adımlarda işlem yapılmaz.
MIPS’te PİPELİNE
 MIPS için Pipeline işlem neden kolaydır?
 Bütün komutlar benzer uzunluktadır.
 Tüm komutlar için fetch ve decode durumları benzer şekilde işlenir.
 Yalnızca birkaç komut formatları vardır.
 Basit bir şekilde, Komutların decodlanması ve tek durumda yapılması
mümkün hale gelir.
 Memory işlemleri sadece load/store komutlarında oluşur.
Böylece memory erişimi tam olarak bir sonraki duruma ertelenmiş olabilir
 Operandlar (İşlenenler) memory’de dizili sıralıdır.
 Bir data transfer komutu yalnızca bir memory’e erişim durumuna ihtiyaç
duyar.
MIPS’te Pipeline
Neler zorlaştırır?
Structural hazards (Yapısal tehlikeler): Pipeline işleminde, farklı komutlarda ,
farklı durumlarda aynı donanım kaynaklarının kullanılması durumu oluşabilir
(Kaynak Çatışması).
Control hazards (Kontrol tehlikeleri): Bir önceki dallanma komutunun
sonucuna bağlı olarak, izleyen komutu mevcut pipeline içine alma sorunu
(Dallanma zorluğu).
Data hazards (Data tehlikeleri): Pipeline’daki bir komutun, aynı pipelin’daki
önceki komutun hesapladığı datayı kullanması gerektiğinde (Veri Beklentisi).
Biz, pipeLine’lı datapath’ı inclemeden önce yukarıda sıralanan olası
tehlikeleri tek tek incelemeliyiz.
Structural Hazards (Yapısal Tehlikeler)
 Structural hazard : Pipeline işleminde aynı clock cyclında bütün
komutların eşzamanlı işlemesi için gereken donanımın yetersizliği.
 Örnek: Varsayınız ki, komut ve data hafızası tek olan, yani tekbir
veriyolu kullanan, bir yapıda pipeline işlemi yapılsın.
 O zaman 1. ve 4. lw komutları arasında bir structural hazard oluşablilir.
 Korkmayın MIPS PİPELİNE’ı destekler şekilde dizayn edilmiştir.
Yapısal tehlikelerden kolayca kaçınılır.
2 4 6 8 10 12 14
Instruction
fetch
Reg ALU
Data
access
Reg
Time
lw $1, 100($0)
lw $2, 200($0)
lw $3, 300($0)
2 ns
Instruction
fetch
Reg ALU
Data
access
Reg
2 ns
Instruction
fetch
Reg ALU
Data
access
Reg
2 ns 2 ns 2 ns 2 ns 2 ns
Program
execution
order
(in instructions)
Pipelined
Instruction
fetch
Reg ALU
Data
access
Reg
2 ns
lw $4, 400($0)
Hazard if single memory
Control Hazards
 Control hazard (Kontrol Tehlikesi): PİPELİNE’in yürütülmesinde bir önceki
komutun sonucuna göre karar vermek gerekebilir. Bu problem genellikle
şartlı ve şartsız dallanma komutlarının işlenmesi durumunda çok
önemlidir.
 Çözüm 1 Stall the pipeline (Pipeline’ı geciktirme)
Instruction
fetch
Reg ALU
Data
access
Reg
Time
beq $1, $2, 40
add $4, $5, $6
lw $3, 300($0)
4 ns
Instruction
fetch
Reg ALU
Data
access
Reg
2ns
Instruction
fetch
Reg ALU
Data
access
Reg
2ns
2 4 6 8 10 12 14 16
Program
execution
order
(in instructions)
Pipeline stall (Pipeline gecikmesi)
bubble
Note that branch outcome is
computed in ID stage with
added hardware (later…)
Control Hazards
 Çözüm 2 Predict branch outcome (dallanma sonucunun önceden tahmin
edilmesi veya dallanmanın olmayacağının tahmini)
Instruction
fetch
Reg ALU
Data
access
Reg
Time
beq $1, $2, 40
add $4, $5, $6
lw $3, 300($0)
Instruction
fetch
Reg ALU
Data
access
Reg
2 ns
Instruction
fetch
Reg ALU
Data
access
Reg
2 ns
Program
execution
order
(in instructions)
Instruction
fetch
Reg ALU
Data
access
Reg
Time
beq $1, $2, 40
add $4, $5 ,$6
or $7, $8, $9
Instruction
fetch
Reg ALU
Data
access
Reg
2 4 6 8 10 12 14
2 4 6 8 10 12 14
Instruction
fetch
Reg ALU
Data
access
Reg
2 ns
4 ns
bubble bubble bubble bubble bubble
Program
execution
order
(in instructions)
Tahmin başarısı
Tahmin hatası: lw’ü geri al (=flush)
Control Hazards (Kontrol Tehlikesi)
 Çözüm 3: Gecikmiş dallanma (Delayed branch) :Derleyici ,
dallanmaları yeniden düzenleyerek, zamanında pipeline içine olmalarını sağlar.
Bu yöntemde derleyici dallanma komutundan önceki ve sonraki komutları analiz
ederek geciktireceği komutların önüne faydalı komutlar yazarak program akışını
yeniden düzenler. Yani dallanma komutuna sıra gelmeden önündeki komutları,
akışı bozmamak şartıyla gecikme adımlarına alıp bu esnada dallanma
komutunuda diğer kesimlerde işlemeye devam eder. Böylece dallanmanın
gecikmesi önlenmiş olur.
Instruction
fetch
Reg ALU
Data
access
Reg
Time
beq $1, $2, 40
add $4, $5, $6
lw $3, 300($0)
Instruction
fetch
Reg ALU
Data
access
Reg
2 ns
Instruction
fetch
Reg ALU
Data
access
Reg
2 ns
2 4 6 8 10 12 14
2 ns
(d elayed branch slot)
Program
execution
order
(in instructions)
Delayed branch beq is followed by add that is
independent of branch outcome
Gecikmiş Dallanmaya Örnek:
5 komutluk bir program olsun. Komutlar sırayla;
1- Hafızadan R1’e yükle
2-R2’yi arttır.
3-R3 e R4’ü topla
4-R5’i R6’dan çıkar
5-X adresine dallan
Aşağıda derleyicinin yapabileceği 2 gerçekleştirme verilmiştir.
İşlem yok komutu kullanılarak
Komutları tekrar sıralayarak
Data Hazards (Veri Tehlikeleri)
 Data hazard : Bir sonraki komut, yürütmesi bitmemiş bir önceki
komutun datasına ihtiyaç duyabilir.
 Çözüm : Mümkünse datayı ilerlet.…
Time
2 4 6 8 10
add $s0, $t0, $t1 IF ID EX MEM WB
add $s0, $t0, $t1
sub $t2, $s0, $t3
Program
execution
order
(in instructions)
IF ID EX WB
IF ID EX MEM
Time
2 4 6 8 10
MEM
MEM WB
Komutun Pipeline diyagramı:
shade indicates use –
left=write, right=read
İlerletme yoksa – mavi çizgi –
Veri zamanda geri gitmek
durumunda. Yani 2.komut 6,8
arasında bekleyecek.;
İlerletme varsa– kırmızı çizgi –
Veri, zamanında hazır edilmiş.
2.komut 6,8 süresinde işlem
yapar.
Data Hazards
 Datayı ilerletmeninde yetmeyeceği durumlar olabilir.
 Örneğin, R-tipi bir komut yükleme komutunu takip ediyorsa, yüklenen
değeri kullanacaksa – load-use data hazard’ı olarak bilinir.
Time
2 4 6 8 10 12 14
lw $s0, 20($t1)
sub $t2, $s0, $t3
Program
execution
order
(in instructions)
IF ID EX MEM WB
IF ID EX MEM WB
Time
2 4 6 8 10 12 14
lw $s0, 20($t1)
sub $t2, $s0, $t3
Program
execution
order
(in instructions)
IF ID EX MEM WB
IF ID EX MEM WB
bubble bubble bubble bubble bubble
Bir kesim(stage) gecikmesiyle, ilerletilen data
sub komutunda kullanılabilir.
Bir Durma (gecikme) olmadan ,alt komuta
girdi sağlamak mümkün değildir. NİYE?
PİPELİNE gecikmesinden (Stall) kaçınmak için kodlamayı
yeniden düzenleme.(Software Solution)
 Example:
lw $t0, 0($t1)
lw $t2, 4($t1)
sw $t2, 0($t1)
sw $t0, 4($t1)
 Reordered code:
lw $t0, 0($t1)
lw $t2, 4($t1)
sw $t0, 4($t1)
sw $t2, 0($t1)
Data hazard
Interchanged
Pipeline çalışan Datapath
 Şimdi bir pipeline datapath yapısını açıklayabiliriz.
 İlk önce bir komutun tamamlanmasındaki 5 adımı hatırlayalım.
1. Instruction Fetch & PC Increment (IF)
2. Instruction Decode and Register Read (ID)
3. Execution or calculate address (EX)
4. Memory access (MEM)
5. Write result into register (WB)
 Hatırlatma: single-cycle işlemci için
 5 adımın hepsi birden single clock cycle’ında yapılır.
 Herbir adım için atanmış bir donanıma (fonsiyonel yapıya) ihtiyaç vardır.
 Biz single cyle datapath donanımını değiştirmeden, bir komutun işlenmesini
birden fazla cycle’da gerçekleşecek şekilde parçalasaydık neler oluşurdu?
 What happens if we break the execution into multiple cycles, but keep the extra hardware?
Hatırlatma - Single-Cycle Datapath “Steps”
5 5
16
RD1
RD2
RN1 RN2 WN
WD
Register File ALU
E
X
T
N
D
16 32
RD
WD
Data
Memory
ADDR
5
Instruction I
32
M
U
X
<<2
RD
Instruction
Memory
ADDR
PC
4
ADD
ADD
M
U
X
32
IF
Instruction Fetch
ID
Instruction Decode
EX
Execute/ Address Calc.
MEM
Memory Access
WB
Write Back
Zero
Pipelined Datapath – Temel Fikirler
 Extra donanımları korumak şartıyla, bir yürütme işlemini bir çok cycle’a
bölersek ne olur?
 What happens if we break the execution into multiple cycles, but keep the extra hardware?
 Cevap: Her bir clok çevriminde yeni bir komutu işlemeye başlayabiliriz.
 We may be able to start executing a new instruction at each clock cycle - pipelining
 İşte bu Pipeline işlemidir.
 Fakat; bu cycle’lar arasındaki süreçte (segment-Kesim) datayı tutmak
için extra registerlara ihtiyaç vardır. Bunlar pipeline register’larıdır.
 Önemli not: Pipeline yürütmede herbir kesimde(segmentte) elde edilen sonuç
bir sonraki kesime aktarılabilir. Aynı kesimde farklı komutlar için eş zamanlı
olarak farklı datalar ile farklı işlemler yapılabilir.
 Dolayısıyla her kesim için bir pipeline register kullanılmalıdır.
Pipelined Datapath
IF/ID
Pipeline registers
5 5
16
RD1
RD2
RN1 RN2 WN
WD
Register File ALU
E
X
T
N
D
16 32
RD
WD
Data
Memory
ADDR
5
Instruction I
32
M
U
X
<<2
RD
Instruction
Memory
ADDR
PC
4
ADD
ADD
M
U
X
32
ID/EX EX/MEM MEM/WB
Zero
64 bits
97 bits 64 bits
128 bits
(datayı saklamak için yeterince genişliktedirler)
Pipelined Datapath
IF/ID
Pipeline registers
5 5
16
RD1
RD2
RN1 RN2 WN
WD
Register File ALU
E
X
T
N
D
16 32
RD
WD
Data
Memory
ADDR
5
Instruction I
32
M
U
X
<<2
RD
Instruction
Memory
ADDR
PC
4
ADD
ADD
M
U
X
32
ID/EX EX/MEM MEM/WB
Zero
64 bits
97 bits 64 bits
128 bits
(datayı saklamak için yeterince genişliktedirler)
Sadece soldan sağa doğru akan veri durumunda tehlikeler oluşabilir? neden?
Datapath’de hatalar
5 5
16
RD1
RD2
RN1 RN2 WN
WD
Register File ALU
E
X
T
N
D
16 32
RD
WD
Data
Memory
ADDR
5
Instruction I
32
M
U
X
<<2
RD
Instruction
Memory
ADDR
PC
4
ADD
ADD
M
U
X
32
Hedef reg’e yazılma süreci, sonraki bir komutun başka bir işlem fazından sonraya denk gelebilir.
IF/ID ID/EX EX/MEM MEM/WB
Düzeltilmiş DATAPATH
5
RD1
RD2
RN1
RN2
WN
WD
Register
File
ALU
E
X
T
N
D
16 32
RD
WD
Data
Memory
ADDR
32
M
U
X
<<2
RD
Instruction
Memory
ADDR
PC
4
ADD
ADD
M
U
X
5
5
5
EX/MEM MEM/WB
Zero
IF/ID ID/EX
64 bits 133 bits
102 bits 69 bits
Hedef Reg’in adresi (5 bitlik) ID/EX, EX/MEM ve MEM/WB reg’lerinede yazılır.
Şimdi bu reg’lerin genişlikleri 5 bit artmıştır.
Pipeline Örnekleri
 Aşağıdaki komut dizisini gözönünde bulundur.
lw $t0, 10($t1)
sw $t3, 20($t4)
add $t5, $t6, $t7
sub $t8, $t9, $t10
Single-Clock-Cycle Diagram:
Clock Cycle 1
LW
Single-Clock-Cycle Diagram:
Clock Cycle 2
SW LW
Single-Clock-Cycle Diagram:
Clock Cycle 3
ADD SW LW
Single-Clock-Cycle Diagram:
Clock Cycle 4
SUB ADD SW LW
Single-Clock-Cycle Diagram:
Clock Cycle 5
SUB ADD SW LW
Single
-Clock
-Cycle Diagram:
Clock Cycle 6
SUB ADD SW
Single-Clock-Cycle Diagram:
Clock Cycle 7
SUB ADD
Single
-Clock
-Cycle Diagram:
Clock Cycle 8 SUB
Alternative View –
Multiple-Clock-Cycle Diagram
lw $t0, 10($t1) IM REG ALU DM REG
sw $t3, 20($t4)
add $t5, $t6, $t7
CC 1 CC 2 CC 3 CC 4 CC 5 CC 6 CC 7
IM REG ALU DM REG
IM REG ALU DM REG
sub $t8, $t9, $t10 IM REG ALU DM REG
CC 8
Time axis (Clock Cycle)
Not:
 Bir R-tipi komutunun yürütülmesi sürecinde; Multicycle ve pipeline
gerçekleştirmeler arasında önemli fark:
 R tipi bir komutta, registere write-back işlemi 5. pipeline kesimindedir
( last write-back segmentindedir). Oysa multicycle gerçekleştirmede
ise bu işlem 4. durumda gerçekleşir. Niyen?
 Reg.file’a yazarken yapısal tehlikelerden dolayı olabilir.
 Tekrar etmeye değer: Boru hattı ve multicycle uygulamalar
arasındaki temel fark, 5 durumu biribirinden ayrıştırmak için
pipeline register yerleştirilmesidir.
 İdeal Pipeline (Duraksama-gecikme yosa) için CPI =1 ‘dir. Niye?
Simple Example: Comparing
Performance
 Compare performance for single-cycle, multicycle, and pipelined
datapaths using the gcc instruction mix
 assume 2 ns for memory access, 2 ns for ALU operation, 1 ns
for register read or write
 assume gcc instruction mix 23% loads, 13% stores, 19%
branches, 2% jumps, 43% ALU
 for pipelined execution assume
 50% of the loads are followed immediately by an instruction that
uses the result of the load
 25% of branches are mispredicted
 branch delay on misprediction is 1 clock cycle
 jumps always incur 1 clock cycle delay so their average time is 2
clock cycles
Simple Example: Comparing
Performance
 Single-cycle (p. 373): average instruction time 8 ns
 Multicycle (p. 397): average instruction time 8.04 ns
 Pipelined:
 loads use 1 cc (clock cycle) when no load-use dependency and 2 cc
when there is dependency – given 50% of loads are followed by
dependency the average cc per load is 1.5
 stores use 1 cc each
 branches use 1 cc when predicted correctly and 2 cc when not –
given 25% misprediction average cc per branch is 1.25
 jumps use 2 cc each
 ALU instructions use 1 cc each
 therefore, average CPI is
1.5  23% + 1  13% + 1.25  19% + 2  2% + 1  43% = 1.18
 therefore, average instruction time is 1.18  2 = 2.36 ns
Vektör İşlemleri
Birçok yazılım uygulaması ( Görüntü işleme, insan genetiği, Sismik veri analizi
v.b), büyük sayı dizileri üzerinde çok büyük sayıda aritmetik işlem yapmayı gerektirir. Bu
sayılar çoğu zaman Floating Point sayı düzlemindeki tek boyutlu veya çok boyutlu diziler
şeklinde toplanmışlardır. . Sıradan bilgisayarlar bu çalışmaları çok uzun sürede
sonlandırabilir. Sayılan işlemlerin yapılabilmesi için iyi kaliteli ( vektör ve paralel işleme
özelliği olan) bilgisayarlara gerek vardır.
Vektör: Tek Boyutlu veri dizisidir.
Satır veya sütün vektörleri şeklinde ifade edilebilirler. V = [V1 V2 V3……….Vn] .
Elemanları V olan bir satır vektörü V(I) şeklinde I indisi ile gösterilir ve bir hafızada dizi
şeklinde saklanır.
Bir vektör olmayan işlemci ile vektör işlemci arasındaki farkı anlamak için
aşağıdaki döngüyü göz önüne alalım.
Vektör işlemci için komut formatı
İç çarpım hesabı için PİPELiNE

• İdeal gaz denklemi, P.V = n.R.T dir. Basınç P değeri aşağıdaki fonksiyonla
hesaplanıyor. MIPS kodunu yazınız. Floting point sayı dönüşümleri yapınız. Sonucu
hafızanın 1100 adresine yazınız.
•
• float gaz (float n, float T) {
• return (n*0.082*(273.0+T)*1.3)
• }
• Data hafızanın 1000 adresinden itibaren n , T değerleri saklanmıştır.
• Data hafızanın başlangıç adresini $f0 registeri tutmaktadır. n, T değerleri sırasıyla
$f13, $f14 registerlerine getiriliyor.
• Sabit değerlere erişim $gp registeri ile sağlanmaktadır. ($gp’in değeri 1500) sabit
değerler 0.082, 273.0, 1.3 $gp’nin gösterdiği adres alanından itibaren sırasıyla
yazılıdır.
sonuç
1. lwc1 $f10,0($gp) # 0.082’nin $f10’ getirilmesi
2. lwc1 $f11, 4($gp) # 273.0’ın $f11’e getirilmesi
3. lwc1 $f12, 8($gp) # 1.3’ın $f12’e getirilmesi
4. lwc1 $f13, 0($f0) # n’ın $f13’e getirilmesi
5. lwc1 $f14, 4($f0) # T’nin $f11’e getirilmesi
6. add.s $f14,$f14,$f11 # T + 273 işlemi
7. mul.s $f13, $f13, $f10 # n*0.082 işlemi
8. mul.s $f13, $f13,$f14 # n*0.082*( T + 273) işlemi
9. mul.s $f15,$f13,$f12 # (n*0.082*( T + 273))*1.3 işl.
10. swc1 $f15, 100($f0) # sonucun 1100 nolu hafızaya.
11. jr $ra
1. lwcl $f10,0($gp)
2. lwcl $f11, 4($gp)
3. lwcl $f12, 8($gp)
4. lwcl $f13, 0($f0)
5. lwcl $f14, 4($f0)
6. add.s $f14,$f14,$f11
7. mul.s $f13, $f13, $f10
8. mul.s $f13, $f13,$f14
9. mul.s $f15,$f13,$f12
10. swcl $f15, 100($f0)
11. jr $ra
Bot - Bilgisayar Organizasyonu Tasarım Dersi
Son
